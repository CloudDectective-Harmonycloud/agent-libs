pipeline {
    agent { label 'agent-builder-parallel' }

    stages {

    // grab the repos we need
    stage('Check out dependencies') {
        steps {
            dir('agent') {
                checkout scm
            }
            dir('oss-falco') {
                checkout([$class: 'GitSCM', branches: [[name: 'master']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: 'github-jenkins-user-token', url: 'https://github.com/draios/oss-falco']]])
            }
            dir('libsinsp') {
                checkout([$class: 'GitSCM', branches: [[name: 'dev']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: 'github-jenkins-user-token', url: 'https://github.com/draios/libsinsp']]])
            }
            dir('libscap') {
                checkout([$class: 'GitSCM', branches: [[name: 'dev']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: 'github-jenkins-user-token', url: 'https://github.com/draios/libscap']]])
            }
            dir('protorepo') {
                checkout([$class: 'GitSCM', branches: [[name: 'master']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: 'github-jenkins-user-token', url: 'https://github.com/draios/protorepo']]])
            }
        }
    }

    stage('Switch to Release Base') {
        when {
            expression { params.RELEASE_BASE != "dev" }
        }
        steps {
            dir('agent') {
                sh "git checkout release-${params.RELEASE_BASE}"
            }
            dir('libsinsp') {
                sh "git checkout agent-release-${params.RELEASE_BASE}"
            }
            dir('libscap') {
                sh "git checkout agent-release-${params.RELEASE_BASE}"
            }
            dir('oss-falco') {
                sh "git checkout agent-release-${params.RELEASE_BASE}"
            }
            dir('protorepo') {
                sh "git checkout agent-release-${params.RELEASE_BASE}"
            }
        }
    }

    // if we need to push the release branch, do so
    stage('Push Release Branch') {
        when {
            expression { params.CREATE_RELEASE_BRANCH == true }
        }
        steps {
            slackSend channel: '#docs,#support', message: "Agent release ${params.RELEASE_VERSION} has branched and is in progress.", tokenCredentialId: 'slack'
            slackSend channel: '#ws-agent-core', message: "@here Agent release ${params.RELEASE_VERSION} has branched and is in progress.", tokenCredentialId: 'slack'
            slackSend channel: "${params.RELEASE_VERSION}_agent_release_prep", message: "@here Release in progress", tokenCredentialId: 'slack'
            withCredentials([sshUserPrivateKey(credentialsId: '4399087a-3e99-41e5-9dbe-a70a554672c8', keyFileVariable: 'GITHUB_KEYFILE', passphraseVariable: 'GITHUB_PASSPHRASE', usernameVariable: 'GITHUB_USERNAME')]) {
                dir('agent') {
                    sh label: '', script: """
                        git checkout -b release-${params.RELEASE_VERSION}
                        export GIT_SSH_COMMAND='ssh -i $GITHUB_KEYFILE -F /dev/null'
                        git push -u origin release-${params.RELEASE_VERSION}
                    """
                }
                dir('libsinsp') {
                    sh label: '', script: """
                        git checkout -b agent-release-${params.RELEASE_VERSION}
                        export GIT_SSH_COMMAND='ssh -i $GITHUB_KEYFILE -F /dev/null'
                        git remote add origin2 ssh://git@github.com/draios/libsinsp.git
                        git push -u origin2 agent-release-${params.RELEASE_VERSION}
                    """
                }
                dir('libscap') {
                    sh label: '', script: """
                        git checkout -b agent-release-${params.RELEASE_VERSION}
                        export GIT_SSH_COMMAND='ssh -i $GITHUB_KEYFILE -F /dev/null'
                        git remote add origin2 ssh://git@github.com/draios/libscap.git
                        git push -u origin2 agent-release-${params.RELEASE_VERSION}
                    """
                }
                dir('oss-falco') {
                    sh label: '', script: """
                        git checkout -b agent-release-${params.RELEASE_VERSION}
                        export GIT_SSH_COMMAND='ssh -i $GITHUB_KEYFILE -F /dev/null'
                        git remote add origin2 ssh://git@github.com/draios/oss-falco.git
                        git push -u origin2 agent-release-${params.RELEASE_VERSION}
                    """
                }
                dir('protorepo') {
                    sh label: '', script: """
                        git checkout -b agent-release-${params.RELEASE_VERSION}
                        export GIT_SSH_COMMAND='ssh -i $GITHUB_KEYFILE -F /dev/null'
                        git remote add origin2 ssh://git@github.com/draios/protorepo.git
                        git push -u origin2 agent-release-${params.RELEASE_VERSION}
                    """
                }

            }
        }
    }

    // switch all clients to the release branch. necessary if we didn't push a release branch
    stage('Switch To Release Branch') {
        steps {
            dir('agent') {
                sh "git checkout release-${params.RELEASE_VERSION}"
            }
            dir('libsinsp') {
                sh "git checkout agent-release-${params.RELEASE_VERSION}"
            }
            dir('libscap') {
                sh "git checkout agent-release-${params.RELEASE_VERSION}"
            }
            dir('oss-falco') {
                sh "git checkout agent-release-${params.RELEASE_VERSION}"
            }
            dir('protorepo') {
                sh "git checkout agent-release-${params.RELEASE_VERSION}"
            }
        }
    }

    // build the promscraper releases. Currently they are hard coded to release branch
    // names, so must be built before anything else will work
    stage('Build Promscrape') {
        parallel {
            stage('Build v1') {
                steps {
                    build job:'promscrape-v1-build',parameters:[string(name:'AGENT_RELEASE', value:"$RELEASE_VERSION")]
                }
            }
            stage('Build v2') {
                steps {
                    build job:'promscrape-v2-build',parameters:[string(name:'AGENT_RELEASE', value:"$RELEASE_VERSION")]
                }
            }
        }
    }

    // build and push the docker builder. this is to ensure we are not affected by
    // non-backwards compatible changes to the builder and can always build
    // this release easily from quay
    stage('Build Builder') {
        steps {
            build job:'agent-build-builder',parameters:[string(name:'AGENT_BRANCH', value:"release-${params.RELEASE_VERSION}"),booleanParam(name:'TAG_LATEST', value:false),string(name:'CONTAINER_NAME', value:"release-$RELEASE_VERSION")]
        }
        post {
            success {
                slackSend channel: "@${params.RELEASER_SLACK_ID}", message: "Build container successfully built for release.", tokenCredentialId: 'slack'
            }
            failure {
                slackSend channel: "@${params.RELEASER_SLACK_ID}", message: "Release failed to build build container. Aborting release. Please fix in the new release branch and rerun with CREATE_RELEASE_BRANCH unchecked.", tokenCredentialId: 'slack'
            }
        }
    }

    // double checks that presubmit tests pass
    stage('Run Presubmit') {
         parallel {
            stage('Unit Test') {
                steps {
                    build job:'agent-presubmit-ut',parameters:[string(name:'AGENT_BRANCH', value:"release-${params.RELEASE_VERSION}"),string(name:'LIBSINSP_BRANCH', value:"agent-release-${params.RELEASE_VERSION}"),string(name:'LIBSCAP_BRANCH', value:"agent-release-${params.RELEASE_VERSION}"),string(name:'FALCO_BRANCH', value:"agent-release-${params.RELEASE_VERSION}"),string(name:'PROTOREPO_BRANCH', value:"agent-release-${params.RELEASE_VERSION}"),string(name:'BUILDER_VERSION', value:"release-$RELEASE_VERSION")]
                }
            }
            stage('System Test') {
                steps {
                    build job:'agent-presubmit-system',parameters:[string(name:'AGENT_BRANCH', value:"release-${params.RELEASE_VERSION}"),string(name:'LIBSINSP_BRANCH', value:"agent-release-${params.RELEASE_VERSION}"),string(name:'LIBSCAP_BRANCH', value:"agent-release-${params.RELEASE_VERSION}"),string(name:'FALCO_BRANCH', value:"agent-release-${params.RELEASE_VERSION}"),string(name:'PROTOREPO_BRANCH', value:"agent-release-${params.RELEASE_VERSION}"),string(name:'BUILDER_VERSION', value:"release-$RELEASE_VERSION")]
                }
            }
        }
        post {
            success {
                slackSend channel: "@${params.RELEASER_SLACK_ID}", message: "Release branch passed presubmit tests.", tokenCredentialId: 'slack'
            }
            failure {
                slackSend channel: "@${params.RELEASER_SLACK_ID}", message: "Release failed presubmit tests. Aborting release. Please fix in the new release branch and rerun with CREATE_RELEASE_BRANCH unchecked.", tokenCredentialId: 'slack'
            }
        }
    }

    // builds the RC, runs integration tests, and uploads to docker/quay
    // Uploaded image should be sysdig/agent:${params.RELEASE_VERSION}-rc
    stage('Build RC') {
        steps {
            build job:'agent-build-rc',parameters:[string(name:'AGENT_BRANCH', value:"release-${params.RELEASE_VERSION}"),string(name:'LIBSINSP_BRANCH', value:"agent-release-${params.RELEASE_VERSION}"),string(name:'LIBSCAP_BRANCH', value:"agent-release-${params.RELEASE_VERSION}"),string(name:'FALCO_BRANCH', value:"agent-release-${params.RELEASE_VERSION}"),string(name:'PROTOREPO_BRANCH', value:"agent-release-${params.RELEASE_VERSION}"),string(name:'BUILDER_VERSION', value:"release-$RELEASE_VERSION"),string(name:'RELEASE_VERSION', value:"$RELEASE_VERSION"),booleanParam(name:'UPLOAD', value:true),booleanParam(name:'PUBLIC_RELEASE', value:true)]
        }
        post {
            success {
                slackSend channel: "${params.RELEASE_VERSION}_agent_release_prep", message: "RC successfully built.", tokenCredentialId: 'slack'
                // The following QA folks are sent the notice and approval link explicitly.
                // Kelly Tucker (U01F2TW4V4Z)
                slackSend channel: '#qa-agent,@U01F2TW4V4Z', message: "RC successfully built. Testing can begin which does not depend on probes.", tokenCredentialId: 'slack'
            }
            failure {
                slackSend channel: "@${params.RELEASER_SLACK_ID}", message: "Release failed to build RC. Aborting release. Please fix in the new release branch and rerun with CREATE_RELEASE_BRANCH unchecked.", tokenCredentialId: 'slack'
            }
        }
    }

    stage('Scan Release Container') {
        parallel {
            stage('agent') {
                steps {
                    build job:'agent-scan-container',parameters:[string(name:'CONTAINER_NAME', value:"sysdig/agent:${params.RELEASE_VERSION}-rc")],propagate: false
                }
            }
            stage('agent slim') {
                steps {
                    build job:'agent-scan-container',parameters:[string(name:'CONTAINER_NAME', value:"sysdig/agent-slim:${params.RELEASE_VERSION}-rc")],propagate: false
                }
            }
            stage('agent slim v1') {
                steps {
                    build job:'agent-scan-container',parameters:[string(name:'CONTAINER_NAME', value:"sysdig/agent-slim:${params.RELEASE_VERSION}-rc-v1")],propagate: false
                }
            }
            stage('agent kmod thin') {
                steps {
                    build job:'agent-scan-container',parameters:[string(name:'CONTAINER_NAME', value:"sysdig/agent-kmodule-thin:${params.RELEASE_VERSION}-rc")],propagate: false
                }
            }
        }
    }

    // github has a weird behavior where if you move tags, it auto moves a release from publish
    // to draft. Once it's there, we can't find it by tags anymore, and finding it by name
    // is a bit more of a pain. So to solve that, we do this in 3 stages:
    // 1: delete an old github release, which we can find by tag
    // 2: move/create the new tag
    // 3: create the new release, which should be publishable
    stage('delete duplicate github release') {
        steps {
            withCredentials([usernamePassword(credentialsId: 'github-jenkins-user-token', passwordVariable: 'GITHUB_PASSWORD', usernameVariable: 'GITHUB_USERNAME')]) {
                sh label: '', script: """
                    curl -sH "Authorization: token $GITHUB_PASSWORD" https://api.github.com/repos/draios/agent/releases/tags/$RELEASE_VERSION
                    RELEASE_ID=`curl -sH "Authorization: token $GITHUB_PASSWORD" https://api.github.com/repos/draios/agent/releases/tags/$RELEASE_VERSION | grep \"id\" | head -n 1 | awk '{print \$2}' | sed 's/.\$//'`
                    if [ -z \$RELEASE_ID ];
                    then
                        echo "No prior release found, nothing to delete"
                    else
                        echo "Deleting release id \$RELEASE_ID"
                        curl -sH "Authorization: token $GITHUB_PASSWORD" -X DELETE https://api.github.com/repos/draios/agent/releases/\$RELEASE_ID
                    fi
                """
            }
        }
    }

    // push the release tags to git.
    stage('Push Tags') {
        steps {
            withCredentials([sshUserPrivateKey(credentialsId: '4399087a-3e99-41e5-9dbe-a70a554672c8', keyFileVariable: 'GITHUB_KEYFILE', passphraseVariable: 'GITHUB_PASSPHRASE', usernameVariable: 'GITHUB_USERNAME')]) {
                dir('agent') {
                    sh label: '', script: """
                        export GIT_SSH_COMMAND='ssh -i $GITHUB_KEYFILE -F /dev/null'
                        git tag -d ${params.RELEASE_VERSION} || echo "Tag not found. No problem."
                        git push origin :refs/tags/${params.RELEASE_VERSION}
                        git tag ${params.RELEASE_VERSION}
                        git push origin ${params.RELEASE_VERSION}
                    """
                }
                dir('libsinsp') {
                    sh label: '', script: """
                        export GIT_SSH_COMMAND='ssh -i $GITHUB_KEYFILE -F /dev/null'
                        git remote add origin2 ssh://git@github.com/draios/libsinsp.git || echo "remote already exists"
                        git tag -d agent/${params.RELEASE_VERSION} || echo "Tag not found. No problem."
                        git push origin2 :refs/tags/agent/${params.RELEASE_VERSION}
                        git tag agent/${params.RELEASE_VERSION}
                        git push origin2 agent/${params.RELEASE_VERSION}
                    """
                }
                dir('libscap') {
                    sh label: '', script: """
                        export GIT_SSH_COMMAND='ssh -i $GITHUB_KEYFILE -F /dev/null'
                        git remote add origin2 ssh://git@github.com/draios/libscap.git || echo "remote already exists"
                        git tag -d agent/${params.RELEASE_VERSION} || echo "Tag not found. No problem."
                        git push origin2 :refs/tags/agent/${params.RELEASE_VERSION}
                        git tag agent/${params.RELEASE_VERSION}
                        git push origin2 agent/${params.RELEASE_VERSION}
                    """
                }
                dir('oss-falco') {
                    sh label: '', script: """
                        export GIT_SSH_COMMAND='ssh -i $GITHUB_KEYFILE -F /dev/null'
                        git remote add origin2 ssh://git@github.com/draios/oss-falco.git || echo "remote already exists"
                        git tag -d agent/${params.RELEASE_VERSION} || echo "Tag not found. No problem."
                        git push origin2 :refs/tags/agent/${params.RELEASE_VERSION}
                        git tag agent/${params.RELEASE_VERSION}
                        git push origin2 agent/${params.RELEASE_VERSION}
                    """
                }
                dir('protorepo') {
                    sh label: '', script: """
                        export GIT_SSH_COMMAND='ssh -i $GITHUB_KEYFILE -F /dev/null'
                        git remote add origin2 ssh://git@github.com/draios/protorepo.git || echo "remote already exists"
                        git tag -d agent/${params.RELEASE_VERSION} || echo "Tag not found. No problem."
                        git push origin2 :refs/tags/agent/${params.RELEASE_VERSION}
                        git tag agent/${params.RELEASE_VERSION}
                        git push origin2 agent/${params.RELEASE_VERSION}
                    """
                }
            }
        }
    }

    stage('create github release') {
        steps {
            withCredentials([usernamePassword(credentialsId: 'github-jenkins-user-token', passwordVariable: 'GITHUB_PASSWORD', usernameVariable: 'GITHUB_USERNAME')]) {
                sh label: '', script: """
                    curl -H "Authorization: token $GITHUB_PASSWORD" --data '{"tag_name":"${params.RELEASE_VERSION}","name":"${params.RELEASE_VERSION}","body":"https://sysdig.atlassian.net/issues/?jql=fixVersion%20%3D%20${params.RELEASE_VERSION} \\n\\n $ADDITIONAL_RELEASE_TEXT","target_commitish":"release-${params.RELEASE_VERSION}","draft":false}' https://api.github.com/repos/draios/agent/releases
                """
            }
        }
    }

    // kick off the probe builder with the correct version. This does not update
    // the default of that job, so we will keep building current GA release until
    // this one is promoted
    stage('Build Probes') {
        steps {
            build job: 'sysdig-probe-builder', parameters: [
                string(name: 'RELEASE_NUMBER', value: "${params.RELEASE_VERSION}"),
                string(name: 'DRIVER_REPO_COMMIT', value: "agent/${params.RELEASE_VERSION}"),
                string(name: 'PROBE_NAME', value: 'sysdigcloud-probe')
            ]
        }
        post {
            success {
                slackSend channel: "@${params.RELEASER_SLACK_ID}", message: "Probes successfully built for RC. Note: Probes for this release will not be rebuilt, even if probe job is rerun.", tokenCredentialId: 'slack'
            }
            failure {
                slackSend channel: "@${params.RELEASER_SLACK_ID}", message: "Release failed to build probes. Aborting release. Please contact dev agent team, as this is currently an unhandled exception.", tokenCredentialId: 'slack'
            }
        }
    }

    stage('Build Sonar') {
        steps {
            build job:'agent-run-builder',parameters:[string(name:'AGENT_BRANCH', value:"release-${params.RELEASE_VERSION}"),string(name:'LIBSINSP_BRANCH', value:"agent-release-${params.RELEASE_VERSION}"),string(name:'LIBSCAP_BRANCH', value:"agent-release-${params.RELEASE_VERSION}"),string(name:'FALCO_BRANCH', value:"agent-release-${params.RELEASE_VERSION}"),string(name:'PROTOREPO_BRANCH', value:"agent-release-${params.RELEASE_VERSION}"),string(name:'BUILDER_VERSION', value:"release-$RELEASE_VERSION"), string(name:'TARGET', value:'sonar')]
        }
        post {
            success {
                slackSend channel: "@${params.RELEASER_SLACK_ID}", message: "Sonar scan done. Check results at https://sonarcloud.io/dashboard?id=draios_agent", tokenCredentialId: 'slack'
            }
        }
    }

	stage('Build GS') {
		steps {
			build job:'agent-build-gs',parameters:[string(name:'BASE_RELEASE_VERSION',value:"${params.RELEASE_VERSION}"),booleanParam(name:'UPLOAD', value:true)]
		}
	}

    stage('Wait for Commit') {
        stages {
			stage('Notify') {
				steps {
					slackSend channel: "${params.RELEASE_VERSION}_agent_release_prep", message: "Release is awaiting approvals", tokenCredentialId: 'slack'
				}
			}

            stage('Wait for QA') {
                steps {
                    // The following QA folks are sent the notice and approval link explicitly.
                    // Kelly Tucker (U01F2TW4V4Z)
                    slackSend channel: '#qa-agent,@U01F2TW4V4Z', message: "Agent release ${params.RELEASE_VERSION} is ready for testing. When complete, go to ${env.BUILD_URL}input and approve the release.", tokenCredentialId: 'slack'
                    input message: 'QA Complete', ok: 'Approve Release'
                }
            }

            stage('Wait for Docs') {
                steps {
                    slackSend channel: '#docs', message: "Agent release ${params.RELEASE_VERSION} is awaiting docs approval. When docs are ready for release, go to ${env.BUILD_URL}input and confirm. NOTE: The release does not become public at this point. Another notification will be made when the release has promoted and release notes should be posted.", tokenCredentialId: 'slack'
                    input message: 'Docs Ready', ok: 'Confirm'
                }
            }

            stage ('Wait for Final Go') {
                 parallel {
                    stage('Wait for Manager') {
                        steps {
                            // Naveen Bali
                            slackSend channel: '@UBYCWGBG9', message: "Agent release ${params.RELEASE_VERSION} is awaiting managerial approval. When complete, go to ${env.BUILD_URL}input and approve the release.", tokenCredentialId: 'slack'
                            input message: 'Manager Complete', ok: 'Approve Release'
                        }
                    }
                    stage('Wait for Releaser') {
                        steps {
                            slackSend channel: "@${params.RELEASER_SLACK_ID},#ws-agent-core", message: "Agent release ${params.RELEASE_VERSION} is awaiting releaser approval. When complete, go to ${env.BUILD_URL}input and approve the release.", tokenCredentialId: 'slack'
                            input message: 'Releaser Complete', ok: 'Approve Release'
                        }
                    }
                }
            }
        }
    }


    stage('Promote') {
        steps {
			slackSend channel: "${params.RELEASE_VERSION}_agent_release_prep", message: "Promote is in progress.", tokenCredentialId: 'slack'
            build job:'agent-promote',parameters:[string(name:'RELEASE_VERSION', value:"${params.RELEASE_VERSION}")]
        }
    }

    }

    post {
        always {
            cleanWs deleteDirs: true, notFailBuild: true
        }
        success {
            slackSend channel: "@${params.RELEASER_SLACK_ID}", message: "Release job success!", tokenCredentialId: 'slack'
			slackSend channel: "${params.RELEASE_VERSION}_agent_release_prep", message: "Release job success!", tokenCredentialId: 'slack'
        }
        failure {
            slackSend channel: "@${params.RELEASER_SLACK_ID}", message: "Release job failure.", tokenCredentialId: 'slack'
			slackSend channel: "${params.RELEASE_VERSION}_agent_release_prep", message: "Release job failure!", tokenCredentialId: 'slack'
        }
    }
}

