// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: draios.proto

#ifndef PROTOBUF_draios_2eproto__INCLUDED
#define PROTOBUF_draios_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace draiosproto {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_draios_2eproto();
void protobuf_InitDefaults_draios_2eproto();
void protobuf_AssignDesc_draios_2eproto();
void protobuf_ShutdownFile_draios_2eproto();

class agent_event;
class app_check;
class app_info;
class app_metric;
class app_tag;
class auto_update_request;
class command_details;
class config_data;
class config_file;
class connection_categories;
class container;
class container_label;
class container_port_mapping;
class counter_bytes;
class counter_proto_entry;
class counter_syscall_errors;
class counter_time;
class counter_time_bidirectional;
class counter_time_bytes;
class dirty_shutdown_report;
class dump_request_start;
class dump_request_stop;
class dump_response;
class error_message;
class falco_baseline;
class falco_category;
class falco_container;
class falco_prog;
class falco_subcategory;
class falco_subcategory_container;
class file_stat;
class host;
class http_info;
class ipv4_connection;
class ipv4_network_interface;
class ipv4tuple;
class java_info;
class jmx_attribute;
class jmx_bean;
class k8s_common;
class k8s_daemonset;
class k8s_deployment;
class k8s_namespace;
class k8s_node;
class k8s_pair;
class k8s_pod;
class k8s_replica_set;
class k8s_replication_controller;
class k8s_service;
class k8s_service_net_port;
class k8s_state;
class key_value;
class marathon_app;
class marathon_group;
class mesos_common;
class mesos_framework;
class mesos_pair;
class mesos_slave;
class mesos_state;
class mesos_task;
class metrics;
class mongodb_collection_details;
class mongodb_info;
class mongodb_op_type_details;
class mounted_fs;
class network_by_port;
class process;
class process_details;
class program;
class proto_info;
class resource_categories;
class sql_entry_details;
class sql_info;
class sql_query_type_details;
class ssh_close_channel;
class ssh_data;
class ssh_open_channel;
class statsd_info;
class statsd_metric;
class statsd_tag;
class status_code_details;
class time_categories;
class transaction_breakdown_categories;
class url_details;

enum sql_statement_type {
  SOP_NONE = 0,
  SOP_SELECT = 1,
  SOP_INSERT = 2,
  SOP_SET = 3,
  SOP_CREATE = 4,
  SOP_DELETE = 5,
  SOP_DROP = 6,
  SOP_REPLACE = 7,
  SOP_UPDATE = 8,
  SOP_USE = 9,
  SOP_SHOW = 10,
  SOP_LOCK = 11,
  SOP_UNLOCK = 12,
  SOP_ALTER = 13
};
bool sql_statement_type_IsValid(int value);
const sql_statement_type sql_statement_type_MIN = SOP_NONE;
const sql_statement_type sql_statement_type_MAX = SOP_ALTER;
const int sql_statement_type_ARRAYSIZE = sql_statement_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* sql_statement_type_descriptor();
inline const ::std::string& sql_statement_type_Name(sql_statement_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    sql_statement_type_descriptor(), value);
}
inline bool sql_statement_type_Parse(
    const ::std::string& name, sql_statement_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<sql_statement_type>(
    sql_statement_type_descriptor(), name, value);
}
enum mongodb_op_type {
  MONGODB_OP_NONE = 0,
  MONGODB_OP_INSERT = 1,
  MONGODB_OP_UPDATE = 2,
  MONGODB_OP_DELETE = 3,
  MONGODB_OP_GET_MORE = 4,
  MONGODB_OP_KILL_CURSORS = 5,
  MONGODB_OP_FIND = 6,
  MONGODB_OP_AGGREGATE = 7,
  MONGODB_OP_COMMAND = 8,
  MONGODB_OP_COUNT = 9,
  MONGODB_OP_DISTINCT = 10,
  MONGODB_OP_MAP_REDUCE = 11,
  MONGODB_OP_GEO_NEAR = 12,
  MONGODB_OP_GEO_SEARCH = 13,
  MONGODB_OP_FIND_AND_MODIFY = 14
};
bool mongodb_op_type_IsValid(int value);
const mongodb_op_type mongodb_op_type_MIN = MONGODB_OP_NONE;
const mongodb_op_type mongodb_op_type_MAX = MONGODB_OP_FIND_AND_MODIFY;
const int mongodb_op_type_ARRAYSIZE = mongodb_op_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* mongodb_op_type_descriptor();
inline const ::std::string& mongodb_op_type_Name(mongodb_op_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    mongodb_op_type_descriptor(), value);
}
inline bool mongodb_op_type_Parse(
    const ::std::string& name, mongodb_op_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<mongodb_op_type>(
    mongodb_op_type_descriptor(), name, value);
}
enum unit {
  UNIT_NONE = 0,
  UNIT_SECOND = 1,
  UNIT_BYTE = 2,
  UNIT_PERCENT = 3
};
bool unit_IsValid(int value);
const unit unit_MIN = UNIT_NONE;
const unit unit_MAX = UNIT_PERCENT;
const int unit_ARRAYSIZE = unit_MAX + 1;

const ::google::protobuf::EnumDescriptor* unit_descriptor();
inline const ::std::string& unit_Name(unit value) {
  return ::google::protobuf::internal::NameOfEnum(
    unit_descriptor(), value);
}
inline bool unit_Parse(
    const ::std::string& name, unit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<unit>(
    unit_descriptor(), name, value);
}
enum scale {
  SCALE_NONE = 0,
  SCALE_MILLI = 1,
  SCALE_MICRO = 2,
  SCALE_NANO = 3,
  SCALE_MINUTE = 4,
  SCALE_HOUR = 5,
  SCALE_DAY = 6,
  SCALE_KILO = 7,
  SCALE_MEGA = 8,
  SCALE_GIGA = 9,
  SCALE_TERA = 10,
  SCALE_KIBI = 11,
  SCALE_MEBI = 12,
  SCALE_GIBI = 13,
  SCALE_TEBI = 14,
  SCALE_PERCENT_0_1 = 15
};
bool scale_IsValid(int value);
const scale scale_MIN = SCALE_NONE;
const scale scale_MAX = SCALE_PERCENT_0_1;
const int scale_ARRAYSIZE = scale_MAX + 1;

const ::google::protobuf::EnumDescriptor* scale_descriptor();
inline const ::std::string& scale_Name(scale value) {
  return ::google::protobuf::internal::NameOfEnum(
    scale_descriptor(), value);
}
inline bool scale_Parse(
    const ::std::string& name, scale* value) {
  return ::google::protobuf::internal::ParseNamedEnum<scale>(
    scale_descriptor(), name, value);
}
enum jmx_metric_type {
  JMX_METRIC_TYPE_COUNTER = 1,
  JMX_METRIC_TYPE_GAUGE = 2
};
bool jmx_metric_type_IsValid(int value);
const jmx_metric_type jmx_metric_type_MIN = JMX_METRIC_TYPE_COUNTER;
const jmx_metric_type jmx_metric_type_MAX = JMX_METRIC_TYPE_GAUGE;
const int jmx_metric_type_ARRAYSIZE = jmx_metric_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* jmx_metric_type_descriptor();
inline const ::std::string& jmx_metric_type_Name(jmx_metric_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    jmx_metric_type_descriptor(), value);
}
inline bool jmx_metric_type_Parse(
    const ::std::string& name, jmx_metric_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<jmx_metric_type>(
    jmx_metric_type_descriptor(), name, value);
}
enum statsd_metric_type {
  STATSD_COUNT = 1,
  STATSD_HISTOGRAM = 2,
  STATSD_GAUGE = 3,
  STATSD_SET = 4
};
bool statsd_metric_type_IsValid(int value);
const statsd_metric_type statsd_metric_type_MIN = STATSD_COUNT;
const statsd_metric_type statsd_metric_type_MAX = STATSD_SET;
const int statsd_metric_type_ARRAYSIZE = statsd_metric_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* statsd_metric_type_descriptor();
inline const ::std::string& statsd_metric_type_Name(statsd_metric_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    statsd_metric_type_descriptor(), value);
}
inline bool statsd_metric_type_Parse(
    const ::std::string& name, statsd_metric_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<statsd_metric_type>(
    statsd_metric_type_descriptor(), name, value);
}
enum app_metric_type {
  APP_METRIC_TYPE_GAUGE = 1,
  APP_METRIC_TYPE_RATE = 2
};
bool app_metric_type_IsValid(int value);
const app_metric_type app_metric_type_MIN = APP_METRIC_TYPE_GAUGE;
const app_metric_type app_metric_type_MAX = APP_METRIC_TYPE_RATE;
const int app_metric_type_ARRAYSIZE = app_metric_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* app_metric_type_descriptor();
inline const ::std::string& app_metric_type_Name(app_metric_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    app_metric_type_descriptor(), value);
}
inline bool app_metric_type_Parse(
    const ::std::string& name, app_metric_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<app_metric_type>(
    app_metric_type_descriptor(), name, value);
}
enum app_check_value {
  APP_CHECK_VALUE_OK = 0,
  APP_CHECK_VALUE_WARNING = 1,
  APP_CHECK_VALUE_CRITICAL = 2,
  APP_CHECK_VALUE_UNKNOWN = 3
};
bool app_check_value_IsValid(int value);
const app_check_value app_check_value_MIN = APP_CHECK_VALUE_OK;
const app_check_value app_check_value_MAX = APP_CHECK_VALUE_UNKNOWN;
const int app_check_value_ARRAYSIZE = app_check_value_MAX + 1;

const ::google::protobuf::EnumDescriptor* app_check_value_descriptor();
inline const ::std::string& app_check_value_Name(app_check_value value) {
  return ::google::protobuf::internal::NameOfEnum(
    app_check_value_descriptor(), value);
}
inline bool app_check_value_Parse(
    const ::std::string& name, app_check_value* value) {
  return ::google::protobuf::internal::ParseNamedEnum<app_check_value>(
    app_check_value_descriptor(), name, value);
}
enum networkrole {
  NONE = 0,
  IS_LOCAL_IPV4_SERVER = 1,
  IS_REMOTE_IPV4_SERVER = 2,
  IS_UNIX_SERVER = 4,
  IS_LOCAL_IPV4_CLIENT = 8,
  IS_REMOTE_IPV4_CLIENT = 16,
  IS_UNIX_CLIENT = 32
};
bool networkrole_IsValid(int value);
const networkrole networkrole_MIN = NONE;
const networkrole networkrole_MAX = IS_UNIX_CLIENT;
const int networkrole_ARRAYSIZE = networkrole_MAX + 1;

const ::google::protobuf::EnumDescriptor* networkrole_descriptor();
inline const ::std::string& networkrole_Name(networkrole value) {
  return ::google::protobuf::internal::NameOfEnum(
    networkrole_descriptor(), value);
}
inline bool networkrole_Parse(
    const ::std::string& name, networkrole* value) {
  return ::google::protobuf::internal::ParseNamedEnum<networkrole>(
    networkrole_descriptor(), name, value);
}
enum message_type {
  METRICS = 1,
  DUMP_REQUEST_START = 2,
  DUMP_REQUEST_STOP = 4,
  DUMP_RESPONSE = 3,
  SSH_OPEN_CHANNEL = 6,
  SSH_CLOSE_CHANNEL = 7,
  SSH_DATA = 8,
  AUTO_UPDATE_REQUEST = 9,
  DIRTY_SHUTDOWN_REPORT = 10,
  CONFIG_DATA = 11,
  ERROR_MESSAGE = 12
};
bool message_type_IsValid(int value);
const message_type message_type_MIN = METRICS;
const message_type message_type_MAX = ERROR_MESSAGE;
const int message_type_ARRAYSIZE = message_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* message_type_descriptor();
inline const ::std::string& message_type_Name(message_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    message_type_descriptor(), value);
}
inline bool message_type_Parse(
    const ::std::string& name, message_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<message_type>(
    message_type_descriptor(), name, value);
}
enum container_type {
  DOCKER = 1,
  LXC = 2,
  LIBVIRT_LXC = 3,
  MESOS = 4,
  RKT = 5
};
bool container_type_IsValid(int value);
const container_type container_type_MIN = DOCKER;
const container_type container_type_MAX = RKT;
const int container_type_ARRAYSIZE = container_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* container_type_descriptor();
inline const ::std::string& container_type_Name(container_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    container_type_descriptor(), value);
}
inline bool container_type_Parse(
    const ::std::string& name, container_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<container_type>(
    container_type_descriptor(), name, value);
}
enum error_type {
  ERR_CONN_LIMIT = 1,
  ERR_INVALID_CUSTOMER_KEY = 2,
  ERR_DUPLICATE_AGENT = 3
};
bool error_type_IsValid(int value);
const error_type error_type_MIN = ERR_CONN_LIMIT;
const error_type error_type_MAX = ERR_DUPLICATE_AGENT;
const int error_type_ARRAYSIZE = error_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* error_type_descriptor();
inline const ::std::string& error_type_Name(error_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    error_type_descriptor(), value);
}
inline bool error_type_Parse(
    const ::std::string& name, error_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<error_type>(
    error_type_descriptor(), name, value);
}
// ===================================================================

class counter_time : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.counter_time) */ {
 public:
  counter_time();
  virtual ~counter_time();

  counter_time(const counter_time& from);

  inline counter_time& operator=(const counter_time& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const counter_time& default_instance();

  static const counter_time* internal_default_instance();

  void Swap(counter_time* other);

  // implements Message ----------------------------------------------

  inline counter_time* New() const { return New(NULL); }

  counter_time* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const counter_time& from);
  void MergeFrom(const counter_time& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(counter_time* other);
  void UnsafeMergeFrom(const counter_time& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 count = 1;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 1;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // required uint64 time_ns = 2;
  bool has_time_ns() const;
  void clear_time_ns();
  static const int kTimeNsFieldNumber = 2;
  ::google::protobuf::uint64 time_ns() const;
  void set_time_ns(::google::protobuf::uint64 value);

  // optional uint32 time_percentage = 3;
  bool has_time_percentage() const;
  void clear_time_percentage();
  static const int kTimePercentageFieldNumber = 3;
  ::google::protobuf::uint32 time_percentage() const;
  void set_time_percentage(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.counter_time)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_time_ns();
  inline void clear_has_time_ns();
  inline void set_has_time_percentage();
  inline void clear_has_time_percentage();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 time_ns_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 time_percentage_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<counter_time> counter_time_default_instance_;

// -------------------------------------------------------------------

class counter_time_bidirectional : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.counter_time_bidirectional) */ {
 public:
  counter_time_bidirectional();
  virtual ~counter_time_bidirectional();

  counter_time_bidirectional(const counter_time_bidirectional& from);

  inline counter_time_bidirectional& operator=(const counter_time_bidirectional& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const counter_time_bidirectional& default_instance();

  static const counter_time_bidirectional* internal_default_instance();

  void Swap(counter_time_bidirectional* other);

  // implements Message ----------------------------------------------

  inline counter_time_bidirectional* New() const { return New(NULL); }

  counter_time_bidirectional* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const counter_time_bidirectional& from);
  void MergeFrom(const counter_time_bidirectional& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(counter_time_bidirectional* other);
  void UnsafeMergeFrom(const counter_time_bidirectional& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 count_in = 1;
  bool has_count_in() const;
  void clear_count_in();
  static const int kCountInFieldNumber = 1;
  ::google::protobuf::uint32 count_in() const;
  void set_count_in(::google::protobuf::uint32 value);

  // required uint32 count_out = 2;
  bool has_count_out() const;
  void clear_count_out();
  static const int kCountOutFieldNumber = 2;
  ::google::protobuf::uint32 count_out() const;
  void set_count_out(::google::protobuf::uint32 value);

  // required uint64 time_ns_in = 3;
  bool has_time_ns_in() const;
  void clear_time_ns_in();
  static const int kTimeNsInFieldNumber = 3;
  ::google::protobuf::uint64 time_ns_in() const;
  void set_time_ns_in(::google::protobuf::uint64 value);

  // required uint64 time_ns_out = 4;
  bool has_time_ns_out() const;
  void clear_time_ns_out();
  static const int kTimeNsOutFieldNumber = 4;
  ::google::protobuf::uint64 time_ns_out() const;
  void set_time_ns_out(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:draiosproto.counter_time_bidirectional)
 private:
  inline void set_has_count_in();
  inline void clear_has_count_in();
  inline void set_has_count_out();
  inline void clear_has_count_out();
  inline void set_has_time_ns_in();
  inline void clear_has_time_ns_in();
  inline void set_has_time_ns_out();
  inline void clear_has_time_ns_out();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 count_in_;
  ::google::protobuf::uint32 count_out_;
  ::google::protobuf::uint64 time_ns_in_;
  ::google::protobuf::uint64 time_ns_out_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<counter_time_bidirectional> counter_time_bidirectional_default_instance_;

// -------------------------------------------------------------------

class counter_bytes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.counter_bytes) */ {
 public:
  counter_bytes();
  virtual ~counter_bytes();

  counter_bytes(const counter_bytes& from);

  inline counter_bytes& operator=(const counter_bytes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const counter_bytes& default_instance();

  static const counter_bytes* internal_default_instance();

  void Swap(counter_bytes* other);

  // implements Message ----------------------------------------------

  inline counter_bytes* New() const { return New(NULL); }

  counter_bytes* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const counter_bytes& from);
  void MergeFrom(const counter_bytes& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(counter_bytes* other);
  void UnsafeMergeFrom(const counter_bytes& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 count_in = 1;
  bool has_count_in() const;
  void clear_count_in();
  static const int kCountInFieldNumber = 1;
  ::google::protobuf::uint32 count_in() const;
  void set_count_in(::google::protobuf::uint32 value);

  // required uint32 count_out = 2;
  bool has_count_out() const;
  void clear_count_out();
  static const int kCountOutFieldNumber = 2;
  ::google::protobuf::uint32 count_out() const;
  void set_count_out(::google::protobuf::uint32 value);

  // required uint32 bytes_in = 3;
  bool has_bytes_in() const;
  void clear_bytes_in();
  static const int kBytesInFieldNumber = 3;
  ::google::protobuf::uint32 bytes_in() const;
  void set_bytes_in(::google::protobuf::uint32 value);

  // required uint32 bytes_out = 4;
  bool has_bytes_out() const;
  void clear_bytes_out();
  static const int kBytesOutFieldNumber = 4;
  ::google::protobuf::uint32 bytes_out() const;
  void set_bytes_out(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.counter_bytes)
 private:
  inline void set_has_count_in();
  inline void clear_has_count_in();
  inline void set_has_count_out();
  inline void clear_has_count_out();
  inline void set_has_bytes_in();
  inline void clear_has_bytes_in();
  inline void set_has_bytes_out();
  inline void clear_has_bytes_out();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 count_in_;
  ::google::protobuf::uint32 count_out_;
  ::google::protobuf::uint32 bytes_in_;
  ::google::protobuf::uint32 bytes_out_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<counter_bytes> counter_bytes_default_instance_;

// -------------------------------------------------------------------

class counter_time_bytes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.counter_time_bytes) */ {
 public:
  counter_time_bytes();
  virtual ~counter_time_bytes();

  counter_time_bytes(const counter_time_bytes& from);

  inline counter_time_bytes& operator=(const counter_time_bytes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const counter_time_bytes& default_instance();

  static const counter_time_bytes* internal_default_instance();

  void Swap(counter_time_bytes* other);

  // implements Message ----------------------------------------------

  inline counter_time_bytes* New() const { return New(NULL); }

  counter_time_bytes* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const counter_time_bytes& from);
  void MergeFrom(const counter_time_bytes& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(counter_time_bytes* other);
  void UnsafeMergeFrom(const counter_time_bytes& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 time_ns_in = 1;
  bool has_time_ns_in() const;
  void clear_time_ns_in();
  static const int kTimeNsInFieldNumber = 1;
  ::google::protobuf::uint64 time_ns_in() const;
  void set_time_ns_in(::google::protobuf::uint64 value);

  // required uint64 time_ns_out = 2;
  bool has_time_ns_out() const;
  void clear_time_ns_out();
  static const int kTimeNsOutFieldNumber = 2;
  ::google::protobuf::uint64 time_ns_out() const;
  void set_time_ns_out(::google::protobuf::uint64 value);

  // required uint64 time_ns_other = 3;
  bool has_time_ns_other() const;
  void clear_time_ns_other();
  static const int kTimeNsOtherFieldNumber = 3;
  ::google::protobuf::uint64 time_ns_other() const;
  void set_time_ns_other(::google::protobuf::uint64 value);

  // required uint32 count_in = 4;
  bool has_count_in() const;
  void clear_count_in();
  static const int kCountInFieldNumber = 4;
  ::google::protobuf::uint32 count_in() const;
  void set_count_in(::google::protobuf::uint32 value);

  // required uint32 count_out = 5;
  bool has_count_out() const;
  void clear_count_out();
  static const int kCountOutFieldNumber = 5;
  ::google::protobuf::uint32 count_out() const;
  void set_count_out(::google::protobuf::uint32 value);

  // required uint32 count_other = 6;
  bool has_count_other() const;
  void clear_count_other();
  static const int kCountOtherFieldNumber = 6;
  ::google::protobuf::uint32 count_other() const;
  void set_count_other(::google::protobuf::uint32 value);

  // required uint32 bytes_in = 7;
  bool has_bytes_in() const;
  void clear_bytes_in();
  static const int kBytesInFieldNumber = 7;
  ::google::protobuf::uint32 bytes_in() const;
  void set_bytes_in(::google::protobuf::uint32 value);

  // required uint32 bytes_out = 8;
  bool has_bytes_out() const;
  void clear_bytes_out();
  static const int kBytesOutFieldNumber = 8;
  ::google::protobuf::uint32 bytes_out() const;
  void set_bytes_out(::google::protobuf::uint32 value);

  // required uint32 bytes_other = 9;
  bool has_bytes_other() const;
  void clear_bytes_other();
  static const int kBytesOtherFieldNumber = 9;
  ::google::protobuf::uint32 bytes_other() const;
  void set_bytes_other(::google::protobuf::uint32 value);

  // optional uint32 time_percentage_in = 10;
  bool has_time_percentage_in() const;
  void clear_time_percentage_in();
  static const int kTimePercentageInFieldNumber = 10;
  ::google::protobuf::uint32 time_percentage_in() const;
  void set_time_percentage_in(::google::protobuf::uint32 value);

  // optional uint32 time_percentage_out = 11;
  bool has_time_percentage_out() const;
  void clear_time_percentage_out();
  static const int kTimePercentageOutFieldNumber = 11;
  ::google::protobuf::uint32 time_percentage_out() const;
  void set_time_percentage_out(::google::protobuf::uint32 value);

  // optional uint32 time_percentage_other = 12;
  bool has_time_percentage_other() const;
  void clear_time_percentage_other();
  static const int kTimePercentageOtherFieldNumber = 12;
  ::google::protobuf::uint32 time_percentage_other() const;
  void set_time_percentage_other(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.counter_time_bytes)
 private:
  inline void set_has_time_ns_in();
  inline void clear_has_time_ns_in();
  inline void set_has_time_ns_out();
  inline void clear_has_time_ns_out();
  inline void set_has_time_ns_other();
  inline void clear_has_time_ns_other();
  inline void set_has_count_in();
  inline void clear_has_count_in();
  inline void set_has_count_out();
  inline void clear_has_count_out();
  inline void set_has_count_other();
  inline void clear_has_count_other();
  inline void set_has_bytes_in();
  inline void clear_has_bytes_in();
  inline void set_has_bytes_out();
  inline void clear_has_bytes_out();
  inline void set_has_bytes_other();
  inline void clear_has_bytes_other();
  inline void set_has_time_percentage_in();
  inline void clear_has_time_percentage_in();
  inline void set_has_time_percentage_out();
  inline void clear_has_time_percentage_out();
  inline void set_has_time_percentage_other();
  inline void clear_has_time_percentage_other();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 time_ns_in_;
  ::google::protobuf::uint64 time_ns_out_;
  ::google::protobuf::uint64 time_ns_other_;
  ::google::protobuf::uint32 count_in_;
  ::google::protobuf::uint32 count_out_;
  ::google::protobuf::uint32 count_other_;
  ::google::protobuf::uint32 bytes_in_;
  ::google::protobuf::uint32 bytes_out_;
  ::google::protobuf::uint32 bytes_other_;
  ::google::protobuf::uint32 time_percentage_in_;
  ::google::protobuf::uint32 time_percentage_out_;
  ::google::protobuf::uint32 time_percentage_other_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<counter_time_bytes> counter_time_bytes_default_instance_;

// -------------------------------------------------------------------

class time_categories : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.time_categories) */ {
 public:
  time_categories();
  virtual ~time_categories();

  time_categories(const time_categories& from);

  inline time_categories& operator=(const time_categories& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const time_categories& default_instance();

  static const time_categories* internal_default_instance();

  void Swap(time_categories* other);

  // implements Message ----------------------------------------------

  inline time_categories* New() const { return New(NULL); }

  time_categories* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const time_categories& from);
  void MergeFrom(const time_categories& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(time_categories* other);
  void UnsafeMergeFrom(const time_categories& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .draiosproto.counter_time unknown = 1;
  bool has_unknown() const;
  void clear_unknown();
  static const int kUnknownFieldNumber = 1;
  const ::draiosproto::counter_time& unknown() const;
  ::draiosproto::counter_time* mutable_unknown();
  ::draiosproto::counter_time* release_unknown();
  void set_allocated_unknown(::draiosproto::counter_time* unknown);

  // optional .draiosproto.counter_time other = 2;
  bool has_other() const;
  void clear_other();
  static const int kOtherFieldNumber = 2;
  const ::draiosproto::counter_time& other() const;
  ::draiosproto::counter_time* mutable_other();
  ::draiosproto::counter_time* release_other();
  void set_allocated_other(::draiosproto::counter_time* other);

  // optional .draiosproto.counter_time file = 3;
  bool has_file() const;
  void clear_file();
  static const int kFileFieldNumber = 3;
  const ::draiosproto::counter_time& file() const;
  ::draiosproto::counter_time* mutable_file();
  ::draiosproto::counter_time* release_file();
  void set_allocated_file(::draiosproto::counter_time* file);

  // optional .draiosproto.counter_time net = 4;
  bool has_net() const;
  void clear_net();
  static const int kNetFieldNumber = 4;
  const ::draiosproto::counter_time& net() const;
  ::draiosproto::counter_time* mutable_net();
  ::draiosproto::counter_time* release_net();
  void set_allocated_net(::draiosproto::counter_time* net);

  // optional .draiosproto.counter_time ipc = 5;
  bool has_ipc() const;
  void clear_ipc();
  static const int kIpcFieldNumber = 5;
  const ::draiosproto::counter_time& ipc() const;
  ::draiosproto::counter_time* mutable_ipc();
  ::draiosproto::counter_time* release_ipc();
  void set_allocated_ipc(::draiosproto::counter_time* ipc);

  // optional .draiosproto.counter_time memory = 6;
  bool has_memory() const;
  void clear_memory();
  static const int kMemoryFieldNumber = 6;
  const ::draiosproto::counter_time& memory() const;
  ::draiosproto::counter_time* mutable_memory();
  ::draiosproto::counter_time* release_memory();
  void set_allocated_memory(::draiosproto::counter_time* memory);

  // optional .draiosproto.counter_time process = 7;
  bool has_process() const;
  void clear_process();
  static const int kProcessFieldNumber = 7;
  const ::draiosproto::counter_time& process() const;
  ::draiosproto::counter_time* mutable_process();
  ::draiosproto::counter_time* release_process();
  void set_allocated_process(::draiosproto::counter_time* process);

  // optional .draiosproto.counter_time sleep = 8;
  bool has_sleep() const;
  void clear_sleep();
  static const int kSleepFieldNumber = 8;
  const ::draiosproto::counter_time& sleep() const;
  ::draiosproto::counter_time* mutable_sleep();
  ::draiosproto::counter_time* release_sleep();
  void set_allocated_sleep(::draiosproto::counter_time* sleep);

  // optional .draiosproto.counter_time system = 9;
  bool has_system() const;
  void clear_system();
  static const int kSystemFieldNumber = 9;
  const ::draiosproto::counter_time& system() const;
  ::draiosproto::counter_time* mutable_system();
  ::draiosproto::counter_time* release_system();
  void set_allocated_system(::draiosproto::counter_time* system);

  // optional .draiosproto.counter_time signal = 10;
  bool has_signal() const;
  void clear_signal();
  static const int kSignalFieldNumber = 10;
  const ::draiosproto::counter_time& signal() const;
  ::draiosproto::counter_time* mutable_signal();
  ::draiosproto::counter_time* release_signal();
  void set_allocated_signal(::draiosproto::counter_time* signal);

  // optional .draiosproto.counter_time user = 11;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 11;
  const ::draiosproto::counter_time& user() const;
  ::draiosproto::counter_time* mutable_user();
  ::draiosproto::counter_time* release_user();
  void set_allocated_user(::draiosproto::counter_time* user);

  // optional .draiosproto.counter_time time = 12;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 12;
  const ::draiosproto::counter_time& time() const;
  ::draiosproto::counter_time* mutable_time();
  ::draiosproto::counter_time* release_time();
  void set_allocated_time(::draiosproto::counter_time* time);

  // optional .draiosproto.counter_time_bytes io_file = 13;
  bool has_io_file() const;
  void clear_io_file();
  static const int kIoFileFieldNumber = 13;
  const ::draiosproto::counter_time_bytes& io_file() const;
  ::draiosproto::counter_time_bytes* mutable_io_file();
  ::draiosproto::counter_time_bytes* release_io_file();
  void set_allocated_io_file(::draiosproto::counter_time_bytes* io_file);

  // optional .draiosproto.counter_time_bytes io_net = 14;
  bool has_io_net() const;
  void clear_io_net();
  static const int kIoNetFieldNumber = 14;
  const ::draiosproto::counter_time_bytes& io_net() const;
  ::draiosproto::counter_time_bytes* mutable_io_net();
  ::draiosproto::counter_time_bytes* release_io_net();
  void set_allocated_io_net(::draiosproto::counter_time_bytes* io_net);

  // optional .draiosproto.counter_time_bytes io_other = 15;
  bool has_io_other() const;
  void clear_io_other();
  static const int kIoOtherFieldNumber = 15;
  const ::draiosproto::counter_time_bytes& io_other() const;
  ::draiosproto::counter_time_bytes* mutable_io_other();
  ::draiosproto::counter_time_bytes* release_io_other();
  void set_allocated_io_other(::draiosproto::counter_time_bytes* io_other);

  // optional .draiosproto.counter_time wait = 16;
  bool has_wait() const;
  void clear_wait();
  static const int kWaitFieldNumber = 16;
  const ::draiosproto::counter_time& wait() const;
  ::draiosproto::counter_time* mutable_wait();
  ::draiosproto::counter_time* release_wait();
  void set_allocated_wait(::draiosproto::counter_time* wait);

  // optional .draiosproto.counter_time processing = 17;
  bool has_processing() const;
  void clear_processing();
  static const int kProcessingFieldNumber = 17;
  const ::draiosproto::counter_time& processing() const;
  ::draiosproto::counter_time* mutable_processing();
  ::draiosproto::counter_time* release_processing();
  void set_allocated_processing(::draiosproto::counter_time* processing);

  // @@protoc_insertion_point(class_scope:draiosproto.time_categories)
 private:
  inline void set_has_unknown();
  inline void clear_has_unknown();
  inline void set_has_other();
  inline void clear_has_other();
  inline void set_has_file();
  inline void clear_has_file();
  inline void set_has_net();
  inline void clear_has_net();
  inline void set_has_ipc();
  inline void clear_has_ipc();
  inline void set_has_memory();
  inline void clear_has_memory();
  inline void set_has_process();
  inline void clear_has_process();
  inline void set_has_sleep();
  inline void clear_has_sleep();
  inline void set_has_system();
  inline void clear_has_system();
  inline void set_has_signal();
  inline void clear_has_signal();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_io_file();
  inline void clear_has_io_file();
  inline void set_has_io_net();
  inline void clear_has_io_net();
  inline void set_has_io_other();
  inline void clear_has_io_other();
  inline void set_has_wait();
  inline void clear_has_wait();
  inline void set_has_processing();
  inline void clear_has_processing();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::draiosproto::counter_time* unknown_;
  ::draiosproto::counter_time* other_;
  ::draiosproto::counter_time* file_;
  ::draiosproto::counter_time* net_;
  ::draiosproto::counter_time* ipc_;
  ::draiosproto::counter_time* memory_;
  ::draiosproto::counter_time* process_;
  ::draiosproto::counter_time* sleep_;
  ::draiosproto::counter_time* system_;
  ::draiosproto::counter_time* signal_;
  ::draiosproto::counter_time* user_;
  ::draiosproto::counter_time* time_;
  ::draiosproto::counter_time_bytes* io_file_;
  ::draiosproto::counter_time_bytes* io_net_;
  ::draiosproto::counter_time_bytes* io_other_;
  ::draiosproto::counter_time* wait_;
  ::draiosproto::counter_time* processing_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<time_categories> time_categories_default_instance_;

// -------------------------------------------------------------------

class transaction_breakdown_categories : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.transaction_breakdown_categories) */ {
 public:
  transaction_breakdown_categories();
  virtual ~transaction_breakdown_categories();

  transaction_breakdown_categories(const transaction_breakdown_categories& from);

  inline transaction_breakdown_categories& operator=(const transaction_breakdown_categories& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const transaction_breakdown_categories& default_instance();

  static const transaction_breakdown_categories* internal_default_instance();

  void Swap(transaction_breakdown_categories* other);

  // implements Message ----------------------------------------------

  inline transaction_breakdown_categories* New() const { return New(NULL); }

  transaction_breakdown_categories* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const transaction_breakdown_categories& from);
  void MergeFrom(const transaction_breakdown_categories& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(transaction_breakdown_categories* other);
  void UnsafeMergeFrom(const transaction_breakdown_categories& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .draiosproto.counter_time other = 2;
  bool has_other() const;
  void clear_other();
  static const int kOtherFieldNumber = 2;
  const ::draiosproto::counter_time& other() const;
  ::draiosproto::counter_time* mutable_other();
  ::draiosproto::counter_time* release_other();
  void set_allocated_other(::draiosproto::counter_time* other);

  // optional .draiosproto.counter_time_bytes io_file = 13;
  bool has_io_file() const;
  void clear_io_file();
  static const int kIoFileFieldNumber = 13;
  const ::draiosproto::counter_time_bytes& io_file() const;
  ::draiosproto::counter_time_bytes* mutable_io_file();
  ::draiosproto::counter_time_bytes* release_io_file();
  void set_allocated_io_file(::draiosproto::counter_time_bytes* io_file);

  // optional .draiosproto.counter_time_bytes io_net = 14;
  bool has_io_net() const;
  void clear_io_net();
  static const int kIoNetFieldNumber = 14;
  const ::draiosproto::counter_time_bytes& io_net() const;
  ::draiosproto::counter_time_bytes* mutable_io_net();
  ::draiosproto::counter_time_bytes* release_io_net();
  void set_allocated_io_net(::draiosproto::counter_time_bytes* io_net);

  // optional .draiosproto.counter_time processing = 17;
  bool has_processing() const;
  void clear_processing();
  static const int kProcessingFieldNumber = 17;
  const ::draiosproto::counter_time& processing() const;
  ::draiosproto::counter_time* mutable_processing();
  ::draiosproto::counter_time* release_processing();
  void set_allocated_processing(::draiosproto::counter_time* processing);

  // @@protoc_insertion_point(class_scope:draiosproto.transaction_breakdown_categories)
 private:
  inline void set_has_other();
  inline void clear_has_other();
  inline void set_has_io_file();
  inline void clear_has_io_file();
  inline void set_has_io_net();
  inline void clear_has_io_net();
  inline void set_has_processing();
  inline void clear_has_processing();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::draiosproto::counter_time* other_;
  ::draiosproto::counter_time_bytes* io_file_;
  ::draiosproto::counter_time_bytes* io_net_;
  ::draiosproto::counter_time* processing_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<transaction_breakdown_categories> transaction_breakdown_categories_default_instance_;

// -------------------------------------------------------------------

class counter_syscall_errors : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.counter_syscall_errors) */ {
 public:
  counter_syscall_errors();
  virtual ~counter_syscall_errors();

  counter_syscall_errors(const counter_syscall_errors& from);

  inline counter_syscall_errors& operator=(const counter_syscall_errors& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const counter_syscall_errors& default_instance();

  static const counter_syscall_errors* internal_default_instance();

  void Swap(counter_syscall_errors* other);

  // implements Message ----------------------------------------------

  inline counter_syscall_errors* New() const { return New(NULL); }

  counter_syscall_errors* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const counter_syscall_errors& from);
  void MergeFrom(const counter_syscall_errors& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(counter_syscall_errors* other);
  void UnsafeMergeFrom(const counter_syscall_errors& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 count = 1;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 1;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // repeated uint32 top_error_codes = 2;
  int top_error_codes_size() const;
  void clear_top_error_codes();
  static const int kTopErrorCodesFieldNumber = 2;
  ::google::protobuf::uint32 top_error_codes(int index) const;
  void set_top_error_codes(int index, ::google::protobuf::uint32 value);
  void add_top_error_codes(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      top_error_codes() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_top_error_codes();

  // optional uint32 count_file = 4;
  bool has_count_file() const;
  void clear_count_file();
  static const int kCountFileFieldNumber = 4;
  ::google::protobuf::uint32 count_file() const;
  void set_count_file(::google::protobuf::uint32 value);

  // optional uint32 count_file_open = 5;
  bool has_count_file_open() const;
  void clear_count_file_open();
  static const int kCountFileOpenFieldNumber = 5;
  ::google::protobuf::uint32 count_file_open() const;
  void set_count_file_open(::google::protobuf::uint32 value);

  // optional uint32 count_net = 6;
  bool has_count_net() const;
  void clear_count_net();
  static const int kCountNetFieldNumber = 6;
  ::google::protobuf::uint32 count_net() const;
  void set_count_net(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.counter_syscall_errors)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_count_file();
  inline void clear_has_count_file();
  inline void set_has_count_file_open();
  inline void clear_has_count_file_open();
  inline void set_has_count_net();
  inline void clear_has_count_net();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > top_error_codes_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 count_file_;
  ::google::protobuf::uint32 count_file_open_;
  ::google::protobuf::uint32 count_net_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<counter_syscall_errors> counter_syscall_errors_default_instance_;

// -------------------------------------------------------------------

class resource_categories : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.resource_categories) */ {
 public:
  resource_categories();
  virtual ~resource_categories();

  resource_categories(const resource_categories& from);

  inline resource_categories& operator=(const resource_categories& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const resource_categories& default_instance();

  static const resource_categories* internal_default_instance();

  void Swap(resource_categories* other);

  // implements Message ----------------------------------------------

  inline resource_categories* New() const { return New(NULL); }

  resource_categories* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const resource_categories& from);
  void MergeFrom(const resource_categories& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(resource_categories* other);
  void UnsafeMergeFrom(const resource_categories& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 capacity_score = 1;
  bool has_capacity_score() const;
  void clear_capacity_score();
  static const int kCapacityScoreFieldNumber = 1;
  ::google::protobuf::uint32 capacity_score() const;
  void set_capacity_score(::google::protobuf::uint32 value);

  // optional uint32 stolen_capacity_score = 6;
  bool has_stolen_capacity_score() const;
  void clear_stolen_capacity_score();
  static const int kStolenCapacityScoreFieldNumber = 6;
  ::google::protobuf::uint32 stolen_capacity_score() const;
  void set_stolen_capacity_score(::google::protobuf::uint32 value);

  // optional uint32 connection_queue_usage_pct = 2;
  bool has_connection_queue_usage_pct() const;
  void clear_connection_queue_usage_pct();
  static const int kConnectionQueueUsagePctFieldNumber = 2;
  ::google::protobuf::uint32 connection_queue_usage_pct() const;
  void set_connection_queue_usage_pct(::google::protobuf::uint32 value);

  // optional uint32 fd_usage_pct = 3;
  bool has_fd_usage_pct() const;
  void clear_fd_usage_pct();
  static const int kFdUsagePctFieldNumber = 3;
  ::google::protobuf::uint32 fd_usage_pct() const;
  void set_fd_usage_pct(::google::protobuf::uint32 value);

  // optional uint32 cpu_pct = 4;
  bool has_cpu_pct() const;
  void clear_cpu_pct();
  static const int kCpuPctFieldNumber = 4;
  ::google::protobuf::uint32 cpu_pct() const;
  void set_cpu_pct(::google::protobuf::uint32 value);

  // optional uint32 resident_memory_usage_kb = 5;
  bool has_resident_memory_usage_kb() const;
  void clear_resident_memory_usage_kb();
  static const int kResidentMemoryUsageKbFieldNumber = 5;
  ::google::protobuf::uint32 resident_memory_usage_kb() const;
  void set_resident_memory_usage_kb(::google::protobuf::uint32 value);

  // optional uint32 virtual_memory_usage_kb = 13;
  bool has_virtual_memory_usage_kb() const;
  void clear_virtual_memory_usage_kb();
  static const int kVirtualMemoryUsageKbFieldNumber = 13;
  ::google::protobuf::uint32 virtual_memory_usage_kb() const;
  void set_virtual_memory_usage_kb(::google::protobuf::uint32 value);

  // optional uint32 swap_memory_usage_kb = 14;
  bool has_swap_memory_usage_kb() const;
  void clear_swap_memory_usage_kb();
  static const int kSwapMemoryUsageKbFieldNumber = 14;
  ::google::protobuf::uint32 swap_memory_usage_kb() const;
  void set_swap_memory_usage_kb(::google::protobuf::uint32 value);

  // optional uint64 major_pagefaults = 15;
  bool has_major_pagefaults() const;
  void clear_major_pagefaults();
  static const int kMajorPagefaultsFieldNumber = 15;
  ::google::protobuf::uint64 major_pagefaults() const;
  void set_major_pagefaults(::google::protobuf::uint64 value);

  // optional uint64 minor_pagefaults = 16;
  bool has_minor_pagefaults() const;
  void clear_minor_pagefaults();
  static const int kMinorPagefaultsFieldNumber = 16;
  ::google::protobuf::uint64 minor_pagefaults() const;
  void set_minor_pagefaults(::google::protobuf::uint64 value);

  // optional uint32 fd_count = 21;
  bool has_fd_count() const;
  void clear_fd_count();
  static const int kFdCountFieldNumber = 21;
  ::google::protobuf::uint32 fd_count() const;
  void set_fd_count(::google::protobuf::uint32 value);

  // optional uint32 cpu_shares = 24;
  bool has_cpu_shares() const;
  void clear_cpu_shares();
  static const int kCpuSharesFieldNumber = 24;
  ::google::protobuf::uint32 cpu_shares() const;
  void set_cpu_shares(::google::protobuf::uint32 value);

  // optional uint32 cpu_shares_usage_pct = 25;
  bool has_cpu_shares_usage_pct() const;
  void clear_cpu_shares_usage_pct();
  static const int kCpuSharesUsagePctFieldNumber = 25;
  ::google::protobuf::uint32 cpu_shares_usage_pct() const;
  void set_cpu_shares_usage_pct(::google::protobuf::uint32 value);

  // optional uint32 memory_limit_kb = 26;
  bool has_memory_limit_kb() const;
  void clear_memory_limit_kb();
  static const int kMemoryLimitKbFieldNumber = 26;
  ::google::protobuf::uint32 memory_limit_kb() const;
  void set_memory_limit_kb(::google::protobuf::uint32 value);

  // optional uint32 swap_limit_kb = 27;
  bool has_swap_limit_kb() const;
  void clear_swap_limit_kb();
  static const int kSwapLimitKbFieldNumber = 27;
  ::google::protobuf::uint32 swap_limit_kb() const;
  void set_swap_limit_kb(::google::protobuf::uint32 value);

  // optional uint32 cpu_quota_used_pct = 28;
  bool has_cpu_quota_used_pct() const;
  void clear_cpu_quota_used_pct();
  static const int kCpuQuotaUsedPctFieldNumber = 28;
  ::google::protobuf::uint32 cpu_quota_used_pct() const;
  void set_cpu_quota_used_pct(::google::protobuf::uint32 value);

  // optional uint32 swap_memory_total_kb = 29;
  bool has_swap_memory_total_kb() const;
  void clear_swap_memory_total_kb();
  static const int kSwapMemoryTotalKbFieldNumber = 29;
  ::google::protobuf::uint32 swap_memory_total_kb() const;
  void set_swap_memory_total_kb(::google::protobuf::uint32 value);

  // optional uint32 swap_memory_available_kb = 30;
  bool has_swap_memory_available_kb() const;
  void clear_swap_memory_available_kb();
  static const int kSwapMemoryAvailableKbFieldNumber = 30;
  ::google::protobuf::uint32 swap_memory_available_kb() const;
  void set_swap_memory_available_kb(::google::protobuf::uint32 value);

  // optional uint64 count_processes = 31;
  bool has_count_processes() const;
  void clear_count_processes();
  static const int kCountProcessesFieldNumber = 31;
  ::google::protobuf::uint64 count_processes() const;
  void set_count_processes(::google::protobuf::uint64 value);

  // optional uint64 proc_start_count = 32;
  bool has_proc_start_count() const;
  void clear_proc_start_count();
  static const int kProcStartCountFieldNumber = 32;
  ::google::protobuf::uint64 proc_start_count() const;
  void set_proc_start_count(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:draiosproto.resource_categories)
 private:
  inline void set_has_capacity_score();
  inline void clear_has_capacity_score();
  inline void set_has_stolen_capacity_score();
  inline void clear_has_stolen_capacity_score();
  inline void set_has_connection_queue_usage_pct();
  inline void clear_has_connection_queue_usage_pct();
  inline void set_has_fd_usage_pct();
  inline void clear_has_fd_usage_pct();
  inline void set_has_cpu_pct();
  inline void clear_has_cpu_pct();
  inline void set_has_resident_memory_usage_kb();
  inline void clear_has_resident_memory_usage_kb();
  inline void set_has_virtual_memory_usage_kb();
  inline void clear_has_virtual_memory_usage_kb();
  inline void set_has_swap_memory_usage_kb();
  inline void clear_has_swap_memory_usage_kb();
  inline void set_has_major_pagefaults();
  inline void clear_has_major_pagefaults();
  inline void set_has_minor_pagefaults();
  inline void clear_has_minor_pagefaults();
  inline void set_has_fd_count();
  inline void clear_has_fd_count();
  inline void set_has_cpu_shares();
  inline void clear_has_cpu_shares();
  inline void set_has_cpu_shares_usage_pct();
  inline void clear_has_cpu_shares_usage_pct();
  inline void set_has_memory_limit_kb();
  inline void clear_has_memory_limit_kb();
  inline void set_has_swap_limit_kb();
  inline void clear_has_swap_limit_kb();
  inline void set_has_cpu_quota_used_pct();
  inline void clear_has_cpu_quota_used_pct();
  inline void set_has_swap_memory_total_kb();
  inline void clear_has_swap_memory_total_kb();
  inline void set_has_swap_memory_available_kb();
  inline void clear_has_swap_memory_available_kb();
  inline void set_has_count_processes();
  inline void clear_has_count_processes();
  inline void set_has_proc_start_count();
  inline void clear_has_proc_start_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 capacity_score_;
  ::google::protobuf::uint32 stolen_capacity_score_;
  ::google::protobuf::uint32 connection_queue_usage_pct_;
  ::google::protobuf::uint32 fd_usage_pct_;
  ::google::protobuf::uint32 cpu_pct_;
  ::google::protobuf::uint32 resident_memory_usage_kb_;
  ::google::protobuf::uint32 virtual_memory_usage_kb_;
  ::google::protobuf::uint32 swap_memory_usage_kb_;
  ::google::protobuf::uint64 major_pagefaults_;
  ::google::protobuf::uint64 minor_pagefaults_;
  ::google::protobuf::uint32 fd_count_;
  ::google::protobuf::uint32 cpu_shares_;
  ::google::protobuf::uint32 cpu_shares_usage_pct_;
  ::google::protobuf::uint32 memory_limit_kb_;
  ::google::protobuf::uint32 swap_limit_kb_;
  ::google::protobuf::uint32 cpu_quota_used_pct_;
  ::google::protobuf::uint32 swap_memory_total_kb_;
  ::google::protobuf::uint32 swap_memory_available_kb_;
  ::google::protobuf::uint64 count_processes_;
  ::google::protobuf::uint64 proc_start_count_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<resource_categories> resource_categories_default_instance_;

// -------------------------------------------------------------------

class connection_categories : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.connection_categories) */ {
 public:
  connection_categories();
  virtual ~connection_categories();

  connection_categories(const connection_categories& from);

  inline connection_categories& operator=(const connection_categories& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const connection_categories& default_instance();

  static const connection_categories* internal_default_instance();

  void Swap(connection_categories* other);

  // implements Message ----------------------------------------------

  inline connection_categories* New() const { return New(NULL); }

  connection_categories* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const connection_categories& from);
  void MergeFrom(const connection_categories& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(connection_categories* other);
  void UnsafeMergeFrom(const connection_categories& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .draiosproto.counter_bytes server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  const ::draiosproto::counter_bytes& server() const;
  ::draiosproto::counter_bytes* mutable_server();
  ::draiosproto::counter_bytes* release_server();
  void set_allocated_server(::draiosproto::counter_bytes* server);

  // optional .draiosproto.counter_bytes client = 2;
  bool has_client() const;
  void clear_client();
  static const int kClientFieldNumber = 2;
  const ::draiosproto::counter_bytes& client() const;
  ::draiosproto::counter_bytes* mutable_client();
  ::draiosproto::counter_bytes* release_client();
  void set_allocated_client(::draiosproto::counter_bytes* client);

  // optional .draiosproto.counter_time_bidirectional transaction_counters = 3;
  bool has_transaction_counters() const;
  void clear_transaction_counters();
  static const int kTransactionCountersFieldNumber = 3;
  const ::draiosproto::counter_time_bidirectional& transaction_counters() const;
  ::draiosproto::counter_time_bidirectional* mutable_transaction_counters();
  ::draiosproto::counter_time_bidirectional* release_transaction_counters();
  void set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters);

  // optional .draiosproto.counter_time_bidirectional min_transaction_counters = 18;
  bool has_min_transaction_counters() const;
  void clear_min_transaction_counters();
  static const int kMinTransactionCountersFieldNumber = 18;
  const ::draiosproto::counter_time_bidirectional& min_transaction_counters() const;
  ::draiosproto::counter_time_bidirectional* mutable_min_transaction_counters();
  ::draiosproto::counter_time_bidirectional* release_min_transaction_counters();
  void set_allocated_min_transaction_counters(::draiosproto::counter_time_bidirectional* min_transaction_counters);

  // optional .draiosproto.counter_time_bidirectional max_transaction_counters = 19;
  bool has_max_transaction_counters() const;
  void clear_max_transaction_counters();
  static const int kMaxTransactionCountersFieldNumber = 19;
  const ::draiosproto::counter_time_bidirectional& max_transaction_counters() const;
  ::draiosproto::counter_time_bidirectional* mutable_max_transaction_counters();
  ::draiosproto::counter_time_bidirectional* release_max_transaction_counters();
  void set_allocated_max_transaction_counters(::draiosproto::counter_time_bidirectional* max_transaction_counters);

  // optional uint32 n_aggregated_connections = 4;
  bool has_n_aggregated_connections() const;
  void clear_n_aggregated_connections();
  static const int kNAggregatedConnectionsFieldNumber = 4;
  ::google::protobuf::uint32 n_aggregated_connections() const;
  void set_n_aggregated_connections(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.connection_categories)
 private:
  inline void set_has_server();
  inline void clear_has_server();
  inline void set_has_client();
  inline void clear_has_client();
  inline void set_has_transaction_counters();
  inline void clear_has_transaction_counters();
  inline void set_has_min_transaction_counters();
  inline void clear_has_min_transaction_counters();
  inline void set_has_max_transaction_counters();
  inline void clear_has_max_transaction_counters();
  inline void set_has_n_aggregated_connections();
  inline void clear_has_n_aggregated_connections();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::draiosproto::counter_bytes* server_;
  ::draiosproto::counter_bytes* client_;
  ::draiosproto::counter_time_bidirectional* transaction_counters_;
  ::draiosproto::counter_time_bidirectional* min_transaction_counters_;
  ::draiosproto::counter_time_bidirectional* max_transaction_counters_;
  ::google::protobuf::uint32 n_aggregated_connections_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<connection_categories> connection_categories_default_instance_;

// -------------------------------------------------------------------

class process_details : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.process_details) */ {
 public:
  process_details();
  virtual ~process_details();

  process_details(const process_details& from);

  inline process_details& operator=(const process_details& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const process_details& default_instance();

  static const process_details* internal_default_instance();

  void Swap(process_details* other);

  // implements Message ----------------------------------------------

  inline process_details* New() const { return New(NULL); }

  process_details* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const process_details& from);
  void MergeFrom(const process_details& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(process_details* other);
  void UnsafeMergeFrom(const process_details& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string comm = 1;
  bool has_comm() const;
  void clear_comm();
  static const int kCommFieldNumber = 1;
  const ::std::string& comm() const;
  void set_comm(const ::std::string& value);
  void set_comm(const char* value);
  void set_comm(const char* value, size_t size);
  ::std::string* mutable_comm();
  ::std::string* release_comm();
  void set_allocated_comm(::std::string* comm);

  // required string exe = 2;
  bool has_exe() const;
  void clear_exe();
  static const int kExeFieldNumber = 2;
  const ::std::string& exe() const;
  void set_exe(const ::std::string& value);
  void set_exe(const char* value);
  void set_exe(const char* value, size_t size);
  ::std::string* mutable_exe();
  ::std::string* release_exe();
  void set_allocated_exe(::std::string* exe);

  // repeated string args = 3;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 3;
  const ::std::string& args(int index) const;
  ::std::string* mutable_args(int index);
  void set_args(int index, const ::std::string& value);
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, size_t size);
  ::std::string* add_args();
  void add_args(const ::std::string& value);
  void add_args(const char* value);
  void add_args(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& args() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_args();

  // optional string container_id = 4;
  bool has_container_id() const;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 4;
  const ::std::string& container_id() const;
  void set_container_id(const ::std::string& value);
  void set_container_id(const char* value);
  void set_container_id(const char* value, size_t size);
  ::std::string* mutable_container_id();
  ::std::string* release_container_id();
  void set_allocated_container_id(::std::string* container_id);

  // @@protoc_insertion_point(class_scope:draiosproto.process_details)
 private:
  inline void set_has_comm();
  inline void clear_has_comm();
  inline void set_has_exe();
  inline void clear_has_exe();
  inline void set_has_container_id();
  inline void clear_has_container_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> args_;
  ::google::protobuf::internal::ArenaStringPtr comm_;
  ::google::protobuf::internal::ArenaStringPtr exe_;
  ::google::protobuf::internal::ArenaStringPtr container_id_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<process_details> process_details_default_instance_;

// -------------------------------------------------------------------

class command_details : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.command_details) */ {
 public:
  command_details();
  virtual ~command_details();

  command_details(const command_details& from);

  inline command_details& operator=(const command_details& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const command_details& default_instance();

  static const command_details* internal_default_instance();

  void Swap(command_details* other);

  // implements Message ----------------------------------------------

  inline command_details* New() const { return New(NULL); }

  command_details* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const command_details& from);
  void MergeFrom(const command_details& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(command_details* other);
  void UnsafeMergeFrom(const command_details& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // required uint32 count = 2;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // required string cmdline = 3;
  bool has_cmdline() const;
  void clear_cmdline();
  static const int kCmdlineFieldNumber = 3;
  const ::std::string& cmdline() const;
  void set_cmdline(const ::std::string& value);
  void set_cmdline(const char* value);
  void set_cmdline(const char* value, size_t size);
  ::std::string* mutable_cmdline();
  ::std::string* release_cmdline();
  void set_allocated_cmdline(::std::string* cmdline);

  // required string exe = 4;
  bool has_exe() const;
  void clear_exe();
  static const int kExeFieldNumber = 4;
  const ::std::string& exe() const;
  void set_exe(const ::std::string& value);
  void set_exe(const char* value);
  void set_exe(const char* value, size_t size);
  ::std::string* mutable_exe();
  ::std::string* release_exe();
  void set_allocated_exe(::std::string* exe);

  // optional string parentcomm = 5;
  bool has_parentcomm() const;
  void clear_parentcomm();
  static const int kParentcommFieldNumber = 5;
  const ::std::string& parentcomm() const;
  void set_parentcomm(const ::std::string& value);
  void set_parentcomm(const char* value);
  void set_parentcomm(const char* value, size_t size);
  ::std::string* mutable_parentcomm();
  ::std::string* release_parentcomm();
  void set_allocated_parentcomm(::std::string* parentcomm);

  // @@protoc_insertion_point(class_scope:draiosproto.command_details)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_cmdline();
  inline void clear_has_cmdline();
  inline void set_has_exe();
  inline void clear_has_exe();
  inline void set_has_parentcomm();
  inline void clear_has_parentcomm();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr cmdline_;
  ::google::protobuf::internal::ArenaStringPtr exe_;
  ::google::protobuf::internal::ArenaStringPtr parentcomm_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint32 count_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<command_details> command_details_default_instance_;

// -------------------------------------------------------------------

class counter_proto_entry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.counter_proto_entry) */ {
 public:
  counter_proto_entry();
  virtual ~counter_proto_entry();

  counter_proto_entry(const counter_proto_entry& from);

  inline counter_proto_entry& operator=(const counter_proto_entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const counter_proto_entry& default_instance();

  static const counter_proto_entry* internal_default_instance();

  void Swap(counter_proto_entry* other);

  // implements Message ----------------------------------------------

  inline counter_proto_entry* New() const { return New(NULL); }

  counter_proto_entry* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const counter_proto_entry& from);
  void MergeFrom(const counter_proto_entry& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(counter_proto_entry* other);
  void UnsafeMergeFrom(const counter_proto_entry& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ncalls = 1;
  bool has_ncalls() const;
  void clear_ncalls();
  static const int kNcallsFieldNumber = 1;
  ::google::protobuf::uint32 ncalls() const;
  void set_ncalls(::google::protobuf::uint32 value);

  // required uint64 time_tot = 2;
  bool has_time_tot() const;
  void clear_time_tot();
  static const int kTimeTotFieldNumber = 2;
  ::google::protobuf::uint64 time_tot() const;
  void set_time_tot(::google::protobuf::uint64 value);

  // required uint64 time_max = 3;
  bool has_time_max() const;
  void clear_time_max();
  static const int kTimeMaxFieldNumber = 3;
  ::google::protobuf::uint64 time_max() const;
  void set_time_max(::google::protobuf::uint64 value);

  // required uint64 bytes_in = 4;
  bool has_bytes_in() const;
  void clear_bytes_in();
  static const int kBytesInFieldNumber = 4;
  ::google::protobuf::uint64 bytes_in() const;
  void set_bytes_in(::google::protobuf::uint64 value);

  // required uint64 bytes_out = 5;
  bool has_bytes_out() const;
  void clear_bytes_out();
  static const int kBytesOutFieldNumber = 5;
  ::google::protobuf::uint64 bytes_out() const;
  void set_bytes_out(::google::protobuf::uint64 value);

  // required uint32 nerrors = 6;
  bool has_nerrors() const;
  void clear_nerrors();
  static const int kNerrorsFieldNumber = 6;
  ::google::protobuf::uint32 nerrors() const;
  void set_nerrors(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.counter_proto_entry)
 private:
  inline void set_has_ncalls();
  inline void clear_has_ncalls();
  inline void set_has_time_tot();
  inline void clear_has_time_tot();
  inline void set_has_time_max();
  inline void clear_has_time_max();
  inline void set_has_bytes_in();
  inline void clear_has_bytes_in();
  inline void set_has_bytes_out();
  inline void clear_has_bytes_out();
  inline void set_has_nerrors();
  inline void clear_has_nerrors();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 time_tot_;
  ::google::protobuf::uint64 time_max_;
  ::google::protobuf::uint32 ncalls_;
  ::google::protobuf::uint32 nerrors_;
  ::google::protobuf::uint64 bytes_in_;
  ::google::protobuf::uint64 bytes_out_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<counter_proto_entry> counter_proto_entry_default_instance_;

// -------------------------------------------------------------------

class url_details : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.url_details) */ {
 public:
  url_details();
  virtual ~url_details();

  url_details(const url_details& from);

  inline url_details& operator=(const url_details& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const url_details& default_instance();

  static const url_details* internal_default_instance();

  void Swap(url_details* other);

  // implements Message ----------------------------------------------

  inline url_details* New() const { return New(NULL); }

  url_details* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const url_details& from);
  void MergeFrom(const url_details& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(url_details* other);
  void UnsafeMergeFrom(const url_details& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string url = 1;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // required .draiosproto.counter_proto_entry counters = 2;
  bool has_counters() const;
  void clear_counters();
  static const int kCountersFieldNumber = 2;
  const ::draiosproto::counter_proto_entry& counters() const;
  ::draiosproto::counter_proto_entry* mutable_counters();
  ::draiosproto::counter_proto_entry* release_counters();
  void set_allocated_counters(::draiosproto::counter_proto_entry* counters);

  // @@protoc_insertion_point(class_scope:draiosproto.url_details)
 private:
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_counters();
  inline void clear_has_counters();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::draiosproto::counter_proto_entry* counters_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<url_details> url_details_default_instance_;

// -------------------------------------------------------------------

class status_code_details : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.status_code_details) */ {
 public:
  status_code_details();
  virtual ~status_code_details();

  status_code_details(const status_code_details& from);

  inline status_code_details& operator=(const status_code_details& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const status_code_details& default_instance();

  static const status_code_details* internal_default_instance();

  void Swap(status_code_details* other);

  // implements Message ----------------------------------------------

  inline status_code_details* New() const { return New(NULL); }

  status_code_details* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const status_code_details& from);
  void MergeFrom(const status_code_details& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(status_code_details* other);
  void UnsafeMergeFrom(const status_code_details& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 status_code = 1;
  bool has_status_code() const;
  void clear_status_code();
  static const int kStatusCodeFieldNumber = 1;
  ::google::protobuf::uint32 status_code() const;
  void set_status_code(::google::protobuf::uint32 value);

  // required uint32 ncalls = 2;
  bool has_ncalls() const;
  void clear_ncalls();
  static const int kNcallsFieldNumber = 2;
  ::google::protobuf::uint32 ncalls() const;
  void set_ncalls(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.status_code_details)
 private:
  inline void set_has_status_code();
  inline void clear_has_status_code();
  inline void set_has_ncalls();
  inline void clear_has_ncalls();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 status_code_;
  ::google::protobuf::uint32 ncalls_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<status_code_details> status_code_details_default_instance_;

// -------------------------------------------------------------------

class http_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.http_info) */ {
 public:
  http_info();
  virtual ~http_info();

  http_info(const http_info& from);

  inline http_info& operator=(const http_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const http_info& default_instance();

  static const http_info* internal_default_instance();

  void Swap(http_info* other);

  // implements Message ----------------------------------------------

  inline http_info* New() const { return New(NULL); }

  http_info* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const http_info& from);
  void MergeFrom(const http_info& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(http_info* other);
  void UnsafeMergeFrom(const http_info& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .draiosproto.url_details server_urls = 1;
  int server_urls_size() const;
  void clear_server_urls();
  static const int kServerUrlsFieldNumber = 1;
  const ::draiosproto::url_details& server_urls(int index) const;
  ::draiosproto::url_details* mutable_server_urls(int index);
  ::draiosproto::url_details* add_server_urls();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::url_details >*
      mutable_server_urls();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::url_details >&
      server_urls() const;

  // repeated .draiosproto.url_details client_urls = 2;
  int client_urls_size() const;
  void clear_client_urls();
  static const int kClientUrlsFieldNumber = 2;
  const ::draiosproto::url_details& client_urls(int index) const;
  ::draiosproto::url_details* mutable_client_urls(int index);
  ::draiosproto::url_details* add_client_urls();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::url_details >*
      mutable_client_urls();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::url_details >&
      client_urls() const;

  // repeated .draiosproto.status_code_details client_status_codes = 3;
  int client_status_codes_size() const;
  void clear_client_status_codes();
  static const int kClientStatusCodesFieldNumber = 3;
  const ::draiosproto::status_code_details& client_status_codes(int index) const;
  ::draiosproto::status_code_details* mutable_client_status_codes(int index);
  ::draiosproto::status_code_details* add_client_status_codes();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::status_code_details >*
      mutable_client_status_codes();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::status_code_details >&
      client_status_codes() const;

  // repeated .draiosproto.status_code_details server_status_codes = 4;
  int server_status_codes_size() const;
  void clear_server_status_codes();
  static const int kServerStatusCodesFieldNumber = 4;
  const ::draiosproto::status_code_details& server_status_codes(int index) const;
  ::draiosproto::status_code_details* mutable_server_status_codes(int index);
  ::draiosproto::status_code_details* add_server_status_codes();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::status_code_details >*
      mutable_server_status_codes();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::status_code_details >&
      server_status_codes() const;

  // @@protoc_insertion_point(class_scope:draiosproto.http_info)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::url_details > server_urls_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::url_details > client_urls_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::status_code_details > client_status_codes_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::status_code_details > server_status_codes_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<http_info> http_info_default_instance_;

// -------------------------------------------------------------------

class sql_entry_details : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.sql_entry_details) */ {
 public:
  sql_entry_details();
  virtual ~sql_entry_details();

  sql_entry_details(const sql_entry_details& from);

  inline sql_entry_details& operator=(const sql_entry_details& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sql_entry_details& default_instance();

  static const sql_entry_details* internal_default_instance();

  void Swap(sql_entry_details* other);

  // implements Message ----------------------------------------------

  inline sql_entry_details* New() const { return New(NULL); }

  sql_entry_details* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sql_entry_details& from);
  void MergeFrom(const sql_entry_details& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(sql_entry_details* other);
  void UnsafeMergeFrom(const sql_entry_details& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required .draiosproto.counter_proto_entry counters = 2;
  bool has_counters() const;
  void clear_counters();
  static const int kCountersFieldNumber = 2;
  const ::draiosproto::counter_proto_entry& counters() const;
  ::draiosproto::counter_proto_entry* mutable_counters();
  ::draiosproto::counter_proto_entry* release_counters();
  void set_allocated_counters(::draiosproto::counter_proto_entry* counters);

  // @@protoc_insertion_point(class_scope:draiosproto.sql_entry_details)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_counters();
  inline void clear_has_counters();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::draiosproto::counter_proto_entry* counters_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<sql_entry_details> sql_entry_details_default_instance_;

// -------------------------------------------------------------------

class sql_query_type_details : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.sql_query_type_details) */ {
 public:
  sql_query_type_details();
  virtual ~sql_query_type_details();

  sql_query_type_details(const sql_query_type_details& from);

  inline sql_query_type_details& operator=(const sql_query_type_details& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sql_query_type_details& default_instance();

  static const sql_query_type_details* internal_default_instance();

  void Swap(sql_query_type_details* other);

  // implements Message ----------------------------------------------

  inline sql_query_type_details* New() const { return New(NULL); }

  sql_query_type_details* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sql_query_type_details& from);
  void MergeFrom(const sql_query_type_details& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(sql_query_type_details* other);
  void UnsafeMergeFrom(const sql_query_type_details& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.sql_statement_type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::draiosproto::sql_statement_type type() const;
  void set_type(::draiosproto::sql_statement_type value);

  // required .draiosproto.counter_proto_entry counters = 2;
  bool has_counters() const;
  void clear_counters();
  static const int kCountersFieldNumber = 2;
  const ::draiosproto::counter_proto_entry& counters() const;
  ::draiosproto::counter_proto_entry* mutable_counters();
  ::draiosproto::counter_proto_entry* release_counters();
  void set_allocated_counters(::draiosproto::counter_proto_entry* counters);

  // @@protoc_insertion_point(class_scope:draiosproto.sql_query_type_details)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_counters();
  inline void clear_has_counters();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::draiosproto::counter_proto_entry* counters_;
  int type_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<sql_query_type_details> sql_query_type_details_default_instance_;

// -------------------------------------------------------------------

class sql_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.sql_info) */ {
 public:
  sql_info();
  virtual ~sql_info();

  sql_info(const sql_info& from);

  inline sql_info& operator=(const sql_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sql_info& default_instance();

  static const sql_info* internal_default_instance();

  void Swap(sql_info* other);

  // implements Message ----------------------------------------------

  inline sql_info* New() const { return New(NULL); }

  sql_info* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sql_info& from);
  void MergeFrom(const sql_info& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(sql_info* other);
  void UnsafeMergeFrom(const sql_info& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .draiosproto.sql_entry_details server_queries = 1;
  int server_queries_size() const;
  void clear_server_queries();
  static const int kServerQueriesFieldNumber = 1;
  const ::draiosproto::sql_entry_details& server_queries(int index) const;
  ::draiosproto::sql_entry_details* mutable_server_queries(int index);
  ::draiosproto::sql_entry_details* add_server_queries();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >*
      mutable_server_queries();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >&
      server_queries() const;

  // repeated .draiosproto.sql_entry_details client_queries = 2;
  int client_queries_size() const;
  void clear_client_queries();
  static const int kClientQueriesFieldNumber = 2;
  const ::draiosproto::sql_entry_details& client_queries(int index) const;
  ::draiosproto::sql_entry_details* mutable_client_queries(int index);
  ::draiosproto::sql_entry_details* add_client_queries();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >*
      mutable_client_queries();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >&
      client_queries() const;

  // repeated .draiosproto.sql_query_type_details server_query_types = 3;
  int server_query_types_size() const;
  void clear_server_query_types();
  static const int kServerQueryTypesFieldNumber = 3;
  const ::draiosproto::sql_query_type_details& server_query_types(int index) const;
  ::draiosproto::sql_query_type_details* mutable_server_query_types(int index);
  ::draiosproto::sql_query_type_details* add_server_query_types();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_query_type_details >*
      mutable_server_query_types();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_query_type_details >&
      server_query_types() const;

  // repeated .draiosproto.sql_query_type_details client_query_types = 4;
  int client_query_types_size() const;
  void clear_client_query_types();
  static const int kClientQueryTypesFieldNumber = 4;
  const ::draiosproto::sql_query_type_details& client_query_types(int index) const;
  ::draiosproto::sql_query_type_details* mutable_client_query_types(int index);
  ::draiosproto::sql_query_type_details* add_client_query_types();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_query_type_details >*
      mutable_client_query_types();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_query_type_details >&
      client_query_types() const;

  // repeated .draiosproto.sql_entry_details server_tables = 5;
  int server_tables_size() const;
  void clear_server_tables();
  static const int kServerTablesFieldNumber = 5;
  const ::draiosproto::sql_entry_details& server_tables(int index) const;
  ::draiosproto::sql_entry_details* mutable_server_tables(int index);
  ::draiosproto::sql_entry_details* add_server_tables();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >*
      mutable_server_tables();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >&
      server_tables() const;

  // repeated .draiosproto.sql_entry_details client_tables = 6;
  int client_tables_size() const;
  void clear_client_tables();
  static const int kClientTablesFieldNumber = 6;
  const ::draiosproto::sql_entry_details& client_tables(int index) const;
  ::draiosproto::sql_entry_details* mutable_client_tables(int index);
  ::draiosproto::sql_entry_details* add_client_tables();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >*
      mutable_client_tables();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >&
      client_tables() const;

  // @@protoc_insertion_point(class_scope:draiosproto.sql_info)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details > server_queries_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details > client_queries_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_query_type_details > server_query_types_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_query_type_details > client_query_types_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details > server_tables_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details > client_tables_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<sql_info> sql_info_default_instance_;

// -------------------------------------------------------------------

class mongodb_collection_details : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.mongodb_collection_details) */ {
 public:
  mongodb_collection_details();
  virtual ~mongodb_collection_details();

  mongodb_collection_details(const mongodb_collection_details& from);

  inline mongodb_collection_details& operator=(const mongodb_collection_details& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mongodb_collection_details& default_instance();

  static const mongodb_collection_details* internal_default_instance();

  void Swap(mongodb_collection_details* other);

  // implements Message ----------------------------------------------

  inline mongodb_collection_details* New() const { return New(NULL); }

  mongodb_collection_details* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mongodb_collection_details& from);
  void MergeFrom(const mongodb_collection_details& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(mongodb_collection_details* other);
  void UnsafeMergeFrom(const mongodb_collection_details& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required .draiosproto.counter_proto_entry counters = 2;
  bool has_counters() const;
  void clear_counters();
  static const int kCountersFieldNumber = 2;
  const ::draiosproto::counter_proto_entry& counters() const;
  ::draiosproto::counter_proto_entry* mutable_counters();
  ::draiosproto::counter_proto_entry* release_counters();
  void set_allocated_counters(::draiosproto::counter_proto_entry* counters);

  // @@protoc_insertion_point(class_scope:draiosproto.mongodb_collection_details)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_counters();
  inline void clear_has_counters();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::draiosproto::counter_proto_entry* counters_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<mongodb_collection_details> mongodb_collection_details_default_instance_;

// -------------------------------------------------------------------

class mongodb_op_type_details : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.mongodb_op_type_details) */ {
 public:
  mongodb_op_type_details();
  virtual ~mongodb_op_type_details();

  mongodb_op_type_details(const mongodb_op_type_details& from);

  inline mongodb_op_type_details& operator=(const mongodb_op_type_details& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mongodb_op_type_details& default_instance();

  static const mongodb_op_type_details* internal_default_instance();

  void Swap(mongodb_op_type_details* other);

  // implements Message ----------------------------------------------

  inline mongodb_op_type_details* New() const { return New(NULL); }

  mongodb_op_type_details* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mongodb_op_type_details& from);
  void MergeFrom(const mongodb_op_type_details& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(mongodb_op_type_details* other);
  void UnsafeMergeFrom(const mongodb_op_type_details& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.mongodb_op_type op = 1;
  bool has_op() const;
  void clear_op();
  static const int kOpFieldNumber = 1;
  ::draiosproto::mongodb_op_type op() const;
  void set_op(::draiosproto::mongodb_op_type value);

  // required .draiosproto.counter_proto_entry counters = 2;
  bool has_counters() const;
  void clear_counters();
  static const int kCountersFieldNumber = 2;
  const ::draiosproto::counter_proto_entry& counters() const;
  ::draiosproto::counter_proto_entry* mutable_counters();
  ::draiosproto::counter_proto_entry* release_counters();
  void set_allocated_counters(::draiosproto::counter_proto_entry* counters);

  // @@protoc_insertion_point(class_scope:draiosproto.mongodb_op_type_details)
 private:
  inline void set_has_op();
  inline void clear_has_op();
  inline void set_has_counters();
  inline void clear_has_counters();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::draiosproto::counter_proto_entry* counters_;
  int op_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<mongodb_op_type_details> mongodb_op_type_details_default_instance_;

// -------------------------------------------------------------------

class mongodb_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.mongodb_info) */ {
 public:
  mongodb_info();
  virtual ~mongodb_info();

  mongodb_info(const mongodb_info& from);

  inline mongodb_info& operator=(const mongodb_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mongodb_info& default_instance();

  static const mongodb_info* internal_default_instance();

  void Swap(mongodb_info* other);

  // implements Message ----------------------------------------------

  inline mongodb_info* New() const { return New(NULL); }

  mongodb_info* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mongodb_info& from);
  void MergeFrom(const mongodb_info& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(mongodb_info* other);
  void UnsafeMergeFrom(const mongodb_info& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .draiosproto.mongodb_op_type_details servers_ops = 1;
  int servers_ops_size() const;
  void clear_servers_ops();
  static const int kServersOpsFieldNumber = 1;
  const ::draiosproto::mongodb_op_type_details& servers_ops(int index) const;
  ::draiosproto::mongodb_op_type_details* mutable_servers_ops(int index);
  ::draiosproto::mongodb_op_type_details* add_servers_ops();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_op_type_details >*
      mutable_servers_ops();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_op_type_details >&
      servers_ops() const;

  // repeated .draiosproto.mongodb_op_type_details client_ops = 2;
  int client_ops_size() const;
  void clear_client_ops();
  static const int kClientOpsFieldNumber = 2;
  const ::draiosproto::mongodb_op_type_details& client_ops(int index) const;
  ::draiosproto::mongodb_op_type_details* mutable_client_ops(int index);
  ::draiosproto::mongodb_op_type_details* add_client_ops();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_op_type_details >*
      mutable_client_ops();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_op_type_details >&
      client_ops() const;

  // repeated .draiosproto.mongodb_collection_details server_collections = 3;
  int server_collections_size() const;
  void clear_server_collections();
  static const int kServerCollectionsFieldNumber = 3;
  const ::draiosproto::mongodb_collection_details& server_collections(int index) const;
  ::draiosproto::mongodb_collection_details* mutable_server_collections(int index);
  ::draiosproto::mongodb_collection_details* add_server_collections();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_collection_details >*
      mutable_server_collections();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_collection_details >&
      server_collections() const;

  // repeated .draiosproto.mongodb_collection_details client_collections = 4;
  int client_collections_size() const;
  void clear_client_collections();
  static const int kClientCollectionsFieldNumber = 4;
  const ::draiosproto::mongodb_collection_details& client_collections(int index) const;
  ::draiosproto::mongodb_collection_details* mutable_client_collections(int index);
  ::draiosproto::mongodb_collection_details* add_client_collections();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_collection_details >*
      mutable_client_collections();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_collection_details >&
      client_collections() const;

  // @@protoc_insertion_point(class_scope:draiosproto.mongodb_info)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_op_type_details > servers_ops_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_op_type_details > client_ops_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_collection_details > server_collections_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_collection_details > client_collections_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<mongodb_info> mongodb_info_default_instance_;

// -------------------------------------------------------------------

class jmx_attribute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.jmx_attribute) */ {
 public:
  jmx_attribute();
  virtual ~jmx_attribute();

  jmx_attribute(const jmx_attribute& from);

  inline jmx_attribute& operator=(const jmx_attribute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const jmx_attribute& default_instance();

  static const jmx_attribute* internal_default_instance();

  void Swap(jmx_attribute* other);

  // implements Message ----------------------------------------------

  inline jmx_attribute* New() const { return New(NULL); }

  jmx_attribute* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const jmx_attribute& from);
  void MergeFrom(const jmx_attribute& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(jmx_attribute* other);
  void UnsafeMergeFrom(const jmx_attribute& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional double value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  double value() const;
  void set_value(double value);

  // optional string alias = 5;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 5;
  const ::std::string& alias() const;
  void set_alias(const ::std::string& value);
  void set_alias(const char* value);
  void set_alias(const char* value, size_t size);
  ::std::string* mutable_alias();
  ::std::string* release_alias();
  void set_allocated_alias(::std::string* alias);

  // optional .draiosproto.jmx_metric_type type = 7;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 7;
  ::draiosproto::jmx_metric_type type() const;
  void set_type(::draiosproto::jmx_metric_type value);

  // optional .draiosproto.unit unit = 8;
  bool has_unit() const;
  void clear_unit();
  static const int kUnitFieldNumber = 8;
  ::draiosproto::unit unit() const;
  void set_unit(::draiosproto::unit value);

  // optional .draiosproto.scale scale = 9;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 9;
  ::draiosproto::scale scale() const;
  void set_scale(::draiosproto::scale value);

  // repeated .draiosproto.jmx_attribute subattributes = 3;
  int subattributes_size() const;
  void clear_subattributes();
  static const int kSubattributesFieldNumber = 3;
  const ::draiosproto::jmx_attribute& subattributes(int index) const;
  ::draiosproto::jmx_attribute* mutable_subattributes(int index);
  ::draiosproto::jmx_attribute* add_subattributes();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_attribute >*
      mutable_subattributes();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_attribute >&
      subattributes() const;

  // @@protoc_insertion_point(class_scope:draiosproto.jmx_attribute)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_alias();
  inline void clear_has_alias();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_unit();
  inline void clear_has_unit();
  inline void set_has_scale();
  inline void clear_has_scale();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_attribute > subattributes_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr alias_;
  double value_;
  int unit_;
  int scale_;
  int type_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<jmx_attribute> jmx_attribute_default_instance_;

// -------------------------------------------------------------------

class jmx_bean : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.jmx_bean) */ {
 public:
  jmx_bean();
  virtual ~jmx_bean();

  jmx_bean(const jmx_bean& from);

  inline jmx_bean& operator=(const jmx_bean& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const jmx_bean& default_instance();

  static const jmx_bean* internal_default_instance();

  void Swap(jmx_bean* other);

  // implements Message ----------------------------------------------

  inline jmx_bean* New() const { return New(NULL); }

  jmx_bean* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const jmx_bean& from);
  void MergeFrom(const jmx_bean& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(jmx_bean* other);
  void UnsafeMergeFrom(const jmx_bean& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .draiosproto.jmx_attribute attributes = 2;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 2;
  const ::draiosproto::jmx_attribute& attributes(int index) const;
  ::draiosproto::jmx_attribute* mutable_attributes(int index);
  ::draiosproto::jmx_attribute* add_attributes();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_attribute >*
      mutable_attributes();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_attribute >&
      attributes() const;

  // @@protoc_insertion_point(class_scope:draiosproto.jmx_bean)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_attribute > attributes_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<jmx_bean> jmx_bean_default_instance_;

// -------------------------------------------------------------------

class java_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.java_info) */ {
 public:
  java_info();
  virtual ~java_info();

  java_info(const java_info& from);

  inline java_info& operator=(const java_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const java_info& default_instance();

  static const java_info* internal_default_instance();

  void Swap(java_info* other);

  // implements Message ----------------------------------------------

  inline java_info* New() const { return New(NULL); }

  java_info* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const java_info& from);
  void MergeFrom(const java_info& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(java_info* other);
  void UnsafeMergeFrom(const java_info& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string process_name = 1;
  bool has_process_name() const;
  void clear_process_name();
  static const int kProcessNameFieldNumber = 1;
  const ::std::string& process_name() const;
  void set_process_name(const ::std::string& value);
  void set_process_name(const char* value);
  void set_process_name(const char* value, size_t size);
  ::std::string* mutable_process_name();
  ::std::string* release_process_name();
  void set_allocated_process_name(::std::string* process_name);

  // repeated .draiosproto.jmx_bean beans = 2;
  int beans_size() const;
  void clear_beans();
  static const int kBeansFieldNumber = 2;
  const ::draiosproto::jmx_bean& beans(int index) const;
  ::draiosproto::jmx_bean* mutable_beans(int index);
  ::draiosproto::jmx_bean* add_beans();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_bean >*
      mutable_beans();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_bean >&
      beans() const;

  // @@protoc_insertion_point(class_scope:draiosproto.java_info)
 private:
  inline void set_has_process_name();
  inline void clear_has_process_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_bean > beans_;
  ::google::protobuf::internal::ArenaStringPtr process_name_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<java_info> java_info_default_instance_;

// -------------------------------------------------------------------

class statsd_tag : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.statsd_tag) */ {
 public:
  statsd_tag();
  virtual ~statsd_tag();

  statsd_tag(const statsd_tag& from);

  inline statsd_tag& operator=(const statsd_tag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const statsd_tag& default_instance();

  static const statsd_tag* internal_default_instance();

  void Swap(statsd_tag* other);

  // implements Message ----------------------------------------------

  inline statsd_tag* New() const { return New(NULL); }

  statsd_tag* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const statsd_tag& from);
  void MergeFrom(const statsd_tag& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(statsd_tag* other);
  void UnsafeMergeFrom(const statsd_tag& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:draiosproto.statsd_tag)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<statsd_tag> statsd_tag_default_instance_;

// -------------------------------------------------------------------

class statsd_metric : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.statsd_metric) */ {
 public:
  statsd_metric();
  virtual ~statsd_metric();

  statsd_metric(const statsd_metric& from);

  inline statsd_metric& operator=(const statsd_metric& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const statsd_metric& default_instance();

  static const statsd_metric* internal_default_instance();

  void Swap(statsd_metric* other);

  // implements Message ----------------------------------------------

  inline statsd_metric* New() const { return New(NULL); }

  statsd_metric* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const statsd_metric& from);
  void MergeFrom(const statsd_metric& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(statsd_metric* other);
  void UnsafeMergeFrom(const statsd_metric& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .draiosproto.statsd_tag tags = 2;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 2;
  const ::draiosproto::statsd_tag& tags(int index) const;
  ::draiosproto::statsd_tag* mutable_tags(int index);
  ::draiosproto::statsd_tag* add_tags();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::statsd_tag >*
      mutable_tags();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::statsd_tag >&
      tags() const;

  // optional .draiosproto.statsd_metric_type type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::draiosproto::statsd_metric_type type() const;
  void set_type(::draiosproto::statsd_metric_type value);

  // optional double value = 4;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 4;
  double value() const;
  void set_value(double value);

  // optional double sum = 5;
  bool has_sum() const;
  void clear_sum();
  static const int kSumFieldNumber = 5;
  double sum() const;
  void set_sum(double value);

  // optional double min = 6;
  bool has_min() const;
  void clear_min();
  static const int kMinFieldNumber = 6;
  double min() const;
  void set_min(double value);

  // optional double max = 7;
  bool has_max() const;
  void clear_max();
  static const int kMaxFieldNumber = 7;
  double max() const;
  void set_max(double value);

  // optional double count = 8;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 8;
  double count() const;
  void set_count(double value);

  // optional double median = 9;
  bool has_median() const;
  void clear_median();
  static const int kMedianFieldNumber = 9;
  double median() const;
  void set_median(double value);

  // optional double percentile_95 = 10;
  bool has_percentile_95() const;
  void clear_percentile_95();
  static const int kPercentile95FieldNumber = 10;
  double percentile_95() const;
  void set_percentile_95(double value);

  // optional double percentile_99 = 11;
  bool has_percentile_99() const;
  void clear_percentile_99();
  static const int kPercentile99FieldNumber = 11;
  double percentile_99() const;
  void set_percentile_99(double value);

  // @@protoc_insertion_point(class_scope:draiosproto.statsd_metric)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_sum();
  inline void clear_has_sum();
  inline void set_has_min();
  inline void clear_has_min();
  inline void set_has_max();
  inline void clear_has_max();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_median();
  inline void clear_has_median();
  inline void set_has_percentile_95();
  inline void clear_has_percentile_95();
  inline void set_has_percentile_99();
  inline void clear_has_percentile_99();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::statsd_tag > tags_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  double value_;
  double sum_;
  double min_;
  double max_;
  double count_;
  double median_;
  double percentile_95_;
  double percentile_99_;
  int type_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<statsd_metric> statsd_metric_default_instance_;

// -------------------------------------------------------------------

class statsd_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.statsd_info) */ {
 public:
  statsd_info();
  virtual ~statsd_info();

  statsd_info(const statsd_info& from);

  inline statsd_info& operator=(const statsd_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const statsd_info& default_instance();

  static const statsd_info* internal_default_instance();

  void Swap(statsd_info* other);

  // implements Message ----------------------------------------------

  inline statsd_info* New() const { return New(NULL); }

  statsd_info* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const statsd_info& from);
  void MergeFrom(const statsd_info& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(statsd_info* other);
  void UnsafeMergeFrom(const statsd_info& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .draiosproto.statsd_metric statsd_metrics = 1;
  int statsd_metrics_size() const;
  void clear_statsd_metrics();
  static const int kStatsdMetricsFieldNumber = 1;
  const ::draiosproto::statsd_metric& statsd_metrics(int index) const;
  ::draiosproto::statsd_metric* mutable_statsd_metrics(int index);
  ::draiosproto::statsd_metric* add_statsd_metrics();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::statsd_metric >*
      mutable_statsd_metrics();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::statsd_metric >&
      statsd_metrics() const;

  // @@protoc_insertion_point(class_scope:draiosproto.statsd_info)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::statsd_metric > statsd_metrics_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<statsd_info> statsd_info_default_instance_;

// -------------------------------------------------------------------

class app_tag : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.app_tag) */ {
 public:
  app_tag();
  virtual ~app_tag();

  app_tag(const app_tag& from);

  inline app_tag& operator=(const app_tag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const app_tag& default_instance();

  static const app_tag* internal_default_instance();

  void Swap(app_tag* other);

  // implements Message ----------------------------------------------

  inline app_tag* New() const { return New(NULL); }

  app_tag* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const app_tag& from);
  void MergeFrom(const app_tag& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(app_tag* other);
  void UnsafeMergeFrom(const app_tag& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:draiosproto.app_tag)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<app_tag> app_tag_default_instance_;

// -------------------------------------------------------------------

class app_metric : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.app_metric) */ {
 public:
  app_metric();
  virtual ~app_metric();

  app_metric(const app_metric& from);

  inline app_metric& operator=(const app_metric& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const app_metric& default_instance();

  static const app_metric* internal_default_instance();

  void Swap(app_metric* other);

  // implements Message ----------------------------------------------

  inline app_metric* New() const { return New(NULL); }

  app_metric* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const app_metric& from);
  void MergeFrom(const app_metric& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(app_metric* other);
  void UnsafeMergeFrom(const app_metric& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .draiosproto.app_metric_type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::draiosproto::app_metric_type type() const;
  void set_type(::draiosproto::app_metric_type value);

  // optional double value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  double value() const;
  void set_value(double value);

  // repeated .draiosproto.app_tag tags = 4;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 4;
  const ::draiosproto::app_tag& tags(int index) const;
  ::draiosproto::app_tag* mutable_tags(int index);
  ::draiosproto::app_tag* add_tags();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::app_tag >*
      mutable_tags();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::app_tag >&
      tags() const;

  // @@protoc_insertion_point(class_scope:draiosproto.app_metric)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::app_tag > tags_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  double value_;
  int type_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<app_metric> app_metric_default_instance_;

// -------------------------------------------------------------------

class app_check : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.app_check) */ {
 public:
  app_check();
  virtual ~app_check();

  app_check(const app_check& from);

  inline app_check& operator=(const app_check& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const app_check& default_instance();

  static const app_check* internal_default_instance();

  void Swap(app_check* other);

  // implements Message ----------------------------------------------

  inline app_check* New() const { return New(NULL); }

  app_check* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const app_check& from);
  void MergeFrom(const app_check& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(app_check* other);
  void UnsafeMergeFrom(const app_check& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .draiosproto.app_check_value value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::draiosproto::app_check_value value() const;
  void set_value(::draiosproto::app_check_value value);

  // repeated .draiosproto.app_tag tags = 3;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 3;
  const ::draiosproto::app_tag& tags(int index) const;
  ::draiosproto::app_tag* mutable_tags(int index);
  ::draiosproto::app_tag* add_tags();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::app_tag >*
      mutable_tags();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::app_tag >&
      tags() const;

  // @@protoc_insertion_point(class_scope:draiosproto.app_check)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::app_tag > tags_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int value_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<app_check> app_check_default_instance_;

// -------------------------------------------------------------------

class app_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.app_info) */ {
 public:
  app_info();
  virtual ~app_info();

  app_info(const app_info& from);

  inline app_info& operator=(const app_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const app_info& default_instance();

  static const app_info* internal_default_instance();

  void Swap(app_info* other);

  // implements Message ----------------------------------------------

  inline app_info* New() const { return New(NULL); }

  app_info* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const app_info& from);
  void MergeFrom(const app_info& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(app_info* other);
  void UnsafeMergeFrom(const app_info& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string process_name = 1;
  bool has_process_name() const;
  void clear_process_name();
  static const int kProcessNameFieldNumber = 1;
  const ::std::string& process_name() const;
  void set_process_name(const ::std::string& value);
  void set_process_name(const char* value);
  void set_process_name(const char* value, size_t size);
  ::std::string* mutable_process_name();
  ::std::string* release_process_name();
  void set_allocated_process_name(::std::string* process_name);

  // repeated .draiosproto.app_metric metrics = 2;
  int metrics_size() const;
  void clear_metrics();
  static const int kMetricsFieldNumber = 2;
  const ::draiosproto::app_metric& metrics(int index) const;
  ::draiosproto::app_metric* mutable_metrics(int index);
  ::draiosproto::app_metric* add_metrics();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::app_metric >*
      mutable_metrics();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::app_metric >&
      metrics() const;

  // repeated .draiosproto.app_check checks = 3;
  int checks_size() const;
  void clear_checks();
  static const int kChecksFieldNumber = 3;
  const ::draiosproto::app_check& checks(int index) const;
  ::draiosproto::app_check* mutable_checks(int index);
  ::draiosproto::app_check* add_checks();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::app_check >*
      mutable_checks();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::app_check >&
      checks() const;

  // @@protoc_insertion_point(class_scope:draiosproto.app_info)
 private:
  inline void set_has_process_name();
  inline void clear_has_process_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::app_metric > metrics_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::app_check > checks_;
  ::google::protobuf::internal::ArenaStringPtr process_name_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<app_info> app_info_default_instance_;

// -------------------------------------------------------------------

class proto_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.proto_info) */ {
 public:
  proto_info();
  virtual ~proto_info();

  proto_info(const proto_info& from);

  inline proto_info& operator=(const proto_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const proto_info& default_instance();

  static const proto_info* internal_default_instance();

  void Swap(proto_info* other);

  // implements Message ----------------------------------------------

  inline proto_info* New() const { return New(NULL); }

  proto_info* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const proto_info& from);
  void MergeFrom(const proto_info& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(proto_info* other);
  void UnsafeMergeFrom(const proto_info& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .draiosproto.http_info http = 1;
  bool has_http() const;
  void clear_http();
  static const int kHttpFieldNumber = 1;
  const ::draiosproto::http_info& http() const;
  ::draiosproto::http_info* mutable_http();
  ::draiosproto::http_info* release_http();
  void set_allocated_http(::draiosproto::http_info* http);

  // optional .draiosproto.sql_info mysql = 2;
  bool has_mysql() const;
  void clear_mysql();
  static const int kMysqlFieldNumber = 2;
  const ::draiosproto::sql_info& mysql() const;
  ::draiosproto::sql_info* mutable_mysql();
  ::draiosproto::sql_info* release_mysql();
  void set_allocated_mysql(::draiosproto::sql_info* mysql);

  // optional .draiosproto.sql_info postgres = 3;
  bool has_postgres() const;
  void clear_postgres();
  static const int kPostgresFieldNumber = 3;
  const ::draiosproto::sql_info& postgres() const;
  ::draiosproto::sql_info* mutable_postgres();
  ::draiosproto::sql_info* release_postgres();
  void set_allocated_postgres(::draiosproto::sql_info* postgres);

  // optional .draiosproto.mongodb_info mongodb = 4;
  bool has_mongodb() const;
  void clear_mongodb();
  static const int kMongodbFieldNumber = 4;
  const ::draiosproto::mongodb_info& mongodb() const;
  ::draiosproto::mongodb_info* mutable_mongodb();
  ::draiosproto::mongodb_info* release_mongodb();
  void set_allocated_mongodb(::draiosproto::mongodb_info* mongodb);

  // optional .draiosproto.java_info java = 5;
  bool has_java() const;
  void clear_java();
  static const int kJavaFieldNumber = 5;
  const ::draiosproto::java_info& java() const;
  ::draiosproto::java_info* mutable_java();
  ::draiosproto::java_info* release_java();
  void set_allocated_java(::draiosproto::java_info* java);

  // optional .draiosproto.statsd_info statsd = 6;
  bool has_statsd() const;
  void clear_statsd();
  static const int kStatsdFieldNumber = 6;
  const ::draiosproto::statsd_info& statsd() const;
  ::draiosproto::statsd_info* mutable_statsd();
  ::draiosproto::statsd_info* release_statsd();
  void set_allocated_statsd(::draiosproto::statsd_info* statsd);

  // optional .draiosproto.app_info app = 7;
  bool has_app() const;
  void clear_app();
  static const int kAppFieldNumber = 7;
  const ::draiosproto::app_info& app() const;
  ::draiosproto::app_info* mutable_app();
  ::draiosproto::app_info* release_app();
  void set_allocated_app(::draiosproto::app_info* app);

  // @@protoc_insertion_point(class_scope:draiosproto.proto_info)
 private:
  inline void set_has_http();
  inline void clear_has_http();
  inline void set_has_mysql();
  inline void clear_has_mysql();
  inline void set_has_postgres();
  inline void clear_has_postgres();
  inline void set_has_mongodb();
  inline void clear_has_mongodb();
  inline void set_has_java();
  inline void clear_has_java();
  inline void set_has_statsd();
  inline void clear_has_statsd();
  inline void set_has_app();
  inline void clear_has_app();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::draiosproto::http_info* http_;
  ::draiosproto::sql_info* mysql_;
  ::draiosproto::sql_info* postgres_;
  ::draiosproto::mongodb_info* mongodb_;
  ::draiosproto::java_info* java_;
  ::draiosproto::statsd_info* statsd_;
  ::draiosproto::app_info* app_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<proto_info> proto_info_default_instance_;

// -------------------------------------------------------------------

class network_by_port : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.network_by_port) */ {
 public:
  network_by_port();
  virtual ~network_by_port();

  network_by_port(const network_by_port& from);

  inline network_by_port& operator=(const network_by_port& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const network_by_port& default_instance();

  static const network_by_port* internal_default_instance();

  void Swap(network_by_port* other);

  // implements Message ----------------------------------------------

  inline network_by_port* New() const { return New(NULL); }

  network_by_port* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const network_by_port& from);
  void MergeFrom(const network_by_port& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(network_by_port* other);
  void UnsafeMergeFrom(const network_by_port& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 port = 1;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 1;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // required .draiosproto.connection_categories counters = 2;
  bool has_counters() const;
  void clear_counters();
  static const int kCountersFieldNumber = 2;
  const ::draiosproto::connection_categories& counters() const;
  ::draiosproto::connection_categories* mutable_counters();
  ::draiosproto::connection_categories* release_counters();
  void set_allocated_counters(::draiosproto::connection_categories* counters);

  // @@protoc_insertion_point(class_scope:draiosproto.network_by_port)
 private:
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_counters();
  inline void clear_has_counters();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::draiosproto::connection_categories* counters_;
  ::google::protobuf::uint32 port_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<network_by_port> network_by_port_default_instance_;

// -------------------------------------------------------------------

class host : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.host) */ {
 public:
  host();
  virtual ~host();

  host(const host& from);

  inline host& operator=(const host& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const host& default_instance();

  static const host* internal_default_instance();

  void Swap(host* other);

  // implements Message ----------------------------------------------

  inline host* New() const { return New(NULL); }

  host* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const host& from);
  void MergeFrom(const host& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(host* other);
  void UnsafeMergeFrom(const host& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string hostname = 1;
  bool has_hostname() const;
  void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);

  // optional uint32 num_cpus = 2;
  bool has_num_cpus() const;
  void clear_num_cpus();
  static const int kNumCpusFieldNumber = 2;
  ::google::protobuf::uint32 num_cpus() const;
  void set_num_cpus(::google::protobuf::uint32 value);

  // repeated uint32 cpu_loads = 3;
  int cpu_loads_size() const;
  void clear_cpu_loads();
  static const int kCpuLoadsFieldNumber = 3;
  ::google::protobuf::uint32 cpu_loads(int index) const;
  void set_cpu_loads(int index, ::google::protobuf::uint32 value);
  void add_cpu_loads(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      cpu_loads() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_cpu_loads();

  // repeated uint32 cpu_steal = 11;
  int cpu_steal_size() const;
  void clear_cpu_steal();
  static const int kCpuStealFieldNumber = 11;
  ::google::protobuf::uint32 cpu_steal(int index) const;
  void set_cpu_steal(int index, ::google::protobuf::uint32 value);
  void add_cpu_steal(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      cpu_steal() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_cpu_steal();

  // required uint64 physical_memory_size_bytes = 4;
  bool has_physical_memory_size_bytes() const;
  void clear_physical_memory_size_bytes();
  static const int kPhysicalMemorySizeBytesFieldNumber = 4;
  ::google::protobuf::uint64 physical_memory_size_bytes() const;
  void set_physical_memory_size_bytes(::google::protobuf::uint64 value);

  // optional .draiosproto.time_categories tcounters = 5;
  bool has_tcounters() const;
  void clear_tcounters();
  static const int kTcountersFieldNumber = 5;
  const ::draiosproto::time_categories& tcounters() const;
  ::draiosproto::time_categories* mutable_tcounters();
  ::draiosproto::time_categories* release_tcounters();
  void set_allocated_tcounters(::draiosproto::time_categories* tcounters);

  // optional .draiosproto.transaction_breakdown_categories reqcounters = 12;
  bool has_reqcounters() const;
  void clear_reqcounters();
  static const int kReqcountersFieldNumber = 12;
  const ::draiosproto::transaction_breakdown_categories& reqcounters() const;
  ::draiosproto::transaction_breakdown_categories* mutable_reqcounters();
  ::draiosproto::transaction_breakdown_categories* release_reqcounters();
  void set_allocated_reqcounters(::draiosproto::transaction_breakdown_categories* reqcounters);

  // optional .draiosproto.counter_time_bidirectional transaction_counters = 6;
  bool has_transaction_counters() const;
  void clear_transaction_counters();
  static const int kTransactionCountersFieldNumber = 6;
  const ::draiosproto::counter_time_bidirectional& transaction_counters() const;
  ::draiosproto::counter_time_bidirectional* mutable_transaction_counters();
  ::draiosproto::counter_time_bidirectional* release_transaction_counters();
  void set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters);

  // optional .draiosproto.counter_time_bidirectional min_transaction_counters = 22;
  bool has_min_transaction_counters() const;
  void clear_min_transaction_counters();
  static const int kMinTransactionCountersFieldNumber = 22;
  const ::draiosproto::counter_time_bidirectional& min_transaction_counters() const;
  ::draiosproto::counter_time_bidirectional* mutable_min_transaction_counters();
  ::draiosproto::counter_time_bidirectional* release_min_transaction_counters();
  void set_allocated_min_transaction_counters(::draiosproto::counter_time_bidirectional* min_transaction_counters);

  // optional .draiosproto.counter_time_bidirectional max_transaction_counters = 23;
  bool has_max_transaction_counters() const;
  void clear_max_transaction_counters();
  static const int kMaxTransactionCountersFieldNumber = 23;
  const ::draiosproto::counter_time_bidirectional& max_transaction_counters() const;
  ::draiosproto::counter_time_bidirectional* mutable_max_transaction_counters();
  ::draiosproto::counter_time_bidirectional* release_max_transaction_counters();
  void set_allocated_max_transaction_counters(::draiosproto::counter_time_bidirectional* max_transaction_counters);

  // optional uint64 transaction_processing_delay = 7;
  bool has_transaction_processing_delay() const;
  void clear_transaction_processing_delay();
  static const int kTransactionProcessingDelayFieldNumber = 7;
  ::google::protobuf::uint64 transaction_processing_delay() const;
  void set_transaction_processing_delay(::google::protobuf::uint64 value);

  // optional uint64 next_tiers_delay = 13;
  bool has_next_tiers_delay() const;
  void clear_next_tiers_delay();
  static const int kNextTiersDelayFieldNumber = 13;
  ::google::protobuf::uint64 next_tiers_delay() const;
  void set_next_tiers_delay(::google::protobuf::uint64 value);

  // optional .draiosproto.resource_categories resource_counters = 8;
  bool has_resource_counters() const;
  void clear_resource_counters();
  static const int kResourceCountersFieldNumber = 8;
  const ::draiosproto::resource_categories& resource_counters() const;
  ::draiosproto::resource_categories* mutable_resource_counters();
  ::draiosproto::resource_categories* release_resource_counters();
  void set_allocated_resource_counters(::draiosproto::resource_categories* resource_counters);

  // optional .draiosproto.counter_syscall_errors syscall_errors = 9;
  bool has_syscall_errors() const;
  void clear_syscall_errors();
  static const int kSyscallErrorsFieldNumber = 9;
  const ::draiosproto::counter_syscall_errors& syscall_errors() const;
  ::draiosproto::counter_syscall_errors* mutable_syscall_errors();
  ::draiosproto::counter_syscall_errors* release_syscall_errors();
  void set_allocated_syscall_errors(::draiosproto::counter_syscall_errors* syscall_errors);

  // optional .draiosproto.counter_time_bytes external_io_net = 10;
  bool has_external_io_net() const;
  void clear_external_io_net();
  static const int kExternalIoNetFieldNumber = 10;
  const ::draiosproto::counter_time_bytes& external_io_net() const;
  ::draiosproto::counter_time_bytes* mutable_external_io_net();
  ::draiosproto::counter_time_bytes* release_external_io_net();
  void set_allocated_external_io_net(::draiosproto::counter_time_bytes* external_io_net);

  // repeated .draiosproto.network_by_port network_by_serverports = 24;
  int network_by_serverports_size() const;
  void clear_network_by_serverports();
  static const int kNetworkByServerportsFieldNumber = 24;
  const ::draiosproto::network_by_port& network_by_serverports(int index) const;
  ::draiosproto::network_by_port* mutable_network_by_serverports(int index);
  ::draiosproto::network_by_port* add_network_by_serverports();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::network_by_port >*
      mutable_network_by_serverports();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::network_by_port >&
      network_by_serverports() const;

  // repeated uint32 cpu_idle = 25;
  int cpu_idle_size() const;
  void clear_cpu_idle();
  static const int kCpuIdleFieldNumber = 25;
  ::google::protobuf::uint32 cpu_idle(int index) const;
  void set_cpu_idle(int index, ::google::protobuf::uint32 value);
  void add_cpu_idle(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      cpu_idle() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_cpu_idle();

  // optional uint64 uptime = 33;
  bool has_uptime() const;
  void clear_uptime();
  static const int kUptimeFieldNumber = 33;
  ::google::protobuf::uint64 uptime() const;
  void set_uptime(::google::protobuf::uint64 value);

  // repeated uint32 system_cpu = 34;
  int system_cpu_size() const;
  void clear_system_cpu();
  static const int kSystemCpuFieldNumber = 34;
  ::google::protobuf::uint32 system_cpu(int index) const;
  void set_system_cpu(int index, ::google::protobuf::uint32 value);
  void add_system_cpu(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      system_cpu() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_system_cpu();

  // repeated uint32 user_cpu = 35;
  int user_cpu_size() const;
  void clear_user_cpu();
  static const int kUserCpuFieldNumber = 35;
  ::google::protobuf::uint32 user_cpu(int index) const;
  void set_user_cpu(int index, ::google::protobuf::uint32 value);
  void add_user_cpu(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      user_cpu() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_user_cpu();

  // optional uint64 memory_bytes_available_kb = 36;
  bool has_memory_bytes_available_kb() const;
  void clear_memory_bytes_available_kb();
  static const int kMemoryBytesAvailableKbFieldNumber = 36;
  ::google::protobuf::uint64 memory_bytes_available_kb() const;
  void set_memory_bytes_available_kb(::google::protobuf::uint64 value);

  // repeated uint32 iowait_cpu = 37;
  int iowait_cpu_size() const;
  void clear_iowait_cpu();
  static const int kIowaitCpuFieldNumber = 37;
  ::google::protobuf::uint32 iowait_cpu(int index) const;
  void set_iowait_cpu(int index, ::google::protobuf::uint32 value);
  void add_iowait_cpu(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      iowait_cpu() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_iowait_cpu();

  // repeated uint32 nice_cpu = 38;
  int nice_cpu_size() const;
  void clear_nice_cpu();
  static const int kNiceCpuFieldNumber = 38;
  ::google::protobuf::uint32 nice_cpu(int index) const;
  void set_nice_cpu(int index, ::google::protobuf::uint32 value);
  void add_nice_cpu(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      nice_cpu() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_nice_cpu();

  // optional uint32 system_load_1 = 41;
  bool has_system_load_1() const;
  void clear_system_load_1();
  static const int kSystemLoad1FieldNumber = 41;
  ::google::protobuf::uint32 system_load_1() const;
  void set_system_load_1(::google::protobuf::uint32 value);

  // optional uint32 system_load_5 = 42;
  bool has_system_load_5() const;
  void clear_system_load_5();
  static const int kSystemLoad5FieldNumber = 42;
  ::google::protobuf::uint32 system_load_5() const;
  void set_system_load_5(::google::protobuf::uint32 value);

  // optional uint32 system_load_15 = 43;
  bool has_system_load_15() const;
  void clear_system_load_15();
  static const int kSystemLoad15FieldNumber = 43;
  ::google::protobuf::uint32 system_load_15() const;
  void set_system_load_15(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.host)
 private:
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_num_cpus();
  inline void clear_has_num_cpus();
  inline void set_has_physical_memory_size_bytes();
  inline void clear_has_physical_memory_size_bytes();
  inline void set_has_tcounters();
  inline void clear_has_tcounters();
  inline void set_has_reqcounters();
  inline void clear_has_reqcounters();
  inline void set_has_transaction_counters();
  inline void clear_has_transaction_counters();
  inline void set_has_min_transaction_counters();
  inline void clear_has_min_transaction_counters();
  inline void set_has_max_transaction_counters();
  inline void clear_has_max_transaction_counters();
  inline void set_has_transaction_processing_delay();
  inline void clear_has_transaction_processing_delay();
  inline void set_has_next_tiers_delay();
  inline void clear_has_next_tiers_delay();
  inline void set_has_resource_counters();
  inline void clear_has_resource_counters();
  inline void set_has_syscall_errors();
  inline void clear_has_syscall_errors();
  inline void set_has_external_io_net();
  inline void clear_has_external_io_net();
  inline void set_has_uptime();
  inline void clear_has_uptime();
  inline void set_has_memory_bytes_available_kb();
  inline void clear_has_memory_bytes_available_kb();
  inline void set_has_system_load_1();
  inline void clear_has_system_load_1();
  inline void set_has_system_load_5();
  inline void clear_has_system_load_5();
  inline void set_has_system_load_15();
  inline void clear_has_system_load_15();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > cpu_loads_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > cpu_steal_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::network_by_port > network_by_serverports_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > cpu_idle_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > system_cpu_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > user_cpu_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > iowait_cpu_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > nice_cpu_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  ::draiosproto::time_categories* tcounters_;
  ::draiosproto::transaction_breakdown_categories* reqcounters_;
  ::draiosproto::counter_time_bidirectional* transaction_counters_;
  ::draiosproto::counter_time_bidirectional* min_transaction_counters_;
  ::draiosproto::counter_time_bidirectional* max_transaction_counters_;
  ::draiosproto::resource_categories* resource_counters_;
  ::draiosproto::counter_syscall_errors* syscall_errors_;
  ::draiosproto::counter_time_bytes* external_io_net_;
  ::google::protobuf::uint64 physical_memory_size_bytes_;
  ::google::protobuf::uint64 transaction_processing_delay_;
  ::google::protobuf::uint64 next_tiers_delay_;
  ::google::protobuf::uint32 num_cpus_;
  ::google::protobuf::uint32 system_load_1_;
  ::google::protobuf::uint64 uptime_;
  ::google::protobuf::uint64 memory_bytes_available_kb_;
  ::google::protobuf::uint32 system_load_5_;
  ::google::protobuf::uint32 system_load_15_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<host> host_default_instance_;

// -------------------------------------------------------------------

class process : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.process) */ {
 public:
  process();
  virtual ~process();

  process(const process& from);

  inline process& operator=(const process& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const process& default_instance();

  static const process* internal_default_instance();

  void Swap(process* other);

  // implements Message ----------------------------------------------

  inline process* New() const { return New(NULL); }

  process* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const process& from);
  void MergeFrom(const process& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(process* other);
  void UnsafeMergeFrom(const process& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .draiosproto.process_details details = 2;
  bool has_details() const;
  void clear_details();
  static const int kDetailsFieldNumber = 2;
  const ::draiosproto::process_details& details() const;
  ::draiosproto::process_details* mutable_details();
  ::draiosproto::process_details* release_details();
  void set_allocated_details(::draiosproto::process_details* details);

  // optional bool is_ipv4_transaction_server = 3;
  bool has_is_ipv4_transaction_server() const;
  void clear_is_ipv4_transaction_server();
  static const int kIsIpv4TransactionServerFieldNumber = 3;
  bool is_ipv4_transaction_server() const;
  void set_is_ipv4_transaction_server(bool value);

  // optional bool is_unix_transaction_server = 4;
  bool has_is_unix_transaction_server() const;
  void clear_is_unix_transaction_server();
  static const int kIsUnixTransactionServerFieldNumber = 4;
  bool is_unix_transaction_server() const;
  void set_is_unix_transaction_server(bool value);

  // optional bool is_ipv4_transaction_client = 10;
  bool has_is_ipv4_transaction_client() const;
  void clear_is_ipv4_transaction_client();
  static const int kIsIpv4TransactionClientFieldNumber = 10;
  bool is_ipv4_transaction_client() const;
  void set_is_ipv4_transaction_client(bool value);

  // optional bool is_unix_transaction_client = 11;
  bool has_is_unix_transaction_client() const;
  void clear_is_unix_transaction_client();
  static const int kIsUnixTransactionClientFieldNumber = 11;
  bool is_unix_transaction_client() const;
  void set_is_unix_transaction_client(bool value);

  // optional uint32 netrole = 13;
  bool has_netrole() const;
  void clear_netrole();
  static const int kNetroleFieldNumber = 13;
  ::google::protobuf::uint32 netrole() const;
  void set_netrole(::google::protobuf::uint32 value);

  // optional .draiosproto.time_categories tcounters = 5;
  bool has_tcounters() const;
  void clear_tcounters();
  static const int kTcountersFieldNumber = 5;
  const ::draiosproto::time_categories& tcounters() const;
  ::draiosproto::time_categories* mutable_tcounters();
  ::draiosproto::time_categories* release_tcounters();
  void set_allocated_tcounters(::draiosproto::time_categories* tcounters);

  // optional .draiosproto.counter_time_bidirectional transaction_counters = 6;
  bool has_transaction_counters() const;
  void clear_transaction_counters();
  static const int kTransactionCountersFieldNumber = 6;
  const ::draiosproto::counter_time_bidirectional& transaction_counters() const;
  ::draiosproto::counter_time_bidirectional* mutable_transaction_counters();
  ::draiosproto::counter_time_bidirectional* release_transaction_counters();
  void set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters);

  // optional .draiosproto.counter_time_bidirectional min_transaction_counters = 18;
  bool has_min_transaction_counters() const;
  void clear_min_transaction_counters();
  static const int kMinTransactionCountersFieldNumber = 18;
  const ::draiosproto::counter_time_bidirectional& min_transaction_counters() const;
  ::draiosproto::counter_time_bidirectional* mutable_min_transaction_counters();
  ::draiosproto::counter_time_bidirectional* release_min_transaction_counters();
  void set_allocated_min_transaction_counters(::draiosproto::counter_time_bidirectional* min_transaction_counters);

  // optional .draiosproto.counter_time_bidirectional max_transaction_counters = 19;
  bool has_max_transaction_counters() const;
  void clear_max_transaction_counters();
  static const int kMaxTransactionCountersFieldNumber = 19;
  const ::draiosproto::counter_time_bidirectional& max_transaction_counters() const;
  ::draiosproto::counter_time_bidirectional* mutable_max_transaction_counters();
  ::draiosproto::counter_time_bidirectional* release_max_transaction_counters();
  void set_allocated_max_transaction_counters(::draiosproto::counter_time_bidirectional* max_transaction_counters);

  // optional uint64 transaction_processing_delay = 7;
  bool has_transaction_processing_delay() const;
  void clear_transaction_processing_delay();
  static const int kTransactionProcessingDelayFieldNumber = 7;
  ::google::protobuf::uint64 transaction_processing_delay() const;
  void set_transaction_processing_delay(::google::protobuf::uint64 value);

  // optional uint64 next_tiers_delay = 12;
  bool has_next_tiers_delay() const;
  void clear_next_tiers_delay();
  static const int kNextTiersDelayFieldNumber = 12;
  ::google::protobuf::uint64 next_tiers_delay() const;
  void set_next_tiers_delay(::google::protobuf::uint64 value);

  // optional .draiosproto.resource_categories resource_counters = 8;
  bool has_resource_counters() const;
  void clear_resource_counters();
  static const int kResourceCountersFieldNumber = 8;
  const ::draiosproto::resource_categories& resource_counters() const;
  ::draiosproto::resource_categories* mutable_resource_counters();
  ::draiosproto::resource_categories* release_resource_counters();
  void set_allocated_resource_counters(::draiosproto::resource_categories* resource_counters);

  // optional .draiosproto.counter_syscall_errors syscall_errors = 9;
  bool has_syscall_errors() const;
  void clear_syscall_errors();
  static const int kSyscallErrorsFieldNumber = 9;
  const ::draiosproto::counter_syscall_errors& syscall_errors() const;
  ::draiosproto::counter_syscall_errors* mutable_syscall_errors();
  ::draiosproto::counter_syscall_errors* release_syscall_errors();
  void set_allocated_syscall_errors(::draiosproto::counter_syscall_errors* syscall_errors);

  // optional .draiosproto.proto_info protos = 20;
  bool has_protos() const;
  void clear_protos();
  static const int kProtosFieldNumber = 20;
  const ::draiosproto::proto_info& protos() const;
  ::draiosproto::proto_info* mutable_protos();
  ::draiosproto::proto_info* release_protos();
  void set_allocated_protos(::draiosproto::proto_info* protos);

  // optional uint64 start_count = 21;
  bool has_start_count() const;
  void clear_start_count();
  static const int kStartCountFieldNumber = 21;
  ::google::protobuf::uint64 start_count() const;
  void set_start_count(::google::protobuf::uint64 value);

  // optional uint64 count_processes = 23;
  bool has_count_processes() const;
  void clear_count_processes();
  static const int kCountProcessesFieldNumber = 23;
  ::google::protobuf::uint64 count_processes() const;
  void set_count_processes(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:draiosproto.process)
 private:
  inline void set_has_details();
  inline void clear_has_details();
  inline void set_has_is_ipv4_transaction_server();
  inline void clear_has_is_ipv4_transaction_server();
  inline void set_has_is_unix_transaction_server();
  inline void clear_has_is_unix_transaction_server();
  inline void set_has_is_ipv4_transaction_client();
  inline void clear_has_is_ipv4_transaction_client();
  inline void set_has_is_unix_transaction_client();
  inline void clear_has_is_unix_transaction_client();
  inline void set_has_netrole();
  inline void clear_has_netrole();
  inline void set_has_tcounters();
  inline void clear_has_tcounters();
  inline void set_has_transaction_counters();
  inline void clear_has_transaction_counters();
  inline void set_has_min_transaction_counters();
  inline void clear_has_min_transaction_counters();
  inline void set_has_max_transaction_counters();
  inline void clear_has_max_transaction_counters();
  inline void set_has_transaction_processing_delay();
  inline void clear_has_transaction_processing_delay();
  inline void set_has_next_tiers_delay();
  inline void clear_has_next_tiers_delay();
  inline void set_has_resource_counters();
  inline void clear_has_resource_counters();
  inline void set_has_syscall_errors();
  inline void clear_has_syscall_errors();
  inline void set_has_protos();
  inline void clear_has_protos();
  inline void set_has_start_count();
  inline void clear_has_start_count();
  inline void set_has_count_processes();
  inline void clear_has_count_processes();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::draiosproto::process_details* details_;
  ::draiosproto::time_categories* tcounters_;
  ::draiosproto::counter_time_bidirectional* transaction_counters_;
  ::draiosproto::counter_time_bidirectional* min_transaction_counters_;
  ::draiosproto::counter_time_bidirectional* max_transaction_counters_;
  ::draiosproto::resource_categories* resource_counters_;
  ::draiosproto::counter_syscall_errors* syscall_errors_;
  ::draiosproto::proto_info* protos_;
  bool is_ipv4_transaction_server_;
  bool is_unix_transaction_server_;
  bool is_ipv4_transaction_client_;
  bool is_unix_transaction_client_;
  ::google::protobuf::uint32 netrole_;
  ::google::protobuf::uint64 transaction_processing_delay_;
  ::google::protobuf::uint64 next_tiers_delay_;
  ::google::protobuf::uint64 start_count_;
  ::google::protobuf::uint64 count_processes_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<process> process_default_instance_;

// -------------------------------------------------------------------

class program : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.program) */ {
 public:
  program();
  virtual ~program();

  program(const program& from);

  inline program& operator=(const program& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const program& default_instance();

  static const program* internal_default_instance();

  void Swap(program* other);

  // implements Message ----------------------------------------------

  inline program* New() const { return New(NULL); }

  program* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const program& from);
  void MergeFrom(const program& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(program* other);
  void UnsafeMergeFrom(const program& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.process procinfo = 1;
  bool has_procinfo() const;
  void clear_procinfo();
  static const int kProcinfoFieldNumber = 1;
  const ::draiosproto::process& procinfo() const;
  ::draiosproto::process* mutable_procinfo();
  ::draiosproto::process* release_procinfo();
  void set_allocated_procinfo(::draiosproto::process* procinfo);

  // repeated uint64 pids = 2;
  int pids_size() const;
  void clear_pids();
  static const int kPidsFieldNumber = 2;
  ::google::protobuf::uint64 pids(int index) const;
  void set_pids(int index, ::google::protobuf::uint64 value);
  void add_pids(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      pids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_pids();

  // @@protoc_insertion_point(class_scope:draiosproto.program)
 private:
  inline void set_has_procinfo();
  inline void clear_has_procinfo();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > pids_;
  ::draiosproto::process* procinfo_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<program> program_default_instance_;

// -------------------------------------------------------------------

class ipv4tuple : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.ipv4tuple) */ {
 public:
  ipv4tuple();
  virtual ~ipv4tuple();

  ipv4tuple(const ipv4tuple& from);

  inline ipv4tuple& operator=(const ipv4tuple& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ipv4tuple& default_instance();

  static const ipv4tuple* internal_default_instance();

  void Swap(ipv4tuple* other);

  // implements Message ----------------------------------------------

  inline ipv4tuple* New() const { return New(NULL); }

  ipv4tuple* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ipv4tuple& from);
  void MergeFrom(const ipv4tuple& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ipv4tuple* other);
  void UnsafeMergeFrom(const ipv4tuple& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 sip = 1;
  bool has_sip() const;
  void clear_sip();
  static const int kSipFieldNumber = 1;
  ::google::protobuf::uint32 sip() const;
  void set_sip(::google::protobuf::uint32 value);

  // required uint32 dip = 2;
  bool has_dip() const;
  void clear_dip();
  static const int kDipFieldNumber = 2;
  ::google::protobuf::uint32 dip() const;
  void set_dip(::google::protobuf::uint32 value);

  // required uint32 sport = 3;
  bool has_sport() const;
  void clear_sport();
  static const int kSportFieldNumber = 3;
  ::google::protobuf::uint32 sport() const;
  void set_sport(::google::protobuf::uint32 value);

  // required uint32 dport = 4;
  bool has_dport() const;
  void clear_dport();
  static const int kDportFieldNumber = 4;
  ::google::protobuf::uint32 dport() const;
  void set_dport(::google::protobuf::uint32 value);

  // required uint32 l4proto = 5;
  bool has_l4proto() const;
  void clear_l4proto();
  static const int kL4ProtoFieldNumber = 5;
  ::google::protobuf::uint32 l4proto() const;
  void set_l4proto(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.ipv4tuple)
 private:
  inline void set_has_sip();
  inline void clear_has_sip();
  inline void set_has_dip();
  inline void clear_has_dip();
  inline void set_has_sport();
  inline void clear_has_sport();
  inline void set_has_dport();
  inline void clear_has_dport();
  inline void set_has_l4proto();
  inline void clear_has_l4proto();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 sip_;
  ::google::protobuf::uint32 dip_;
  ::google::protobuf::uint32 sport_;
  ::google::protobuf::uint32 dport_;
  ::google::protobuf::uint32 l4proto_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ipv4tuple> ipv4tuple_default_instance_;

// -------------------------------------------------------------------

class ipv4_connection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.ipv4_connection) */ {
 public:
  ipv4_connection();
  virtual ~ipv4_connection();

  ipv4_connection(const ipv4_connection& from);

  inline ipv4_connection& operator=(const ipv4_connection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ipv4_connection& default_instance();

  static const ipv4_connection* internal_default_instance();

  void Swap(ipv4_connection* other);

  // implements Message ----------------------------------------------

  inline ipv4_connection* New() const { return New(NULL); }

  ipv4_connection* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ipv4_connection& from);
  void MergeFrom(const ipv4_connection& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ipv4_connection* other);
  void UnsafeMergeFrom(const ipv4_connection& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.ipv4tuple tuple = 1;
  bool has_tuple() const;
  void clear_tuple();
  static const int kTupleFieldNumber = 1;
  const ::draiosproto::ipv4tuple& tuple() const;
  ::draiosproto::ipv4tuple* mutable_tuple();
  ::draiosproto::ipv4tuple* release_tuple();
  void set_allocated_tuple(::draiosproto::ipv4tuple* tuple);

  // optional uint64 spid = 2;
  bool has_spid() const;
  void clear_spid();
  static const int kSpidFieldNumber = 2;
  ::google::protobuf::uint64 spid() const;
  void set_spid(::google::protobuf::uint64 value);

  // optional uint64 dpid = 5;
  bool has_dpid() const;
  void clear_dpid();
  static const int kDpidFieldNumber = 5;
  ::google::protobuf::uint64 dpid() const;
  void set_dpid(::google::protobuf::uint64 value);

  // required .draiosproto.connection_categories counters = 8;
  bool has_counters() const;
  void clear_counters();
  static const int kCountersFieldNumber = 8;
  const ::draiosproto::connection_categories& counters() const;
  ::draiosproto::connection_categories* mutable_counters();
  ::draiosproto::connection_categories* release_counters();
  void set_allocated_counters(::draiosproto::connection_categories* counters);

  // @@protoc_insertion_point(class_scope:draiosproto.ipv4_connection)
 private:
  inline void set_has_tuple();
  inline void clear_has_tuple();
  inline void set_has_spid();
  inline void clear_has_spid();
  inline void set_has_dpid();
  inline void clear_has_dpid();
  inline void set_has_counters();
  inline void clear_has_counters();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::draiosproto::ipv4tuple* tuple_;
  ::draiosproto::connection_categories* counters_;
  ::google::protobuf::uint64 spid_;
  ::google::protobuf::uint64 dpid_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ipv4_connection> ipv4_connection_default_instance_;

// -------------------------------------------------------------------

class ipv4_network_interface : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.ipv4_network_interface) */ {
 public:
  ipv4_network_interface();
  virtual ~ipv4_network_interface();

  ipv4_network_interface(const ipv4_network_interface& from);

  inline ipv4_network_interface& operator=(const ipv4_network_interface& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ipv4_network_interface& default_instance();

  static const ipv4_network_interface* internal_default_instance();

  void Swap(ipv4_network_interface* other);

  // implements Message ----------------------------------------------

  inline ipv4_network_interface* New() const { return New(NULL); }

  ipv4_network_interface* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ipv4_network_interface& from);
  void MergeFrom(const ipv4_network_interface& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ipv4_network_interface* other);
  void UnsafeMergeFrom(const ipv4_network_interface& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required uint32 addr = 2;
  bool has_addr() const;
  void clear_addr();
  static const int kAddrFieldNumber = 2;
  ::google::protobuf::uint32 addr() const;
  void set_addr(::google::protobuf::uint32 value);

  // required uint32 netmask = 3;
  bool has_netmask() const;
  void clear_netmask();
  static const int kNetmaskFieldNumber = 3;
  ::google::protobuf::uint32 netmask() const;
  void set_netmask(::google::protobuf::uint32 value);

  // optional uint32 bcast = 4;
  bool has_bcast() const;
  void clear_bcast();
  static const int kBcastFieldNumber = 4;
  ::google::protobuf::uint32 bcast() const;
  void set_bcast(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.ipv4_network_interface)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_addr();
  inline void clear_has_addr();
  inline void set_has_netmask();
  inline void clear_has_netmask();
  inline void set_has_bcast();
  inline void clear_has_bcast();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 addr_;
  ::google::protobuf::uint32 netmask_;
  ::google::protobuf::uint32 bcast_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ipv4_network_interface> ipv4_network_interface_default_instance_;

// -------------------------------------------------------------------

class mounted_fs : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.mounted_fs) */ {
 public:
  mounted_fs();
  virtual ~mounted_fs();

  mounted_fs(const mounted_fs& from);

  inline mounted_fs& operator=(const mounted_fs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mounted_fs& default_instance();

  static const mounted_fs* internal_default_instance();

  void Swap(mounted_fs* other);

  // implements Message ----------------------------------------------

  inline mounted_fs* New() const { return New(NULL); }

  mounted_fs* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mounted_fs& from);
  void MergeFrom(const mounted_fs& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(mounted_fs* other);
  void UnsafeMergeFrom(const mounted_fs& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string device = 1;
  bool has_device() const;
  void clear_device();
  static const int kDeviceFieldNumber = 1;
  const ::std::string& device() const;
  void set_device(const ::std::string& value);
  void set_device(const char* value);
  void set_device(const char* value, size_t size);
  ::std::string* mutable_device();
  ::std::string* release_device();
  void set_allocated_device(::std::string* device);

  // required string mount_dir = 2;
  bool has_mount_dir() const;
  void clear_mount_dir();
  static const int kMountDirFieldNumber = 2;
  const ::std::string& mount_dir() const;
  void set_mount_dir(const ::std::string& value);
  void set_mount_dir(const char* value);
  void set_mount_dir(const char* value, size_t size);
  ::std::string* mutable_mount_dir();
  ::std::string* release_mount_dir();
  void set_allocated_mount_dir(::std::string* mount_dir);

  // required string type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // required uint64 size_bytes = 4;
  bool has_size_bytes() const;
  void clear_size_bytes();
  static const int kSizeBytesFieldNumber = 4;
  ::google::protobuf::uint64 size_bytes() const;
  void set_size_bytes(::google::protobuf::uint64 value);

  // required uint64 used_bytes = 5;
  bool has_used_bytes() const;
  void clear_used_bytes();
  static const int kUsedBytesFieldNumber = 5;
  ::google::protobuf::uint64 used_bytes() const;
  void set_used_bytes(::google::protobuf::uint64 value);

  // required uint64 available_bytes = 6;
  bool has_available_bytes() const;
  void clear_available_bytes();
  static const int kAvailableBytesFieldNumber = 6;
  ::google::protobuf::uint64 available_bytes() const;
  void set_available_bytes(::google::protobuf::uint64 value);

  // optional uint64 total_inodes = 10;
  bool has_total_inodes() const;
  void clear_total_inodes();
  static const int kTotalInodesFieldNumber = 10;
  ::google::protobuf::uint64 total_inodes() const;
  void set_total_inodes(::google::protobuf::uint64 value);

  // optional uint64 used_inodes = 11;
  bool has_used_inodes() const;
  void clear_used_inodes();
  static const int kUsedInodesFieldNumber = 11;
  ::google::protobuf::uint64 used_inodes() const;
  void set_used_inodes(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:draiosproto.mounted_fs)
 private:
  inline void set_has_device();
  inline void clear_has_device();
  inline void set_has_mount_dir();
  inline void clear_has_mount_dir();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_size_bytes();
  inline void clear_has_size_bytes();
  inline void set_has_used_bytes();
  inline void clear_has_used_bytes();
  inline void set_has_available_bytes();
  inline void clear_has_available_bytes();
  inline void set_has_total_inodes();
  inline void clear_has_total_inodes();
  inline void set_has_used_inodes();
  inline void clear_has_used_inodes();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr device_;
  ::google::protobuf::internal::ArenaStringPtr mount_dir_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::uint64 size_bytes_;
  ::google::protobuf::uint64 used_bytes_;
  ::google::protobuf::uint64 available_bytes_;
  ::google::protobuf::uint64 total_inodes_;
  ::google::protobuf::uint64 used_inodes_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<mounted_fs> mounted_fs_default_instance_;

// -------------------------------------------------------------------

class file_stat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.file_stat) */ {
 public:
  file_stat();
  virtual ~file_stat();

  file_stat(const file_stat& from);

  inline file_stat& operator=(const file_stat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const file_stat& default_instance();

  static const file_stat* internal_default_instance();

  void Swap(file_stat* other);

  // implements Message ----------------------------------------------

  inline file_stat* New() const { return New(NULL); }

  file_stat* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const file_stat& from);
  void MergeFrom(const file_stat& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(file_stat* other);
  void UnsafeMergeFrom(const file_stat& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required uint32 bytes = 2;
  bool has_bytes() const;
  void clear_bytes();
  static const int kBytesFieldNumber = 2;
  ::google::protobuf::uint32 bytes() const;
  void set_bytes(::google::protobuf::uint32 value);

  // required uint64 time_ns = 3;
  bool has_time_ns() const;
  void clear_time_ns();
  static const int kTimeNsFieldNumber = 3;
  ::google::protobuf::uint64 time_ns() const;
  void set_time_ns(::google::protobuf::uint64 value);

  // required uint32 open_count = 4;
  bool has_open_count() const;
  void clear_open_count();
  static const int kOpenCountFieldNumber = 4;
  ::google::protobuf::uint32 open_count() const;
  void set_open_count(::google::protobuf::uint32 value);

  // required uint32 errors = 5;
  bool has_errors() const;
  void clear_errors();
  static const int kErrorsFieldNumber = 5;
  ::google::protobuf::uint32 errors() const;
  void set_errors(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.file_stat)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_bytes();
  inline void clear_has_bytes();
  inline void set_has_time_ns();
  inline void clear_has_time_ns();
  inline void set_has_open_count();
  inline void clear_has_open_count();
  inline void set_has_errors();
  inline void clear_has_errors();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 time_ns_;
  ::google::protobuf::uint32 bytes_;
  ::google::protobuf::uint32 open_count_;
  ::google::protobuf::uint32 errors_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<file_stat> file_stat_default_instance_;

// -------------------------------------------------------------------

class container_port_mapping : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.container_port_mapping) */ {
 public:
  container_port_mapping();
  virtual ~container_port_mapping();

  container_port_mapping(const container_port_mapping& from);

  inline container_port_mapping& operator=(const container_port_mapping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const container_port_mapping& default_instance();

  static const container_port_mapping* internal_default_instance();

  void Swap(container_port_mapping* other);

  // implements Message ----------------------------------------------

  inline container_port_mapping* New() const { return New(NULL); }

  container_port_mapping* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const container_port_mapping& from);
  void MergeFrom(const container_port_mapping& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(container_port_mapping* other);
  void UnsafeMergeFrom(const container_port_mapping& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 host_ip = 1;
  bool has_host_ip() const;
  void clear_host_ip();
  static const int kHostIpFieldNumber = 1;
  ::google::protobuf::uint32 host_ip() const;
  void set_host_ip(::google::protobuf::uint32 value);

  // optional uint32 host_port = 2;
  bool has_host_port() const;
  void clear_host_port();
  static const int kHostPortFieldNumber = 2;
  ::google::protobuf::uint32 host_port() const;
  void set_host_port(::google::protobuf::uint32 value);

  // optional uint32 container_ip = 3;
  bool has_container_ip() const;
  void clear_container_ip();
  static const int kContainerIpFieldNumber = 3;
  ::google::protobuf::uint32 container_ip() const;
  void set_container_ip(::google::protobuf::uint32 value);

  // optional uint32 container_port = 4;
  bool has_container_port() const;
  void clear_container_port();
  static const int kContainerPortFieldNumber = 4;
  ::google::protobuf::uint32 container_port() const;
  void set_container_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.container_port_mapping)
 private:
  inline void set_has_host_ip();
  inline void clear_has_host_ip();
  inline void set_has_host_port();
  inline void clear_has_host_port();
  inline void set_has_container_ip();
  inline void clear_has_container_ip();
  inline void set_has_container_port();
  inline void clear_has_container_port();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 host_ip_;
  ::google::protobuf::uint32 host_port_;
  ::google::protobuf::uint32 container_ip_;
  ::google::protobuf::uint32 container_port_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<container_port_mapping> container_port_mapping_default_instance_;

// -------------------------------------------------------------------

class container_label : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.container_label) */ {
 public:
  container_label();
  virtual ~container_label();

  container_label(const container_label& from);

  inline container_label& operator=(const container_label& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const container_label& default_instance();

  static const container_label* internal_default_instance();

  void Swap(container_label* other);

  // implements Message ----------------------------------------------

  inline container_label* New() const { return New(NULL); }

  container_label* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const container_label& from);
  void MergeFrom(const container_label& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(container_label* other);
  void UnsafeMergeFrom(const container_label& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:draiosproto.container_label)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<container_label> container_label_default_instance_;

// -------------------------------------------------------------------

class container : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.container) */ {
 public:
  container();
  virtual ~container();

  container(const container& from);

  inline container& operator=(const container& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const container& default_instance();

  static const container* internal_default_instance();

  void Swap(container* other);

  // implements Message ----------------------------------------------

  inline container* New() const { return New(NULL); }

  container* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const container& from);
  void MergeFrom(const container& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(container* other);
  void UnsafeMergeFrom(const container& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional .draiosproto.container_type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::draiosproto::container_type type() const;
  void set_type(::draiosproto::container_type value);

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string image = 4;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 4;
  const ::std::string& image() const;
  void set_image(const ::std::string& value);
  void set_image(const char* value);
  void set_image(const char* value, size_t size);
  ::std::string* mutable_image();
  ::std::string* release_image();
  void set_allocated_image(::std::string* image);

  // optional .draiosproto.time_categories tcounters = 5;
  bool has_tcounters() const;
  void clear_tcounters();
  static const int kTcountersFieldNumber = 5;
  const ::draiosproto::time_categories& tcounters() const;
  ::draiosproto::time_categories* mutable_tcounters();
  ::draiosproto::time_categories* release_tcounters();
  void set_allocated_tcounters(::draiosproto::time_categories* tcounters);

  // optional .draiosproto.transaction_breakdown_categories reqcounters = 6;
  bool has_reqcounters() const;
  void clear_reqcounters();
  static const int kReqcountersFieldNumber = 6;
  const ::draiosproto::transaction_breakdown_categories& reqcounters() const;
  ::draiosproto::transaction_breakdown_categories* mutable_reqcounters();
  ::draiosproto::transaction_breakdown_categories* release_reqcounters();
  void set_allocated_reqcounters(::draiosproto::transaction_breakdown_categories* reqcounters);

  // optional .draiosproto.counter_time_bidirectional transaction_counters = 7;
  bool has_transaction_counters() const;
  void clear_transaction_counters();
  static const int kTransactionCountersFieldNumber = 7;
  const ::draiosproto::counter_time_bidirectional& transaction_counters() const;
  ::draiosproto::counter_time_bidirectional* mutable_transaction_counters();
  ::draiosproto::counter_time_bidirectional* release_transaction_counters();
  void set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters);

  // optional .draiosproto.counter_time_bidirectional min_transaction_counters = 8;
  bool has_min_transaction_counters() const;
  void clear_min_transaction_counters();
  static const int kMinTransactionCountersFieldNumber = 8;
  const ::draiosproto::counter_time_bidirectional& min_transaction_counters() const;
  ::draiosproto::counter_time_bidirectional* mutable_min_transaction_counters();
  ::draiosproto::counter_time_bidirectional* release_min_transaction_counters();
  void set_allocated_min_transaction_counters(::draiosproto::counter_time_bidirectional* min_transaction_counters);

  // optional .draiosproto.counter_time_bidirectional max_transaction_counters = 9;
  bool has_max_transaction_counters() const;
  void clear_max_transaction_counters();
  static const int kMaxTransactionCountersFieldNumber = 9;
  const ::draiosproto::counter_time_bidirectional& max_transaction_counters() const;
  ::draiosproto::counter_time_bidirectional* mutable_max_transaction_counters();
  ::draiosproto::counter_time_bidirectional* release_max_transaction_counters();
  void set_allocated_max_transaction_counters(::draiosproto::counter_time_bidirectional* max_transaction_counters);

  // optional uint64 transaction_processing_delay = 10;
  bool has_transaction_processing_delay() const;
  void clear_transaction_processing_delay();
  static const int kTransactionProcessingDelayFieldNumber = 10;
  ::google::protobuf::uint64 transaction_processing_delay() const;
  void set_transaction_processing_delay(::google::protobuf::uint64 value);

  // optional uint64 next_tiers_delay = 12;
  bool has_next_tiers_delay() const;
  void clear_next_tiers_delay();
  static const int kNextTiersDelayFieldNumber = 12;
  ::google::protobuf::uint64 next_tiers_delay() const;
  void set_next_tiers_delay(::google::protobuf::uint64 value);

  // optional .draiosproto.resource_categories resource_counters = 13;
  bool has_resource_counters() const;
  void clear_resource_counters();
  static const int kResourceCountersFieldNumber = 13;
  const ::draiosproto::resource_categories& resource_counters() const;
  ::draiosproto::resource_categories* mutable_resource_counters();
  ::draiosproto::resource_categories* release_resource_counters();
  void set_allocated_resource_counters(::draiosproto::resource_categories* resource_counters);

  // optional .draiosproto.counter_syscall_errors syscall_errors = 14;
  bool has_syscall_errors() const;
  void clear_syscall_errors();
  static const int kSyscallErrorsFieldNumber = 14;
  const ::draiosproto::counter_syscall_errors& syscall_errors() const;
  ::draiosproto::counter_syscall_errors* mutable_syscall_errors();
  ::draiosproto::counter_syscall_errors* release_syscall_errors();
  void set_allocated_syscall_errors(::draiosproto::counter_syscall_errors* syscall_errors);

  // repeated .draiosproto.container_port_mapping port_mappings = 18;
  int port_mappings_size() const;
  void clear_port_mappings();
  static const int kPortMappingsFieldNumber = 18;
  const ::draiosproto::container_port_mapping& port_mappings(int index) const;
  ::draiosproto::container_port_mapping* mutable_port_mappings(int index);
  ::draiosproto::container_port_mapping* add_port_mappings();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::container_port_mapping >*
      mutable_port_mappings();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::container_port_mapping >&
      port_mappings() const;

  // optional .draiosproto.proto_info protos = 19;
  bool has_protos() const;
  void clear_protos();
  static const int kProtosFieldNumber = 19;
  const ::draiosproto::proto_info& protos() const;
  ::draiosproto::proto_info* mutable_protos();
  ::draiosproto::proto_info* release_protos();
  void set_allocated_protos(::draiosproto::proto_info* protos);

  // repeated .draiosproto.container_label labels = 20;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 20;
  const ::draiosproto::container_label& labels(int index) const;
  ::draiosproto::container_label* mutable_labels(int index);
  ::draiosproto::container_label* add_labels();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::container_label >*
      mutable_labels();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::container_label >&
      labels() const;

  // repeated .draiosproto.mounted_fs mounts = 21;
  int mounts_size() const;
  void clear_mounts();
  static const int kMountsFieldNumber = 21;
  const ::draiosproto::mounted_fs& mounts(int index) const;
  ::draiosproto::mounted_fs* mutable_mounts(int index);
  ::draiosproto::mounted_fs* add_mounts();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mounted_fs >*
      mutable_mounts();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::mounted_fs >&
      mounts() const;

  // repeated .draiosproto.network_by_port network_by_serverports = 22;
  int network_by_serverports_size() const;
  void clear_network_by_serverports();
  static const int kNetworkByServerportsFieldNumber = 22;
  const ::draiosproto::network_by_port& network_by_serverports(int index) const;
  ::draiosproto::network_by_port* mutable_network_by_serverports(int index);
  ::draiosproto::network_by_port* add_network_by_serverports();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::network_by_port >*
      mutable_network_by_serverports();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::network_by_port >&
      network_by_serverports() const;

  // optional string mesos_task_id = 23;
  bool has_mesos_task_id() const;
  void clear_mesos_task_id();
  static const int kMesosTaskIdFieldNumber = 23;
  const ::std::string& mesos_task_id() const;
  void set_mesos_task_id(const ::std::string& value);
  void set_mesos_task_id(const char* value);
  void set_mesos_task_id(const char* value, size_t size);
  ::std::string* mutable_mesos_task_id();
  ::std::string* release_mesos_task_id();
  void set_allocated_mesos_task_id(::std::string* mesos_task_id);

  // optional string image_id = 24;
  bool has_image_id() const;
  void clear_image_id();
  static const int kImageIdFieldNumber = 24;
  const ::std::string& image_id() const;
  void set_image_id(const ::std::string& value);
  void set_image_id(const char* value);
  void set_image_id(const char* value, size_t size);
  ::std::string* mutable_image_id();
  ::std::string* release_image_id();
  void set_allocated_image_id(::std::string* image_id);

  // @@protoc_insertion_point(class_scope:draiosproto.container)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_tcounters();
  inline void clear_has_tcounters();
  inline void set_has_reqcounters();
  inline void clear_has_reqcounters();
  inline void set_has_transaction_counters();
  inline void clear_has_transaction_counters();
  inline void set_has_min_transaction_counters();
  inline void clear_has_min_transaction_counters();
  inline void set_has_max_transaction_counters();
  inline void clear_has_max_transaction_counters();
  inline void set_has_transaction_processing_delay();
  inline void clear_has_transaction_processing_delay();
  inline void set_has_next_tiers_delay();
  inline void clear_has_next_tiers_delay();
  inline void set_has_resource_counters();
  inline void clear_has_resource_counters();
  inline void set_has_syscall_errors();
  inline void clear_has_syscall_errors();
  inline void set_has_protos();
  inline void clear_has_protos();
  inline void set_has_mesos_task_id();
  inline void clear_has_mesos_task_id();
  inline void set_has_image_id();
  inline void clear_has_image_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::container_port_mapping > port_mappings_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::container_label > labels_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mounted_fs > mounts_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::network_by_port > network_by_serverports_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr image_;
  ::google::protobuf::internal::ArenaStringPtr mesos_task_id_;
  ::google::protobuf::internal::ArenaStringPtr image_id_;
  ::draiosproto::time_categories* tcounters_;
  ::draiosproto::transaction_breakdown_categories* reqcounters_;
  ::draiosproto::counter_time_bidirectional* transaction_counters_;
  ::draiosproto::counter_time_bidirectional* min_transaction_counters_;
  ::draiosproto::counter_time_bidirectional* max_transaction_counters_;
  ::draiosproto::resource_categories* resource_counters_;
  ::draiosproto::counter_syscall_errors* syscall_errors_;
  ::draiosproto::proto_info* protos_;
  ::google::protobuf::uint64 transaction_processing_delay_;
  ::google::protobuf::uint64 next_tiers_delay_;
  int type_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<container> container_default_instance_;

// -------------------------------------------------------------------

class k8s_pair : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.k8s_pair) */ {
 public:
  k8s_pair();
  virtual ~k8s_pair();

  k8s_pair(const k8s_pair& from);

  inline k8s_pair& operator=(const k8s_pair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const k8s_pair& default_instance();

  static const k8s_pair* internal_default_instance();

  void Swap(k8s_pair* other);

  // implements Message ----------------------------------------------

  inline k8s_pair* New() const { return New(NULL); }

  k8s_pair* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const k8s_pair& from);
  void MergeFrom(const k8s_pair& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(k8s_pair* other);
  void UnsafeMergeFrom(const k8s_pair& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:draiosproto.k8s_pair)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<k8s_pair> k8s_pair_default_instance_;

// -------------------------------------------------------------------

class k8s_common : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.k8s_common) */ {
 public:
  k8s_common();
  virtual ~k8s_common();

  k8s_common(const k8s_common& from);

  inline k8s_common& operator=(const k8s_common& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const k8s_common& default_instance();

  static const k8s_common* internal_default_instance();

  void Swap(k8s_common* other);

  // implements Message ----------------------------------------------

  inline k8s_common* New() const { return New(NULL); }

  k8s_common* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const k8s_common& from);
  void MergeFrom(const k8s_common& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(k8s_common* other);
  void UnsafeMergeFrom(const k8s_common& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string uid = 2;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 2;
  const ::std::string& uid() const;
  void set_uid(const ::std::string& value);
  void set_uid(const char* value);
  void set_uid(const char* value, size_t size);
  ::std::string* mutable_uid();
  ::std::string* release_uid();
  void set_allocated_uid(::std::string* uid);

  // optional string namespace = 3;
  bool has_namespace_() const;
  void clear_namespace_();
  static const int kNamespaceFieldNumber = 3;
  const ::std::string& namespace_() const;
  void set_namespace_(const ::std::string& value);
  void set_namespace_(const char* value);
  void set_namespace_(const char* value, size_t size);
  ::std::string* mutable_namespace_();
  ::std::string* release_namespace_();
  void set_allocated_namespace_(::std::string* namespace_);

  // repeated .draiosproto.k8s_pair labels = 4;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 4;
  const ::draiosproto::k8s_pair& labels(int index) const;
  ::draiosproto::k8s_pair* mutable_labels(int index);
  ::draiosproto::k8s_pair* add_labels();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pair >*
      mutable_labels();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pair >&
      labels() const;

  // repeated .draiosproto.k8s_pair selectors = 5;
  int selectors_size() const;
  void clear_selectors();
  static const int kSelectorsFieldNumber = 5;
  const ::draiosproto::k8s_pair& selectors(int index) const;
  ::draiosproto::k8s_pair* mutable_selectors(int index);
  ::draiosproto::k8s_pair* add_selectors();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pair >*
      mutable_selectors();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pair >&
      selectors() const;

  // @@protoc_insertion_point(class_scope:draiosproto.k8s_common)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_namespace_();
  inline void clear_has_namespace_();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pair > labels_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pair > selectors_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr uid_;
  ::google::protobuf::internal::ArenaStringPtr namespace__;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<k8s_common> k8s_common_default_instance_;

// -------------------------------------------------------------------

class k8s_namespace : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.k8s_namespace) */ {
 public:
  k8s_namespace();
  virtual ~k8s_namespace();

  k8s_namespace(const k8s_namespace& from);

  inline k8s_namespace& operator=(const k8s_namespace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const k8s_namespace& default_instance();

  static const k8s_namespace* internal_default_instance();

  void Swap(k8s_namespace* other);

  // implements Message ----------------------------------------------

  inline k8s_namespace* New() const { return New(NULL); }

  k8s_namespace* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const k8s_namespace& from);
  void MergeFrom(const k8s_namespace& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(k8s_namespace* other);
  void UnsafeMergeFrom(const k8s_namespace& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.k8s_common common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  const ::draiosproto::k8s_common& common() const;
  ::draiosproto::k8s_common* mutable_common();
  ::draiosproto::k8s_common* release_common();
  void set_allocated_common(::draiosproto::k8s_common* common);

  // @@protoc_insertion_point(class_scope:draiosproto.k8s_namespace)
 private:
  inline void set_has_common();
  inline void clear_has_common();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::draiosproto::k8s_common* common_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<k8s_namespace> k8s_namespace_default_instance_;

// -------------------------------------------------------------------

class k8s_node : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.k8s_node) */ {
 public:
  k8s_node();
  virtual ~k8s_node();

  k8s_node(const k8s_node& from);

  inline k8s_node& operator=(const k8s_node& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const k8s_node& default_instance();

  static const k8s_node* internal_default_instance();

  void Swap(k8s_node* other);

  // implements Message ----------------------------------------------

  inline k8s_node* New() const { return New(NULL); }

  k8s_node* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const k8s_node& from);
  void MergeFrom(const k8s_node& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(k8s_node* other);
  void UnsafeMergeFrom(const k8s_node& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.k8s_common common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  const ::draiosproto::k8s_common& common() const;
  ::draiosproto::k8s_common* mutable_common();
  ::draiosproto::k8s_common* release_common();
  void set_allocated_common(::draiosproto::k8s_common* common);

  // repeated string host_ips = 2;
  int host_ips_size() const;
  void clear_host_ips();
  static const int kHostIpsFieldNumber = 2;
  const ::std::string& host_ips(int index) const;
  ::std::string* mutable_host_ips(int index);
  void set_host_ips(int index, const ::std::string& value);
  void set_host_ips(int index, const char* value);
  void set_host_ips(int index, const char* value, size_t size);
  ::std::string* add_host_ips();
  void add_host_ips(const ::std::string& value);
  void add_host_ips(const char* value);
  void add_host_ips(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& host_ips() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_host_ips();

  // @@protoc_insertion_point(class_scope:draiosproto.k8s_node)
 private:
  inline void set_has_common();
  inline void clear_has_common();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> host_ips_;
  ::draiosproto::k8s_common* common_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<k8s_node> k8s_node_default_instance_;

// -------------------------------------------------------------------

class k8s_pod : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.k8s_pod) */ {
 public:
  k8s_pod();
  virtual ~k8s_pod();

  k8s_pod(const k8s_pod& from);

  inline k8s_pod& operator=(const k8s_pod& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const k8s_pod& default_instance();

  static const k8s_pod* internal_default_instance();

  void Swap(k8s_pod* other);

  // implements Message ----------------------------------------------

  inline k8s_pod* New() const { return New(NULL); }

  k8s_pod* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const k8s_pod& from);
  void MergeFrom(const k8s_pod& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(k8s_pod* other);
  void UnsafeMergeFrom(const k8s_pod& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.k8s_common common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  const ::draiosproto::k8s_common& common() const;
  ::draiosproto::k8s_common* mutable_common();
  ::draiosproto::k8s_common* release_common();
  void set_allocated_common(::draiosproto::k8s_common* common);

  // repeated string container_ids = 2;
  int container_ids_size() const;
  void clear_container_ids();
  static const int kContainerIdsFieldNumber = 2;
  const ::std::string& container_ids(int index) const;
  ::std::string* mutable_container_ids(int index);
  void set_container_ids(int index, const ::std::string& value);
  void set_container_ids(int index, const char* value);
  void set_container_ids(int index, const char* value, size_t size);
  ::std::string* add_container_ids();
  void add_container_ids(const ::std::string& value);
  void add_container_ids(const char* value);
  void add_container_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& container_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_container_ids();

  // optional string node_name = 3;
  bool has_node_name() const;
  void clear_node_name();
  static const int kNodeNameFieldNumber = 3;
  const ::std::string& node_name() const;
  void set_node_name(const ::std::string& value);
  void set_node_name(const char* value);
  void set_node_name(const char* value, size_t size);
  ::std::string* mutable_node_name();
  ::std::string* release_node_name();
  void set_allocated_node_name(::std::string* node_name);

  // optional string host_ip = 4;
  bool has_host_ip() const;
  void clear_host_ip();
  static const int kHostIpFieldNumber = 4;
  const ::std::string& host_ip() const;
  void set_host_ip(const ::std::string& value);
  void set_host_ip(const char* value);
  void set_host_ip(const char* value, size_t size);
  ::std::string* mutable_host_ip();
  ::std::string* release_host_ip();
  void set_allocated_host_ip(::std::string* host_ip);

  // optional string internal_ip = 5;
  bool has_internal_ip() const;
  void clear_internal_ip();
  static const int kInternalIpFieldNumber = 5;
  const ::std::string& internal_ip() const;
  void set_internal_ip(const ::std::string& value);
  void set_internal_ip(const char* value);
  void set_internal_ip(const char* value, size_t size);
  ::std::string* mutable_internal_ip();
  ::std::string* release_internal_ip();
  void set_allocated_internal_ip(::std::string* internal_ip);

  // optional uint32 restart_count = 6;
  bool has_restart_count() const;
  void clear_restart_count();
  static const int kRestartCountFieldNumber = 6;
  ::google::protobuf::uint32 restart_count() const;
  void set_restart_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.k8s_pod)
 private:
  inline void set_has_common();
  inline void clear_has_common();
  inline void set_has_node_name();
  inline void clear_has_node_name();
  inline void set_has_host_ip();
  inline void clear_has_host_ip();
  inline void set_has_internal_ip();
  inline void clear_has_internal_ip();
  inline void set_has_restart_count();
  inline void clear_has_restart_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> container_ids_;
  ::google::protobuf::internal::ArenaStringPtr node_name_;
  ::google::protobuf::internal::ArenaStringPtr host_ip_;
  ::google::protobuf::internal::ArenaStringPtr internal_ip_;
  ::draiosproto::k8s_common* common_;
  ::google::protobuf::uint32 restart_count_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<k8s_pod> k8s_pod_default_instance_;

// -------------------------------------------------------------------

class k8s_replication_controller : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.k8s_replication_controller) */ {
 public:
  k8s_replication_controller();
  virtual ~k8s_replication_controller();

  k8s_replication_controller(const k8s_replication_controller& from);

  inline k8s_replication_controller& operator=(const k8s_replication_controller& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const k8s_replication_controller& default_instance();

  static const k8s_replication_controller* internal_default_instance();

  void Swap(k8s_replication_controller* other);

  // implements Message ----------------------------------------------

  inline k8s_replication_controller* New() const { return New(NULL); }

  k8s_replication_controller* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const k8s_replication_controller& from);
  void MergeFrom(const k8s_replication_controller& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(k8s_replication_controller* other);
  void UnsafeMergeFrom(const k8s_replication_controller& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.k8s_common common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  const ::draiosproto::k8s_common& common() const;
  ::draiosproto::k8s_common* mutable_common();
  ::draiosproto::k8s_common* release_common();
  void set_allocated_common(::draiosproto::k8s_common* common);

  // optional uint32 replicas_desired = 2;
  bool has_replicas_desired() const;
  void clear_replicas_desired();
  static const int kReplicasDesiredFieldNumber = 2;
  ::google::protobuf::uint32 replicas_desired() const;
  void set_replicas_desired(::google::protobuf::uint32 value);

  // optional uint32 replicas_running = 3;
  bool has_replicas_running() const;
  void clear_replicas_running();
  static const int kReplicasRunningFieldNumber = 3;
  ::google::protobuf::uint32 replicas_running() const;
  void set_replicas_running(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.k8s_replication_controller)
 private:
  inline void set_has_common();
  inline void clear_has_common();
  inline void set_has_replicas_desired();
  inline void clear_has_replicas_desired();
  inline void set_has_replicas_running();
  inline void clear_has_replicas_running();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::draiosproto::k8s_common* common_;
  ::google::protobuf::uint32 replicas_desired_;
  ::google::protobuf::uint32 replicas_running_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<k8s_replication_controller> k8s_replication_controller_default_instance_;

// -------------------------------------------------------------------

class k8s_replica_set : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.k8s_replica_set) */ {
 public:
  k8s_replica_set();
  virtual ~k8s_replica_set();

  k8s_replica_set(const k8s_replica_set& from);

  inline k8s_replica_set& operator=(const k8s_replica_set& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const k8s_replica_set& default_instance();

  static const k8s_replica_set* internal_default_instance();

  void Swap(k8s_replica_set* other);

  // implements Message ----------------------------------------------

  inline k8s_replica_set* New() const { return New(NULL); }

  k8s_replica_set* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const k8s_replica_set& from);
  void MergeFrom(const k8s_replica_set& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(k8s_replica_set* other);
  void UnsafeMergeFrom(const k8s_replica_set& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.k8s_common common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  const ::draiosproto::k8s_common& common() const;
  ::draiosproto::k8s_common* mutable_common();
  ::draiosproto::k8s_common* release_common();
  void set_allocated_common(::draiosproto::k8s_common* common);

  // optional uint32 replicas_desired = 2;
  bool has_replicas_desired() const;
  void clear_replicas_desired();
  static const int kReplicasDesiredFieldNumber = 2;
  ::google::protobuf::uint32 replicas_desired() const;
  void set_replicas_desired(::google::protobuf::uint32 value);

  // optional uint32 replicas_running = 3;
  bool has_replicas_running() const;
  void clear_replicas_running();
  static const int kReplicasRunningFieldNumber = 3;
  ::google::protobuf::uint32 replicas_running() const;
  void set_replicas_running(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.k8s_replica_set)
 private:
  inline void set_has_common();
  inline void clear_has_common();
  inline void set_has_replicas_desired();
  inline void clear_has_replicas_desired();
  inline void set_has_replicas_running();
  inline void clear_has_replicas_running();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::draiosproto::k8s_common* common_;
  ::google::protobuf::uint32 replicas_desired_;
  ::google::protobuf::uint32 replicas_running_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<k8s_replica_set> k8s_replica_set_default_instance_;

// -------------------------------------------------------------------

class k8s_service_net_port : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.k8s_service.net_port) */ {
 public:
  k8s_service_net_port();
  virtual ~k8s_service_net_port();

  k8s_service_net_port(const k8s_service_net_port& from);

  inline k8s_service_net_port& operator=(const k8s_service_net_port& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const k8s_service_net_port& default_instance();

  static const k8s_service_net_port* internal_default_instance();

  void Swap(k8s_service_net_port* other);

  // implements Message ----------------------------------------------

  inline k8s_service_net_port* New() const { return New(NULL); }

  k8s_service_net_port* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const k8s_service_net_port& from);
  void MergeFrom(const k8s_service_net_port& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(k8s_service_net_port* other);
  void UnsafeMergeFrom(const k8s_service_net_port& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 port = 1;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 1;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // required uint32 target_port = 2;
  bool has_target_port() const;
  void clear_target_port();
  static const int kTargetPortFieldNumber = 2;
  ::google::protobuf::uint32 target_port() const;
  void set_target_port(::google::protobuf::uint32 value);

  // optional string protocol = 3;
  bool has_protocol() const;
  void clear_protocol();
  static const int kProtocolFieldNumber = 3;
  const ::std::string& protocol() const;
  void set_protocol(const ::std::string& value);
  void set_protocol(const char* value);
  void set_protocol(const char* value, size_t size);
  ::std::string* mutable_protocol();
  ::std::string* release_protocol();
  void set_allocated_protocol(::std::string* protocol);

  // optional uint32 node_port = 4;
  bool has_node_port() const;
  void clear_node_port();
  static const int kNodePortFieldNumber = 4;
  ::google::protobuf::uint32 node_port() const;
  void set_node_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.k8s_service.net_port)
 private:
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_target_port();
  inline void clear_has_target_port();
  inline void set_has_protocol();
  inline void clear_has_protocol();
  inline void set_has_node_port();
  inline void clear_has_node_port();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr protocol_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint32 target_port_;
  ::google::protobuf::uint32 node_port_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<k8s_service_net_port> k8s_service_net_port_default_instance_;

// -------------------------------------------------------------------

class k8s_service : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.k8s_service) */ {
 public:
  k8s_service();
  virtual ~k8s_service();

  k8s_service(const k8s_service& from);

  inline k8s_service& operator=(const k8s_service& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const k8s_service& default_instance();

  static const k8s_service* internal_default_instance();

  void Swap(k8s_service* other);

  // implements Message ----------------------------------------------

  inline k8s_service* New() const { return New(NULL); }

  k8s_service* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const k8s_service& from);
  void MergeFrom(const k8s_service& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(k8s_service* other);
  void UnsafeMergeFrom(const k8s_service& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef k8s_service_net_port net_port;

  // accessors -------------------------------------------------------

  // required .draiosproto.k8s_common common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  const ::draiosproto::k8s_common& common() const;
  ::draiosproto::k8s_common* mutable_common();
  ::draiosproto::k8s_common* release_common();
  void set_allocated_common(::draiosproto::k8s_common* common);

  // optional string cluster_ip = 2;
  bool has_cluster_ip() const;
  void clear_cluster_ip();
  static const int kClusterIpFieldNumber = 2;
  const ::std::string& cluster_ip() const;
  void set_cluster_ip(const ::std::string& value);
  void set_cluster_ip(const char* value);
  void set_cluster_ip(const char* value, size_t size);
  ::std::string* mutable_cluster_ip();
  ::std::string* release_cluster_ip();
  void set_allocated_cluster_ip(::std::string* cluster_ip);

  // repeated .draiosproto.k8s_service.net_port ports = 3;
  int ports_size() const;
  void clear_ports();
  static const int kPortsFieldNumber = 3;
  const ::draiosproto::k8s_service_net_port& ports(int index) const;
  ::draiosproto::k8s_service_net_port* mutable_ports(int index);
  ::draiosproto::k8s_service_net_port* add_ports();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_service_net_port >*
      mutable_ports();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_service_net_port >&
      ports() const;

  // @@protoc_insertion_point(class_scope:draiosproto.k8s_service)
 private:
  inline void set_has_common();
  inline void clear_has_common();
  inline void set_has_cluster_ip();
  inline void clear_has_cluster_ip();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_service_net_port > ports_;
  ::google::protobuf::internal::ArenaStringPtr cluster_ip_;
  ::draiosproto::k8s_common* common_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<k8s_service> k8s_service_default_instance_;

// -------------------------------------------------------------------

class k8s_deployment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.k8s_deployment) */ {
 public:
  k8s_deployment();
  virtual ~k8s_deployment();

  k8s_deployment(const k8s_deployment& from);

  inline k8s_deployment& operator=(const k8s_deployment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const k8s_deployment& default_instance();

  static const k8s_deployment* internal_default_instance();

  void Swap(k8s_deployment* other);

  // implements Message ----------------------------------------------

  inline k8s_deployment* New() const { return New(NULL); }

  k8s_deployment* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const k8s_deployment& from);
  void MergeFrom(const k8s_deployment& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(k8s_deployment* other);
  void UnsafeMergeFrom(const k8s_deployment& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.k8s_common common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  const ::draiosproto::k8s_common& common() const;
  ::draiosproto::k8s_common* mutable_common();
  ::draiosproto::k8s_common* release_common();
  void set_allocated_common(::draiosproto::k8s_common* common);

  // optional uint32 replicas_desired = 2;
  bool has_replicas_desired() const;
  void clear_replicas_desired();
  static const int kReplicasDesiredFieldNumber = 2;
  ::google::protobuf::uint32 replicas_desired() const;
  void set_replicas_desired(::google::protobuf::uint32 value);

  // optional uint32 replicas_running = 3;
  bool has_replicas_running() const;
  void clear_replicas_running();
  static const int kReplicasRunningFieldNumber = 3;
  ::google::protobuf::uint32 replicas_running() const;
  void set_replicas_running(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.k8s_deployment)
 private:
  inline void set_has_common();
  inline void clear_has_common();
  inline void set_has_replicas_desired();
  inline void clear_has_replicas_desired();
  inline void set_has_replicas_running();
  inline void clear_has_replicas_running();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::draiosproto::k8s_common* common_;
  ::google::protobuf::uint32 replicas_desired_;
  ::google::protobuf::uint32 replicas_running_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<k8s_deployment> k8s_deployment_default_instance_;

// -------------------------------------------------------------------

class k8s_daemonset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.k8s_daemonset) */ {
 public:
  k8s_daemonset();
  virtual ~k8s_daemonset();

  k8s_daemonset(const k8s_daemonset& from);

  inline k8s_daemonset& operator=(const k8s_daemonset& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const k8s_daemonset& default_instance();

  static const k8s_daemonset* internal_default_instance();

  void Swap(k8s_daemonset* other);

  // implements Message ----------------------------------------------

  inline k8s_daemonset* New() const { return New(NULL); }

  k8s_daemonset* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const k8s_daemonset& from);
  void MergeFrom(const k8s_daemonset& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(k8s_daemonset* other);
  void UnsafeMergeFrom(const k8s_daemonset& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.k8s_common common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  const ::draiosproto::k8s_common& common() const;
  ::draiosproto::k8s_common* mutable_common();
  ::draiosproto::k8s_common* release_common();
  void set_allocated_common(::draiosproto::k8s_common* common);

  // optional uint32 current_scheduled = 2;
  bool has_current_scheduled() const;
  void clear_current_scheduled();
  static const int kCurrentScheduledFieldNumber = 2;
  ::google::protobuf::uint32 current_scheduled() const;
  void set_current_scheduled(::google::protobuf::uint32 value);

  // optional uint32 desired_scheduled = 3;
  bool has_desired_scheduled() const;
  void clear_desired_scheduled();
  static const int kDesiredScheduledFieldNumber = 3;
  ::google::protobuf::uint32 desired_scheduled() const;
  void set_desired_scheduled(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.k8s_daemonset)
 private:
  inline void set_has_common();
  inline void clear_has_common();
  inline void set_has_current_scheduled();
  inline void clear_has_current_scheduled();
  inline void set_has_desired_scheduled();
  inline void clear_has_desired_scheduled();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::draiosproto::k8s_common* common_;
  ::google::protobuf::uint32 current_scheduled_;
  ::google::protobuf::uint32 desired_scheduled_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<k8s_daemonset> k8s_daemonset_default_instance_;

// -------------------------------------------------------------------

class k8s_state : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.k8s_state) */ {
 public:
  k8s_state();
  virtual ~k8s_state();

  k8s_state(const k8s_state& from);

  inline k8s_state& operator=(const k8s_state& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const k8s_state& default_instance();

  static const k8s_state* internal_default_instance();

  void Swap(k8s_state* other);

  // implements Message ----------------------------------------------

  inline k8s_state* New() const { return New(NULL); }

  k8s_state* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const k8s_state& from);
  void MergeFrom(const k8s_state& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(k8s_state* other);
  void UnsafeMergeFrom(const k8s_state& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .draiosproto.k8s_namespace namespaces = 1;
  int namespaces_size() const;
  void clear_namespaces();
  static const int kNamespacesFieldNumber = 1;
  const ::draiosproto::k8s_namespace& namespaces(int index) const;
  ::draiosproto::k8s_namespace* mutable_namespaces(int index);
  ::draiosproto::k8s_namespace* add_namespaces();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_namespace >*
      mutable_namespaces();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_namespace >&
      namespaces() const;

  // repeated .draiosproto.k8s_node nodes = 2;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 2;
  const ::draiosproto::k8s_node& nodes(int index) const;
  ::draiosproto::k8s_node* mutable_nodes(int index);
  ::draiosproto::k8s_node* add_nodes();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_node >*
      mutable_nodes();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_node >&
      nodes() const;

  // repeated .draiosproto.k8s_pod pods = 3;
  int pods_size() const;
  void clear_pods();
  static const int kPodsFieldNumber = 3;
  const ::draiosproto::k8s_pod& pods(int index) const;
  ::draiosproto::k8s_pod* mutable_pods(int index);
  ::draiosproto::k8s_pod* add_pods();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pod >*
      mutable_pods();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pod >&
      pods() const;

  // repeated .draiosproto.k8s_replication_controller controllers = 4;
  int controllers_size() const;
  void clear_controllers();
  static const int kControllersFieldNumber = 4;
  const ::draiosproto::k8s_replication_controller& controllers(int index) const;
  ::draiosproto::k8s_replication_controller* mutable_controllers(int index);
  ::draiosproto::k8s_replication_controller* add_controllers();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_replication_controller >*
      mutable_controllers();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_replication_controller >&
      controllers() const;

  // repeated .draiosproto.k8s_service services = 5;
  int services_size() const;
  void clear_services();
  static const int kServicesFieldNumber = 5;
  const ::draiosproto::k8s_service& services(int index) const;
  ::draiosproto::k8s_service* mutable_services(int index);
  ::draiosproto::k8s_service* add_services();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_service >*
      mutable_services();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_service >&
      services() const;

  // repeated .draiosproto.k8s_replica_set replica_sets = 6;
  int replica_sets_size() const;
  void clear_replica_sets();
  static const int kReplicaSetsFieldNumber = 6;
  const ::draiosproto::k8s_replica_set& replica_sets(int index) const;
  ::draiosproto::k8s_replica_set* mutable_replica_sets(int index);
  ::draiosproto::k8s_replica_set* add_replica_sets();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_replica_set >*
      mutable_replica_sets();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_replica_set >&
      replica_sets() const;

  // repeated .draiosproto.k8s_deployment deployments = 7;
  int deployments_size() const;
  void clear_deployments();
  static const int kDeploymentsFieldNumber = 7;
  const ::draiosproto::k8s_deployment& deployments(int index) const;
  ::draiosproto::k8s_deployment* mutable_deployments(int index);
  ::draiosproto::k8s_deployment* add_deployments();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_deployment >*
      mutable_deployments();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_deployment >&
      deployments() const;

  // repeated .draiosproto.k8s_daemonset daemonsets = 8;
  int daemonsets_size() const;
  void clear_daemonsets();
  static const int kDaemonsetsFieldNumber = 8;
  const ::draiosproto::k8s_daemonset& daemonsets(int index) const;
  ::draiosproto::k8s_daemonset* mutable_daemonsets(int index);
  ::draiosproto::k8s_daemonset* add_daemonsets();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_daemonset >*
      mutable_daemonsets();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_daemonset >&
      daemonsets() const;

  // @@protoc_insertion_point(class_scope:draiosproto.k8s_state)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_namespace > namespaces_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_node > nodes_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pod > pods_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_replication_controller > controllers_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_service > services_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_replica_set > replica_sets_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_deployment > deployments_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_daemonset > daemonsets_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<k8s_state> k8s_state_default_instance_;

// -------------------------------------------------------------------

class mesos_pair : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.mesos_pair) */ {
 public:
  mesos_pair();
  virtual ~mesos_pair();

  mesos_pair(const mesos_pair& from);

  inline mesos_pair& operator=(const mesos_pair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mesos_pair& default_instance();

  static const mesos_pair* internal_default_instance();

  void Swap(mesos_pair* other);

  // implements Message ----------------------------------------------

  inline mesos_pair* New() const { return New(NULL); }

  mesos_pair* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mesos_pair& from);
  void MergeFrom(const mesos_pair& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(mesos_pair* other);
  void UnsafeMergeFrom(const mesos_pair& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:draiosproto.mesos_pair)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<mesos_pair> mesos_pair_default_instance_;

// -------------------------------------------------------------------

class mesos_common : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.mesos_common) */ {
 public:
  mesos_common();
  virtual ~mesos_common();

  mesos_common(const mesos_common& from);

  inline mesos_common& operator=(const mesos_common& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mesos_common& default_instance();

  static const mesos_common* internal_default_instance();

  void Swap(mesos_common* other);

  // implements Message ----------------------------------------------

  inline mesos_common* New() const { return New(NULL); }

  mesos_common* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mesos_common& from);
  void MergeFrom(const mesos_common& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(mesos_common* other);
  void UnsafeMergeFrom(const mesos_common& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string uid = 1;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 1;
  const ::std::string& uid() const;
  void set_uid(const ::std::string& value);
  void set_uid(const char* value);
  void set_uid(const char* value, size_t size);
  ::std::string* mutable_uid();
  ::std::string* release_uid();
  void set_allocated_uid(::std::string* uid);

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .draiosproto.mesos_pair labels = 3;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 3;
  const ::draiosproto::mesos_pair& labels(int index) const;
  ::draiosproto::mesos_pair* mutable_labels(int index);
  ::draiosproto::mesos_pair* add_labels();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_pair >*
      mutable_labels();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_pair >&
      labels() const;

  // @@protoc_insertion_point(class_scope:draiosproto.mesos_common)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_pair > labels_;
  ::google::protobuf::internal::ArenaStringPtr uid_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<mesos_common> mesos_common_default_instance_;

// -------------------------------------------------------------------

class mesos_task : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.mesos_task) */ {
 public:
  mesos_task();
  virtual ~mesos_task();

  mesos_task(const mesos_task& from);

  inline mesos_task& operator=(const mesos_task& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mesos_task& default_instance();

  static const mesos_task* internal_default_instance();

  void Swap(mesos_task* other);

  // implements Message ----------------------------------------------

  inline mesos_task* New() const { return New(NULL); }

  mesos_task* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mesos_task& from);
  void MergeFrom(const mesos_task& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(mesos_task* other);
  void UnsafeMergeFrom(const mesos_task& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.mesos_common common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  const ::draiosproto::mesos_common& common() const;
  ::draiosproto::mesos_common* mutable_common();
  ::draiosproto::mesos_common* release_common();
  void set_allocated_common(::draiosproto::mesos_common* common);

  // required string slave_id = 2;
  bool has_slave_id() const;
  void clear_slave_id();
  static const int kSlaveIdFieldNumber = 2;
  const ::std::string& slave_id() const;
  void set_slave_id(const ::std::string& value);
  void set_slave_id(const char* value);
  void set_slave_id(const char* value, size_t size);
  ::std::string* mutable_slave_id();
  ::std::string* release_slave_id();
  void set_allocated_slave_id(::std::string* slave_id);

  // @@protoc_insertion_point(class_scope:draiosproto.mesos_task)
 private:
  inline void set_has_common();
  inline void clear_has_common();
  inline void set_has_slave_id();
  inline void clear_has_slave_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr slave_id_;
  ::draiosproto::mesos_common* common_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<mesos_task> mesos_task_default_instance_;

// -------------------------------------------------------------------

class marathon_app : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.marathon_app) */ {
 public:
  marathon_app();
  virtual ~marathon_app();

  marathon_app(const marathon_app& from);

  inline marathon_app& operator=(const marathon_app& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const marathon_app& default_instance();

  static const marathon_app* internal_default_instance();

  void Swap(marathon_app* other);

  // implements Message ----------------------------------------------

  inline marathon_app* New() const { return New(NULL); }

  marathon_app* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const marathon_app& from);
  void MergeFrom(const marathon_app& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(marathon_app* other);
  void UnsafeMergeFrom(const marathon_app& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // repeated string task_ids = 2;
  int task_ids_size() const;
  void clear_task_ids();
  static const int kTaskIdsFieldNumber = 2;
  const ::std::string& task_ids(int index) const;
  ::std::string* mutable_task_ids(int index);
  void set_task_ids(int index, const ::std::string& value);
  void set_task_ids(int index, const char* value);
  void set_task_ids(int index, const char* value, size_t size);
  ::std::string* add_task_ids();
  void add_task_ids(const ::std::string& value);
  void add_task_ids(const char* value);
  void add_task_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& task_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_task_ids();

  // @@protoc_insertion_point(class_scope:draiosproto.marathon_app)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> task_ids_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<marathon_app> marathon_app_default_instance_;

// -------------------------------------------------------------------

class marathon_group : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.marathon_group) */ {
 public:
  marathon_group();
  virtual ~marathon_group();

  marathon_group(const marathon_group& from);

  inline marathon_group& operator=(const marathon_group& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const marathon_group& default_instance();

  static const marathon_group* internal_default_instance();

  void Swap(marathon_group* other);

  // implements Message ----------------------------------------------

  inline marathon_group* New() const { return New(NULL); }

  marathon_group* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const marathon_group& from);
  void MergeFrom(const marathon_group& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(marathon_group* other);
  void UnsafeMergeFrom(const marathon_group& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // repeated .draiosproto.marathon_app apps = 2;
  int apps_size() const;
  void clear_apps();
  static const int kAppsFieldNumber = 2;
  const ::draiosproto::marathon_app& apps(int index) const;
  ::draiosproto::marathon_app* mutable_apps(int index);
  ::draiosproto::marathon_app* add_apps();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_app >*
      mutable_apps();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_app >&
      apps() const;

  // repeated .draiosproto.marathon_group groups = 3;
  int groups_size() const;
  void clear_groups();
  static const int kGroupsFieldNumber = 3;
  const ::draiosproto::marathon_group& groups(int index) const;
  ::draiosproto::marathon_group* mutable_groups(int index);
  ::draiosproto::marathon_group* add_groups();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_group >*
      mutable_groups();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_group >&
      groups() const;

  // @@protoc_insertion_point(class_scope:draiosproto.marathon_group)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_app > apps_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_group > groups_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<marathon_group> marathon_group_default_instance_;

// -------------------------------------------------------------------

class mesos_framework : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.mesos_framework) */ {
 public:
  mesos_framework();
  virtual ~mesos_framework();

  mesos_framework(const mesos_framework& from);

  inline mesos_framework& operator=(const mesos_framework& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mesos_framework& default_instance();

  static const mesos_framework* internal_default_instance();

  void Swap(mesos_framework* other);

  // implements Message ----------------------------------------------

  inline mesos_framework* New() const { return New(NULL); }

  mesos_framework* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mesos_framework& from);
  void MergeFrom(const mesos_framework& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(mesos_framework* other);
  void UnsafeMergeFrom(const mesos_framework& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.mesos_common common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  const ::draiosproto::mesos_common& common() const;
  ::draiosproto::mesos_common* mutable_common();
  ::draiosproto::mesos_common* release_common();
  void set_allocated_common(::draiosproto::mesos_common* common);

  // repeated .draiosproto.mesos_task tasks = 2;
  int tasks_size() const;
  void clear_tasks();
  static const int kTasksFieldNumber = 2;
  const ::draiosproto::mesos_task& tasks(int index) const;
  ::draiosproto::mesos_task* mutable_tasks(int index);
  ::draiosproto::mesos_task* add_tasks();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_task >*
      mutable_tasks();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_task >&
      tasks() const;

  // @@protoc_insertion_point(class_scope:draiosproto.mesos_framework)
 private:
  inline void set_has_common();
  inline void clear_has_common();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_task > tasks_;
  ::draiosproto::mesos_common* common_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<mesos_framework> mesos_framework_default_instance_;

// -------------------------------------------------------------------

class mesos_slave : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.mesos_slave) */ {
 public:
  mesos_slave();
  virtual ~mesos_slave();

  mesos_slave(const mesos_slave& from);

  inline mesos_slave& operator=(const mesos_slave& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mesos_slave& default_instance();

  static const mesos_slave* internal_default_instance();

  void Swap(mesos_slave* other);

  // implements Message ----------------------------------------------

  inline mesos_slave* New() const { return New(NULL); }

  mesos_slave* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mesos_slave& from);
  void MergeFrom(const mesos_slave& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(mesos_slave* other);
  void UnsafeMergeFrom(const mesos_slave& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.mesos_common common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  const ::draiosproto::mesos_common& common() const;
  ::draiosproto::mesos_common* mutable_common();
  ::draiosproto::mesos_common* release_common();
  void set_allocated_common(::draiosproto::mesos_common* common);

  // @@protoc_insertion_point(class_scope:draiosproto.mesos_slave)
 private:
  inline void set_has_common();
  inline void clear_has_common();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::draiosproto::mesos_common* common_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<mesos_slave> mesos_slave_default_instance_;

// -------------------------------------------------------------------

class mesos_state : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.mesos_state) */ {
 public:
  mesos_state();
  virtual ~mesos_state();

  mesos_state(const mesos_state& from);

  inline mesos_state& operator=(const mesos_state& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mesos_state& default_instance();

  static const mesos_state* internal_default_instance();

  void Swap(mesos_state* other);

  // implements Message ----------------------------------------------

  inline mesos_state* New() const { return New(NULL); }

  mesos_state* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mesos_state& from);
  void MergeFrom(const mesos_state& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(mesos_state* other);
  void UnsafeMergeFrom(const mesos_state& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .draiosproto.mesos_framework frameworks = 1;
  int frameworks_size() const;
  void clear_frameworks();
  static const int kFrameworksFieldNumber = 1;
  const ::draiosproto::mesos_framework& frameworks(int index) const;
  ::draiosproto::mesos_framework* mutable_frameworks(int index);
  ::draiosproto::mesos_framework* add_frameworks();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_framework >*
      mutable_frameworks();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_framework >&
      frameworks() const;

  // repeated .draiosproto.marathon_group groups = 2;
  int groups_size() const;
  void clear_groups();
  static const int kGroupsFieldNumber = 2;
  const ::draiosproto::marathon_group& groups(int index) const;
  ::draiosproto::marathon_group* mutable_groups(int index);
  ::draiosproto::marathon_group* add_groups();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_group >*
      mutable_groups();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_group >&
      groups() const;

  // repeated .draiosproto.mesos_slave slaves = 3;
  int slaves_size() const;
  void clear_slaves();
  static const int kSlavesFieldNumber = 3;
  const ::draiosproto::mesos_slave& slaves(int index) const;
  ::draiosproto::mesos_slave* mutable_slaves(int index);
  ::draiosproto::mesos_slave* add_slaves();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_slave >*
      mutable_slaves();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_slave >&
      slaves() const;

  // @@protoc_insertion_point(class_scope:draiosproto.mesos_state)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_framework > frameworks_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_group > groups_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_slave > slaves_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<mesos_state> mesos_state_default_instance_;

// -------------------------------------------------------------------

class metrics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.metrics) */ {
 public:
  metrics();
  virtual ~metrics();

  metrics(const metrics& from);

  inline metrics& operator=(const metrics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const metrics& default_instance();

  static const metrics* internal_default_instance();

  void Swap(metrics* other);

  // implements Message ----------------------------------------------

  inline metrics* New() const { return New(NULL); }

  metrics* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const metrics& from);
  void MergeFrom(const metrics& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(metrics* other);
  void UnsafeMergeFrom(const metrics& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  bool has_timestamp_ns() const;
  void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  ::google::protobuf::uint64 timestamp_ns() const;
  void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  bool has_machine_id() const;
  void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  const ::std::string& machine_id() const;
  void set_machine_id(const ::std::string& value);
  void set_machine_id(const char* value);
  void set_machine_id(const char* value, size_t size);
  ::std::string* mutable_machine_id();
  ::std::string* release_machine_id();
  void set_allocated_machine_id(::std::string* machine_id);

  // optional string customer_id = 3;
  bool has_customer_id() const;
  void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  const ::std::string& customer_id() const;
  void set_customer_id(const ::std::string& value);
  void set_customer_id(const char* value);
  void set_customer_id(const char* value, size_t size);
  ::std::string* mutable_customer_id();
  ::std::string* release_customer_id();
  void set_allocated_customer_id(::std::string* customer_id);

  // optional uint32 sampling_ratio = 10;
  bool has_sampling_ratio() const;
  void clear_sampling_ratio();
  static const int kSamplingRatioFieldNumber = 10;
  ::google::protobuf::uint32 sampling_ratio() const;
  void set_sampling_ratio(::google::protobuf::uint32 value);

  // optional string host_custom_name = 11;
  bool has_host_custom_name() const;
  void clear_host_custom_name();
  static const int kHostCustomNameFieldNumber = 11;
  const ::std::string& host_custom_name() const;
  void set_host_custom_name(const ::std::string& value);
  void set_host_custom_name(const char* value);
  void set_host_custom_name(const char* value, size_t size);
  ::std::string* mutable_host_custom_name();
  ::std::string* release_host_custom_name();
  void set_allocated_host_custom_name(::std::string* host_custom_name);

  // optional string host_tags = 12;
  bool has_host_tags() const;
  void clear_host_tags();
  static const int kHostTagsFieldNumber = 12;
  const ::std::string& host_tags() const;
  void set_host_tags(const ::std::string& value);
  void set_host_tags(const char* value);
  void set_host_tags(const char* value, size_t size);
  ::std::string* mutable_host_tags();
  ::std::string* release_host_tags();
  void set_allocated_host_tags(::std::string* host_tags);

  // optional bool is_host_hidden = 14;
  bool has_is_host_hidden() const;
  void clear_is_host_hidden();
  static const int kIsHostHiddenFieldNumber = 14;
  bool is_host_hidden() const;
  void set_is_host_hidden(bool value);

  // optional string hidden_processes = 15;
  bool has_hidden_processes() const;
  void clear_hidden_processes();
  static const int kHiddenProcessesFieldNumber = 15;
  const ::std::string& hidden_processes() const;
  void set_hidden_processes(const ::std::string& value);
  void set_hidden_processes(const char* value);
  void set_hidden_processes(const char* value, size_t size);
  ::std::string* mutable_hidden_processes();
  ::std::string* release_hidden_processes();
  void set_allocated_hidden_processes(::std::string* hidden_processes);

  // optional string version = 16;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 16;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // optional string instance_id = 21;
  bool has_instance_id() const;
  void clear_instance_id();
  static const int kInstanceIdFieldNumber = 21;
  const ::std::string& instance_id() const;
  void set_instance_id(const ::std::string& value);
  void set_instance_id(const char* value);
  void set_instance_id(const char* value, size_t size);
  ::std::string* mutable_instance_id();
  ::std::string* release_instance_id();
  void set_allocated_instance_id(::std::string* instance_id);

  // optional .draiosproto.host hostinfo = 4;
  bool has_hostinfo() const;
  void clear_hostinfo();
  static const int kHostinfoFieldNumber = 4;
  const ::draiosproto::host& hostinfo() const;
  ::draiosproto::host* mutable_hostinfo();
  ::draiosproto::host* release_hostinfo();
  void set_allocated_hostinfo(::draiosproto::host* hostinfo);

  // repeated .draiosproto.program programs = 9;
  int programs_size() const;
  void clear_programs();
  static const int kProgramsFieldNumber = 9;
  const ::draiosproto::program& programs(int index) const;
  ::draiosproto::program* mutable_programs(int index);
  ::draiosproto::program* add_programs();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::program >*
      mutable_programs();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::program >&
      programs() const;

  // repeated .draiosproto.ipv4_connection ipv4_connections = 7;
  int ipv4_connections_size() const;
  void clear_ipv4_connections();
  static const int kIpv4ConnectionsFieldNumber = 7;
  const ::draiosproto::ipv4_connection& ipv4_connections(int index) const;
  ::draiosproto::ipv4_connection* mutable_ipv4_connections(int index);
  ::draiosproto::ipv4_connection* add_ipv4_connections();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_connection >*
      mutable_ipv4_connections();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_connection >&
      ipv4_connections() const;

  // repeated .draiosproto.ipv4_network_interface ipv4_network_interfaces = 8;
  int ipv4_network_interfaces_size() const;
  void clear_ipv4_network_interfaces();
  static const int kIpv4NetworkInterfacesFieldNumber = 8;
  const ::draiosproto::ipv4_network_interface& ipv4_network_interfaces(int index) const;
  ::draiosproto::ipv4_network_interface* mutable_ipv4_network_interfaces(int index);
  ::draiosproto::ipv4_network_interface* add_ipv4_network_interfaces();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_network_interface >*
      mutable_ipv4_network_interfaces();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_network_interface >&
      ipv4_network_interfaces() const;

  // repeated .draiosproto.command_details commands = 17;
  int commands_size() const;
  void clear_commands();
  static const int kCommandsFieldNumber = 17;
  const ::draiosproto::command_details& commands(int index) const;
  ::draiosproto::command_details* mutable_commands(int index);
  ::draiosproto::command_details* add_commands();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::command_details >*
      mutable_commands();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::command_details >&
      commands() const;

  // repeated .draiosproto.mounted_fs mounts = 18;
  int mounts_size() const;
  void clear_mounts();
  static const int kMountsFieldNumber = 18;
  const ::draiosproto::mounted_fs& mounts(int index) const;
  ::draiosproto::mounted_fs* mutable_mounts(int index);
  ::draiosproto::mounted_fs* add_mounts();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mounted_fs >*
      mutable_mounts();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::mounted_fs >&
      mounts() const;

  // repeated .draiosproto.file_stat top_files = 19;
  int top_files_size() const;
  void clear_top_files();
  static const int kTopFilesFieldNumber = 19;
  const ::draiosproto::file_stat& top_files(int index) const;
  ::draiosproto::file_stat* mutable_top_files(int index);
  ::draiosproto::file_stat* add_top_files();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::file_stat >*
      mutable_top_files();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::file_stat >&
      top_files() const;

  // optional .draiosproto.proto_info protos = 20;
  bool has_protos() const;
  void clear_protos();
  static const int kProtosFieldNumber = 20;
  const ::draiosproto::proto_info& protos() const;
  ::draiosproto::proto_info* mutable_protos();
  ::draiosproto::proto_info* release_protos();
  void set_allocated_protos(::draiosproto::proto_info* protos);

  // repeated .draiosproto.container containers = 22;
  int containers_size() const;
  void clear_containers();
  static const int kContainersFieldNumber = 22;
  const ::draiosproto::container& containers(int index) const;
  ::draiosproto::container* mutable_containers(int index);
  ::draiosproto::container* add_containers();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::container >*
      mutable_containers();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::container >&
      containers() const;

  // optional .draiosproto.k8s_state kubernetes = 24;
  bool has_kubernetes() const;
  void clear_kubernetes();
  static const int kKubernetesFieldNumber = 24;
  const ::draiosproto::k8s_state& kubernetes() const;
  ::draiosproto::k8s_state* mutable_kubernetes();
  ::draiosproto::k8s_state* release_kubernetes();
  void set_allocated_kubernetes(::draiosproto::k8s_state* kubernetes);

  // optional .draiosproto.mesos_state mesos = 25;
  bool has_mesos() const;
  void clear_mesos();
  static const int kMesosFieldNumber = 25;
  const ::draiosproto::mesos_state& mesos() const;
  ::draiosproto::mesos_state* mutable_mesos();
  ::draiosproto::mesos_state* release_mesos();
  void set_allocated_mesos(::draiosproto::mesos_state* mesos);

  // repeated .draiosproto.agent_event events = 26;
  int events_size() const;
  void clear_events();
  static const int kEventsFieldNumber = 26;
  const ::draiosproto::agent_event& events(int index) const;
  ::draiosproto::agent_event* mutable_events(int index);
  ::draiosproto::agent_event* add_events();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::agent_event >*
      mutable_events();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::agent_event >&
      events() const;

  // optional .draiosproto.falco_baseline falcobl = 27;
  bool has_falcobl() const;
  void clear_falcobl();
  static const int kFalcoblFieldNumber = 27;
  const ::draiosproto::falco_baseline& falcobl() const;
  ::draiosproto::falco_baseline* mutable_falcobl();
  ::draiosproto::falco_baseline* release_falcobl();
  void set_allocated_falcobl(::draiosproto::falco_baseline* falcobl);

  // @@protoc_insertion_point(class_scope:draiosproto.metrics)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();
  inline void set_has_sampling_ratio();
  inline void clear_has_sampling_ratio();
  inline void set_has_host_custom_name();
  inline void clear_has_host_custom_name();
  inline void set_has_host_tags();
  inline void clear_has_host_tags();
  inline void set_has_is_host_hidden();
  inline void clear_has_is_host_hidden();
  inline void set_has_hidden_processes();
  inline void clear_has_hidden_processes();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_instance_id();
  inline void clear_has_instance_id();
  inline void set_has_hostinfo();
  inline void clear_has_hostinfo();
  inline void set_has_protos();
  inline void clear_has_protos();
  inline void set_has_kubernetes();
  inline void clear_has_kubernetes();
  inline void set_has_mesos();
  inline void clear_has_mesos();
  inline void set_has_falcobl();
  inline void clear_has_falcobl();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::program > programs_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_connection > ipv4_connections_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_network_interface > ipv4_network_interfaces_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::command_details > commands_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mounted_fs > mounts_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::file_stat > top_files_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::container > containers_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::agent_event > events_;
  ::google::protobuf::internal::ArenaStringPtr machine_id_;
  ::google::protobuf::internal::ArenaStringPtr customer_id_;
  ::google::protobuf::internal::ArenaStringPtr host_custom_name_;
  ::google::protobuf::internal::ArenaStringPtr host_tags_;
  ::google::protobuf::internal::ArenaStringPtr hidden_processes_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr instance_id_;
  ::draiosproto::host* hostinfo_;
  ::draiosproto::proto_info* protos_;
  ::draiosproto::k8s_state* kubernetes_;
  ::draiosproto::mesos_state* mesos_;
  ::draiosproto::falco_baseline* falcobl_;
  ::google::protobuf::uint64 timestamp_ns_;
  ::google::protobuf::uint32 sampling_ratio_;
  bool is_host_hidden_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<metrics> metrics_default_instance_;

// -------------------------------------------------------------------

class dump_request_start : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.dump_request_start) */ {
 public:
  dump_request_start();
  virtual ~dump_request_start();

  dump_request_start(const dump_request_start& from);

  inline dump_request_start& operator=(const dump_request_start& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dump_request_start& default_instance();

  static const dump_request_start* internal_default_instance();

  void Swap(dump_request_start* other);

  // implements Message ----------------------------------------------

  inline dump_request_start* New() const { return New(NULL); }

  dump_request_start* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dump_request_start& from);
  void MergeFrom(const dump_request_start& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(dump_request_start* other);
  void UnsafeMergeFrom(const dump_request_start& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  bool has_timestamp_ns() const;
  void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  ::google::protobuf::uint64 timestamp_ns() const;
  void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  bool has_machine_id() const;
  void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  const ::std::string& machine_id() const;
  void set_machine_id(const ::std::string& value);
  void set_machine_id(const char* value);
  void set_machine_id(const char* value, size_t size);
  ::std::string* mutable_machine_id();
  ::std::string* release_machine_id();
  void set_allocated_machine_id(::std::string* machine_id);

  // optional string customer_id = 3;
  bool has_customer_id() const;
  void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  const ::std::string& customer_id() const;
  void set_customer_id(const ::std::string& value);
  void set_customer_id(const char* value);
  void set_customer_id(const char* value, size_t size);
  ::std::string* mutable_customer_id();
  ::std::string* release_customer_id();
  void set_allocated_customer_id(::std::string* customer_id);

  // optional uint64 duration_ns = 4;
  bool has_duration_ns() const;
  void clear_duration_ns();
  static const int kDurationNsFieldNumber = 4;
  ::google::protobuf::uint64 duration_ns() const;
  void set_duration_ns(::google::protobuf::uint64 value);

  // optional string filters = 5;
  bool has_filters() const;
  void clear_filters();
  static const int kFiltersFieldNumber = 5;
  const ::std::string& filters() const;
  void set_filters(const ::std::string& value);
  void set_filters(const char* value);
  void set_filters(const char* value, size_t size);
  ::std::string* mutable_filters();
  ::std::string* release_filters();
  void set_allocated_filters(::std::string* filters);

  // optional uint64 max_size = 7;
  bool has_max_size() const;
  void clear_max_size();
  static const int kMaxSizeFieldNumber = 7;
  ::google::protobuf::uint64 max_size() const;
  void set_max_size(::google::protobuf::uint64 value);

  // required string token = 6;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 6;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:draiosproto.dump_request_start)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();
  inline void set_has_duration_ns();
  inline void clear_has_duration_ns();
  inline void set_has_filters();
  inline void clear_has_filters();
  inline void set_has_max_size();
  inline void clear_has_max_size();
  inline void set_has_token();
  inline void clear_has_token();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr machine_id_;
  ::google::protobuf::internal::ArenaStringPtr customer_id_;
  ::google::protobuf::internal::ArenaStringPtr filters_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::google::protobuf::uint64 timestamp_ns_;
  ::google::protobuf::uint64 duration_ns_;
  ::google::protobuf::uint64 max_size_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<dump_request_start> dump_request_start_default_instance_;

// -------------------------------------------------------------------

class dump_request_stop : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.dump_request_stop) */ {
 public:
  dump_request_stop();
  virtual ~dump_request_stop();

  dump_request_stop(const dump_request_stop& from);

  inline dump_request_stop& operator=(const dump_request_stop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dump_request_stop& default_instance();

  static const dump_request_stop* internal_default_instance();

  void Swap(dump_request_stop* other);

  // implements Message ----------------------------------------------

  inline dump_request_stop* New() const { return New(NULL); }

  dump_request_stop* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dump_request_stop& from);
  void MergeFrom(const dump_request_stop& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(dump_request_stop* other);
  void UnsafeMergeFrom(const dump_request_stop& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  bool has_timestamp_ns() const;
  void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  ::google::protobuf::uint64 timestamp_ns() const;
  void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  bool has_machine_id() const;
  void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  const ::std::string& machine_id() const;
  void set_machine_id(const ::std::string& value);
  void set_machine_id(const char* value);
  void set_machine_id(const char* value, size_t size);
  ::std::string* mutable_machine_id();
  ::std::string* release_machine_id();
  void set_allocated_machine_id(::std::string* machine_id);

  // optional string customer_id = 3;
  bool has_customer_id() const;
  void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  const ::std::string& customer_id() const;
  void set_customer_id(const ::std::string& value);
  void set_customer_id(const char* value);
  void set_customer_id(const char* value, size_t size);
  ::std::string* mutable_customer_id();
  ::std::string* release_customer_id();
  void set_allocated_customer_id(::std::string* customer_id);

  // required string token = 4;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 4;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:draiosproto.dump_request_stop)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();
  inline void set_has_token();
  inline void clear_has_token();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr machine_id_;
  ::google::protobuf::internal::ArenaStringPtr customer_id_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::google::protobuf::uint64 timestamp_ns_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<dump_request_stop> dump_request_stop_default_instance_;

// -------------------------------------------------------------------

class dump_response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.dump_response) */ {
 public:
  dump_response();
  virtual ~dump_response();

  dump_response(const dump_response& from);

  inline dump_response& operator=(const dump_response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dump_response& default_instance();

  static const dump_response* internal_default_instance();

  void Swap(dump_response* other);

  // implements Message ----------------------------------------------

  inline dump_response* New() const { return New(NULL); }

  dump_response* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dump_response& from);
  void MergeFrom(const dump_response& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(dump_response* other);
  void UnsafeMergeFrom(const dump_response& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  bool has_timestamp_ns() const;
  void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  ::google::protobuf::uint64 timestamp_ns() const;
  void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  bool has_machine_id() const;
  void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  const ::std::string& machine_id() const;
  void set_machine_id(const ::std::string& value);
  void set_machine_id(const char* value);
  void set_machine_id(const char* value, size_t size);
  ::std::string* mutable_machine_id();
  ::std::string* release_machine_id();
  void set_allocated_machine_id(::std::string* machine_id);

  // optional string customer_id = 3;
  bool has_customer_id() const;
  void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  const ::std::string& customer_id() const;
  void set_customer_id(const ::std::string& value);
  void set_customer_id(const char* value);
  void set_customer_id(const char* value, size_t size);
  ::std::string* mutable_customer_id();
  ::std::string* release_customer_id();
  void set_allocated_customer_id(::std::string* customer_id);

  // optional uint32 chunk_no = 7;
  bool has_chunk_no() const;
  void clear_chunk_no();
  static const int kChunkNoFieldNumber = 7;
  ::google::protobuf::uint32 chunk_no() const;
  void set_chunk_no(::google::protobuf::uint32 value);

  // optional bool final_chunk = 8;
  bool has_final_chunk() const;
  void clear_final_chunk();
  static const int kFinalChunkFieldNumber = 8;
  bool final_chunk() const;
  void set_final_chunk(bool value);

  // optional bool keep_alive = 9;
  bool has_keep_alive() const;
  void clear_keep_alive();
  static const int kKeepAliveFieldNumber = 9;
  bool keep_alive() const;
  void set_keep_alive(bool value);

  // optional bytes content = 4;
  bool has_content() const;
  void clear_content();
  static const int kContentFieldNumber = 4;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // optional uint64 final_size_bytes = 10;
  bool has_final_size_bytes() const;
  void clear_final_size_bytes();
  static const int kFinalSizeBytesFieldNumber = 10;
  ::google::protobuf::uint64 final_size_bytes() const;
  void set_final_size_bytes(::google::protobuf::uint64 value);

  // optional string error = 5;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 5;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // required string token = 6;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 6;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:draiosproto.dump_response)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();
  inline void set_has_chunk_no();
  inline void clear_has_chunk_no();
  inline void set_has_final_chunk();
  inline void clear_has_final_chunk();
  inline void set_has_keep_alive();
  inline void clear_has_keep_alive();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_final_size_bytes();
  inline void clear_has_final_size_bytes();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_token();
  inline void clear_has_token();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr machine_id_;
  ::google::protobuf::internal::ArenaStringPtr customer_id_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::google::protobuf::uint64 timestamp_ns_;
  ::google::protobuf::uint32 chunk_no_;
  bool final_chunk_;
  bool keep_alive_;
  ::google::protobuf::uint64 final_size_bytes_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<dump_response> dump_response_default_instance_;

// -------------------------------------------------------------------

class ssh_open_channel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.ssh_open_channel) */ {
 public:
  ssh_open_channel();
  virtual ~ssh_open_channel();

  ssh_open_channel(const ssh_open_channel& from);

  inline ssh_open_channel& operator=(const ssh_open_channel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ssh_open_channel& default_instance();

  static const ssh_open_channel* internal_default_instance();

  void Swap(ssh_open_channel* other);

  // implements Message ----------------------------------------------

  inline ssh_open_channel* New() const { return New(NULL); }

  ssh_open_channel* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ssh_open_channel& from);
  void MergeFrom(const ssh_open_channel& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ssh_open_channel* other);
  void UnsafeMergeFrom(const ssh_open_channel& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  bool has_timestamp_ns() const;
  void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  ::google::protobuf::uint64 timestamp_ns() const;
  void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  bool has_machine_id() const;
  void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  const ::std::string& machine_id() const;
  void set_machine_id(const ::std::string& value);
  void set_machine_id(const char* value);
  void set_machine_id(const char* value, size_t size);
  ::std::string* mutable_machine_id();
  ::std::string* release_machine_id();
  void set_allocated_machine_id(::std::string* machine_id);

  // optional string customer_id = 3;
  bool has_customer_id() const;
  void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  const ::std::string& customer_id() const;
  void set_customer_id(const ::std::string& value);
  void set_customer_id(const char* value);
  void set_customer_id(const char* value, size_t size);
  ::std::string* mutable_customer_id();
  ::std::string* release_customer_id();
  void set_allocated_customer_id(::std::string* customer_id);

  // required string token = 4;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 4;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // required string user = 5;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 5;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // optional string password = 6;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 6;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // optional string key = 7;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 7;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string passphrase = 8;
  bool has_passphrase() const;
  void clear_passphrase();
  static const int kPassphraseFieldNumber = 8;
  const ::std::string& passphrase() const;
  void set_passphrase(const ::std::string& value);
  void set_passphrase(const char* value);
  void set_passphrase(const char* value, size_t size);
  ::std::string* mutable_passphrase();
  ::std::string* release_passphrase();
  void set_allocated_passphrase(::std::string* passphrase);

  // optional uint32 port = 9;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 9;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.ssh_open_channel)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_passphrase();
  inline void clear_has_passphrase();
  inline void set_has_port();
  inline void clear_has_port();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr machine_id_;
  ::google::protobuf::internal::ArenaStringPtr customer_id_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr passphrase_;
  ::google::protobuf::uint64 timestamp_ns_;
  ::google::protobuf::uint32 port_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ssh_open_channel> ssh_open_channel_default_instance_;

// -------------------------------------------------------------------

class ssh_data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.ssh_data) */ {
 public:
  ssh_data();
  virtual ~ssh_data();

  ssh_data(const ssh_data& from);

  inline ssh_data& operator=(const ssh_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ssh_data& default_instance();

  static const ssh_data* internal_default_instance();

  void Swap(ssh_data* other);

  // implements Message ----------------------------------------------

  inline ssh_data* New() const { return New(NULL); }

  ssh_data* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ssh_data& from);
  void MergeFrom(const ssh_data& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ssh_data* other);
  void UnsafeMergeFrom(const ssh_data& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  bool has_timestamp_ns() const;
  void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  ::google::protobuf::uint64 timestamp_ns() const;
  void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  bool has_machine_id() const;
  void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  const ::std::string& machine_id() const;
  void set_machine_id(const ::std::string& value);
  void set_machine_id(const char* value);
  void set_machine_id(const char* value, size_t size);
  ::std::string* mutable_machine_id();
  ::std::string* release_machine_id();
  void set_allocated_machine_id(::std::string* machine_id);

  // optional string customer_id = 3;
  bool has_customer_id() const;
  void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  const ::std::string& customer_id() const;
  void set_customer_id(const ::std::string& value);
  void set_customer_id(const char* value);
  void set_customer_id(const char* value, size_t size);
  ::std::string* mutable_customer_id();
  ::std::string* release_customer_id();
  void set_allocated_customer_id(::std::string* customer_id);

  // required string token = 4;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 4;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // optional bytes data = 5;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 5;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional string error = 6;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 6;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // optional int32 exit_status = 7;
  bool has_exit_status() const;
  void clear_exit_status();
  static const int kExitStatusFieldNumber = 7;
  ::google::protobuf::int32 exit_status() const;
  void set_exit_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.ssh_data)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_exit_status();
  inline void clear_has_exit_status();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr machine_id_;
  ::google::protobuf::internal::ArenaStringPtr customer_id_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::google::protobuf::uint64 timestamp_ns_;
  ::google::protobuf::int32 exit_status_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ssh_data> ssh_data_default_instance_;

// -------------------------------------------------------------------

class ssh_close_channel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.ssh_close_channel) */ {
 public:
  ssh_close_channel();
  virtual ~ssh_close_channel();

  ssh_close_channel(const ssh_close_channel& from);

  inline ssh_close_channel& operator=(const ssh_close_channel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ssh_close_channel& default_instance();

  static const ssh_close_channel* internal_default_instance();

  void Swap(ssh_close_channel* other);

  // implements Message ----------------------------------------------

  inline ssh_close_channel* New() const { return New(NULL); }

  ssh_close_channel* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ssh_close_channel& from);
  void MergeFrom(const ssh_close_channel& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ssh_close_channel* other);
  void UnsafeMergeFrom(const ssh_close_channel& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  bool has_timestamp_ns() const;
  void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  ::google::protobuf::uint64 timestamp_ns() const;
  void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  bool has_machine_id() const;
  void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  const ::std::string& machine_id() const;
  void set_machine_id(const ::std::string& value);
  void set_machine_id(const char* value);
  void set_machine_id(const char* value, size_t size);
  ::std::string* mutable_machine_id();
  ::std::string* release_machine_id();
  void set_allocated_machine_id(::std::string* machine_id);

  // optional string customer_id = 3;
  bool has_customer_id() const;
  void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  const ::std::string& customer_id() const;
  void set_customer_id(const ::std::string& value);
  void set_customer_id(const char* value);
  void set_customer_id(const char* value, size_t size);
  ::std::string* mutable_customer_id();
  ::std::string* release_customer_id();
  void set_allocated_customer_id(::std::string* customer_id);

  // required string token = 4;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 4;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:draiosproto.ssh_close_channel)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();
  inline void set_has_token();
  inline void clear_has_token();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr machine_id_;
  ::google::protobuf::internal::ArenaStringPtr customer_id_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::google::protobuf::uint64 timestamp_ns_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ssh_close_channel> ssh_close_channel_default_instance_;

// -------------------------------------------------------------------

class auto_update_request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.auto_update_request) */ {
 public:
  auto_update_request();
  virtual ~auto_update_request();

  auto_update_request(const auto_update_request& from);

  inline auto_update_request& operator=(const auto_update_request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const auto_update_request& default_instance();

  static const auto_update_request* internal_default_instance();

  void Swap(auto_update_request* other);

  // implements Message ----------------------------------------------

  inline auto_update_request* New() const { return New(NULL); }

  auto_update_request* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const auto_update_request& from);
  void MergeFrom(const auto_update_request& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(auto_update_request* other);
  void UnsafeMergeFrom(const auto_update_request& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  bool has_timestamp_ns() const;
  void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  ::google::protobuf::uint64 timestamp_ns() const;
  void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  bool has_machine_id() const;
  void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  const ::std::string& machine_id() const;
  void set_machine_id(const ::std::string& value);
  void set_machine_id(const char* value);
  void set_machine_id(const char* value, size_t size);
  ::std::string* mutable_machine_id();
  ::std::string* release_machine_id();
  void set_allocated_machine_id(::std::string* machine_id);

  // optional string customer_id = 3;
  bool has_customer_id() const;
  void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  const ::std::string& customer_id() const;
  void set_customer_id(const ::std::string& value);
  void set_customer_id(const char* value);
  void set_customer_id(const char* value, size_t size);
  ::std::string* mutable_customer_id();
  ::std::string* release_customer_id();
  void set_allocated_customer_id(::std::string* customer_id);

  // @@protoc_insertion_point(class_scope:draiosproto.auto_update_request)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr machine_id_;
  ::google::protobuf::internal::ArenaStringPtr customer_id_;
  ::google::protobuf::uint64 timestamp_ns_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<auto_update_request> auto_update_request_default_instance_;

// -------------------------------------------------------------------

class dirty_shutdown_report : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.dirty_shutdown_report) */ {
 public:
  dirty_shutdown_report();
  virtual ~dirty_shutdown_report();

  dirty_shutdown_report(const dirty_shutdown_report& from);

  inline dirty_shutdown_report& operator=(const dirty_shutdown_report& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dirty_shutdown_report& default_instance();

  static const dirty_shutdown_report* internal_default_instance();

  void Swap(dirty_shutdown_report* other);

  // implements Message ----------------------------------------------

  inline dirty_shutdown_report* New() const { return New(NULL); }

  dirty_shutdown_report* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dirty_shutdown_report& from);
  void MergeFrom(const dirty_shutdown_report& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(dirty_shutdown_report* other);
  void UnsafeMergeFrom(const dirty_shutdown_report& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  bool has_timestamp_ns() const;
  void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  ::google::protobuf::uint64 timestamp_ns() const;
  void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  bool has_machine_id() const;
  void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  const ::std::string& machine_id() const;
  void set_machine_id(const ::std::string& value);
  void set_machine_id(const char* value);
  void set_machine_id(const char* value, size_t size);
  ::std::string* mutable_machine_id();
  ::std::string* release_machine_id();
  void set_allocated_machine_id(::std::string* machine_id);

  // optional string customer_id = 3;
  bool has_customer_id() const;
  void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  const ::std::string& customer_id() const;
  void set_customer_id(const ::std::string& value);
  void set_customer_id(const char* value);
  void set_customer_id(const char* value, size_t size);
  ::std::string* mutable_customer_id();
  ::std::string* release_customer_id();
  void set_allocated_customer_id(::std::string* customer_id);

  // required string log = 4;
  bool has_log() const;
  void clear_log();
  static const int kLogFieldNumber = 4;
  const ::std::string& log() const;
  void set_log(const ::std::string& value);
  void set_log(const char* value);
  void set_log(const char* value, size_t size);
  ::std::string* mutable_log();
  ::std::string* release_log();
  void set_allocated_log(::std::string* log);

  // @@protoc_insertion_point(class_scope:draiosproto.dirty_shutdown_report)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();
  inline void set_has_log();
  inline void clear_has_log();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr machine_id_;
  ::google::protobuf::internal::ArenaStringPtr customer_id_;
  ::google::protobuf::internal::ArenaStringPtr log_;
  ::google::protobuf::uint64 timestamp_ns_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<dirty_shutdown_report> dirty_shutdown_report_default_instance_;

// -------------------------------------------------------------------

class key_value : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.key_value) */ {
 public:
  key_value();
  virtual ~key_value();

  key_value(const key_value& from);

  inline key_value& operator=(const key_value& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const key_value& default_instance();

  static const key_value* internal_default_instance();

  void Swap(key_value* other);

  // implements Message ----------------------------------------------

  inline key_value* New() const { return New(NULL); }

  key_value* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const key_value& from);
  void MergeFrom(const key_value& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(key_value* other);
  void UnsafeMergeFrom(const key_value& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:draiosproto.key_value)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<key_value> key_value_default_instance_;

// -------------------------------------------------------------------

class agent_event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.agent_event) */ {
 public:
  agent_event();
  virtual ~agent_event();

  agent_event(const agent_event& from);

  inline agent_event& operator=(const agent_event& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const agent_event& default_instance();

  static const agent_event* internal_default_instance();

  void Swap(agent_event* other);

  // implements Message ----------------------------------------------

  inline agent_event* New() const { return New(NULL); }

  agent_event* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const agent_event& from);
  void MergeFrom(const agent_event& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(agent_event* other);
  void UnsafeMergeFrom(const agent_event& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 timestamp_sec = 1;
  bool has_timestamp_sec() const;
  void clear_timestamp_sec();
  static const int kTimestampSecFieldNumber = 1;
  ::google::protobuf::uint64 timestamp_sec() const;
  void set_timestamp_sec(::google::protobuf::uint64 value);

  // optional string scope = 2;
  bool has_scope() const;
  void clear_scope();
  static const int kScopeFieldNumber = 2;
  const ::std::string& scope() const;
  void set_scope(const ::std::string& value);
  void set_scope(const char* value);
  void set_scope(const char* value, size_t size);
  ::std::string* mutable_scope();
  ::std::string* release_scope();
  void set_allocated_scope(::std::string* scope);

  // optional string title = 3;
  bool has_title() const;
  void clear_title();
  static const int kTitleFieldNumber = 3;
  const ::std::string& title() const;
  void set_title(const ::std::string& value);
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  ::std::string* mutable_title();
  ::std::string* release_title();
  void set_allocated_title(::std::string* title);

  // optional string description = 4;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 4;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional uint32 severity = 5;
  bool has_severity() const;
  void clear_severity();
  static const int kSeverityFieldNumber = 5;
  ::google::protobuf::uint32 severity() const;
  void set_severity(::google::protobuf::uint32 value);

  // repeated .draiosproto.key_value tags = 6;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 6;
  const ::draiosproto::key_value& tags(int index) const;
  ::draiosproto::key_value* mutable_tags(int index);
  ::draiosproto::key_value* add_tags();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::key_value >*
      mutable_tags();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::key_value >&
      tags() const;

  // @@protoc_insertion_point(class_scope:draiosproto.agent_event)
 private:
  inline void set_has_timestamp_sec();
  inline void clear_has_timestamp_sec();
  inline void set_has_scope();
  inline void clear_has_scope();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_severity();
  inline void clear_has_severity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::key_value > tags_;
  ::google::protobuf::internal::ArenaStringPtr scope_;
  ::google::protobuf::internal::ArenaStringPtr title_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::uint64 timestamp_sec_;
  ::google::protobuf::uint32 severity_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<agent_event> agent_event_default_instance_;

// -------------------------------------------------------------------

class config_file : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.config_file) */ {
 public:
  config_file();
  virtual ~config_file();

  config_file(const config_file& from);

  inline config_file& operator=(const config_file& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const config_file& default_instance();

  static const config_file* internal_default_instance();

  void Swap(config_file* other);

  // implements Message ----------------------------------------------

  inline config_file* New() const { return New(NULL); }

  config_file* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const config_file& from);
  void MergeFrom(const config_file& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(config_file* other);
  void UnsafeMergeFrom(const config_file& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string content = 2;
  bool has_content() const;
  void clear_content();
  static const int kContentFieldNumber = 2;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:draiosproto.config_file)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<config_file> config_file_default_instance_;

// -------------------------------------------------------------------

class config_data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.config_data) */ {
 public:
  config_data();
  virtual ~config_data();

  config_data(const config_data& from);

  inline config_data& operator=(const config_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const config_data& default_instance();

  static const config_data* internal_default_instance();

  void Swap(config_data* other);

  // implements Message ----------------------------------------------

  inline config_data* New() const { return New(NULL); }

  config_data* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const config_data& from);
  void MergeFrom(const config_data& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(config_data* other);
  void UnsafeMergeFrom(const config_data& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .draiosproto.config_file config_files = 1;
  int config_files_size() const;
  void clear_config_files();
  static const int kConfigFilesFieldNumber = 1;
  const ::draiosproto::config_file& config_files(int index) const;
  ::draiosproto::config_file* mutable_config_files(int index);
  ::draiosproto::config_file* add_config_files();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::config_file >*
      mutable_config_files();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::config_file >&
      config_files() const;

  // @@protoc_insertion_point(class_scope:draiosproto.config_data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::config_file > config_files_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<config_data> config_data_default_instance_;

// -------------------------------------------------------------------

class error_message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.error_message) */ {
 public:
  error_message();
  virtual ~error_message();

  error_message(const error_message& from);

  inline error_message& operator=(const error_message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const error_message& default_instance();

  static const error_message* internal_default_instance();

  void Swap(error_message* other);

  // implements Message ----------------------------------------------

  inline error_message* New() const { return New(NULL); }

  error_message* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const error_message& from);
  void MergeFrom(const error_message& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(error_message* other);
  void UnsafeMergeFrom(const error_message& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .draiosproto.error_type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::draiosproto::error_type type() const;
  void set_type(::draiosproto::error_type value);

  // optional string description = 2;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 2;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // @@protoc_insertion_point(class_scope:draiosproto.error_message)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_description();
  inline void clear_has_description();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  int type_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<error_message> error_message_default_instance_;

// -------------------------------------------------------------------

class falco_subcategory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.falco_subcategory) */ {
 public:
  falco_subcategory();
  virtual ~falco_subcategory();

  falco_subcategory(const falco_subcategory& from);

  inline falco_subcategory& operator=(const falco_subcategory& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const falco_subcategory& default_instance();

  static const falco_subcategory* internal_default_instance();

  void Swap(falco_subcategory* other);

  // implements Message ----------------------------------------------

  inline falco_subcategory* New() const { return New(NULL); }

  falco_subcategory* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const falco_subcategory& from);
  void MergeFrom(const falco_subcategory& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(falco_subcategory* other);
  void UnsafeMergeFrom(const falco_subcategory& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated string d = 2;
  int d_size() const;
  void clear_d();
  static const int kDFieldNumber = 2;
  const ::std::string& d(int index) const;
  ::std::string* mutable_d(int index);
  void set_d(int index, const ::std::string& value);
  void set_d(int index, const char* value);
  void set_d(int index, const char* value, size_t size);
  ::std::string* add_d();
  void add_d(const ::std::string& value);
  void add_d(const char* value);
  void add_d(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& d() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_d();

  // optional bool full = 3;
  bool has_full() const;
  void clear_full();
  static const int kFullFieldNumber = 3;
  bool full() const;
  void set_full(bool value);

  // @@protoc_insertion_point(class_scope:draiosproto.falco_subcategory)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_full();
  inline void clear_has_full();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> d_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool full_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<falco_subcategory> falco_subcategory_default_instance_;

// -------------------------------------------------------------------

class falco_subcategory_container : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.falco_subcategory_container) */ {
 public:
  falco_subcategory_container();
  virtual ~falco_subcategory_container();

  falco_subcategory_container(const falco_subcategory_container& from);

  inline falco_subcategory_container& operator=(const falco_subcategory_container& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const falco_subcategory_container& default_instance();

  static const falco_subcategory_container* internal_default_instance();

  void Swap(falco_subcategory_container* other);

  // implements Message ----------------------------------------------

  inline falco_subcategory_container* New() const { return New(NULL); }

  falco_subcategory_container* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const falco_subcategory_container& from);
  void MergeFrom(const falco_subcategory_container& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(falco_subcategory_container* other);
  void UnsafeMergeFrom(const falco_subcategory_container& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .draiosproto.falco_subcategory subcats = 1;
  int subcats_size() const;
  void clear_subcats();
  static const int kSubcatsFieldNumber = 1;
  const ::draiosproto::falco_subcategory& subcats(int index) const;
  ::draiosproto::falco_subcategory* mutable_subcats(int index);
  ::draiosproto::falco_subcategory* add_subcats();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_subcategory >*
      mutable_subcats();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_subcategory >&
      subcats() const;

  // @@protoc_insertion_point(class_scope:draiosproto.falco_subcategory_container)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_subcategory > subcats_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<falco_subcategory_container> falco_subcategory_container_default_instance_;

// -------------------------------------------------------------------

class falco_category : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.falco_category) */ {
 public:
  falco_category();
  virtual ~falco_category();

  falco_category(const falco_category& from);

  inline falco_category& operator=(const falco_category& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const falco_category& default_instance();

  static const falco_category* internal_default_instance();

  void Swap(falco_category* other);

  // implements Message ----------------------------------------------

  inline falco_category* New() const { return New(NULL); }

  falco_category* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const falco_category& from);
  void MergeFrom(const falco_category& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(falco_category* other);
  void UnsafeMergeFrom(const falco_category& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .draiosproto.falco_subcategory_container startup_subcats = 2;
  int startup_subcats_size() const;
  void clear_startup_subcats();
  static const int kStartupSubcatsFieldNumber = 2;
  const ::draiosproto::falco_subcategory_container& startup_subcats(int index) const;
  ::draiosproto::falco_subcategory_container* mutable_startup_subcats(int index);
  ::draiosproto::falco_subcategory_container* add_startup_subcats();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_subcategory_container >*
      mutable_startup_subcats();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_subcategory_container >&
      startup_subcats() const;

  // repeated .draiosproto.falco_subcategory_container regular_subcats = 3;
  int regular_subcats_size() const;
  void clear_regular_subcats();
  static const int kRegularSubcatsFieldNumber = 3;
  const ::draiosproto::falco_subcategory_container& regular_subcats(int index) const;
  ::draiosproto::falco_subcategory_container* mutable_regular_subcats(int index);
  ::draiosproto::falco_subcategory_container* add_regular_subcats();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_subcategory_container >*
      mutable_regular_subcats();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_subcategory_container >&
      regular_subcats() const;

  // @@protoc_insertion_point(class_scope:draiosproto.falco_category)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_subcategory_container > startup_subcats_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_subcategory_container > regular_subcats_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<falco_category> falco_category_default_instance_;

// -------------------------------------------------------------------

class falco_prog : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.falco_prog) */ {
 public:
  falco_prog();
  virtual ~falco_prog();

  falco_prog(const falco_prog& from);

  inline falco_prog& operator=(const falco_prog& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const falco_prog& default_instance();

  static const falco_prog* internal_default_instance();

  void Swap(falco_prog* other);

  // implements Message ----------------------------------------------

  inline falco_prog* New() const { return New(NULL); }

  falco_prog* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const falco_prog& from);
  void MergeFrom(const falco_prog& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(falco_prog* other);
  void UnsafeMergeFrom(const falco_prog& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string comm = 1;
  bool has_comm() const;
  void clear_comm();
  static const int kCommFieldNumber = 1;
  const ::std::string& comm() const;
  void set_comm(const ::std::string& value);
  void set_comm(const char* value);
  void set_comm(const char* value, size_t size);
  ::std::string* mutable_comm();
  ::std::string* release_comm();
  void set_allocated_comm(::std::string* comm);

  // required string exe = 2;
  bool has_exe() const;
  void clear_exe();
  static const int kExeFieldNumber = 2;
  const ::std::string& exe() const;
  void set_exe(const ::std::string& value);
  void set_exe(const char* value);
  void set_exe(const char* value, size_t size);
  ::std::string* mutable_exe();
  ::std::string* release_exe();
  void set_allocated_exe(::std::string* exe);

  // repeated string args = 3;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 3;
  const ::std::string& args(int index) const;
  ::std::string* mutable_args(int index);
  void set_args(int index, const ::std::string& value);
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, size_t size);
  ::std::string* add_args();
  void add_args(const ::std::string& value);
  void add_args(const char* value);
  void add_args(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& args() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_args();

  // required uint64 user_id = 4;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 4;
  ::google::protobuf::uint64 user_id() const;
  void set_user_id(::google::protobuf::uint64 value);

  // optional string container_id = 5;
  bool has_container_id() const;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 5;
  const ::std::string& container_id() const;
  void set_container_id(const ::std::string& value);
  void set_container_id(const char* value);
  void set_container_id(const char* value, size_t size);
  ::std::string* mutable_container_id();
  ::std::string* release_container_id();
  void set_allocated_container_id(::std::string* container_id);

  // repeated .draiosproto.falco_category cats = 6;
  int cats_size() const;
  void clear_cats();
  static const int kCatsFieldNumber = 6;
  const ::draiosproto::falco_category& cats(int index) const;
  ::draiosproto::falco_category* mutable_cats(int index);
  ::draiosproto::falco_category* add_cats();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_category >*
      mutable_cats();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_category >&
      cats() const;

  // @@protoc_insertion_point(class_scope:draiosproto.falco_prog)
 private:
  inline void set_has_comm();
  inline void clear_has_comm();
  inline void set_has_exe();
  inline void clear_has_exe();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_container_id();
  inline void clear_has_container_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> args_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_category > cats_;
  ::google::protobuf::internal::ArenaStringPtr comm_;
  ::google::protobuf::internal::ArenaStringPtr exe_;
  ::google::protobuf::internal::ArenaStringPtr container_id_;
  ::google::protobuf::uint64 user_id_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<falco_prog> falco_prog_default_instance_;

// -------------------------------------------------------------------

class falco_container : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.falco_container) */ {
 public:
  falco_container();
  virtual ~falco_container();

  falco_container(const falco_container& from);

  inline falco_container& operator=(const falco_container& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const falco_container& default_instance();

  static const falco_container* internal_default_instance();

  void Swap(falco_container* other);

  // implements Message ----------------------------------------------

  inline falco_container* New() const { return New(NULL); }

  falco_container* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const falco_container& from);
  void MergeFrom(const falco_container& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(falco_container* other);
  void UnsafeMergeFrom(const falco_container& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string image_name = 3;
  bool has_image_name() const;
  void clear_image_name();
  static const int kImageNameFieldNumber = 3;
  const ::std::string& image_name() const;
  void set_image_name(const ::std::string& value);
  void set_image_name(const char* value);
  void set_image_name(const char* value, size_t size);
  ::std::string* mutable_image_name();
  ::std::string* release_image_name();
  void set_allocated_image_name(::std::string* image_name);

  // optional string image_id = 4;
  bool has_image_id() const;
  void clear_image_id();
  static const int kImageIdFieldNumber = 4;
  const ::std::string& image_id() const;
  void set_image_id(const ::std::string& value);
  void set_image_id(const char* value);
  void set_image_id(const char* value, size_t size);
  ::std::string* mutable_image_id();
  ::std::string* release_image_id();
  void set_allocated_image_id(::std::string* image_id);

  // @@protoc_insertion_point(class_scope:draiosproto.falco_container)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_image_name();
  inline void clear_has_image_name();
  inline void set_has_image_id();
  inline void clear_has_image_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr image_name_;
  ::google::protobuf::internal::ArenaStringPtr image_id_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<falco_container> falco_container_default_instance_;

// -------------------------------------------------------------------

class falco_baseline : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:draiosproto.falco_baseline) */ {
 public:
  falco_baseline();
  virtual ~falco_baseline();

  falco_baseline(const falco_baseline& from);

  inline falco_baseline& operator=(const falco_baseline& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const falco_baseline& default_instance();

  static const falco_baseline* internal_default_instance();

  void Swap(falco_baseline* other);

  // implements Message ----------------------------------------------

  inline falco_baseline* New() const { return New(NULL); }

  falco_baseline* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const falco_baseline& from);
  void MergeFrom(const falco_baseline& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(falco_baseline* other);
  void UnsafeMergeFrom(const falco_baseline& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .draiosproto.falco_prog progs = 1;
  int progs_size() const;
  void clear_progs();
  static const int kProgsFieldNumber = 1;
  const ::draiosproto::falco_prog& progs(int index) const;
  ::draiosproto::falco_prog* mutable_progs(int index);
  ::draiosproto::falco_prog* add_progs();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_prog >*
      mutable_progs();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_prog >&
      progs() const;

  // repeated .draiosproto.falco_container containers = 2;
  int containers_size() const;
  void clear_containers();
  static const int kContainersFieldNumber = 2;
  const ::draiosproto::falco_container& containers(int index) const;
  ::draiosproto::falco_container* mutable_containers(int index);
  ::draiosproto::falco_container* add_containers();
  ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_container >*
      mutable_containers();
  const ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_container >&
      containers() const;

  // @@protoc_insertion_point(class_scope:draiosproto.falco_baseline)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_prog > progs_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_container > containers_;
  friend void  protobuf_InitDefaults_draios_2eproto_impl();
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<falco_baseline> falco_baseline_default_instance_;

// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// counter_time

// required uint32 count = 1;
inline bool counter_time::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void counter_time::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void counter_time::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void counter_time::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 counter_time::count() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_time.count)
  return count_;
}
inline void counter_time::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_time.count)
}

// required uint64 time_ns = 2;
inline bool counter_time::has_time_ns() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void counter_time::set_has_time_ns() {
  _has_bits_[0] |= 0x00000002u;
}
inline void counter_time::clear_has_time_ns() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void counter_time::clear_time_ns() {
  time_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_time_ns();
}
inline ::google::protobuf::uint64 counter_time::time_ns() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_time.time_ns)
  return time_ns_;
}
inline void counter_time::set_time_ns(::google::protobuf::uint64 value) {
  set_has_time_ns();
  time_ns_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_time.time_ns)
}

// optional uint32 time_percentage = 3;
inline bool counter_time::has_time_percentage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void counter_time::set_has_time_percentage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void counter_time::clear_has_time_percentage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void counter_time::clear_time_percentage() {
  time_percentage_ = 0u;
  clear_has_time_percentage();
}
inline ::google::protobuf::uint32 counter_time::time_percentage() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_time.time_percentage)
  return time_percentage_;
}
inline void counter_time::set_time_percentage(::google::protobuf::uint32 value) {
  set_has_time_percentage();
  time_percentage_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_time.time_percentage)
}

inline const counter_time* counter_time::internal_default_instance() {
  return &counter_time_default_instance_.get();
}
// -------------------------------------------------------------------

// counter_time_bidirectional

// required uint32 count_in = 1;
inline bool counter_time_bidirectional::has_count_in() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void counter_time_bidirectional::set_has_count_in() {
  _has_bits_[0] |= 0x00000001u;
}
inline void counter_time_bidirectional::clear_has_count_in() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void counter_time_bidirectional::clear_count_in() {
  count_in_ = 0u;
  clear_has_count_in();
}
inline ::google::protobuf::uint32 counter_time_bidirectional::count_in() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_time_bidirectional.count_in)
  return count_in_;
}
inline void counter_time_bidirectional::set_count_in(::google::protobuf::uint32 value) {
  set_has_count_in();
  count_in_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_time_bidirectional.count_in)
}

// required uint32 count_out = 2;
inline bool counter_time_bidirectional::has_count_out() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void counter_time_bidirectional::set_has_count_out() {
  _has_bits_[0] |= 0x00000002u;
}
inline void counter_time_bidirectional::clear_has_count_out() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void counter_time_bidirectional::clear_count_out() {
  count_out_ = 0u;
  clear_has_count_out();
}
inline ::google::protobuf::uint32 counter_time_bidirectional::count_out() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_time_bidirectional.count_out)
  return count_out_;
}
inline void counter_time_bidirectional::set_count_out(::google::protobuf::uint32 value) {
  set_has_count_out();
  count_out_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_time_bidirectional.count_out)
}

// required uint64 time_ns_in = 3;
inline bool counter_time_bidirectional::has_time_ns_in() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void counter_time_bidirectional::set_has_time_ns_in() {
  _has_bits_[0] |= 0x00000004u;
}
inline void counter_time_bidirectional::clear_has_time_ns_in() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void counter_time_bidirectional::clear_time_ns_in() {
  time_ns_in_ = GOOGLE_ULONGLONG(0);
  clear_has_time_ns_in();
}
inline ::google::protobuf::uint64 counter_time_bidirectional::time_ns_in() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_time_bidirectional.time_ns_in)
  return time_ns_in_;
}
inline void counter_time_bidirectional::set_time_ns_in(::google::protobuf::uint64 value) {
  set_has_time_ns_in();
  time_ns_in_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_time_bidirectional.time_ns_in)
}

// required uint64 time_ns_out = 4;
inline bool counter_time_bidirectional::has_time_ns_out() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void counter_time_bidirectional::set_has_time_ns_out() {
  _has_bits_[0] |= 0x00000008u;
}
inline void counter_time_bidirectional::clear_has_time_ns_out() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void counter_time_bidirectional::clear_time_ns_out() {
  time_ns_out_ = GOOGLE_ULONGLONG(0);
  clear_has_time_ns_out();
}
inline ::google::protobuf::uint64 counter_time_bidirectional::time_ns_out() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_time_bidirectional.time_ns_out)
  return time_ns_out_;
}
inline void counter_time_bidirectional::set_time_ns_out(::google::protobuf::uint64 value) {
  set_has_time_ns_out();
  time_ns_out_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_time_bidirectional.time_ns_out)
}

inline const counter_time_bidirectional* counter_time_bidirectional::internal_default_instance() {
  return &counter_time_bidirectional_default_instance_.get();
}
// -------------------------------------------------------------------

// counter_bytes

// required uint32 count_in = 1;
inline bool counter_bytes::has_count_in() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void counter_bytes::set_has_count_in() {
  _has_bits_[0] |= 0x00000001u;
}
inline void counter_bytes::clear_has_count_in() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void counter_bytes::clear_count_in() {
  count_in_ = 0u;
  clear_has_count_in();
}
inline ::google::protobuf::uint32 counter_bytes::count_in() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_bytes.count_in)
  return count_in_;
}
inline void counter_bytes::set_count_in(::google::protobuf::uint32 value) {
  set_has_count_in();
  count_in_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_bytes.count_in)
}

// required uint32 count_out = 2;
inline bool counter_bytes::has_count_out() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void counter_bytes::set_has_count_out() {
  _has_bits_[0] |= 0x00000002u;
}
inline void counter_bytes::clear_has_count_out() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void counter_bytes::clear_count_out() {
  count_out_ = 0u;
  clear_has_count_out();
}
inline ::google::protobuf::uint32 counter_bytes::count_out() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_bytes.count_out)
  return count_out_;
}
inline void counter_bytes::set_count_out(::google::protobuf::uint32 value) {
  set_has_count_out();
  count_out_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_bytes.count_out)
}

// required uint32 bytes_in = 3;
inline bool counter_bytes::has_bytes_in() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void counter_bytes::set_has_bytes_in() {
  _has_bits_[0] |= 0x00000004u;
}
inline void counter_bytes::clear_has_bytes_in() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void counter_bytes::clear_bytes_in() {
  bytes_in_ = 0u;
  clear_has_bytes_in();
}
inline ::google::protobuf::uint32 counter_bytes::bytes_in() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_bytes.bytes_in)
  return bytes_in_;
}
inline void counter_bytes::set_bytes_in(::google::protobuf::uint32 value) {
  set_has_bytes_in();
  bytes_in_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_bytes.bytes_in)
}

// required uint32 bytes_out = 4;
inline bool counter_bytes::has_bytes_out() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void counter_bytes::set_has_bytes_out() {
  _has_bits_[0] |= 0x00000008u;
}
inline void counter_bytes::clear_has_bytes_out() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void counter_bytes::clear_bytes_out() {
  bytes_out_ = 0u;
  clear_has_bytes_out();
}
inline ::google::protobuf::uint32 counter_bytes::bytes_out() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_bytes.bytes_out)
  return bytes_out_;
}
inline void counter_bytes::set_bytes_out(::google::protobuf::uint32 value) {
  set_has_bytes_out();
  bytes_out_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_bytes.bytes_out)
}

inline const counter_bytes* counter_bytes::internal_default_instance() {
  return &counter_bytes_default_instance_.get();
}
// -------------------------------------------------------------------

// counter_time_bytes

// required uint64 time_ns_in = 1;
inline bool counter_time_bytes::has_time_ns_in() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void counter_time_bytes::set_has_time_ns_in() {
  _has_bits_[0] |= 0x00000001u;
}
inline void counter_time_bytes::clear_has_time_ns_in() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void counter_time_bytes::clear_time_ns_in() {
  time_ns_in_ = GOOGLE_ULONGLONG(0);
  clear_has_time_ns_in();
}
inline ::google::protobuf::uint64 counter_time_bytes::time_ns_in() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_time_bytes.time_ns_in)
  return time_ns_in_;
}
inline void counter_time_bytes::set_time_ns_in(::google::protobuf::uint64 value) {
  set_has_time_ns_in();
  time_ns_in_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_time_bytes.time_ns_in)
}

// required uint64 time_ns_out = 2;
inline bool counter_time_bytes::has_time_ns_out() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void counter_time_bytes::set_has_time_ns_out() {
  _has_bits_[0] |= 0x00000002u;
}
inline void counter_time_bytes::clear_has_time_ns_out() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void counter_time_bytes::clear_time_ns_out() {
  time_ns_out_ = GOOGLE_ULONGLONG(0);
  clear_has_time_ns_out();
}
inline ::google::protobuf::uint64 counter_time_bytes::time_ns_out() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_time_bytes.time_ns_out)
  return time_ns_out_;
}
inline void counter_time_bytes::set_time_ns_out(::google::protobuf::uint64 value) {
  set_has_time_ns_out();
  time_ns_out_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_time_bytes.time_ns_out)
}

// required uint64 time_ns_other = 3;
inline bool counter_time_bytes::has_time_ns_other() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void counter_time_bytes::set_has_time_ns_other() {
  _has_bits_[0] |= 0x00000004u;
}
inline void counter_time_bytes::clear_has_time_ns_other() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void counter_time_bytes::clear_time_ns_other() {
  time_ns_other_ = GOOGLE_ULONGLONG(0);
  clear_has_time_ns_other();
}
inline ::google::protobuf::uint64 counter_time_bytes::time_ns_other() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_time_bytes.time_ns_other)
  return time_ns_other_;
}
inline void counter_time_bytes::set_time_ns_other(::google::protobuf::uint64 value) {
  set_has_time_ns_other();
  time_ns_other_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_time_bytes.time_ns_other)
}

// required uint32 count_in = 4;
inline bool counter_time_bytes::has_count_in() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void counter_time_bytes::set_has_count_in() {
  _has_bits_[0] |= 0x00000008u;
}
inline void counter_time_bytes::clear_has_count_in() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void counter_time_bytes::clear_count_in() {
  count_in_ = 0u;
  clear_has_count_in();
}
inline ::google::protobuf::uint32 counter_time_bytes::count_in() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_time_bytes.count_in)
  return count_in_;
}
inline void counter_time_bytes::set_count_in(::google::protobuf::uint32 value) {
  set_has_count_in();
  count_in_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_time_bytes.count_in)
}

// required uint32 count_out = 5;
inline bool counter_time_bytes::has_count_out() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void counter_time_bytes::set_has_count_out() {
  _has_bits_[0] |= 0x00000010u;
}
inline void counter_time_bytes::clear_has_count_out() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void counter_time_bytes::clear_count_out() {
  count_out_ = 0u;
  clear_has_count_out();
}
inline ::google::protobuf::uint32 counter_time_bytes::count_out() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_time_bytes.count_out)
  return count_out_;
}
inline void counter_time_bytes::set_count_out(::google::protobuf::uint32 value) {
  set_has_count_out();
  count_out_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_time_bytes.count_out)
}

// required uint32 count_other = 6;
inline bool counter_time_bytes::has_count_other() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void counter_time_bytes::set_has_count_other() {
  _has_bits_[0] |= 0x00000020u;
}
inline void counter_time_bytes::clear_has_count_other() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void counter_time_bytes::clear_count_other() {
  count_other_ = 0u;
  clear_has_count_other();
}
inline ::google::protobuf::uint32 counter_time_bytes::count_other() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_time_bytes.count_other)
  return count_other_;
}
inline void counter_time_bytes::set_count_other(::google::protobuf::uint32 value) {
  set_has_count_other();
  count_other_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_time_bytes.count_other)
}

// required uint32 bytes_in = 7;
inline bool counter_time_bytes::has_bytes_in() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void counter_time_bytes::set_has_bytes_in() {
  _has_bits_[0] |= 0x00000040u;
}
inline void counter_time_bytes::clear_has_bytes_in() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void counter_time_bytes::clear_bytes_in() {
  bytes_in_ = 0u;
  clear_has_bytes_in();
}
inline ::google::protobuf::uint32 counter_time_bytes::bytes_in() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_time_bytes.bytes_in)
  return bytes_in_;
}
inline void counter_time_bytes::set_bytes_in(::google::protobuf::uint32 value) {
  set_has_bytes_in();
  bytes_in_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_time_bytes.bytes_in)
}

// required uint32 bytes_out = 8;
inline bool counter_time_bytes::has_bytes_out() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void counter_time_bytes::set_has_bytes_out() {
  _has_bits_[0] |= 0x00000080u;
}
inline void counter_time_bytes::clear_has_bytes_out() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void counter_time_bytes::clear_bytes_out() {
  bytes_out_ = 0u;
  clear_has_bytes_out();
}
inline ::google::protobuf::uint32 counter_time_bytes::bytes_out() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_time_bytes.bytes_out)
  return bytes_out_;
}
inline void counter_time_bytes::set_bytes_out(::google::protobuf::uint32 value) {
  set_has_bytes_out();
  bytes_out_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_time_bytes.bytes_out)
}

// required uint32 bytes_other = 9;
inline bool counter_time_bytes::has_bytes_other() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void counter_time_bytes::set_has_bytes_other() {
  _has_bits_[0] |= 0x00000100u;
}
inline void counter_time_bytes::clear_has_bytes_other() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void counter_time_bytes::clear_bytes_other() {
  bytes_other_ = 0u;
  clear_has_bytes_other();
}
inline ::google::protobuf::uint32 counter_time_bytes::bytes_other() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_time_bytes.bytes_other)
  return bytes_other_;
}
inline void counter_time_bytes::set_bytes_other(::google::protobuf::uint32 value) {
  set_has_bytes_other();
  bytes_other_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_time_bytes.bytes_other)
}

// optional uint32 time_percentage_in = 10;
inline bool counter_time_bytes::has_time_percentage_in() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void counter_time_bytes::set_has_time_percentage_in() {
  _has_bits_[0] |= 0x00000200u;
}
inline void counter_time_bytes::clear_has_time_percentage_in() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void counter_time_bytes::clear_time_percentage_in() {
  time_percentage_in_ = 0u;
  clear_has_time_percentage_in();
}
inline ::google::protobuf::uint32 counter_time_bytes::time_percentage_in() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_time_bytes.time_percentage_in)
  return time_percentage_in_;
}
inline void counter_time_bytes::set_time_percentage_in(::google::protobuf::uint32 value) {
  set_has_time_percentage_in();
  time_percentage_in_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_time_bytes.time_percentage_in)
}

// optional uint32 time_percentage_out = 11;
inline bool counter_time_bytes::has_time_percentage_out() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void counter_time_bytes::set_has_time_percentage_out() {
  _has_bits_[0] |= 0x00000400u;
}
inline void counter_time_bytes::clear_has_time_percentage_out() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void counter_time_bytes::clear_time_percentage_out() {
  time_percentage_out_ = 0u;
  clear_has_time_percentage_out();
}
inline ::google::protobuf::uint32 counter_time_bytes::time_percentage_out() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_time_bytes.time_percentage_out)
  return time_percentage_out_;
}
inline void counter_time_bytes::set_time_percentage_out(::google::protobuf::uint32 value) {
  set_has_time_percentage_out();
  time_percentage_out_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_time_bytes.time_percentage_out)
}

// optional uint32 time_percentage_other = 12;
inline bool counter_time_bytes::has_time_percentage_other() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void counter_time_bytes::set_has_time_percentage_other() {
  _has_bits_[0] |= 0x00000800u;
}
inline void counter_time_bytes::clear_has_time_percentage_other() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void counter_time_bytes::clear_time_percentage_other() {
  time_percentage_other_ = 0u;
  clear_has_time_percentage_other();
}
inline ::google::protobuf::uint32 counter_time_bytes::time_percentage_other() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_time_bytes.time_percentage_other)
  return time_percentage_other_;
}
inline void counter_time_bytes::set_time_percentage_other(::google::protobuf::uint32 value) {
  set_has_time_percentage_other();
  time_percentage_other_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_time_bytes.time_percentage_other)
}

inline const counter_time_bytes* counter_time_bytes::internal_default_instance() {
  return &counter_time_bytes_default_instance_.get();
}
// -------------------------------------------------------------------

// time_categories

// optional .draiosproto.counter_time unknown = 1;
inline bool time_categories::has_unknown() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void time_categories::set_has_unknown() {
  _has_bits_[0] |= 0x00000001u;
}
inline void time_categories::clear_has_unknown() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void time_categories::clear_unknown() {
  if (unknown_ != NULL) unknown_->::draiosproto::counter_time::Clear();
  clear_has_unknown();
}
inline const ::draiosproto::counter_time& time_categories::unknown() const {
  // @@protoc_insertion_point(field_get:draiosproto.time_categories.unknown)
  return unknown_ != NULL ? *unknown_
                         : *::draiosproto::counter_time::internal_default_instance();
}
inline ::draiosproto::counter_time* time_categories::mutable_unknown() {
  set_has_unknown();
  if (unknown_ == NULL) {
    unknown_ = new ::draiosproto::counter_time;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.time_categories.unknown)
  return unknown_;
}
inline ::draiosproto::counter_time* time_categories::release_unknown() {
  // @@protoc_insertion_point(field_release:draiosproto.time_categories.unknown)
  clear_has_unknown();
  ::draiosproto::counter_time* temp = unknown_;
  unknown_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_unknown(::draiosproto::counter_time* unknown) {
  delete unknown_;
  unknown_ = unknown;
  if (unknown) {
    set_has_unknown();
  } else {
    clear_has_unknown();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.time_categories.unknown)
}

// optional .draiosproto.counter_time other = 2;
inline bool time_categories::has_other() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void time_categories::set_has_other() {
  _has_bits_[0] |= 0x00000002u;
}
inline void time_categories::clear_has_other() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void time_categories::clear_other() {
  if (other_ != NULL) other_->::draiosproto::counter_time::Clear();
  clear_has_other();
}
inline const ::draiosproto::counter_time& time_categories::other() const {
  // @@protoc_insertion_point(field_get:draiosproto.time_categories.other)
  return other_ != NULL ? *other_
                         : *::draiosproto::counter_time::internal_default_instance();
}
inline ::draiosproto::counter_time* time_categories::mutable_other() {
  set_has_other();
  if (other_ == NULL) {
    other_ = new ::draiosproto::counter_time;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.time_categories.other)
  return other_;
}
inline ::draiosproto::counter_time* time_categories::release_other() {
  // @@protoc_insertion_point(field_release:draiosproto.time_categories.other)
  clear_has_other();
  ::draiosproto::counter_time* temp = other_;
  other_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_other(::draiosproto::counter_time* other) {
  delete other_;
  other_ = other;
  if (other) {
    set_has_other();
  } else {
    clear_has_other();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.time_categories.other)
}

// optional .draiosproto.counter_time file = 3;
inline bool time_categories::has_file() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void time_categories::set_has_file() {
  _has_bits_[0] |= 0x00000004u;
}
inline void time_categories::clear_has_file() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void time_categories::clear_file() {
  if (file_ != NULL) file_->::draiosproto::counter_time::Clear();
  clear_has_file();
}
inline const ::draiosproto::counter_time& time_categories::file() const {
  // @@protoc_insertion_point(field_get:draiosproto.time_categories.file)
  return file_ != NULL ? *file_
                         : *::draiosproto::counter_time::internal_default_instance();
}
inline ::draiosproto::counter_time* time_categories::mutable_file() {
  set_has_file();
  if (file_ == NULL) {
    file_ = new ::draiosproto::counter_time;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.time_categories.file)
  return file_;
}
inline ::draiosproto::counter_time* time_categories::release_file() {
  // @@protoc_insertion_point(field_release:draiosproto.time_categories.file)
  clear_has_file();
  ::draiosproto::counter_time* temp = file_;
  file_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_file(::draiosproto::counter_time* file) {
  delete file_;
  file_ = file;
  if (file) {
    set_has_file();
  } else {
    clear_has_file();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.time_categories.file)
}

// optional .draiosproto.counter_time net = 4;
inline bool time_categories::has_net() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void time_categories::set_has_net() {
  _has_bits_[0] |= 0x00000008u;
}
inline void time_categories::clear_has_net() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void time_categories::clear_net() {
  if (net_ != NULL) net_->::draiosproto::counter_time::Clear();
  clear_has_net();
}
inline const ::draiosproto::counter_time& time_categories::net() const {
  // @@protoc_insertion_point(field_get:draiosproto.time_categories.net)
  return net_ != NULL ? *net_
                         : *::draiosproto::counter_time::internal_default_instance();
}
inline ::draiosproto::counter_time* time_categories::mutable_net() {
  set_has_net();
  if (net_ == NULL) {
    net_ = new ::draiosproto::counter_time;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.time_categories.net)
  return net_;
}
inline ::draiosproto::counter_time* time_categories::release_net() {
  // @@protoc_insertion_point(field_release:draiosproto.time_categories.net)
  clear_has_net();
  ::draiosproto::counter_time* temp = net_;
  net_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_net(::draiosproto::counter_time* net) {
  delete net_;
  net_ = net;
  if (net) {
    set_has_net();
  } else {
    clear_has_net();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.time_categories.net)
}

// optional .draiosproto.counter_time ipc = 5;
inline bool time_categories::has_ipc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void time_categories::set_has_ipc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void time_categories::clear_has_ipc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void time_categories::clear_ipc() {
  if (ipc_ != NULL) ipc_->::draiosproto::counter_time::Clear();
  clear_has_ipc();
}
inline const ::draiosproto::counter_time& time_categories::ipc() const {
  // @@protoc_insertion_point(field_get:draiosproto.time_categories.ipc)
  return ipc_ != NULL ? *ipc_
                         : *::draiosproto::counter_time::internal_default_instance();
}
inline ::draiosproto::counter_time* time_categories::mutable_ipc() {
  set_has_ipc();
  if (ipc_ == NULL) {
    ipc_ = new ::draiosproto::counter_time;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.time_categories.ipc)
  return ipc_;
}
inline ::draiosproto::counter_time* time_categories::release_ipc() {
  // @@protoc_insertion_point(field_release:draiosproto.time_categories.ipc)
  clear_has_ipc();
  ::draiosproto::counter_time* temp = ipc_;
  ipc_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_ipc(::draiosproto::counter_time* ipc) {
  delete ipc_;
  ipc_ = ipc;
  if (ipc) {
    set_has_ipc();
  } else {
    clear_has_ipc();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.time_categories.ipc)
}

// optional .draiosproto.counter_time memory = 6;
inline bool time_categories::has_memory() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void time_categories::set_has_memory() {
  _has_bits_[0] |= 0x00000020u;
}
inline void time_categories::clear_has_memory() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void time_categories::clear_memory() {
  if (memory_ != NULL) memory_->::draiosproto::counter_time::Clear();
  clear_has_memory();
}
inline const ::draiosproto::counter_time& time_categories::memory() const {
  // @@protoc_insertion_point(field_get:draiosproto.time_categories.memory)
  return memory_ != NULL ? *memory_
                         : *::draiosproto::counter_time::internal_default_instance();
}
inline ::draiosproto::counter_time* time_categories::mutable_memory() {
  set_has_memory();
  if (memory_ == NULL) {
    memory_ = new ::draiosproto::counter_time;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.time_categories.memory)
  return memory_;
}
inline ::draiosproto::counter_time* time_categories::release_memory() {
  // @@protoc_insertion_point(field_release:draiosproto.time_categories.memory)
  clear_has_memory();
  ::draiosproto::counter_time* temp = memory_;
  memory_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_memory(::draiosproto::counter_time* memory) {
  delete memory_;
  memory_ = memory;
  if (memory) {
    set_has_memory();
  } else {
    clear_has_memory();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.time_categories.memory)
}

// optional .draiosproto.counter_time process = 7;
inline bool time_categories::has_process() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void time_categories::set_has_process() {
  _has_bits_[0] |= 0x00000040u;
}
inline void time_categories::clear_has_process() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void time_categories::clear_process() {
  if (process_ != NULL) process_->::draiosproto::counter_time::Clear();
  clear_has_process();
}
inline const ::draiosproto::counter_time& time_categories::process() const {
  // @@protoc_insertion_point(field_get:draiosproto.time_categories.process)
  return process_ != NULL ? *process_
                         : *::draiosproto::counter_time::internal_default_instance();
}
inline ::draiosproto::counter_time* time_categories::mutable_process() {
  set_has_process();
  if (process_ == NULL) {
    process_ = new ::draiosproto::counter_time;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.time_categories.process)
  return process_;
}
inline ::draiosproto::counter_time* time_categories::release_process() {
  // @@protoc_insertion_point(field_release:draiosproto.time_categories.process)
  clear_has_process();
  ::draiosproto::counter_time* temp = process_;
  process_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_process(::draiosproto::counter_time* process) {
  delete process_;
  process_ = process;
  if (process) {
    set_has_process();
  } else {
    clear_has_process();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.time_categories.process)
}

// optional .draiosproto.counter_time sleep = 8;
inline bool time_categories::has_sleep() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void time_categories::set_has_sleep() {
  _has_bits_[0] |= 0x00000080u;
}
inline void time_categories::clear_has_sleep() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void time_categories::clear_sleep() {
  if (sleep_ != NULL) sleep_->::draiosproto::counter_time::Clear();
  clear_has_sleep();
}
inline const ::draiosproto::counter_time& time_categories::sleep() const {
  // @@protoc_insertion_point(field_get:draiosproto.time_categories.sleep)
  return sleep_ != NULL ? *sleep_
                         : *::draiosproto::counter_time::internal_default_instance();
}
inline ::draiosproto::counter_time* time_categories::mutable_sleep() {
  set_has_sleep();
  if (sleep_ == NULL) {
    sleep_ = new ::draiosproto::counter_time;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.time_categories.sleep)
  return sleep_;
}
inline ::draiosproto::counter_time* time_categories::release_sleep() {
  // @@protoc_insertion_point(field_release:draiosproto.time_categories.sleep)
  clear_has_sleep();
  ::draiosproto::counter_time* temp = sleep_;
  sleep_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_sleep(::draiosproto::counter_time* sleep) {
  delete sleep_;
  sleep_ = sleep;
  if (sleep) {
    set_has_sleep();
  } else {
    clear_has_sleep();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.time_categories.sleep)
}

// optional .draiosproto.counter_time system = 9;
inline bool time_categories::has_system() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void time_categories::set_has_system() {
  _has_bits_[0] |= 0x00000100u;
}
inline void time_categories::clear_has_system() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void time_categories::clear_system() {
  if (system_ != NULL) system_->::draiosproto::counter_time::Clear();
  clear_has_system();
}
inline const ::draiosproto::counter_time& time_categories::system() const {
  // @@protoc_insertion_point(field_get:draiosproto.time_categories.system)
  return system_ != NULL ? *system_
                         : *::draiosproto::counter_time::internal_default_instance();
}
inline ::draiosproto::counter_time* time_categories::mutable_system() {
  set_has_system();
  if (system_ == NULL) {
    system_ = new ::draiosproto::counter_time;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.time_categories.system)
  return system_;
}
inline ::draiosproto::counter_time* time_categories::release_system() {
  // @@protoc_insertion_point(field_release:draiosproto.time_categories.system)
  clear_has_system();
  ::draiosproto::counter_time* temp = system_;
  system_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_system(::draiosproto::counter_time* system) {
  delete system_;
  system_ = system;
  if (system) {
    set_has_system();
  } else {
    clear_has_system();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.time_categories.system)
}

// optional .draiosproto.counter_time signal = 10;
inline bool time_categories::has_signal() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void time_categories::set_has_signal() {
  _has_bits_[0] |= 0x00000200u;
}
inline void time_categories::clear_has_signal() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void time_categories::clear_signal() {
  if (signal_ != NULL) signal_->::draiosproto::counter_time::Clear();
  clear_has_signal();
}
inline const ::draiosproto::counter_time& time_categories::signal() const {
  // @@protoc_insertion_point(field_get:draiosproto.time_categories.signal)
  return signal_ != NULL ? *signal_
                         : *::draiosproto::counter_time::internal_default_instance();
}
inline ::draiosproto::counter_time* time_categories::mutable_signal() {
  set_has_signal();
  if (signal_ == NULL) {
    signal_ = new ::draiosproto::counter_time;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.time_categories.signal)
  return signal_;
}
inline ::draiosproto::counter_time* time_categories::release_signal() {
  // @@protoc_insertion_point(field_release:draiosproto.time_categories.signal)
  clear_has_signal();
  ::draiosproto::counter_time* temp = signal_;
  signal_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_signal(::draiosproto::counter_time* signal) {
  delete signal_;
  signal_ = signal;
  if (signal) {
    set_has_signal();
  } else {
    clear_has_signal();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.time_categories.signal)
}

// optional .draiosproto.counter_time user = 11;
inline bool time_categories::has_user() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void time_categories::set_has_user() {
  _has_bits_[0] |= 0x00000400u;
}
inline void time_categories::clear_has_user() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void time_categories::clear_user() {
  if (user_ != NULL) user_->::draiosproto::counter_time::Clear();
  clear_has_user();
}
inline const ::draiosproto::counter_time& time_categories::user() const {
  // @@protoc_insertion_point(field_get:draiosproto.time_categories.user)
  return user_ != NULL ? *user_
                         : *::draiosproto::counter_time::internal_default_instance();
}
inline ::draiosproto::counter_time* time_categories::mutable_user() {
  set_has_user();
  if (user_ == NULL) {
    user_ = new ::draiosproto::counter_time;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.time_categories.user)
  return user_;
}
inline ::draiosproto::counter_time* time_categories::release_user() {
  // @@protoc_insertion_point(field_release:draiosproto.time_categories.user)
  clear_has_user();
  ::draiosproto::counter_time* temp = user_;
  user_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_user(::draiosproto::counter_time* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.time_categories.user)
}

// optional .draiosproto.counter_time time = 12;
inline bool time_categories::has_time() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void time_categories::set_has_time() {
  _has_bits_[0] |= 0x00000800u;
}
inline void time_categories::clear_has_time() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void time_categories::clear_time() {
  if (time_ != NULL) time_->::draiosproto::counter_time::Clear();
  clear_has_time();
}
inline const ::draiosproto::counter_time& time_categories::time() const {
  // @@protoc_insertion_point(field_get:draiosproto.time_categories.time)
  return time_ != NULL ? *time_
                         : *::draiosproto::counter_time::internal_default_instance();
}
inline ::draiosproto::counter_time* time_categories::mutable_time() {
  set_has_time();
  if (time_ == NULL) {
    time_ = new ::draiosproto::counter_time;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.time_categories.time)
  return time_;
}
inline ::draiosproto::counter_time* time_categories::release_time() {
  // @@protoc_insertion_point(field_release:draiosproto.time_categories.time)
  clear_has_time();
  ::draiosproto::counter_time* temp = time_;
  time_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_time(::draiosproto::counter_time* time) {
  delete time_;
  time_ = time;
  if (time) {
    set_has_time();
  } else {
    clear_has_time();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.time_categories.time)
}

// optional .draiosproto.counter_time_bytes io_file = 13;
inline bool time_categories::has_io_file() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void time_categories::set_has_io_file() {
  _has_bits_[0] |= 0x00001000u;
}
inline void time_categories::clear_has_io_file() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void time_categories::clear_io_file() {
  if (io_file_ != NULL) io_file_->::draiosproto::counter_time_bytes::Clear();
  clear_has_io_file();
}
inline const ::draiosproto::counter_time_bytes& time_categories::io_file() const {
  // @@protoc_insertion_point(field_get:draiosproto.time_categories.io_file)
  return io_file_ != NULL ? *io_file_
                         : *::draiosproto::counter_time_bytes::internal_default_instance();
}
inline ::draiosproto::counter_time_bytes* time_categories::mutable_io_file() {
  set_has_io_file();
  if (io_file_ == NULL) {
    io_file_ = new ::draiosproto::counter_time_bytes;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.time_categories.io_file)
  return io_file_;
}
inline ::draiosproto::counter_time_bytes* time_categories::release_io_file() {
  // @@protoc_insertion_point(field_release:draiosproto.time_categories.io_file)
  clear_has_io_file();
  ::draiosproto::counter_time_bytes* temp = io_file_;
  io_file_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_io_file(::draiosproto::counter_time_bytes* io_file) {
  delete io_file_;
  io_file_ = io_file;
  if (io_file) {
    set_has_io_file();
  } else {
    clear_has_io_file();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.time_categories.io_file)
}

// optional .draiosproto.counter_time_bytes io_net = 14;
inline bool time_categories::has_io_net() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void time_categories::set_has_io_net() {
  _has_bits_[0] |= 0x00002000u;
}
inline void time_categories::clear_has_io_net() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void time_categories::clear_io_net() {
  if (io_net_ != NULL) io_net_->::draiosproto::counter_time_bytes::Clear();
  clear_has_io_net();
}
inline const ::draiosproto::counter_time_bytes& time_categories::io_net() const {
  // @@protoc_insertion_point(field_get:draiosproto.time_categories.io_net)
  return io_net_ != NULL ? *io_net_
                         : *::draiosproto::counter_time_bytes::internal_default_instance();
}
inline ::draiosproto::counter_time_bytes* time_categories::mutable_io_net() {
  set_has_io_net();
  if (io_net_ == NULL) {
    io_net_ = new ::draiosproto::counter_time_bytes;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.time_categories.io_net)
  return io_net_;
}
inline ::draiosproto::counter_time_bytes* time_categories::release_io_net() {
  // @@protoc_insertion_point(field_release:draiosproto.time_categories.io_net)
  clear_has_io_net();
  ::draiosproto::counter_time_bytes* temp = io_net_;
  io_net_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_io_net(::draiosproto::counter_time_bytes* io_net) {
  delete io_net_;
  io_net_ = io_net;
  if (io_net) {
    set_has_io_net();
  } else {
    clear_has_io_net();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.time_categories.io_net)
}

// optional .draiosproto.counter_time_bytes io_other = 15;
inline bool time_categories::has_io_other() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void time_categories::set_has_io_other() {
  _has_bits_[0] |= 0x00004000u;
}
inline void time_categories::clear_has_io_other() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void time_categories::clear_io_other() {
  if (io_other_ != NULL) io_other_->::draiosproto::counter_time_bytes::Clear();
  clear_has_io_other();
}
inline const ::draiosproto::counter_time_bytes& time_categories::io_other() const {
  // @@protoc_insertion_point(field_get:draiosproto.time_categories.io_other)
  return io_other_ != NULL ? *io_other_
                         : *::draiosproto::counter_time_bytes::internal_default_instance();
}
inline ::draiosproto::counter_time_bytes* time_categories::mutable_io_other() {
  set_has_io_other();
  if (io_other_ == NULL) {
    io_other_ = new ::draiosproto::counter_time_bytes;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.time_categories.io_other)
  return io_other_;
}
inline ::draiosproto::counter_time_bytes* time_categories::release_io_other() {
  // @@protoc_insertion_point(field_release:draiosproto.time_categories.io_other)
  clear_has_io_other();
  ::draiosproto::counter_time_bytes* temp = io_other_;
  io_other_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_io_other(::draiosproto::counter_time_bytes* io_other) {
  delete io_other_;
  io_other_ = io_other;
  if (io_other) {
    set_has_io_other();
  } else {
    clear_has_io_other();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.time_categories.io_other)
}

// optional .draiosproto.counter_time wait = 16;
inline bool time_categories::has_wait() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void time_categories::set_has_wait() {
  _has_bits_[0] |= 0x00008000u;
}
inline void time_categories::clear_has_wait() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void time_categories::clear_wait() {
  if (wait_ != NULL) wait_->::draiosproto::counter_time::Clear();
  clear_has_wait();
}
inline const ::draiosproto::counter_time& time_categories::wait() const {
  // @@protoc_insertion_point(field_get:draiosproto.time_categories.wait)
  return wait_ != NULL ? *wait_
                         : *::draiosproto::counter_time::internal_default_instance();
}
inline ::draiosproto::counter_time* time_categories::mutable_wait() {
  set_has_wait();
  if (wait_ == NULL) {
    wait_ = new ::draiosproto::counter_time;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.time_categories.wait)
  return wait_;
}
inline ::draiosproto::counter_time* time_categories::release_wait() {
  // @@protoc_insertion_point(field_release:draiosproto.time_categories.wait)
  clear_has_wait();
  ::draiosproto::counter_time* temp = wait_;
  wait_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_wait(::draiosproto::counter_time* wait) {
  delete wait_;
  wait_ = wait;
  if (wait) {
    set_has_wait();
  } else {
    clear_has_wait();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.time_categories.wait)
}

// optional .draiosproto.counter_time processing = 17;
inline bool time_categories::has_processing() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void time_categories::set_has_processing() {
  _has_bits_[0] |= 0x00010000u;
}
inline void time_categories::clear_has_processing() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void time_categories::clear_processing() {
  if (processing_ != NULL) processing_->::draiosproto::counter_time::Clear();
  clear_has_processing();
}
inline const ::draiosproto::counter_time& time_categories::processing() const {
  // @@protoc_insertion_point(field_get:draiosproto.time_categories.processing)
  return processing_ != NULL ? *processing_
                         : *::draiosproto::counter_time::internal_default_instance();
}
inline ::draiosproto::counter_time* time_categories::mutable_processing() {
  set_has_processing();
  if (processing_ == NULL) {
    processing_ = new ::draiosproto::counter_time;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.time_categories.processing)
  return processing_;
}
inline ::draiosproto::counter_time* time_categories::release_processing() {
  // @@protoc_insertion_point(field_release:draiosproto.time_categories.processing)
  clear_has_processing();
  ::draiosproto::counter_time* temp = processing_;
  processing_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_processing(::draiosproto::counter_time* processing) {
  delete processing_;
  processing_ = processing;
  if (processing) {
    set_has_processing();
  } else {
    clear_has_processing();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.time_categories.processing)
}

inline const time_categories* time_categories::internal_default_instance() {
  return &time_categories_default_instance_.get();
}
// -------------------------------------------------------------------

// transaction_breakdown_categories

// optional .draiosproto.counter_time other = 2;
inline bool transaction_breakdown_categories::has_other() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void transaction_breakdown_categories::set_has_other() {
  _has_bits_[0] |= 0x00000001u;
}
inline void transaction_breakdown_categories::clear_has_other() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void transaction_breakdown_categories::clear_other() {
  if (other_ != NULL) other_->::draiosproto::counter_time::Clear();
  clear_has_other();
}
inline const ::draiosproto::counter_time& transaction_breakdown_categories::other() const {
  // @@protoc_insertion_point(field_get:draiosproto.transaction_breakdown_categories.other)
  return other_ != NULL ? *other_
                         : *::draiosproto::counter_time::internal_default_instance();
}
inline ::draiosproto::counter_time* transaction_breakdown_categories::mutable_other() {
  set_has_other();
  if (other_ == NULL) {
    other_ = new ::draiosproto::counter_time;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.transaction_breakdown_categories.other)
  return other_;
}
inline ::draiosproto::counter_time* transaction_breakdown_categories::release_other() {
  // @@protoc_insertion_point(field_release:draiosproto.transaction_breakdown_categories.other)
  clear_has_other();
  ::draiosproto::counter_time* temp = other_;
  other_ = NULL;
  return temp;
}
inline void transaction_breakdown_categories::set_allocated_other(::draiosproto::counter_time* other) {
  delete other_;
  other_ = other;
  if (other) {
    set_has_other();
  } else {
    clear_has_other();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.transaction_breakdown_categories.other)
}

// optional .draiosproto.counter_time_bytes io_file = 13;
inline bool transaction_breakdown_categories::has_io_file() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void transaction_breakdown_categories::set_has_io_file() {
  _has_bits_[0] |= 0x00000002u;
}
inline void transaction_breakdown_categories::clear_has_io_file() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void transaction_breakdown_categories::clear_io_file() {
  if (io_file_ != NULL) io_file_->::draiosproto::counter_time_bytes::Clear();
  clear_has_io_file();
}
inline const ::draiosproto::counter_time_bytes& transaction_breakdown_categories::io_file() const {
  // @@protoc_insertion_point(field_get:draiosproto.transaction_breakdown_categories.io_file)
  return io_file_ != NULL ? *io_file_
                         : *::draiosproto::counter_time_bytes::internal_default_instance();
}
inline ::draiosproto::counter_time_bytes* transaction_breakdown_categories::mutable_io_file() {
  set_has_io_file();
  if (io_file_ == NULL) {
    io_file_ = new ::draiosproto::counter_time_bytes;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.transaction_breakdown_categories.io_file)
  return io_file_;
}
inline ::draiosproto::counter_time_bytes* transaction_breakdown_categories::release_io_file() {
  // @@protoc_insertion_point(field_release:draiosproto.transaction_breakdown_categories.io_file)
  clear_has_io_file();
  ::draiosproto::counter_time_bytes* temp = io_file_;
  io_file_ = NULL;
  return temp;
}
inline void transaction_breakdown_categories::set_allocated_io_file(::draiosproto::counter_time_bytes* io_file) {
  delete io_file_;
  io_file_ = io_file;
  if (io_file) {
    set_has_io_file();
  } else {
    clear_has_io_file();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.transaction_breakdown_categories.io_file)
}

// optional .draiosproto.counter_time_bytes io_net = 14;
inline bool transaction_breakdown_categories::has_io_net() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void transaction_breakdown_categories::set_has_io_net() {
  _has_bits_[0] |= 0x00000004u;
}
inline void transaction_breakdown_categories::clear_has_io_net() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void transaction_breakdown_categories::clear_io_net() {
  if (io_net_ != NULL) io_net_->::draiosproto::counter_time_bytes::Clear();
  clear_has_io_net();
}
inline const ::draiosproto::counter_time_bytes& transaction_breakdown_categories::io_net() const {
  // @@protoc_insertion_point(field_get:draiosproto.transaction_breakdown_categories.io_net)
  return io_net_ != NULL ? *io_net_
                         : *::draiosproto::counter_time_bytes::internal_default_instance();
}
inline ::draiosproto::counter_time_bytes* transaction_breakdown_categories::mutable_io_net() {
  set_has_io_net();
  if (io_net_ == NULL) {
    io_net_ = new ::draiosproto::counter_time_bytes;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.transaction_breakdown_categories.io_net)
  return io_net_;
}
inline ::draiosproto::counter_time_bytes* transaction_breakdown_categories::release_io_net() {
  // @@protoc_insertion_point(field_release:draiosproto.transaction_breakdown_categories.io_net)
  clear_has_io_net();
  ::draiosproto::counter_time_bytes* temp = io_net_;
  io_net_ = NULL;
  return temp;
}
inline void transaction_breakdown_categories::set_allocated_io_net(::draiosproto::counter_time_bytes* io_net) {
  delete io_net_;
  io_net_ = io_net;
  if (io_net) {
    set_has_io_net();
  } else {
    clear_has_io_net();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.transaction_breakdown_categories.io_net)
}

// optional .draiosproto.counter_time processing = 17;
inline bool transaction_breakdown_categories::has_processing() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void transaction_breakdown_categories::set_has_processing() {
  _has_bits_[0] |= 0x00000008u;
}
inline void transaction_breakdown_categories::clear_has_processing() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void transaction_breakdown_categories::clear_processing() {
  if (processing_ != NULL) processing_->::draiosproto::counter_time::Clear();
  clear_has_processing();
}
inline const ::draiosproto::counter_time& transaction_breakdown_categories::processing() const {
  // @@protoc_insertion_point(field_get:draiosproto.transaction_breakdown_categories.processing)
  return processing_ != NULL ? *processing_
                         : *::draiosproto::counter_time::internal_default_instance();
}
inline ::draiosproto::counter_time* transaction_breakdown_categories::mutable_processing() {
  set_has_processing();
  if (processing_ == NULL) {
    processing_ = new ::draiosproto::counter_time;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.transaction_breakdown_categories.processing)
  return processing_;
}
inline ::draiosproto::counter_time* transaction_breakdown_categories::release_processing() {
  // @@protoc_insertion_point(field_release:draiosproto.transaction_breakdown_categories.processing)
  clear_has_processing();
  ::draiosproto::counter_time* temp = processing_;
  processing_ = NULL;
  return temp;
}
inline void transaction_breakdown_categories::set_allocated_processing(::draiosproto::counter_time* processing) {
  delete processing_;
  processing_ = processing;
  if (processing) {
    set_has_processing();
  } else {
    clear_has_processing();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.transaction_breakdown_categories.processing)
}

inline const transaction_breakdown_categories* transaction_breakdown_categories::internal_default_instance() {
  return &transaction_breakdown_categories_default_instance_.get();
}
// -------------------------------------------------------------------

// counter_syscall_errors

// required uint32 count = 1;
inline bool counter_syscall_errors::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void counter_syscall_errors::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void counter_syscall_errors::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void counter_syscall_errors::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 counter_syscall_errors::count() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_syscall_errors.count)
  return count_;
}
inline void counter_syscall_errors::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_syscall_errors.count)
}

// repeated uint32 top_error_codes = 2;
inline int counter_syscall_errors::top_error_codes_size() const {
  return top_error_codes_.size();
}
inline void counter_syscall_errors::clear_top_error_codes() {
  top_error_codes_.Clear();
}
inline ::google::protobuf::uint32 counter_syscall_errors::top_error_codes(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_syscall_errors.top_error_codes)
  return top_error_codes_.Get(index);
}
inline void counter_syscall_errors::set_top_error_codes(int index, ::google::protobuf::uint32 value) {
  top_error_codes_.Set(index, value);
  // @@protoc_insertion_point(field_set:draiosproto.counter_syscall_errors.top_error_codes)
}
inline void counter_syscall_errors::add_top_error_codes(::google::protobuf::uint32 value) {
  top_error_codes_.Add(value);
  // @@protoc_insertion_point(field_add:draiosproto.counter_syscall_errors.top_error_codes)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
counter_syscall_errors::top_error_codes() const {
  // @@protoc_insertion_point(field_list:draiosproto.counter_syscall_errors.top_error_codes)
  return top_error_codes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
counter_syscall_errors::mutable_top_error_codes() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.counter_syscall_errors.top_error_codes)
  return &top_error_codes_;
}

// optional uint32 count_file = 4;
inline bool counter_syscall_errors::has_count_file() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void counter_syscall_errors::set_has_count_file() {
  _has_bits_[0] |= 0x00000004u;
}
inline void counter_syscall_errors::clear_has_count_file() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void counter_syscall_errors::clear_count_file() {
  count_file_ = 0u;
  clear_has_count_file();
}
inline ::google::protobuf::uint32 counter_syscall_errors::count_file() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_syscall_errors.count_file)
  return count_file_;
}
inline void counter_syscall_errors::set_count_file(::google::protobuf::uint32 value) {
  set_has_count_file();
  count_file_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_syscall_errors.count_file)
}

// optional uint32 count_file_open = 5;
inline bool counter_syscall_errors::has_count_file_open() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void counter_syscall_errors::set_has_count_file_open() {
  _has_bits_[0] |= 0x00000008u;
}
inline void counter_syscall_errors::clear_has_count_file_open() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void counter_syscall_errors::clear_count_file_open() {
  count_file_open_ = 0u;
  clear_has_count_file_open();
}
inline ::google::protobuf::uint32 counter_syscall_errors::count_file_open() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_syscall_errors.count_file_open)
  return count_file_open_;
}
inline void counter_syscall_errors::set_count_file_open(::google::protobuf::uint32 value) {
  set_has_count_file_open();
  count_file_open_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_syscall_errors.count_file_open)
}

// optional uint32 count_net = 6;
inline bool counter_syscall_errors::has_count_net() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void counter_syscall_errors::set_has_count_net() {
  _has_bits_[0] |= 0x00000010u;
}
inline void counter_syscall_errors::clear_has_count_net() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void counter_syscall_errors::clear_count_net() {
  count_net_ = 0u;
  clear_has_count_net();
}
inline ::google::protobuf::uint32 counter_syscall_errors::count_net() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_syscall_errors.count_net)
  return count_net_;
}
inline void counter_syscall_errors::set_count_net(::google::protobuf::uint32 value) {
  set_has_count_net();
  count_net_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_syscall_errors.count_net)
}

inline const counter_syscall_errors* counter_syscall_errors::internal_default_instance() {
  return &counter_syscall_errors_default_instance_.get();
}
// -------------------------------------------------------------------

// resource_categories

// optional uint32 capacity_score = 1;
inline bool resource_categories::has_capacity_score() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void resource_categories::set_has_capacity_score() {
  _has_bits_[0] |= 0x00000001u;
}
inline void resource_categories::clear_has_capacity_score() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void resource_categories::clear_capacity_score() {
  capacity_score_ = 0u;
  clear_has_capacity_score();
}
inline ::google::protobuf::uint32 resource_categories::capacity_score() const {
  // @@protoc_insertion_point(field_get:draiosproto.resource_categories.capacity_score)
  return capacity_score_;
}
inline void resource_categories::set_capacity_score(::google::protobuf::uint32 value) {
  set_has_capacity_score();
  capacity_score_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.resource_categories.capacity_score)
}

// optional uint32 stolen_capacity_score = 6;
inline bool resource_categories::has_stolen_capacity_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void resource_categories::set_has_stolen_capacity_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void resource_categories::clear_has_stolen_capacity_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void resource_categories::clear_stolen_capacity_score() {
  stolen_capacity_score_ = 0u;
  clear_has_stolen_capacity_score();
}
inline ::google::protobuf::uint32 resource_categories::stolen_capacity_score() const {
  // @@protoc_insertion_point(field_get:draiosproto.resource_categories.stolen_capacity_score)
  return stolen_capacity_score_;
}
inline void resource_categories::set_stolen_capacity_score(::google::protobuf::uint32 value) {
  set_has_stolen_capacity_score();
  stolen_capacity_score_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.resource_categories.stolen_capacity_score)
}

// optional uint32 connection_queue_usage_pct = 2;
inline bool resource_categories::has_connection_queue_usage_pct() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void resource_categories::set_has_connection_queue_usage_pct() {
  _has_bits_[0] |= 0x00000004u;
}
inline void resource_categories::clear_has_connection_queue_usage_pct() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void resource_categories::clear_connection_queue_usage_pct() {
  connection_queue_usage_pct_ = 0u;
  clear_has_connection_queue_usage_pct();
}
inline ::google::protobuf::uint32 resource_categories::connection_queue_usage_pct() const {
  // @@protoc_insertion_point(field_get:draiosproto.resource_categories.connection_queue_usage_pct)
  return connection_queue_usage_pct_;
}
inline void resource_categories::set_connection_queue_usage_pct(::google::protobuf::uint32 value) {
  set_has_connection_queue_usage_pct();
  connection_queue_usage_pct_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.resource_categories.connection_queue_usage_pct)
}

// optional uint32 fd_usage_pct = 3;
inline bool resource_categories::has_fd_usage_pct() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void resource_categories::set_has_fd_usage_pct() {
  _has_bits_[0] |= 0x00000008u;
}
inline void resource_categories::clear_has_fd_usage_pct() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void resource_categories::clear_fd_usage_pct() {
  fd_usage_pct_ = 0u;
  clear_has_fd_usage_pct();
}
inline ::google::protobuf::uint32 resource_categories::fd_usage_pct() const {
  // @@protoc_insertion_point(field_get:draiosproto.resource_categories.fd_usage_pct)
  return fd_usage_pct_;
}
inline void resource_categories::set_fd_usage_pct(::google::protobuf::uint32 value) {
  set_has_fd_usage_pct();
  fd_usage_pct_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.resource_categories.fd_usage_pct)
}

// optional uint32 cpu_pct = 4;
inline bool resource_categories::has_cpu_pct() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void resource_categories::set_has_cpu_pct() {
  _has_bits_[0] |= 0x00000010u;
}
inline void resource_categories::clear_has_cpu_pct() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void resource_categories::clear_cpu_pct() {
  cpu_pct_ = 0u;
  clear_has_cpu_pct();
}
inline ::google::protobuf::uint32 resource_categories::cpu_pct() const {
  // @@protoc_insertion_point(field_get:draiosproto.resource_categories.cpu_pct)
  return cpu_pct_;
}
inline void resource_categories::set_cpu_pct(::google::protobuf::uint32 value) {
  set_has_cpu_pct();
  cpu_pct_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.resource_categories.cpu_pct)
}

// optional uint32 resident_memory_usage_kb = 5;
inline bool resource_categories::has_resident_memory_usage_kb() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void resource_categories::set_has_resident_memory_usage_kb() {
  _has_bits_[0] |= 0x00000020u;
}
inline void resource_categories::clear_has_resident_memory_usage_kb() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void resource_categories::clear_resident_memory_usage_kb() {
  resident_memory_usage_kb_ = 0u;
  clear_has_resident_memory_usage_kb();
}
inline ::google::protobuf::uint32 resource_categories::resident_memory_usage_kb() const {
  // @@protoc_insertion_point(field_get:draiosproto.resource_categories.resident_memory_usage_kb)
  return resident_memory_usage_kb_;
}
inline void resource_categories::set_resident_memory_usage_kb(::google::protobuf::uint32 value) {
  set_has_resident_memory_usage_kb();
  resident_memory_usage_kb_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.resource_categories.resident_memory_usage_kb)
}

// optional uint32 virtual_memory_usage_kb = 13;
inline bool resource_categories::has_virtual_memory_usage_kb() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void resource_categories::set_has_virtual_memory_usage_kb() {
  _has_bits_[0] |= 0x00000040u;
}
inline void resource_categories::clear_has_virtual_memory_usage_kb() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void resource_categories::clear_virtual_memory_usage_kb() {
  virtual_memory_usage_kb_ = 0u;
  clear_has_virtual_memory_usage_kb();
}
inline ::google::protobuf::uint32 resource_categories::virtual_memory_usage_kb() const {
  // @@protoc_insertion_point(field_get:draiosproto.resource_categories.virtual_memory_usage_kb)
  return virtual_memory_usage_kb_;
}
inline void resource_categories::set_virtual_memory_usage_kb(::google::protobuf::uint32 value) {
  set_has_virtual_memory_usage_kb();
  virtual_memory_usage_kb_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.resource_categories.virtual_memory_usage_kb)
}

// optional uint32 swap_memory_usage_kb = 14;
inline bool resource_categories::has_swap_memory_usage_kb() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void resource_categories::set_has_swap_memory_usage_kb() {
  _has_bits_[0] |= 0x00000080u;
}
inline void resource_categories::clear_has_swap_memory_usage_kb() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void resource_categories::clear_swap_memory_usage_kb() {
  swap_memory_usage_kb_ = 0u;
  clear_has_swap_memory_usage_kb();
}
inline ::google::protobuf::uint32 resource_categories::swap_memory_usage_kb() const {
  // @@protoc_insertion_point(field_get:draiosproto.resource_categories.swap_memory_usage_kb)
  return swap_memory_usage_kb_;
}
inline void resource_categories::set_swap_memory_usage_kb(::google::protobuf::uint32 value) {
  set_has_swap_memory_usage_kb();
  swap_memory_usage_kb_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.resource_categories.swap_memory_usage_kb)
}

// optional uint64 major_pagefaults = 15;
inline bool resource_categories::has_major_pagefaults() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void resource_categories::set_has_major_pagefaults() {
  _has_bits_[0] |= 0x00000100u;
}
inline void resource_categories::clear_has_major_pagefaults() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void resource_categories::clear_major_pagefaults() {
  major_pagefaults_ = GOOGLE_ULONGLONG(0);
  clear_has_major_pagefaults();
}
inline ::google::protobuf::uint64 resource_categories::major_pagefaults() const {
  // @@protoc_insertion_point(field_get:draiosproto.resource_categories.major_pagefaults)
  return major_pagefaults_;
}
inline void resource_categories::set_major_pagefaults(::google::protobuf::uint64 value) {
  set_has_major_pagefaults();
  major_pagefaults_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.resource_categories.major_pagefaults)
}

// optional uint64 minor_pagefaults = 16;
inline bool resource_categories::has_minor_pagefaults() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void resource_categories::set_has_minor_pagefaults() {
  _has_bits_[0] |= 0x00000200u;
}
inline void resource_categories::clear_has_minor_pagefaults() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void resource_categories::clear_minor_pagefaults() {
  minor_pagefaults_ = GOOGLE_ULONGLONG(0);
  clear_has_minor_pagefaults();
}
inline ::google::protobuf::uint64 resource_categories::minor_pagefaults() const {
  // @@protoc_insertion_point(field_get:draiosproto.resource_categories.minor_pagefaults)
  return minor_pagefaults_;
}
inline void resource_categories::set_minor_pagefaults(::google::protobuf::uint64 value) {
  set_has_minor_pagefaults();
  minor_pagefaults_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.resource_categories.minor_pagefaults)
}

// optional uint32 fd_count = 21;
inline bool resource_categories::has_fd_count() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void resource_categories::set_has_fd_count() {
  _has_bits_[0] |= 0x00000400u;
}
inline void resource_categories::clear_has_fd_count() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void resource_categories::clear_fd_count() {
  fd_count_ = 0u;
  clear_has_fd_count();
}
inline ::google::protobuf::uint32 resource_categories::fd_count() const {
  // @@protoc_insertion_point(field_get:draiosproto.resource_categories.fd_count)
  return fd_count_;
}
inline void resource_categories::set_fd_count(::google::protobuf::uint32 value) {
  set_has_fd_count();
  fd_count_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.resource_categories.fd_count)
}

// optional uint32 cpu_shares = 24;
inline bool resource_categories::has_cpu_shares() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void resource_categories::set_has_cpu_shares() {
  _has_bits_[0] |= 0x00000800u;
}
inline void resource_categories::clear_has_cpu_shares() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void resource_categories::clear_cpu_shares() {
  cpu_shares_ = 0u;
  clear_has_cpu_shares();
}
inline ::google::protobuf::uint32 resource_categories::cpu_shares() const {
  // @@protoc_insertion_point(field_get:draiosproto.resource_categories.cpu_shares)
  return cpu_shares_;
}
inline void resource_categories::set_cpu_shares(::google::protobuf::uint32 value) {
  set_has_cpu_shares();
  cpu_shares_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.resource_categories.cpu_shares)
}

// optional uint32 cpu_shares_usage_pct = 25;
inline bool resource_categories::has_cpu_shares_usage_pct() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void resource_categories::set_has_cpu_shares_usage_pct() {
  _has_bits_[0] |= 0x00001000u;
}
inline void resource_categories::clear_has_cpu_shares_usage_pct() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void resource_categories::clear_cpu_shares_usage_pct() {
  cpu_shares_usage_pct_ = 0u;
  clear_has_cpu_shares_usage_pct();
}
inline ::google::protobuf::uint32 resource_categories::cpu_shares_usage_pct() const {
  // @@protoc_insertion_point(field_get:draiosproto.resource_categories.cpu_shares_usage_pct)
  return cpu_shares_usage_pct_;
}
inline void resource_categories::set_cpu_shares_usage_pct(::google::protobuf::uint32 value) {
  set_has_cpu_shares_usage_pct();
  cpu_shares_usage_pct_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.resource_categories.cpu_shares_usage_pct)
}

// optional uint32 memory_limit_kb = 26;
inline bool resource_categories::has_memory_limit_kb() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void resource_categories::set_has_memory_limit_kb() {
  _has_bits_[0] |= 0x00002000u;
}
inline void resource_categories::clear_has_memory_limit_kb() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void resource_categories::clear_memory_limit_kb() {
  memory_limit_kb_ = 0u;
  clear_has_memory_limit_kb();
}
inline ::google::protobuf::uint32 resource_categories::memory_limit_kb() const {
  // @@protoc_insertion_point(field_get:draiosproto.resource_categories.memory_limit_kb)
  return memory_limit_kb_;
}
inline void resource_categories::set_memory_limit_kb(::google::protobuf::uint32 value) {
  set_has_memory_limit_kb();
  memory_limit_kb_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.resource_categories.memory_limit_kb)
}

// optional uint32 swap_limit_kb = 27;
inline bool resource_categories::has_swap_limit_kb() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void resource_categories::set_has_swap_limit_kb() {
  _has_bits_[0] |= 0x00004000u;
}
inline void resource_categories::clear_has_swap_limit_kb() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void resource_categories::clear_swap_limit_kb() {
  swap_limit_kb_ = 0u;
  clear_has_swap_limit_kb();
}
inline ::google::protobuf::uint32 resource_categories::swap_limit_kb() const {
  // @@protoc_insertion_point(field_get:draiosproto.resource_categories.swap_limit_kb)
  return swap_limit_kb_;
}
inline void resource_categories::set_swap_limit_kb(::google::protobuf::uint32 value) {
  set_has_swap_limit_kb();
  swap_limit_kb_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.resource_categories.swap_limit_kb)
}

// optional uint32 cpu_quota_used_pct = 28;
inline bool resource_categories::has_cpu_quota_used_pct() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void resource_categories::set_has_cpu_quota_used_pct() {
  _has_bits_[0] |= 0x00008000u;
}
inline void resource_categories::clear_has_cpu_quota_used_pct() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void resource_categories::clear_cpu_quota_used_pct() {
  cpu_quota_used_pct_ = 0u;
  clear_has_cpu_quota_used_pct();
}
inline ::google::protobuf::uint32 resource_categories::cpu_quota_used_pct() const {
  // @@protoc_insertion_point(field_get:draiosproto.resource_categories.cpu_quota_used_pct)
  return cpu_quota_used_pct_;
}
inline void resource_categories::set_cpu_quota_used_pct(::google::protobuf::uint32 value) {
  set_has_cpu_quota_used_pct();
  cpu_quota_used_pct_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.resource_categories.cpu_quota_used_pct)
}

// optional uint32 swap_memory_total_kb = 29;
inline bool resource_categories::has_swap_memory_total_kb() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void resource_categories::set_has_swap_memory_total_kb() {
  _has_bits_[0] |= 0x00010000u;
}
inline void resource_categories::clear_has_swap_memory_total_kb() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void resource_categories::clear_swap_memory_total_kb() {
  swap_memory_total_kb_ = 0u;
  clear_has_swap_memory_total_kb();
}
inline ::google::protobuf::uint32 resource_categories::swap_memory_total_kb() const {
  // @@protoc_insertion_point(field_get:draiosproto.resource_categories.swap_memory_total_kb)
  return swap_memory_total_kb_;
}
inline void resource_categories::set_swap_memory_total_kb(::google::protobuf::uint32 value) {
  set_has_swap_memory_total_kb();
  swap_memory_total_kb_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.resource_categories.swap_memory_total_kb)
}

// optional uint32 swap_memory_available_kb = 30;
inline bool resource_categories::has_swap_memory_available_kb() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void resource_categories::set_has_swap_memory_available_kb() {
  _has_bits_[0] |= 0x00020000u;
}
inline void resource_categories::clear_has_swap_memory_available_kb() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void resource_categories::clear_swap_memory_available_kb() {
  swap_memory_available_kb_ = 0u;
  clear_has_swap_memory_available_kb();
}
inline ::google::protobuf::uint32 resource_categories::swap_memory_available_kb() const {
  // @@protoc_insertion_point(field_get:draiosproto.resource_categories.swap_memory_available_kb)
  return swap_memory_available_kb_;
}
inline void resource_categories::set_swap_memory_available_kb(::google::protobuf::uint32 value) {
  set_has_swap_memory_available_kb();
  swap_memory_available_kb_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.resource_categories.swap_memory_available_kb)
}

// optional uint64 count_processes = 31;
inline bool resource_categories::has_count_processes() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void resource_categories::set_has_count_processes() {
  _has_bits_[0] |= 0x00040000u;
}
inline void resource_categories::clear_has_count_processes() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void resource_categories::clear_count_processes() {
  count_processes_ = GOOGLE_ULONGLONG(0);
  clear_has_count_processes();
}
inline ::google::protobuf::uint64 resource_categories::count_processes() const {
  // @@protoc_insertion_point(field_get:draiosproto.resource_categories.count_processes)
  return count_processes_;
}
inline void resource_categories::set_count_processes(::google::protobuf::uint64 value) {
  set_has_count_processes();
  count_processes_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.resource_categories.count_processes)
}

// optional uint64 proc_start_count = 32;
inline bool resource_categories::has_proc_start_count() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void resource_categories::set_has_proc_start_count() {
  _has_bits_[0] |= 0x00080000u;
}
inline void resource_categories::clear_has_proc_start_count() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void resource_categories::clear_proc_start_count() {
  proc_start_count_ = GOOGLE_ULONGLONG(0);
  clear_has_proc_start_count();
}
inline ::google::protobuf::uint64 resource_categories::proc_start_count() const {
  // @@protoc_insertion_point(field_get:draiosproto.resource_categories.proc_start_count)
  return proc_start_count_;
}
inline void resource_categories::set_proc_start_count(::google::protobuf::uint64 value) {
  set_has_proc_start_count();
  proc_start_count_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.resource_categories.proc_start_count)
}

inline const resource_categories* resource_categories::internal_default_instance() {
  return &resource_categories_default_instance_.get();
}
// -------------------------------------------------------------------

// connection_categories

// optional .draiosproto.counter_bytes server = 1;
inline bool connection_categories::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void connection_categories::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void connection_categories::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void connection_categories::clear_server() {
  if (server_ != NULL) server_->::draiosproto::counter_bytes::Clear();
  clear_has_server();
}
inline const ::draiosproto::counter_bytes& connection_categories::server() const {
  // @@protoc_insertion_point(field_get:draiosproto.connection_categories.server)
  return server_ != NULL ? *server_
                         : *::draiosproto::counter_bytes::internal_default_instance();
}
inline ::draiosproto::counter_bytes* connection_categories::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    server_ = new ::draiosproto::counter_bytes;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.connection_categories.server)
  return server_;
}
inline ::draiosproto::counter_bytes* connection_categories::release_server() {
  // @@protoc_insertion_point(field_release:draiosproto.connection_categories.server)
  clear_has_server();
  ::draiosproto::counter_bytes* temp = server_;
  server_ = NULL;
  return temp;
}
inline void connection_categories::set_allocated_server(::draiosproto::counter_bytes* server) {
  delete server_;
  server_ = server;
  if (server) {
    set_has_server();
  } else {
    clear_has_server();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.connection_categories.server)
}

// optional .draiosproto.counter_bytes client = 2;
inline bool connection_categories::has_client() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void connection_categories::set_has_client() {
  _has_bits_[0] |= 0x00000002u;
}
inline void connection_categories::clear_has_client() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void connection_categories::clear_client() {
  if (client_ != NULL) client_->::draiosproto::counter_bytes::Clear();
  clear_has_client();
}
inline const ::draiosproto::counter_bytes& connection_categories::client() const {
  // @@protoc_insertion_point(field_get:draiosproto.connection_categories.client)
  return client_ != NULL ? *client_
                         : *::draiosproto::counter_bytes::internal_default_instance();
}
inline ::draiosproto::counter_bytes* connection_categories::mutable_client() {
  set_has_client();
  if (client_ == NULL) {
    client_ = new ::draiosproto::counter_bytes;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.connection_categories.client)
  return client_;
}
inline ::draiosproto::counter_bytes* connection_categories::release_client() {
  // @@protoc_insertion_point(field_release:draiosproto.connection_categories.client)
  clear_has_client();
  ::draiosproto::counter_bytes* temp = client_;
  client_ = NULL;
  return temp;
}
inline void connection_categories::set_allocated_client(::draiosproto::counter_bytes* client) {
  delete client_;
  client_ = client;
  if (client) {
    set_has_client();
  } else {
    clear_has_client();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.connection_categories.client)
}

// optional .draiosproto.counter_time_bidirectional transaction_counters = 3;
inline bool connection_categories::has_transaction_counters() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void connection_categories::set_has_transaction_counters() {
  _has_bits_[0] |= 0x00000004u;
}
inline void connection_categories::clear_has_transaction_counters() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void connection_categories::clear_transaction_counters() {
  if (transaction_counters_ != NULL) transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& connection_categories::transaction_counters() const {
  // @@protoc_insertion_point(field_get:draiosproto.connection_categories.transaction_counters)
  return transaction_counters_ != NULL ? *transaction_counters_
                         : *::draiosproto::counter_time_bidirectional::internal_default_instance();
}
inline ::draiosproto::counter_time_bidirectional* connection_categories::mutable_transaction_counters() {
  set_has_transaction_counters();
  if (transaction_counters_ == NULL) {
    transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.connection_categories.transaction_counters)
  return transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* connection_categories::release_transaction_counters() {
  // @@protoc_insertion_point(field_release:draiosproto.connection_categories.transaction_counters)
  clear_has_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = transaction_counters_;
  transaction_counters_ = NULL;
  return temp;
}
inline void connection_categories::set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters) {
  delete transaction_counters_;
  transaction_counters_ = transaction_counters;
  if (transaction_counters) {
    set_has_transaction_counters();
  } else {
    clear_has_transaction_counters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.connection_categories.transaction_counters)
}

// optional .draiosproto.counter_time_bidirectional min_transaction_counters = 18;
inline bool connection_categories::has_min_transaction_counters() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void connection_categories::set_has_min_transaction_counters() {
  _has_bits_[0] |= 0x00000008u;
}
inline void connection_categories::clear_has_min_transaction_counters() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void connection_categories::clear_min_transaction_counters() {
  if (min_transaction_counters_ != NULL) min_transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_min_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& connection_categories::min_transaction_counters() const {
  // @@protoc_insertion_point(field_get:draiosproto.connection_categories.min_transaction_counters)
  return min_transaction_counters_ != NULL ? *min_transaction_counters_
                         : *::draiosproto::counter_time_bidirectional::internal_default_instance();
}
inline ::draiosproto::counter_time_bidirectional* connection_categories::mutable_min_transaction_counters() {
  set_has_min_transaction_counters();
  if (min_transaction_counters_ == NULL) {
    min_transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.connection_categories.min_transaction_counters)
  return min_transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* connection_categories::release_min_transaction_counters() {
  // @@protoc_insertion_point(field_release:draiosproto.connection_categories.min_transaction_counters)
  clear_has_min_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = min_transaction_counters_;
  min_transaction_counters_ = NULL;
  return temp;
}
inline void connection_categories::set_allocated_min_transaction_counters(::draiosproto::counter_time_bidirectional* min_transaction_counters) {
  delete min_transaction_counters_;
  min_transaction_counters_ = min_transaction_counters;
  if (min_transaction_counters) {
    set_has_min_transaction_counters();
  } else {
    clear_has_min_transaction_counters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.connection_categories.min_transaction_counters)
}

// optional .draiosproto.counter_time_bidirectional max_transaction_counters = 19;
inline bool connection_categories::has_max_transaction_counters() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void connection_categories::set_has_max_transaction_counters() {
  _has_bits_[0] |= 0x00000010u;
}
inline void connection_categories::clear_has_max_transaction_counters() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void connection_categories::clear_max_transaction_counters() {
  if (max_transaction_counters_ != NULL) max_transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_max_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& connection_categories::max_transaction_counters() const {
  // @@protoc_insertion_point(field_get:draiosproto.connection_categories.max_transaction_counters)
  return max_transaction_counters_ != NULL ? *max_transaction_counters_
                         : *::draiosproto::counter_time_bidirectional::internal_default_instance();
}
inline ::draiosproto::counter_time_bidirectional* connection_categories::mutable_max_transaction_counters() {
  set_has_max_transaction_counters();
  if (max_transaction_counters_ == NULL) {
    max_transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.connection_categories.max_transaction_counters)
  return max_transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* connection_categories::release_max_transaction_counters() {
  // @@protoc_insertion_point(field_release:draiosproto.connection_categories.max_transaction_counters)
  clear_has_max_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = max_transaction_counters_;
  max_transaction_counters_ = NULL;
  return temp;
}
inline void connection_categories::set_allocated_max_transaction_counters(::draiosproto::counter_time_bidirectional* max_transaction_counters) {
  delete max_transaction_counters_;
  max_transaction_counters_ = max_transaction_counters;
  if (max_transaction_counters) {
    set_has_max_transaction_counters();
  } else {
    clear_has_max_transaction_counters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.connection_categories.max_transaction_counters)
}

// optional uint32 n_aggregated_connections = 4;
inline bool connection_categories::has_n_aggregated_connections() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void connection_categories::set_has_n_aggregated_connections() {
  _has_bits_[0] |= 0x00000020u;
}
inline void connection_categories::clear_has_n_aggregated_connections() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void connection_categories::clear_n_aggregated_connections() {
  n_aggregated_connections_ = 0u;
  clear_has_n_aggregated_connections();
}
inline ::google::protobuf::uint32 connection_categories::n_aggregated_connections() const {
  // @@protoc_insertion_point(field_get:draiosproto.connection_categories.n_aggregated_connections)
  return n_aggregated_connections_;
}
inline void connection_categories::set_n_aggregated_connections(::google::protobuf::uint32 value) {
  set_has_n_aggregated_connections();
  n_aggregated_connections_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.connection_categories.n_aggregated_connections)
}

inline const connection_categories* connection_categories::internal_default_instance() {
  return &connection_categories_default_instance_.get();
}
// -------------------------------------------------------------------

// process_details

// required string comm = 1;
inline bool process_details::has_comm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void process_details::set_has_comm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void process_details::clear_has_comm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void process_details::clear_comm() {
  comm_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comm();
}
inline const ::std::string& process_details::comm() const {
  // @@protoc_insertion_point(field_get:draiosproto.process_details.comm)
  return comm_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void process_details::set_comm(const ::std::string& value) {
  set_has_comm();
  comm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.process_details.comm)
}
inline void process_details::set_comm(const char* value) {
  set_has_comm();
  comm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.process_details.comm)
}
inline void process_details::set_comm(const char* value, size_t size) {
  set_has_comm();
  comm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.process_details.comm)
}
inline ::std::string* process_details::mutable_comm() {
  set_has_comm();
  // @@protoc_insertion_point(field_mutable:draiosproto.process_details.comm)
  return comm_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* process_details::release_comm() {
  // @@protoc_insertion_point(field_release:draiosproto.process_details.comm)
  clear_has_comm();
  return comm_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void process_details::set_allocated_comm(::std::string* comm) {
  if (comm != NULL) {
    set_has_comm();
  } else {
    clear_has_comm();
  }
  comm_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comm);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.process_details.comm)
}

// required string exe = 2;
inline bool process_details::has_exe() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void process_details::set_has_exe() {
  _has_bits_[0] |= 0x00000002u;
}
inline void process_details::clear_has_exe() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void process_details::clear_exe() {
  exe_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exe();
}
inline const ::std::string& process_details::exe() const {
  // @@protoc_insertion_point(field_get:draiosproto.process_details.exe)
  return exe_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void process_details::set_exe(const ::std::string& value) {
  set_has_exe();
  exe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.process_details.exe)
}
inline void process_details::set_exe(const char* value) {
  set_has_exe();
  exe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.process_details.exe)
}
inline void process_details::set_exe(const char* value, size_t size) {
  set_has_exe();
  exe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.process_details.exe)
}
inline ::std::string* process_details::mutable_exe() {
  set_has_exe();
  // @@protoc_insertion_point(field_mutable:draiosproto.process_details.exe)
  return exe_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* process_details::release_exe() {
  // @@protoc_insertion_point(field_release:draiosproto.process_details.exe)
  clear_has_exe();
  return exe_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void process_details::set_allocated_exe(::std::string* exe) {
  if (exe != NULL) {
    set_has_exe();
  } else {
    clear_has_exe();
  }
  exe_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exe);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.process_details.exe)
}

// repeated string args = 3;
inline int process_details::args_size() const {
  return args_.size();
}
inline void process_details::clear_args() {
  args_.Clear();
}
inline const ::std::string& process_details::args(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.process_details.args)
  return args_.Get(index);
}
inline ::std::string* process_details::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.process_details.args)
  return args_.Mutable(index);
}
inline void process_details::set_args(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:draiosproto.process_details.args)
  args_.Mutable(index)->assign(value);
}
inline void process_details::set_args(int index, const char* value) {
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:draiosproto.process_details.args)
}
inline void process_details::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:draiosproto.process_details.args)
}
inline ::std::string* process_details::add_args() {
  // @@protoc_insertion_point(field_add_mutable:draiosproto.process_details.args)
  return args_.Add();
}
inline void process_details::add_args(const ::std::string& value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:draiosproto.process_details.args)
}
inline void process_details::add_args(const char* value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:draiosproto.process_details.args)
}
inline void process_details::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:draiosproto.process_details.args)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
process_details::args() const {
  // @@protoc_insertion_point(field_list:draiosproto.process_details.args)
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
process_details::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.process_details.args)
  return &args_;
}

// optional string container_id = 4;
inline bool process_details::has_container_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void process_details::set_has_container_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void process_details::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void process_details::clear_container_id() {
  container_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_container_id();
}
inline const ::std::string& process_details::container_id() const {
  // @@protoc_insertion_point(field_get:draiosproto.process_details.container_id)
  return container_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void process_details::set_container_id(const ::std::string& value) {
  set_has_container_id();
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.process_details.container_id)
}
inline void process_details::set_container_id(const char* value) {
  set_has_container_id();
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.process_details.container_id)
}
inline void process_details::set_container_id(const char* value, size_t size) {
  set_has_container_id();
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.process_details.container_id)
}
inline ::std::string* process_details::mutable_container_id() {
  set_has_container_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.process_details.container_id)
  return container_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* process_details::release_container_id() {
  // @@protoc_insertion_point(field_release:draiosproto.process_details.container_id)
  clear_has_container_id();
  return container_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void process_details::set_allocated_container_id(::std::string* container_id) {
  if (container_id != NULL) {
    set_has_container_id();
  } else {
    clear_has_container_id();
  }
  container_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), container_id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.process_details.container_id)
}

inline const process_details* process_details::internal_default_instance() {
  return &process_details_default_instance_.get();
}
// -------------------------------------------------------------------

// command_details

// required uint64 timestamp = 1;
inline bool command_details::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void command_details::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void command_details::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void command_details::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 command_details::timestamp() const {
  // @@protoc_insertion_point(field_get:draiosproto.command_details.timestamp)
  return timestamp_;
}
inline void command_details::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.command_details.timestamp)
}

// required uint32 count = 2;
inline bool command_details::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void command_details::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void command_details::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void command_details::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 command_details::count() const {
  // @@protoc_insertion_point(field_get:draiosproto.command_details.count)
  return count_;
}
inline void command_details::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.command_details.count)
}

// required string cmdline = 3;
inline bool command_details::has_cmdline() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void command_details::set_has_cmdline() {
  _has_bits_[0] |= 0x00000004u;
}
inline void command_details::clear_has_cmdline() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void command_details::clear_cmdline() {
  cmdline_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_cmdline();
}
inline const ::std::string& command_details::cmdline() const {
  // @@protoc_insertion_point(field_get:draiosproto.command_details.cmdline)
  return cmdline_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_details::set_cmdline(const ::std::string& value) {
  set_has_cmdline();
  cmdline_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.command_details.cmdline)
}
inline void command_details::set_cmdline(const char* value) {
  set_has_cmdline();
  cmdline_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.command_details.cmdline)
}
inline void command_details::set_cmdline(const char* value, size_t size) {
  set_has_cmdline();
  cmdline_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.command_details.cmdline)
}
inline ::std::string* command_details::mutable_cmdline() {
  set_has_cmdline();
  // @@protoc_insertion_point(field_mutable:draiosproto.command_details.cmdline)
  return cmdline_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_details::release_cmdline() {
  // @@protoc_insertion_point(field_release:draiosproto.command_details.cmdline)
  clear_has_cmdline();
  return cmdline_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_details::set_allocated_cmdline(::std::string* cmdline) {
  if (cmdline != NULL) {
    set_has_cmdline();
  } else {
    clear_has_cmdline();
  }
  cmdline_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cmdline);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.command_details.cmdline)
}

// required string exe = 4;
inline bool command_details::has_exe() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void command_details::set_has_exe() {
  _has_bits_[0] |= 0x00000008u;
}
inline void command_details::clear_has_exe() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void command_details::clear_exe() {
  exe_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exe();
}
inline const ::std::string& command_details::exe() const {
  // @@protoc_insertion_point(field_get:draiosproto.command_details.exe)
  return exe_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_details::set_exe(const ::std::string& value) {
  set_has_exe();
  exe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.command_details.exe)
}
inline void command_details::set_exe(const char* value) {
  set_has_exe();
  exe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.command_details.exe)
}
inline void command_details::set_exe(const char* value, size_t size) {
  set_has_exe();
  exe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.command_details.exe)
}
inline ::std::string* command_details::mutable_exe() {
  set_has_exe();
  // @@protoc_insertion_point(field_mutable:draiosproto.command_details.exe)
  return exe_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_details::release_exe() {
  // @@protoc_insertion_point(field_release:draiosproto.command_details.exe)
  clear_has_exe();
  return exe_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_details::set_allocated_exe(::std::string* exe) {
  if (exe != NULL) {
    set_has_exe();
  } else {
    clear_has_exe();
  }
  exe_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exe);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.command_details.exe)
}

// optional string parentcomm = 5;
inline bool command_details::has_parentcomm() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void command_details::set_has_parentcomm() {
  _has_bits_[0] |= 0x00000010u;
}
inline void command_details::clear_has_parentcomm() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void command_details::clear_parentcomm() {
  parentcomm_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_parentcomm();
}
inline const ::std::string& command_details::parentcomm() const {
  // @@protoc_insertion_point(field_get:draiosproto.command_details.parentcomm)
  return parentcomm_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_details::set_parentcomm(const ::std::string& value) {
  set_has_parentcomm();
  parentcomm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.command_details.parentcomm)
}
inline void command_details::set_parentcomm(const char* value) {
  set_has_parentcomm();
  parentcomm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.command_details.parentcomm)
}
inline void command_details::set_parentcomm(const char* value, size_t size) {
  set_has_parentcomm();
  parentcomm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.command_details.parentcomm)
}
inline ::std::string* command_details::mutable_parentcomm() {
  set_has_parentcomm();
  // @@protoc_insertion_point(field_mutable:draiosproto.command_details.parentcomm)
  return parentcomm_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* command_details::release_parentcomm() {
  // @@protoc_insertion_point(field_release:draiosproto.command_details.parentcomm)
  clear_has_parentcomm();
  return parentcomm_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void command_details::set_allocated_parentcomm(::std::string* parentcomm) {
  if (parentcomm != NULL) {
    set_has_parentcomm();
  } else {
    clear_has_parentcomm();
  }
  parentcomm_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parentcomm);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.command_details.parentcomm)
}

inline const command_details* command_details::internal_default_instance() {
  return &command_details_default_instance_.get();
}
// -------------------------------------------------------------------

// counter_proto_entry

// required uint32 ncalls = 1;
inline bool counter_proto_entry::has_ncalls() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void counter_proto_entry::set_has_ncalls() {
  _has_bits_[0] |= 0x00000001u;
}
inline void counter_proto_entry::clear_has_ncalls() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void counter_proto_entry::clear_ncalls() {
  ncalls_ = 0u;
  clear_has_ncalls();
}
inline ::google::protobuf::uint32 counter_proto_entry::ncalls() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_proto_entry.ncalls)
  return ncalls_;
}
inline void counter_proto_entry::set_ncalls(::google::protobuf::uint32 value) {
  set_has_ncalls();
  ncalls_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_proto_entry.ncalls)
}

// required uint64 time_tot = 2;
inline bool counter_proto_entry::has_time_tot() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void counter_proto_entry::set_has_time_tot() {
  _has_bits_[0] |= 0x00000002u;
}
inline void counter_proto_entry::clear_has_time_tot() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void counter_proto_entry::clear_time_tot() {
  time_tot_ = GOOGLE_ULONGLONG(0);
  clear_has_time_tot();
}
inline ::google::protobuf::uint64 counter_proto_entry::time_tot() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_proto_entry.time_tot)
  return time_tot_;
}
inline void counter_proto_entry::set_time_tot(::google::protobuf::uint64 value) {
  set_has_time_tot();
  time_tot_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_proto_entry.time_tot)
}

// required uint64 time_max = 3;
inline bool counter_proto_entry::has_time_max() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void counter_proto_entry::set_has_time_max() {
  _has_bits_[0] |= 0x00000004u;
}
inline void counter_proto_entry::clear_has_time_max() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void counter_proto_entry::clear_time_max() {
  time_max_ = GOOGLE_ULONGLONG(0);
  clear_has_time_max();
}
inline ::google::protobuf::uint64 counter_proto_entry::time_max() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_proto_entry.time_max)
  return time_max_;
}
inline void counter_proto_entry::set_time_max(::google::protobuf::uint64 value) {
  set_has_time_max();
  time_max_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_proto_entry.time_max)
}

// required uint64 bytes_in = 4;
inline bool counter_proto_entry::has_bytes_in() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void counter_proto_entry::set_has_bytes_in() {
  _has_bits_[0] |= 0x00000008u;
}
inline void counter_proto_entry::clear_has_bytes_in() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void counter_proto_entry::clear_bytes_in() {
  bytes_in_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_in();
}
inline ::google::protobuf::uint64 counter_proto_entry::bytes_in() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_proto_entry.bytes_in)
  return bytes_in_;
}
inline void counter_proto_entry::set_bytes_in(::google::protobuf::uint64 value) {
  set_has_bytes_in();
  bytes_in_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_proto_entry.bytes_in)
}

// required uint64 bytes_out = 5;
inline bool counter_proto_entry::has_bytes_out() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void counter_proto_entry::set_has_bytes_out() {
  _has_bits_[0] |= 0x00000010u;
}
inline void counter_proto_entry::clear_has_bytes_out() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void counter_proto_entry::clear_bytes_out() {
  bytes_out_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_out();
}
inline ::google::protobuf::uint64 counter_proto_entry::bytes_out() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_proto_entry.bytes_out)
  return bytes_out_;
}
inline void counter_proto_entry::set_bytes_out(::google::protobuf::uint64 value) {
  set_has_bytes_out();
  bytes_out_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_proto_entry.bytes_out)
}

// required uint32 nerrors = 6;
inline bool counter_proto_entry::has_nerrors() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void counter_proto_entry::set_has_nerrors() {
  _has_bits_[0] |= 0x00000020u;
}
inline void counter_proto_entry::clear_has_nerrors() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void counter_proto_entry::clear_nerrors() {
  nerrors_ = 0u;
  clear_has_nerrors();
}
inline ::google::protobuf::uint32 counter_proto_entry::nerrors() const {
  // @@protoc_insertion_point(field_get:draiosproto.counter_proto_entry.nerrors)
  return nerrors_;
}
inline void counter_proto_entry::set_nerrors(::google::protobuf::uint32 value) {
  set_has_nerrors();
  nerrors_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.counter_proto_entry.nerrors)
}

inline const counter_proto_entry* counter_proto_entry::internal_default_instance() {
  return &counter_proto_entry_default_instance_.get();
}
// -------------------------------------------------------------------

// url_details

// required string url = 1;
inline bool url_details::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void url_details::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void url_details::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void url_details::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& url_details::url() const {
  // @@protoc_insertion_point(field_get:draiosproto.url_details.url)
  return url_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void url_details::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.url_details.url)
}
inline void url_details::set_url(const char* value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.url_details.url)
}
inline void url_details::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.url_details.url)
}
inline ::std::string* url_details::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:draiosproto.url_details.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* url_details::release_url() {
  // @@protoc_insertion_point(field_release:draiosproto.url_details.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void url_details::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.url_details.url)
}

// required .draiosproto.counter_proto_entry counters = 2;
inline bool url_details::has_counters() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void url_details::set_has_counters() {
  _has_bits_[0] |= 0x00000002u;
}
inline void url_details::clear_has_counters() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void url_details::clear_counters() {
  if (counters_ != NULL) counters_->::draiosproto::counter_proto_entry::Clear();
  clear_has_counters();
}
inline const ::draiosproto::counter_proto_entry& url_details::counters() const {
  // @@protoc_insertion_point(field_get:draiosproto.url_details.counters)
  return counters_ != NULL ? *counters_
                         : *::draiosproto::counter_proto_entry::internal_default_instance();
}
inline ::draiosproto::counter_proto_entry* url_details::mutable_counters() {
  set_has_counters();
  if (counters_ == NULL) {
    counters_ = new ::draiosproto::counter_proto_entry;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.url_details.counters)
  return counters_;
}
inline ::draiosproto::counter_proto_entry* url_details::release_counters() {
  // @@protoc_insertion_point(field_release:draiosproto.url_details.counters)
  clear_has_counters();
  ::draiosproto::counter_proto_entry* temp = counters_;
  counters_ = NULL;
  return temp;
}
inline void url_details::set_allocated_counters(::draiosproto::counter_proto_entry* counters) {
  delete counters_;
  counters_ = counters;
  if (counters) {
    set_has_counters();
  } else {
    clear_has_counters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.url_details.counters)
}

inline const url_details* url_details::internal_default_instance() {
  return &url_details_default_instance_.get();
}
// -------------------------------------------------------------------

// status_code_details

// required uint32 status_code = 1;
inline bool status_code_details::has_status_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void status_code_details::set_has_status_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void status_code_details::clear_has_status_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void status_code_details::clear_status_code() {
  status_code_ = 0u;
  clear_has_status_code();
}
inline ::google::protobuf::uint32 status_code_details::status_code() const {
  // @@protoc_insertion_point(field_get:draiosproto.status_code_details.status_code)
  return status_code_;
}
inline void status_code_details::set_status_code(::google::protobuf::uint32 value) {
  set_has_status_code();
  status_code_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.status_code_details.status_code)
}

// required uint32 ncalls = 2;
inline bool status_code_details::has_ncalls() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void status_code_details::set_has_ncalls() {
  _has_bits_[0] |= 0x00000002u;
}
inline void status_code_details::clear_has_ncalls() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void status_code_details::clear_ncalls() {
  ncalls_ = 0u;
  clear_has_ncalls();
}
inline ::google::protobuf::uint32 status_code_details::ncalls() const {
  // @@protoc_insertion_point(field_get:draiosproto.status_code_details.ncalls)
  return ncalls_;
}
inline void status_code_details::set_ncalls(::google::protobuf::uint32 value) {
  set_has_ncalls();
  ncalls_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.status_code_details.ncalls)
}

inline const status_code_details* status_code_details::internal_default_instance() {
  return &status_code_details_default_instance_.get();
}
// -------------------------------------------------------------------

// http_info

// repeated .draiosproto.url_details server_urls = 1;
inline int http_info::server_urls_size() const {
  return server_urls_.size();
}
inline void http_info::clear_server_urls() {
  server_urls_.Clear();
}
inline const ::draiosproto::url_details& http_info::server_urls(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.http_info.server_urls)
  return server_urls_.Get(index);
}
inline ::draiosproto::url_details* http_info::mutable_server_urls(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.http_info.server_urls)
  return server_urls_.Mutable(index);
}
inline ::draiosproto::url_details* http_info::add_server_urls() {
  // @@protoc_insertion_point(field_add:draiosproto.http_info.server_urls)
  return server_urls_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::url_details >*
http_info::mutable_server_urls() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.http_info.server_urls)
  return &server_urls_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::url_details >&
http_info::server_urls() const {
  // @@protoc_insertion_point(field_list:draiosproto.http_info.server_urls)
  return server_urls_;
}

// repeated .draiosproto.url_details client_urls = 2;
inline int http_info::client_urls_size() const {
  return client_urls_.size();
}
inline void http_info::clear_client_urls() {
  client_urls_.Clear();
}
inline const ::draiosproto::url_details& http_info::client_urls(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.http_info.client_urls)
  return client_urls_.Get(index);
}
inline ::draiosproto::url_details* http_info::mutable_client_urls(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.http_info.client_urls)
  return client_urls_.Mutable(index);
}
inline ::draiosproto::url_details* http_info::add_client_urls() {
  // @@protoc_insertion_point(field_add:draiosproto.http_info.client_urls)
  return client_urls_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::url_details >*
http_info::mutable_client_urls() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.http_info.client_urls)
  return &client_urls_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::url_details >&
http_info::client_urls() const {
  // @@protoc_insertion_point(field_list:draiosproto.http_info.client_urls)
  return client_urls_;
}

// repeated .draiosproto.status_code_details client_status_codes = 3;
inline int http_info::client_status_codes_size() const {
  return client_status_codes_.size();
}
inline void http_info::clear_client_status_codes() {
  client_status_codes_.Clear();
}
inline const ::draiosproto::status_code_details& http_info::client_status_codes(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.http_info.client_status_codes)
  return client_status_codes_.Get(index);
}
inline ::draiosproto::status_code_details* http_info::mutable_client_status_codes(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.http_info.client_status_codes)
  return client_status_codes_.Mutable(index);
}
inline ::draiosproto::status_code_details* http_info::add_client_status_codes() {
  // @@protoc_insertion_point(field_add:draiosproto.http_info.client_status_codes)
  return client_status_codes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::status_code_details >*
http_info::mutable_client_status_codes() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.http_info.client_status_codes)
  return &client_status_codes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::status_code_details >&
http_info::client_status_codes() const {
  // @@protoc_insertion_point(field_list:draiosproto.http_info.client_status_codes)
  return client_status_codes_;
}

// repeated .draiosproto.status_code_details server_status_codes = 4;
inline int http_info::server_status_codes_size() const {
  return server_status_codes_.size();
}
inline void http_info::clear_server_status_codes() {
  server_status_codes_.Clear();
}
inline const ::draiosproto::status_code_details& http_info::server_status_codes(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.http_info.server_status_codes)
  return server_status_codes_.Get(index);
}
inline ::draiosproto::status_code_details* http_info::mutable_server_status_codes(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.http_info.server_status_codes)
  return server_status_codes_.Mutable(index);
}
inline ::draiosproto::status_code_details* http_info::add_server_status_codes() {
  // @@protoc_insertion_point(field_add:draiosproto.http_info.server_status_codes)
  return server_status_codes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::status_code_details >*
http_info::mutable_server_status_codes() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.http_info.server_status_codes)
  return &server_status_codes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::status_code_details >&
http_info::server_status_codes() const {
  // @@protoc_insertion_point(field_list:draiosproto.http_info.server_status_codes)
  return server_status_codes_;
}

inline const http_info* http_info::internal_default_instance() {
  return &http_info_default_instance_.get();
}
// -------------------------------------------------------------------

// sql_entry_details

// required string name = 1;
inline bool sql_entry_details::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sql_entry_details::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sql_entry_details::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sql_entry_details::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& sql_entry_details::name() const {
  // @@protoc_insertion_point(field_get:draiosproto.sql_entry_details.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void sql_entry_details::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.sql_entry_details.name)
}
inline void sql_entry_details::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.sql_entry_details.name)
}
inline void sql_entry_details::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.sql_entry_details.name)
}
inline ::std::string* sql_entry_details::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:draiosproto.sql_entry_details.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* sql_entry_details::release_name() {
  // @@protoc_insertion_point(field_release:draiosproto.sql_entry_details.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void sql_entry_details::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.sql_entry_details.name)
}

// required .draiosproto.counter_proto_entry counters = 2;
inline bool sql_entry_details::has_counters() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sql_entry_details::set_has_counters() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sql_entry_details::clear_has_counters() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sql_entry_details::clear_counters() {
  if (counters_ != NULL) counters_->::draiosproto::counter_proto_entry::Clear();
  clear_has_counters();
}
inline const ::draiosproto::counter_proto_entry& sql_entry_details::counters() const {
  // @@protoc_insertion_point(field_get:draiosproto.sql_entry_details.counters)
  return counters_ != NULL ? *counters_
                         : *::draiosproto::counter_proto_entry::internal_default_instance();
}
inline ::draiosproto::counter_proto_entry* sql_entry_details::mutable_counters() {
  set_has_counters();
  if (counters_ == NULL) {
    counters_ = new ::draiosproto::counter_proto_entry;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.sql_entry_details.counters)
  return counters_;
}
inline ::draiosproto::counter_proto_entry* sql_entry_details::release_counters() {
  // @@protoc_insertion_point(field_release:draiosproto.sql_entry_details.counters)
  clear_has_counters();
  ::draiosproto::counter_proto_entry* temp = counters_;
  counters_ = NULL;
  return temp;
}
inline void sql_entry_details::set_allocated_counters(::draiosproto::counter_proto_entry* counters) {
  delete counters_;
  counters_ = counters;
  if (counters) {
    set_has_counters();
  } else {
    clear_has_counters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.sql_entry_details.counters)
}

inline const sql_entry_details* sql_entry_details::internal_default_instance() {
  return &sql_entry_details_default_instance_.get();
}
// -------------------------------------------------------------------

// sql_query_type_details

// required .draiosproto.sql_statement_type type = 1;
inline bool sql_query_type_details::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sql_query_type_details::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sql_query_type_details::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sql_query_type_details::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::draiosproto::sql_statement_type sql_query_type_details::type() const {
  // @@protoc_insertion_point(field_get:draiosproto.sql_query_type_details.type)
  return static_cast< ::draiosproto::sql_statement_type >(type_);
}
inline void sql_query_type_details::set_type(::draiosproto::sql_statement_type value) {
  assert(::draiosproto::sql_statement_type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.sql_query_type_details.type)
}

// required .draiosproto.counter_proto_entry counters = 2;
inline bool sql_query_type_details::has_counters() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sql_query_type_details::set_has_counters() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sql_query_type_details::clear_has_counters() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sql_query_type_details::clear_counters() {
  if (counters_ != NULL) counters_->::draiosproto::counter_proto_entry::Clear();
  clear_has_counters();
}
inline const ::draiosproto::counter_proto_entry& sql_query_type_details::counters() const {
  // @@protoc_insertion_point(field_get:draiosproto.sql_query_type_details.counters)
  return counters_ != NULL ? *counters_
                         : *::draiosproto::counter_proto_entry::internal_default_instance();
}
inline ::draiosproto::counter_proto_entry* sql_query_type_details::mutable_counters() {
  set_has_counters();
  if (counters_ == NULL) {
    counters_ = new ::draiosproto::counter_proto_entry;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.sql_query_type_details.counters)
  return counters_;
}
inline ::draiosproto::counter_proto_entry* sql_query_type_details::release_counters() {
  // @@protoc_insertion_point(field_release:draiosproto.sql_query_type_details.counters)
  clear_has_counters();
  ::draiosproto::counter_proto_entry* temp = counters_;
  counters_ = NULL;
  return temp;
}
inline void sql_query_type_details::set_allocated_counters(::draiosproto::counter_proto_entry* counters) {
  delete counters_;
  counters_ = counters;
  if (counters) {
    set_has_counters();
  } else {
    clear_has_counters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.sql_query_type_details.counters)
}

inline const sql_query_type_details* sql_query_type_details::internal_default_instance() {
  return &sql_query_type_details_default_instance_.get();
}
// -------------------------------------------------------------------

// sql_info

// repeated .draiosproto.sql_entry_details server_queries = 1;
inline int sql_info::server_queries_size() const {
  return server_queries_.size();
}
inline void sql_info::clear_server_queries() {
  server_queries_.Clear();
}
inline const ::draiosproto::sql_entry_details& sql_info::server_queries(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.sql_info.server_queries)
  return server_queries_.Get(index);
}
inline ::draiosproto::sql_entry_details* sql_info::mutable_server_queries(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.sql_info.server_queries)
  return server_queries_.Mutable(index);
}
inline ::draiosproto::sql_entry_details* sql_info::add_server_queries() {
  // @@protoc_insertion_point(field_add:draiosproto.sql_info.server_queries)
  return server_queries_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >*
sql_info::mutable_server_queries() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.sql_info.server_queries)
  return &server_queries_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >&
sql_info::server_queries() const {
  // @@protoc_insertion_point(field_list:draiosproto.sql_info.server_queries)
  return server_queries_;
}

// repeated .draiosproto.sql_entry_details client_queries = 2;
inline int sql_info::client_queries_size() const {
  return client_queries_.size();
}
inline void sql_info::clear_client_queries() {
  client_queries_.Clear();
}
inline const ::draiosproto::sql_entry_details& sql_info::client_queries(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.sql_info.client_queries)
  return client_queries_.Get(index);
}
inline ::draiosproto::sql_entry_details* sql_info::mutable_client_queries(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.sql_info.client_queries)
  return client_queries_.Mutable(index);
}
inline ::draiosproto::sql_entry_details* sql_info::add_client_queries() {
  // @@protoc_insertion_point(field_add:draiosproto.sql_info.client_queries)
  return client_queries_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >*
sql_info::mutable_client_queries() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.sql_info.client_queries)
  return &client_queries_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >&
sql_info::client_queries() const {
  // @@protoc_insertion_point(field_list:draiosproto.sql_info.client_queries)
  return client_queries_;
}

// repeated .draiosproto.sql_query_type_details server_query_types = 3;
inline int sql_info::server_query_types_size() const {
  return server_query_types_.size();
}
inline void sql_info::clear_server_query_types() {
  server_query_types_.Clear();
}
inline const ::draiosproto::sql_query_type_details& sql_info::server_query_types(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.sql_info.server_query_types)
  return server_query_types_.Get(index);
}
inline ::draiosproto::sql_query_type_details* sql_info::mutable_server_query_types(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.sql_info.server_query_types)
  return server_query_types_.Mutable(index);
}
inline ::draiosproto::sql_query_type_details* sql_info::add_server_query_types() {
  // @@protoc_insertion_point(field_add:draiosproto.sql_info.server_query_types)
  return server_query_types_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_query_type_details >*
sql_info::mutable_server_query_types() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.sql_info.server_query_types)
  return &server_query_types_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_query_type_details >&
sql_info::server_query_types() const {
  // @@protoc_insertion_point(field_list:draiosproto.sql_info.server_query_types)
  return server_query_types_;
}

// repeated .draiosproto.sql_query_type_details client_query_types = 4;
inline int sql_info::client_query_types_size() const {
  return client_query_types_.size();
}
inline void sql_info::clear_client_query_types() {
  client_query_types_.Clear();
}
inline const ::draiosproto::sql_query_type_details& sql_info::client_query_types(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.sql_info.client_query_types)
  return client_query_types_.Get(index);
}
inline ::draiosproto::sql_query_type_details* sql_info::mutable_client_query_types(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.sql_info.client_query_types)
  return client_query_types_.Mutable(index);
}
inline ::draiosproto::sql_query_type_details* sql_info::add_client_query_types() {
  // @@protoc_insertion_point(field_add:draiosproto.sql_info.client_query_types)
  return client_query_types_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_query_type_details >*
sql_info::mutable_client_query_types() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.sql_info.client_query_types)
  return &client_query_types_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_query_type_details >&
sql_info::client_query_types() const {
  // @@protoc_insertion_point(field_list:draiosproto.sql_info.client_query_types)
  return client_query_types_;
}

// repeated .draiosproto.sql_entry_details server_tables = 5;
inline int sql_info::server_tables_size() const {
  return server_tables_.size();
}
inline void sql_info::clear_server_tables() {
  server_tables_.Clear();
}
inline const ::draiosproto::sql_entry_details& sql_info::server_tables(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.sql_info.server_tables)
  return server_tables_.Get(index);
}
inline ::draiosproto::sql_entry_details* sql_info::mutable_server_tables(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.sql_info.server_tables)
  return server_tables_.Mutable(index);
}
inline ::draiosproto::sql_entry_details* sql_info::add_server_tables() {
  // @@protoc_insertion_point(field_add:draiosproto.sql_info.server_tables)
  return server_tables_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >*
sql_info::mutable_server_tables() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.sql_info.server_tables)
  return &server_tables_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >&
sql_info::server_tables() const {
  // @@protoc_insertion_point(field_list:draiosproto.sql_info.server_tables)
  return server_tables_;
}

// repeated .draiosproto.sql_entry_details client_tables = 6;
inline int sql_info::client_tables_size() const {
  return client_tables_.size();
}
inline void sql_info::clear_client_tables() {
  client_tables_.Clear();
}
inline const ::draiosproto::sql_entry_details& sql_info::client_tables(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.sql_info.client_tables)
  return client_tables_.Get(index);
}
inline ::draiosproto::sql_entry_details* sql_info::mutable_client_tables(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.sql_info.client_tables)
  return client_tables_.Mutable(index);
}
inline ::draiosproto::sql_entry_details* sql_info::add_client_tables() {
  // @@protoc_insertion_point(field_add:draiosproto.sql_info.client_tables)
  return client_tables_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >*
sql_info::mutable_client_tables() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.sql_info.client_tables)
  return &client_tables_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >&
sql_info::client_tables() const {
  // @@protoc_insertion_point(field_list:draiosproto.sql_info.client_tables)
  return client_tables_;
}

inline const sql_info* sql_info::internal_default_instance() {
  return &sql_info_default_instance_.get();
}
// -------------------------------------------------------------------

// mongodb_collection_details

// required string name = 1;
inline bool mongodb_collection_details::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mongodb_collection_details::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mongodb_collection_details::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mongodb_collection_details::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& mongodb_collection_details::name() const {
  // @@protoc_insertion_point(field_get:draiosproto.mongodb_collection_details.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void mongodb_collection_details::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.mongodb_collection_details.name)
}
inline void mongodb_collection_details::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.mongodb_collection_details.name)
}
inline void mongodb_collection_details::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.mongodb_collection_details.name)
}
inline ::std::string* mongodb_collection_details::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:draiosproto.mongodb_collection_details.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* mongodb_collection_details::release_name() {
  // @@protoc_insertion_point(field_release:draiosproto.mongodb_collection_details.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void mongodb_collection_details::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.mongodb_collection_details.name)
}

// required .draiosproto.counter_proto_entry counters = 2;
inline bool mongodb_collection_details::has_counters() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mongodb_collection_details::set_has_counters() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mongodb_collection_details::clear_has_counters() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mongodb_collection_details::clear_counters() {
  if (counters_ != NULL) counters_->::draiosproto::counter_proto_entry::Clear();
  clear_has_counters();
}
inline const ::draiosproto::counter_proto_entry& mongodb_collection_details::counters() const {
  // @@protoc_insertion_point(field_get:draiosproto.mongodb_collection_details.counters)
  return counters_ != NULL ? *counters_
                         : *::draiosproto::counter_proto_entry::internal_default_instance();
}
inline ::draiosproto::counter_proto_entry* mongodb_collection_details::mutable_counters() {
  set_has_counters();
  if (counters_ == NULL) {
    counters_ = new ::draiosproto::counter_proto_entry;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.mongodb_collection_details.counters)
  return counters_;
}
inline ::draiosproto::counter_proto_entry* mongodb_collection_details::release_counters() {
  // @@protoc_insertion_point(field_release:draiosproto.mongodb_collection_details.counters)
  clear_has_counters();
  ::draiosproto::counter_proto_entry* temp = counters_;
  counters_ = NULL;
  return temp;
}
inline void mongodb_collection_details::set_allocated_counters(::draiosproto::counter_proto_entry* counters) {
  delete counters_;
  counters_ = counters;
  if (counters) {
    set_has_counters();
  } else {
    clear_has_counters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.mongodb_collection_details.counters)
}

inline const mongodb_collection_details* mongodb_collection_details::internal_default_instance() {
  return &mongodb_collection_details_default_instance_.get();
}
// -------------------------------------------------------------------

// mongodb_op_type_details

// required .draiosproto.mongodb_op_type op = 1;
inline bool mongodb_op_type_details::has_op() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mongodb_op_type_details::set_has_op() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mongodb_op_type_details::clear_has_op() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mongodb_op_type_details::clear_op() {
  op_ = 0;
  clear_has_op();
}
inline ::draiosproto::mongodb_op_type mongodb_op_type_details::op() const {
  // @@protoc_insertion_point(field_get:draiosproto.mongodb_op_type_details.op)
  return static_cast< ::draiosproto::mongodb_op_type >(op_);
}
inline void mongodb_op_type_details::set_op(::draiosproto::mongodb_op_type value) {
  assert(::draiosproto::mongodb_op_type_IsValid(value));
  set_has_op();
  op_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.mongodb_op_type_details.op)
}

// required .draiosproto.counter_proto_entry counters = 2;
inline bool mongodb_op_type_details::has_counters() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mongodb_op_type_details::set_has_counters() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mongodb_op_type_details::clear_has_counters() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mongodb_op_type_details::clear_counters() {
  if (counters_ != NULL) counters_->::draiosproto::counter_proto_entry::Clear();
  clear_has_counters();
}
inline const ::draiosproto::counter_proto_entry& mongodb_op_type_details::counters() const {
  // @@protoc_insertion_point(field_get:draiosproto.mongodb_op_type_details.counters)
  return counters_ != NULL ? *counters_
                         : *::draiosproto::counter_proto_entry::internal_default_instance();
}
inline ::draiosproto::counter_proto_entry* mongodb_op_type_details::mutable_counters() {
  set_has_counters();
  if (counters_ == NULL) {
    counters_ = new ::draiosproto::counter_proto_entry;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.mongodb_op_type_details.counters)
  return counters_;
}
inline ::draiosproto::counter_proto_entry* mongodb_op_type_details::release_counters() {
  // @@protoc_insertion_point(field_release:draiosproto.mongodb_op_type_details.counters)
  clear_has_counters();
  ::draiosproto::counter_proto_entry* temp = counters_;
  counters_ = NULL;
  return temp;
}
inline void mongodb_op_type_details::set_allocated_counters(::draiosproto::counter_proto_entry* counters) {
  delete counters_;
  counters_ = counters;
  if (counters) {
    set_has_counters();
  } else {
    clear_has_counters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.mongodb_op_type_details.counters)
}

inline const mongodb_op_type_details* mongodb_op_type_details::internal_default_instance() {
  return &mongodb_op_type_details_default_instance_.get();
}
// -------------------------------------------------------------------

// mongodb_info

// repeated .draiosproto.mongodb_op_type_details servers_ops = 1;
inline int mongodb_info::servers_ops_size() const {
  return servers_ops_.size();
}
inline void mongodb_info::clear_servers_ops() {
  servers_ops_.Clear();
}
inline const ::draiosproto::mongodb_op_type_details& mongodb_info::servers_ops(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.mongodb_info.servers_ops)
  return servers_ops_.Get(index);
}
inline ::draiosproto::mongodb_op_type_details* mongodb_info::mutable_servers_ops(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.mongodb_info.servers_ops)
  return servers_ops_.Mutable(index);
}
inline ::draiosproto::mongodb_op_type_details* mongodb_info::add_servers_ops() {
  // @@protoc_insertion_point(field_add:draiosproto.mongodb_info.servers_ops)
  return servers_ops_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_op_type_details >*
mongodb_info::mutable_servers_ops() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.mongodb_info.servers_ops)
  return &servers_ops_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_op_type_details >&
mongodb_info::servers_ops() const {
  // @@protoc_insertion_point(field_list:draiosproto.mongodb_info.servers_ops)
  return servers_ops_;
}

// repeated .draiosproto.mongodb_op_type_details client_ops = 2;
inline int mongodb_info::client_ops_size() const {
  return client_ops_.size();
}
inline void mongodb_info::clear_client_ops() {
  client_ops_.Clear();
}
inline const ::draiosproto::mongodb_op_type_details& mongodb_info::client_ops(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.mongodb_info.client_ops)
  return client_ops_.Get(index);
}
inline ::draiosproto::mongodb_op_type_details* mongodb_info::mutable_client_ops(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.mongodb_info.client_ops)
  return client_ops_.Mutable(index);
}
inline ::draiosproto::mongodb_op_type_details* mongodb_info::add_client_ops() {
  // @@protoc_insertion_point(field_add:draiosproto.mongodb_info.client_ops)
  return client_ops_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_op_type_details >*
mongodb_info::mutable_client_ops() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.mongodb_info.client_ops)
  return &client_ops_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_op_type_details >&
mongodb_info::client_ops() const {
  // @@protoc_insertion_point(field_list:draiosproto.mongodb_info.client_ops)
  return client_ops_;
}

// repeated .draiosproto.mongodb_collection_details server_collections = 3;
inline int mongodb_info::server_collections_size() const {
  return server_collections_.size();
}
inline void mongodb_info::clear_server_collections() {
  server_collections_.Clear();
}
inline const ::draiosproto::mongodb_collection_details& mongodb_info::server_collections(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.mongodb_info.server_collections)
  return server_collections_.Get(index);
}
inline ::draiosproto::mongodb_collection_details* mongodb_info::mutable_server_collections(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.mongodb_info.server_collections)
  return server_collections_.Mutable(index);
}
inline ::draiosproto::mongodb_collection_details* mongodb_info::add_server_collections() {
  // @@protoc_insertion_point(field_add:draiosproto.mongodb_info.server_collections)
  return server_collections_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_collection_details >*
mongodb_info::mutable_server_collections() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.mongodb_info.server_collections)
  return &server_collections_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_collection_details >&
mongodb_info::server_collections() const {
  // @@protoc_insertion_point(field_list:draiosproto.mongodb_info.server_collections)
  return server_collections_;
}

// repeated .draiosproto.mongodb_collection_details client_collections = 4;
inline int mongodb_info::client_collections_size() const {
  return client_collections_.size();
}
inline void mongodb_info::clear_client_collections() {
  client_collections_.Clear();
}
inline const ::draiosproto::mongodb_collection_details& mongodb_info::client_collections(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.mongodb_info.client_collections)
  return client_collections_.Get(index);
}
inline ::draiosproto::mongodb_collection_details* mongodb_info::mutable_client_collections(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.mongodb_info.client_collections)
  return client_collections_.Mutable(index);
}
inline ::draiosproto::mongodb_collection_details* mongodb_info::add_client_collections() {
  // @@protoc_insertion_point(field_add:draiosproto.mongodb_info.client_collections)
  return client_collections_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_collection_details >*
mongodb_info::mutable_client_collections() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.mongodb_info.client_collections)
  return &client_collections_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_collection_details >&
mongodb_info::client_collections() const {
  // @@protoc_insertion_point(field_list:draiosproto.mongodb_info.client_collections)
  return client_collections_;
}

inline const mongodb_info* mongodb_info::internal_default_instance() {
  return &mongodb_info_default_instance_.get();
}
// -------------------------------------------------------------------

// jmx_attribute

// optional string name = 1;
inline bool jmx_attribute::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void jmx_attribute::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void jmx_attribute::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void jmx_attribute::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& jmx_attribute::name() const {
  // @@protoc_insertion_point(field_get:draiosproto.jmx_attribute.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void jmx_attribute::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.jmx_attribute.name)
}
inline void jmx_attribute::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.jmx_attribute.name)
}
inline void jmx_attribute::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.jmx_attribute.name)
}
inline ::std::string* jmx_attribute::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:draiosproto.jmx_attribute.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* jmx_attribute::release_name() {
  // @@protoc_insertion_point(field_release:draiosproto.jmx_attribute.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void jmx_attribute::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.jmx_attribute.name)
}

// optional double value = 2;
inline bool jmx_attribute::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void jmx_attribute::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void jmx_attribute::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void jmx_attribute::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double jmx_attribute::value() const {
  // @@protoc_insertion_point(field_get:draiosproto.jmx_attribute.value)
  return value_;
}
inline void jmx_attribute::set_value(double value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.jmx_attribute.value)
}

// optional string alias = 5;
inline bool jmx_attribute::has_alias() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void jmx_attribute::set_has_alias() {
  _has_bits_[0] |= 0x00000004u;
}
inline void jmx_attribute::clear_has_alias() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void jmx_attribute::clear_alias() {
  alias_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_alias();
}
inline const ::std::string& jmx_attribute::alias() const {
  // @@protoc_insertion_point(field_get:draiosproto.jmx_attribute.alias)
  return alias_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void jmx_attribute::set_alias(const ::std::string& value) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.jmx_attribute.alias)
}
inline void jmx_attribute::set_alias(const char* value) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.jmx_attribute.alias)
}
inline void jmx_attribute::set_alias(const char* value, size_t size) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.jmx_attribute.alias)
}
inline ::std::string* jmx_attribute::mutable_alias() {
  set_has_alias();
  // @@protoc_insertion_point(field_mutable:draiosproto.jmx_attribute.alias)
  return alias_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* jmx_attribute::release_alias() {
  // @@protoc_insertion_point(field_release:draiosproto.jmx_attribute.alias)
  clear_has_alias();
  return alias_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void jmx_attribute::set_allocated_alias(::std::string* alias) {
  if (alias != NULL) {
    set_has_alias();
  } else {
    clear_has_alias();
  }
  alias_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), alias);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.jmx_attribute.alias)
}

// optional .draiosproto.jmx_metric_type type = 7;
inline bool jmx_attribute::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void jmx_attribute::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void jmx_attribute::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void jmx_attribute::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::draiosproto::jmx_metric_type jmx_attribute::type() const {
  // @@protoc_insertion_point(field_get:draiosproto.jmx_attribute.type)
  return static_cast< ::draiosproto::jmx_metric_type >(type_);
}
inline void jmx_attribute::set_type(::draiosproto::jmx_metric_type value) {
  assert(::draiosproto::jmx_metric_type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.jmx_attribute.type)
}

// optional .draiosproto.unit unit = 8;
inline bool jmx_attribute::has_unit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void jmx_attribute::set_has_unit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void jmx_attribute::clear_has_unit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void jmx_attribute::clear_unit() {
  unit_ = 0;
  clear_has_unit();
}
inline ::draiosproto::unit jmx_attribute::unit() const {
  // @@protoc_insertion_point(field_get:draiosproto.jmx_attribute.unit)
  return static_cast< ::draiosproto::unit >(unit_);
}
inline void jmx_attribute::set_unit(::draiosproto::unit value) {
  assert(::draiosproto::unit_IsValid(value));
  set_has_unit();
  unit_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.jmx_attribute.unit)
}

// optional .draiosproto.scale scale = 9;
inline bool jmx_attribute::has_scale() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void jmx_attribute::set_has_scale() {
  _has_bits_[0] |= 0x00000020u;
}
inline void jmx_attribute::clear_has_scale() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void jmx_attribute::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline ::draiosproto::scale jmx_attribute::scale() const {
  // @@protoc_insertion_point(field_get:draiosproto.jmx_attribute.scale)
  return static_cast< ::draiosproto::scale >(scale_);
}
inline void jmx_attribute::set_scale(::draiosproto::scale value) {
  assert(::draiosproto::scale_IsValid(value));
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.jmx_attribute.scale)
}

// repeated .draiosproto.jmx_attribute subattributes = 3;
inline int jmx_attribute::subattributes_size() const {
  return subattributes_.size();
}
inline void jmx_attribute::clear_subattributes() {
  subattributes_.Clear();
}
inline const ::draiosproto::jmx_attribute& jmx_attribute::subattributes(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.jmx_attribute.subattributes)
  return subattributes_.Get(index);
}
inline ::draiosproto::jmx_attribute* jmx_attribute::mutable_subattributes(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.jmx_attribute.subattributes)
  return subattributes_.Mutable(index);
}
inline ::draiosproto::jmx_attribute* jmx_attribute::add_subattributes() {
  // @@protoc_insertion_point(field_add:draiosproto.jmx_attribute.subattributes)
  return subattributes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_attribute >*
jmx_attribute::mutable_subattributes() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.jmx_attribute.subattributes)
  return &subattributes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_attribute >&
jmx_attribute::subattributes() const {
  // @@protoc_insertion_point(field_list:draiosproto.jmx_attribute.subattributes)
  return subattributes_;
}

inline const jmx_attribute* jmx_attribute::internal_default_instance() {
  return &jmx_attribute_default_instance_.get();
}
// -------------------------------------------------------------------

// jmx_bean

// optional string name = 1;
inline bool jmx_bean::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void jmx_bean::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void jmx_bean::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void jmx_bean::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& jmx_bean::name() const {
  // @@protoc_insertion_point(field_get:draiosproto.jmx_bean.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void jmx_bean::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.jmx_bean.name)
}
inline void jmx_bean::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.jmx_bean.name)
}
inline void jmx_bean::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.jmx_bean.name)
}
inline ::std::string* jmx_bean::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:draiosproto.jmx_bean.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* jmx_bean::release_name() {
  // @@protoc_insertion_point(field_release:draiosproto.jmx_bean.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void jmx_bean::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.jmx_bean.name)
}

// repeated .draiosproto.jmx_attribute attributes = 2;
inline int jmx_bean::attributes_size() const {
  return attributes_.size();
}
inline void jmx_bean::clear_attributes() {
  attributes_.Clear();
}
inline const ::draiosproto::jmx_attribute& jmx_bean::attributes(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.jmx_bean.attributes)
  return attributes_.Get(index);
}
inline ::draiosproto::jmx_attribute* jmx_bean::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.jmx_bean.attributes)
  return attributes_.Mutable(index);
}
inline ::draiosproto::jmx_attribute* jmx_bean::add_attributes() {
  // @@protoc_insertion_point(field_add:draiosproto.jmx_bean.attributes)
  return attributes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_attribute >*
jmx_bean::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.jmx_bean.attributes)
  return &attributes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_attribute >&
jmx_bean::attributes() const {
  // @@protoc_insertion_point(field_list:draiosproto.jmx_bean.attributes)
  return attributes_;
}

inline const jmx_bean* jmx_bean::internal_default_instance() {
  return &jmx_bean_default_instance_.get();
}
// -------------------------------------------------------------------

// java_info

// optional string process_name = 1;
inline bool java_info::has_process_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void java_info::set_has_process_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void java_info::clear_has_process_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void java_info::clear_process_name() {
  process_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_process_name();
}
inline const ::std::string& java_info::process_name() const {
  // @@protoc_insertion_point(field_get:draiosproto.java_info.process_name)
  return process_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void java_info::set_process_name(const ::std::string& value) {
  set_has_process_name();
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.java_info.process_name)
}
inline void java_info::set_process_name(const char* value) {
  set_has_process_name();
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.java_info.process_name)
}
inline void java_info::set_process_name(const char* value, size_t size) {
  set_has_process_name();
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.java_info.process_name)
}
inline ::std::string* java_info::mutable_process_name() {
  set_has_process_name();
  // @@protoc_insertion_point(field_mutable:draiosproto.java_info.process_name)
  return process_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* java_info::release_process_name() {
  // @@protoc_insertion_point(field_release:draiosproto.java_info.process_name)
  clear_has_process_name();
  return process_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void java_info::set_allocated_process_name(::std::string* process_name) {
  if (process_name != NULL) {
    set_has_process_name();
  } else {
    clear_has_process_name();
  }
  process_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), process_name);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.java_info.process_name)
}

// repeated .draiosproto.jmx_bean beans = 2;
inline int java_info::beans_size() const {
  return beans_.size();
}
inline void java_info::clear_beans() {
  beans_.Clear();
}
inline const ::draiosproto::jmx_bean& java_info::beans(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.java_info.beans)
  return beans_.Get(index);
}
inline ::draiosproto::jmx_bean* java_info::mutable_beans(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.java_info.beans)
  return beans_.Mutable(index);
}
inline ::draiosproto::jmx_bean* java_info::add_beans() {
  // @@protoc_insertion_point(field_add:draiosproto.java_info.beans)
  return beans_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_bean >*
java_info::mutable_beans() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.java_info.beans)
  return &beans_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_bean >&
java_info::beans() const {
  // @@protoc_insertion_point(field_list:draiosproto.java_info.beans)
  return beans_;
}

inline const java_info* java_info::internal_default_instance() {
  return &java_info_default_instance_.get();
}
// -------------------------------------------------------------------

// statsd_tag

// required string key = 1;
inline bool statsd_tag::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void statsd_tag::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void statsd_tag::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void statsd_tag::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& statsd_tag::key() const {
  // @@protoc_insertion_point(field_get:draiosproto.statsd_tag.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void statsd_tag::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.statsd_tag.key)
}
inline void statsd_tag::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.statsd_tag.key)
}
inline void statsd_tag::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.statsd_tag.key)
}
inline ::std::string* statsd_tag::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:draiosproto.statsd_tag.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* statsd_tag::release_key() {
  // @@protoc_insertion_point(field_release:draiosproto.statsd_tag.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void statsd_tag::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.statsd_tag.key)
}

// optional string value = 2;
inline bool statsd_tag::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void statsd_tag::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void statsd_tag::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void statsd_tag::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& statsd_tag::value() const {
  // @@protoc_insertion_point(field_get:draiosproto.statsd_tag.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void statsd_tag::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.statsd_tag.value)
}
inline void statsd_tag::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.statsd_tag.value)
}
inline void statsd_tag::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.statsd_tag.value)
}
inline ::std::string* statsd_tag::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:draiosproto.statsd_tag.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* statsd_tag::release_value() {
  // @@protoc_insertion_point(field_release:draiosproto.statsd_tag.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void statsd_tag::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.statsd_tag.value)
}

inline const statsd_tag* statsd_tag::internal_default_instance() {
  return &statsd_tag_default_instance_.get();
}
// -------------------------------------------------------------------

// statsd_metric

// optional string name = 1;
inline bool statsd_metric::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void statsd_metric::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void statsd_metric::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void statsd_metric::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& statsd_metric::name() const {
  // @@protoc_insertion_point(field_get:draiosproto.statsd_metric.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void statsd_metric::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.statsd_metric.name)
}
inline void statsd_metric::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.statsd_metric.name)
}
inline void statsd_metric::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.statsd_metric.name)
}
inline ::std::string* statsd_metric::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:draiosproto.statsd_metric.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* statsd_metric::release_name() {
  // @@protoc_insertion_point(field_release:draiosproto.statsd_metric.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void statsd_metric::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.statsd_metric.name)
}

// repeated .draiosproto.statsd_tag tags = 2;
inline int statsd_metric::tags_size() const {
  return tags_.size();
}
inline void statsd_metric::clear_tags() {
  tags_.Clear();
}
inline const ::draiosproto::statsd_tag& statsd_metric::tags(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.statsd_metric.tags)
  return tags_.Get(index);
}
inline ::draiosproto::statsd_tag* statsd_metric::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.statsd_metric.tags)
  return tags_.Mutable(index);
}
inline ::draiosproto::statsd_tag* statsd_metric::add_tags() {
  // @@protoc_insertion_point(field_add:draiosproto.statsd_metric.tags)
  return tags_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::statsd_tag >*
statsd_metric::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.statsd_metric.tags)
  return &tags_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::statsd_tag >&
statsd_metric::tags() const {
  // @@protoc_insertion_point(field_list:draiosproto.statsd_metric.tags)
  return tags_;
}

// optional .draiosproto.statsd_metric_type type = 3;
inline bool statsd_metric::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void statsd_metric::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void statsd_metric::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void statsd_metric::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::draiosproto::statsd_metric_type statsd_metric::type() const {
  // @@protoc_insertion_point(field_get:draiosproto.statsd_metric.type)
  return static_cast< ::draiosproto::statsd_metric_type >(type_);
}
inline void statsd_metric::set_type(::draiosproto::statsd_metric_type value) {
  assert(::draiosproto::statsd_metric_type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.statsd_metric.type)
}

// optional double value = 4;
inline bool statsd_metric::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void statsd_metric::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void statsd_metric::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void statsd_metric::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double statsd_metric::value() const {
  // @@protoc_insertion_point(field_get:draiosproto.statsd_metric.value)
  return value_;
}
inline void statsd_metric::set_value(double value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.statsd_metric.value)
}

// optional double sum = 5;
inline bool statsd_metric::has_sum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void statsd_metric::set_has_sum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void statsd_metric::clear_has_sum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void statsd_metric::clear_sum() {
  sum_ = 0;
  clear_has_sum();
}
inline double statsd_metric::sum() const {
  // @@protoc_insertion_point(field_get:draiosproto.statsd_metric.sum)
  return sum_;
}
inline void statsd_metric::set_sum(double value) {
  set_has_sum();
  sum_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.statsd_metric.sum)
}

// optional double min = 6;
inline bool statsd_metric::has_min() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void statsd_metric::set_has_min() {
  _has_bits_[0] |= 0x00000020u;
}
inline void statsd_metric::clear_has_min() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void statsd_metric::clear_min() {
  min_ = 0;
  clear_has_min();
}
inline double statsd_metric::min() const {
  // @@protoc_insertion_point(field_get:draiosproto.statsd_metric.min)
  return min_;
}
inline void statsd_metric::set_min(double value) {
  set_has_min();
  min_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.statsd_metric.min)
}

// optional double max = 7;
inline bool statsd_metric::has_max() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void statsd_metric::set_has_max() {
  _has_bits_[0] |= 0x00000040u;
}
inline void statsd_metric::clear_has_max() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void statsd_metric::clear_max() {
  max_ = 0;
  clear_has_max();
}
inline double statsd_metric::max() const {
  // @@protoc_insertion_point(field_get:draiosproto.statsd_metric.max)
  return max_;
}
inline void statsd_metric::set_max(double value) {
  set_has_max();
  max_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.statsd_metric.max)
}

// optional double count = 8;
inline bool statsd_metric::has_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void statsd_metric::set_has_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void statsd_metric::clear_has_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void statsd_metric::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline double statsd_metric::count() const {
  // @@protoc_insertion_point(field_get:draiosproto.statsd_metric.count)
  return count_;
}
inline void statsd_metric::set_count(double value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.statsd_metric.count)
}

// optional double median = 9;
inline bool statsd_metric::has_median() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void statsd_metric::set_has_median() {
  _has_bits_[0] |= 0x00000100u;
}
inline void statsd_metric::clear_has_median() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void statsd_metric::clear_median() {
  median_ = 0;
  clear_has_median();
}
inline double statsd_metric::median() const {
  // @@protoc_insertion_point(field_get:draiosproto.statsd_metric.median)
  return median_;
}
inline void statsd_metric::set_median(double value) {
  set_has_median();
  median_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.statsd_metric.median)
}

// optional double percentile_95 = 10;
inline bool statsd_metric::has_percentile_95() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void statsd_metric::set_has_percentile_95() {
  _has_bits_[0] |= 0x00000200u;
}
inline void statsd_metric::clear_has_percentile_95() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void statsd_metric::clear_percentile_95() {
  percentile_95_ = 0;
  clear_has_percentile_95();
}
inline double statsd_metric::percentile_95() const {
  // @@protoc_insertion_point(field_get:draiosproto.statsd_metric.percentile_95)
  return percentile_95_;
}
inline void statsd_metric::set_percentile_95(double value) {
  set_has_percentile_95();
  percentile_95_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.statsd_metric.percentile_95)
}

// optional double percentile_99 = 11;
inline bool statsd_metric::has_percentile_99() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void statsd_metric::set_has_percentile_99() {
  _has_bits_[0] |= 0x00000400u;
}
inline void statsd_metric::clear_has_percentile_99() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void statsd_metric::clear_percentile_99() {
  percentile_99_ = 0;
  clear_has_percentile_99();
}
inline double statsd_metric::percentile_99() const {
  // @@protoc_insertion_point(field_get:draiosproto.statsd_metric.percentile_99)
  return percentile_99_;
}
inline void statsd_metric::set_percentile_99(double value) {
  set_has_percentile_99();
  percentile_99_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.statsd_metric.percentile_99)
}

inline const statsd_metric* statsd_metric::internal_default_instance() {
  return &statsd_metric_default_instance_.get();
}
// -------------------------------------------------------------------

// statsd_info

// repeated .draiosproto.statsd_metric statsd_metrics = 1;
inline int statsd_info::statsd_metrics_size() const {
  return statsd_metrics_.size();
}
inline void statsd_info::clear_statsd_metrics() {
  statsd_metrics_.Clear();
}
inline const ::draiosproto::statsd_metric& statsd_info::statsd_metrics(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.statsd_info.statsd_metrics)
  return statsd_metrics_.Get(index);
}
inline ::draiosproto::statsd_metric* statsd_info::mutable_statsd_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.statsd_info.statsd_metrics)
  return statsd_metrics_.Mutable(index);
}
inline ::draiosproto::statsd_metric* statsd_info::add_statsd_metrics() {
  // @@protoc_insertion_point(field_add:draiosproto.statsd_info.statsd_metrics)
  return statsd_metrics_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::statsd_metric >*
statsd_info::mutable_statsd_metrics() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.statsd_info.statsd_metrics)
  return &statsd_metrics_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::statsd_metric >&
statsd_info::statsd_metrics() const {
  // @@protoc_insertion_point(field_list:draiosproto.statsd_info.statsd_metrics)
  return statsd_metrics_;
}

inline const statsd_info* statsd_info::internal_default_instance() {
  return &statsd_info_default_instance_.get();
}
// -------------------------------------------------------------------

// app_tag

// required string key = 1;
inline bool app_tag::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void app_tag::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void app_tag::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void app_tag::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& app_tag::key() const {
  // @@protoc_insertion_point(field_get:draiosproto.app_tag.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void app_tag::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.app_tag.key)
}
inline void app_tag::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.app_tag.key)
}
inline void app_tag::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.app_tag.key)
}
inline ::std::string* app_tag::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:draiosproto.app_tag.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* app_tag::release_key() {
  // @@protoc_insertion_point(field_release:draiosproto.app_tag.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void app_tag::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.app_tag.key)
}

// optional string value = 2;
inline bool app_tag::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void app_tag::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void app_tag::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void app_tag::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& app_tag::value() const {
  // @@protoc_insertion_point(field_get:draiosproto.app_tag.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void app_tag::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.app_tag.value)
}
inline void app_tag::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.app_tag.value)
}
inline void app_tag::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.app_tag.value)
}
inline ::std::string* app_tag::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:draiosproto.app_tag.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* app_tag::release_value() {
  // @@protoc_insertion_point(field_release:draiosproto.app_tag.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void app_tag::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.app_tag.value)
}

inline const app_tag* app_tag::internal_default_instance() {
  return &app_tag_default_instance_.get();
}
// -------------------------------------------------------------------

// app_metric

// optional string name = 1;
inline bool app_metric::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void app_metric::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void app_metric::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void app_metric::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& app_metric::name() const {
  // @@protoc_insertion_point(field_get:draiosproto.app_metric.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void app_metric::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.app_metric.name)
}
inline void app_metric::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.app_metric.name)
}
inline void app_metric::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.app_metric.name)
}
inline ::std::string* app_metric::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:draiosproto.app_metric.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* app_metric::release_name() {
  // @@protoc_insertion_point(field_release:draiosproto.app_metric.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void app_metric::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.app_metric.name)
}

// optional .draiosproto.app_metric_type type = 2;
inline bool app_metric::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void app_metric::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void app_metric::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void app_metric::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::draiosproto::app_metric_type app_metric::type() const {
  // @@protoc_insertion_point(field_get:draiosproto.app_metric.type)
  return static_cast< ::draiosproto::app_metric_type >(type_);
}
inline void app_metric::set_type(::draiosproto::app_metric_type value) {
  assert(::draiosproto::app_metric_type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.app_metric.type)
}

// optional double value = 3;
inline bool app_metric::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void app_metric::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void app_metric::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void app_metric::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double app_metric::value() const {
  // @@protoc_insertion_point(field_get:draiosproto.app_metric.value)
  return value_;
}
inline void app_metric::set_value(double value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.app_metric.value)
}

// repeated .draiosproto.app_tag tags = 4;
inline int app_metric::tags_size() const {
  return tags_.size();
}
inline void app_metric::clear_tags() {
  tags_.Clear();
}
inline const ::draiosproto::app_tag& app_metric::tags(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.app_metric.tags)
  return tags_.Get(index);
}
inline ::draiosproto::app_tag* app_metric::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.app_metric.tags)
  return tags_.Mutable(index);
}
inline ::draiosproto::app_tag* app_metric::add_tags() {
  // @@protoc_insertion_point(field_add:draiosproto.app_metric.tags)
  return tags_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::app_tag >*
app_metric::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.app_metric.tags)
  return &tags_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::app_tag >&
app_metric::tags() const {
  // @@protoc_insertion_point(field_list:draiosproto.app_metric.tags)
  return tags_;
}

inline const app_metric* app_metric::internal_default_instance() {
  return &app_metric_default_instance_.get();
}
// -------------------------------------------------------------------

// app_check

// optional string name = 1;
inline bool app_check::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void app_check::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void app_check::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void app_check::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& app_check::name() const {
  // @@protoc_insertion_point(field_get:draiosproto.app_check.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void app_check::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.app_check.name)
}
inline void app_check::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.app_check.name)
}
inline void app_check::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.app_check.name)
}
inline ::std::string* app_check::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:draiosproto.app_check.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* app_check::release_name() {
  // @@protoc_insertion_point(field_release:draiosproto.app_check.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void app_check::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.app_check.name)
}

// optional .draiosproto.app_check_value value = 2;
inline bool app_check::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void app_check::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void app_check::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void app_check::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::draiosproto::app_check_value app_check::value() const {
  // @@protoc_insertion_point(field_get:draiosproto.app_check.value)
  return static_cast< ::draiosproto::app_check_value >(value_);
}
inline void app_check::set_value(::draiosproto::app_check_value value) {
  assert(::draiosproto::app_check_value_IsValid(value));
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.app_check.value)
}

// repeated .draiosproto.app_tag tags = 3;
inline int app_check::tags_size() const {
  return tags_.size();
}
inline void app_check::clear_tags() {
  tags_.Clear();
}
inline const ::draiosproto::app_tag& app_check::tags(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.app_check.tags)
  return tags_.Get(index);
}
inline ::draiosproto::app_tag* app_check::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.app_check.tags)
  return tags_.Mutable(index);
}
inline ::draiosproto::app_tag* app_check::add_tags() {
  // @@protoc_insertion_point(field_add:draiosproto.app_check.tags)
  return tags_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::app_tag >*
app_check::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.app_check.tags)
  return &tags_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::app_tag >&
app_check::tags() const {
  // @@protoc_insertion_point(field_list:draiosproto.app_check.tags)
  return tags_;
}

inline const app_check* app_check::internal_default_instance() {
  return &app_check_default_instance_.get();
}
// -------------------------------------------------------------------

// app_info

// optional string process_name = 1;
inline bool app_info::has_process_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void app_info::set_has_process_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void app_info::clear_has_process_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void app_info::clear_process_name() {
  process_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_process_name();
}
inline const ::std::string& app_info::process_name() const {
  // @@protoc_insertion_point(field_get:draiosproto.app_info.process_name)
  return process_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void app_info::set_process_name(const ::std::string& value) {
  set_has_process_name();
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.app_info.process_name)
}
inline void app_info::set_process_name(const char* value) {
  set_has_process_name();
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.app_info.process_name)
}
inline void app_info::set_process_name(const char* value, size_t size) {
  set_has_process_name();
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.app_info.process_name)
}
inline ::std::string* app_info::mutable_process_name() {
  set_has_process_name();
  // @@protoc_insertion_point(field_mutable:draiosproto.app_info.process_name)
  return process_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* app_info::release_process_name() {
  // @@protoc_insertion_point(field_release:draiosproto.app_info.process_name)
  clear_has_process_name();
  return process_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void app_info::set_allocated_process_name(::std::string* process_name) {
  if (process_name != NULL) {
    set_has_process_name();
  } else {
    clear_has_process_name();
  }
  process_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), process_name);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.app_info.process_name)
}

// repeated .draiosproto.app_metric metrics = 2;
inline int app_info::metrics_size() const {
  return metrics_.size();
}
inline void app_info::clear_metrics() {
  metrics_.Clear();
}
inline const ::draiosproto::app_metric& app_info::metrics(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.app_info.metrics)
  return metrics_.Get(index);
}
inline ::draiosproto::app_metric* app_info::mutable_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.app_info.metrics)
  return metrics_.Mutable(index);
}
inline ::draiosproto::app_metric* app_info::add_metrics() {
  // @@protoc_insertion_point(field_add:draiosproto.app_info.metrics)
  return metrics_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::app_metric >*
app_info::mutable_metrics() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.app_info.metrics)
  return &metrics_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::app_metric >&
app_info::metrics() const {
  // @@protoc_insertion_point(field_list:draiosproto.app_info.metrics)
  return metrics_;
}

// repeated .draiosproto.app_check checks = 3;
inline int app_info::checks_size() const {
  return checks_.size();
}
inline void app_info::clear_checks() {
  checks_.Clear();
}
inline const ::draiosproto::app_check& app_info::checks(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.app_info.checks)
  return checks_.Get(index);
}
inline ::draiosproto::app_check* app_info::mutable_checks(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.app_info.checks)
  return checks_.Mutable(index);
}
inline ::draiosproto::app_check* app_info::add_checks() {
  // @@protoc_insertion_point(field_add:draiosproto.app_info.checks)
  return checks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::app_check >*
app_info::mutable_checks() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.app_info.checks)
  return &checks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::app_check >&
app_info::checks() const {
  // @@protoc_insertion_point(field_list:draiosproto.app_info.checks)
  return checks_;
}

inline const app_info* app_info::internal_default_instance() {
  return &app_info_default_instance_.get();
}
// -------------------------------------------------------------------

// proto_info

// optional .draiosproto.http_info http = 1;
inline bool proto_info::has_http() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void proto_info::set_has_http() {
  _has_bits_[0] |= 0x00000001u;
}
inline void proto_info::clear_has_http() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void proto_info::clear_http() {
  if (http_ != NULL) http_->::draiosproto::http_info::Clear();
  clear_has_http();
}
inline const ::draiosproto::http_info& proto_info::http() const {
  // @@protoc_insertion_point(field_get:draiosproto.proto_info.http)
  return http_ != NULL ? *http_
                         : *::draiosproto::http_info::internal_default_instance();
}
inline ::draiosproto::http_info* proto_info::mutable_http() {
  set_has_http();
  if (http_ == NULL) {
    http_ = new ::draiosproto::http_info;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.proto_info.http)
  return http_;
}
inline ::draiosproto::http_info* proto_info::release_http() {
  // @@protoc_insertion_point(field_release:draiosproto.proto_info.http)
  clear_has_http();
  ::draiosproto::http_info* temp = http_;
  http_ = NULL;
  return temp;
}
inline void proto_info::set_allocated_http(::draiosproto::http_info* http) {
  delete http_;
  http_ = http;
  if (http) {
    set_has_http();
  } else {
    clear_has_http();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.proto_info.http)
}

// optional .draiosproto.sql_info mysql = 2;
inline bool proto_info::has_mysql() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void proto_info::set_has_mysql() {
  _has_bits_[0] |= 0x00000002u;
}
inline void proto_info::clear_has_mysql() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void proto_info::clear_mysql() {
  if (mysql_ != NULL) mysql_->::draiosproto::sql_info::Clear();
  clear_has_mysql();
}
inline const ::draiosproto::sql_info& proto_info::mysql() const {
  // @@protoc_insertion_point(field_get:draiosproto.proto_info.mysql)
  return mysql_ != NULL ? *mysql_
                         : *::draiosproto::sql_info::internal_default_instance();
}
inline ::draiosproto::sql_info* proto_info::mutable_mysql() {
  set_has_mysql();
  if (mysql_ == NULL) {
    mysql_ = new ::draiosproto::sql_info;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.proto_info.mysql)
  return mysql_;
}
inline ::draiosproto::sql_info* proto_info::release_mysql() {
  // @@protoc_insertion_point(field_release:draiosproto.proto_info.mysql)
  clear_has_mysql();
  ::draiosproto::sql_info* temp = mysql_;
  mysql_ = NULL;
  return temp;
}
inline void proto_info::set_allocated_mysql(::draiosproto::sql_info* mysql) {
  delete mysql_;
  mysql_ = mysql;
  if (mysql) {
    set_has_mysql();
  } else {
    clear_has_mysql();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.proto_info.mysql)
}

// optional .draiosproto.sql_info postgres = 3;
inline bool proto_info::has_postgres() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void proto_info::set_has_postgres() {
  _has_bits_[0] |= 0x00000004u;
}
inline void proto_info::clear_has_postgres() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void proto_info::clear_postgres() {
  if (postgres_ != NULL) postgres_->::draiosproto::sql_info::Clear();
  clear_has_postgres();
}
inline const ::draiosproto::sql_info& proto_info::postgres() const {
  // @@protoc_insertion_point(field_get:draiosproto.proto_info.postgres)
  return postgres_ != NULL ? *postgres_
                         : *::draiosproto::sql_info::internal_default_instance();
}
inline ::draiosproto::sql_info* proto_info::mutable_postgres() {
  set_has_postgres();
  if (postgres_ == NULL) {
    postgres_ = new ::draiosproto::sql_info;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.proto_info.postgres)
  return postgres_;
}
inline ::draiosproto::sql_info* proto_info::release_postgres() {
  // @@protoc_insertion_point(field_release:draiosproto.proto_info.postgres)
  clear_has_postgres();
  ::draiosproto::sql_info* temp = postgres_;
  postgres_ = NULL;
  return temp;
}
inline void proto_info::set_allocated_postgres(::draiosproto::sql_info* postgres) {
  delete postgres_;
  postgres_ = postgres;
  if (postgres) {
    set_has_postgres();
  } else {
    clear_has_postgres();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.proto_info.postgres)
}

// optional .draiosproto.mongodb_info mongodb = 4;
inline bool proto_info::has_mongodb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void proto_info::set_has_mongodb() {
  _has_bits_[0] |= 0x00000008u;
}
inline void proto_info::clear_has_mongodb() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void proto_info::clear_mongodb() {
  if (mongodb_ != NULL) mongodb_->::draiosproto::mongodb_info::Clear();
  clear_has_mongodb();
}
inline const ::draiosproto::mongodb_info& proto_info::mongodb() const {
  // @@protoc_insertion_point(field_get:draiosproto.proto_info.mongodb)
  return mongodb_ != NULL ? *mongodb_
                         : *::draiosproto::mongodb_info::internal_default_instance();
}
inline ::draiosproto::mongodb_info* proto_info::mutable_mongodb() {
  set_has_mongodb();
  if (mongodb_ == NULL) {
    mongodb_ = new ::draiosproto::mongodb_info;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.proto_info.mongodb)
  return mongodb_;
}
inline ::draiosproto::mongodb_info* proto_info::release_mongodb() {
  // @@protoc_insertion_point(field_release:draiosproto.proto_info.mongodb)
  clear_has_mongodb();
  ::draiosproto::mongodb_info* temp = mongodb_;
  mongodb_ = NULL;
  return temp;
}
inline void proto_info::set_allocated_mongodb(::draiosproto::mongodb_info* mongodb) {
  delete mongodb_;
  mongodb_ = mongodb;
  if (mongodb) {
    set_has_mongodb();
  } else {
    clear_has_mongodb();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.proto_info.mongodb)
}

// optional .draiosproto.java_info java = 5;
inline bool proto_info::has_java() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void proto_info::set_has_java() {
  _has_bits_[0] |= 0x00000010u;
}
inline void proto_info::clear_has_java() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void proto_info::clear_java() {
  if (java_ != NULL) java_->::draiosproto::java_info::Clear();
  clear_has_java();
}
inline const ::draiosproto::java_info& proto_info::java() const {
  // @@protoc_insertion_point(field_get:draiosproto.proto_info.java)
  return java_ != NULL ? *java_
                         : *::draiosproto::java_info::internal_default_instance();
}
inline ::draiosproto::java_info* proto_info::mutable_java() {
  set_has_java();
  if (java_ == NULL) {
    java_ = new ::draiosproto::java_info;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.proto_info.java)
  return java_;
}
inline ::draiosproto::java_info* proto_info::release_java() {
  // @@protoc_insertion_point(field_release:draiosproto.proto_info.java)
  clear_has_java();
  ::draiosproto::java_info* temp = java_;
  java_ = NULL;
  return temp;
}
inline void proto_info::set_allocated_java(::draiosproto::java_info* java) {
  delete java_;
  java_ = java;
  if (java) {
    set_has_java();
  } else {
    clear_has_java();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.proto_info.java)
}

// optional .draiosproto.statsd_info statsd = 6;
inline bool proto_info::has_statsd() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void proto_info::set_has_statsd() {
  _has_bits_[0] |= 0x00000020u;
}
inline void proto_info::clear_has_statsd() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void proto_info::clear_statsd() {
  if (statsd_ != NULL) statsd_->::draiosproto::statsd_info::Clear();
  clear_has_statsd();
}
inline const ::draiosproto::statsd_info& proto_info::statsd() const {
  // @@protoc_insertion_point(field_get:draiosproto.proto_info.statsd)
  return statsd_ != NULL ? *statsd_
                         : *::draiosproto::statsd_info::internal_default_instance();
}
inline ::draiosproto::statsd_info* proto_info::mutable_statsd() {
  set_has_statsd();
  if (statsd_ == NULL) {
    statsd_ = new ::draiosproto::statsd_info;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.proto_info.statsd)
  return statsd_;
}
inline ::draiosproto::statsd_info* proto_info::release_statsd() {
  // @@protoc_insertion_point(field_release:draiosproto.proto_info.statsd)
  clear_has_statsd();
  ::draiosproto::statsd_info* temp = statsd_;
  statsd_ = NULL;
  return temp;
}
inline void proto_info::set_allocated_statsd(::draiosproto::statsd_info* statsd) {
  delete statsd_;
  statsd_ = statsd;
  if (statsd) {
    set_has_statsd();
  } else {
    clear_has_statsd();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.proto_info.statsd)
}

// optional .draiosproto.app_info app = 7;
inline bool proto_info::has_app() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void proto_info::set_has_app() {
  _has_bits_[0] |= 0x00000040u;
}
inline void proto_info::clear_has_app() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void proto_info::clear_app() {
  if (app_ != NULL) app_->::draiosproto::app_info::Clear();
  clear_has_app();
}
inline const ::draiosproto::app_info& proto_info::app() const {
  // @@protoc_insertion_point(field_get:draiosproto.proto_info.app)
  return app_ != NULL ? *app_
                         : *::draiosproto::app_info::internal_default_instance();
}
inline ::draiosproto::app_info* proto_info::mutable_app() {
  set_has_app();
  if (app_ == NULL) {
    app_ = new ::draiosproto::app_info;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.proto_info.app)
  return app_;
}
inline ::draiosproto::app_info* proto_info::release_app() {
  // @@protoc_insertion_point(field_release:draiosproto.proto_info.app)
  clear_has_app();
  ::draiosproto::app_info* temp = app_;
  app_ = NULL;
  return temp;
}
inline void proto_info::set_allocated_app(::draiosproto::app_info* app) {
  delete app_;
  app_ = app;
  if (app) {
    set_has_app();
  } else {
    clear_has_app();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.proto_info.app)
}

inline const proto_info* proto_info::internal_default_instance() {
  return &proto_info_default_instance_.get();
}
// -------------------------------------------------------------------

// network_by_port

// required uint32 port = 1;
inline bool network_by_port::has_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void network_by_port::set_has_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void network_by_port::clear_has_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void network_by_port::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 network_by_port::port() const {
  // @@protoc_insertion_point(field_get:draiosproto.network_by_port.port)
  return port_;
}
inline void network_by_port::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.network_by_port.port)
}

// required .draiosproto.connection_categories counters = 2;
inline bool network_by_port::has_counters() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void network_by_port::set_has_counters() {
  _has_bits_[0] |= 0x00000002u;
}
inline void network_by_port::clear_has_counters() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void network_by_port::clear_counters() {
  if (counters_ != NULL) counters_->::draiosproto::connection_categories::Clear();
  clear_has_counters();
}
inline const ::draiosproto::connection_categories& network_by_port::counters() const {
  // @@protoc_insertion_point(field_get:draiosproto.network_by_port.counters)
  return counters_ != NULL ? *counters_
                         : *::draiosproto::connection_categories::internal_default_instance();
}
inline ::draiosproto::connection_categories* network_by_port::mutable_counters() {
  set_has_counters();
  if (counters_ == NULL) {
    counters_ = new ::draiosproto::connection_categories;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.network_by_port.counters)
  return counters_;
}
inline ::draiosproto::connection_categories* network_by_port::release_counters() {
  // @@protoc_insertion_point(field_release:draiosproto.network_by_port.counters)
  clear_has_counters();
  ::draiosproto::connection_categories* temp = counters_;
  counters_ = NULL;
  return temp;
}
inline void network_by_port::set_allocated_counters(::draiosproto::connection_categories* counters) {
  delete counters_;
  counters_ = counters;
  if (counters) {
    set_has_counters();
  } else {
    clear_has_counters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.network_by_port.counters)
}

inline const network_by_port* network_by_port::internal_default_instance() {
  return &network_by_port_default_instance_.get();
}
// -------------------------------------------------------------------

// host

// optional string hostname = 1;
inline bool host::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void host::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void host::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void host::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hostname();
}
inline const ::std::string& host::hostname() const {
  // @@protoc_insertion_point(field_get:draiosproto.host.hostname)
  return hostname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void host::set_hostname(const ::std::string& value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.host.hostname)
}
inline void host::set_hostname(const char* value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.host.hostname)
}
inline void host::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.host.hostname)
}
inline ::std::string* host::mutable_hostname() {
  set_has_hostname();
  // @@protoc_insertion_point(field_mutable:draiosproto.host.hostname)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* host::release_hostname() {
  // @@protoc_insertion_point(field_release:draiosproto.host.hostname)
  clear_has_hostname();
  return hostname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void host::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.host.hostname)
}

// optional uint32 num_cpus = 2;
inline bool host::has_num_cpus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void host::set_has_num_cpus() {
  _has_bits_[0] |= 0x00000002u;
}
inline void host::clear_has_num_cpus() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void host::clear_num_cpus() {
  num_cpus_ = 0u;
  clear_has_num_cpus();
}
inline ::google::protobuf::uint32 host::num_cpus() const {
  // @@protoc_insertion_point(field_get:draiosproto.host.num_cpus)
  return num_cpus_;
}
inline void host::set_num_cpus(::google::protobuf::uint32 value) {
  set_has_num_cpus();
  num_cpus_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.host.num_cpus)
}

// repeated uint32 cpu_loads = 3;
inline int host::cpu_loads_size() const {
  return cpu_loads_.size();
}
inline void host::clear_cpu_loads() {
  cpu_loads_.Clear();
}
inline ::google::protobuf::uint32 host::cpu_loads(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.host.cpu_loads)
  return cpu_loads_.Get(index);
}
inline void host::set_cpu_loads(int index, ::google::protobuf::uint32 value) {
  cpu_loads_.Set(index, value);
  // @@protoc_insertion_point(field_set:draiosproto.host.cpu_loads)
}
inline void host::add_cpu_loads(::google::protobuf::uint32 value) {
  cpu_loads_.Add(value);
  // @@protoc_insertion_point(field_add:draiosproto.host.cpu_loads)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
host::cpu_loads() const {
  // @@protoc_insertion_point(field_list:draiosproto.host.cpu_loads)
  return cpu_loads_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
host::mutable_cpu_loads() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.host.cpu_loads)
  return &cpu_loads_;
}

// repeated uint32 cpu_steal = 11;
inline int host::cpu_steal_size() const {
  return cpu_steal_.size();
}
inline void host::clear_cpu_steal() {
  cpu_steal_.Clear();
}
inline ::google::protobuf::uint32 host::cpu_steal(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.host.cpu_steal)
  return cpu_steal_.Get(index);
}
inline void host::set_cpu_steal(int index, ::google::protobuf::uint32 value) {
  cpu_steal_.Set(index, value);
  // @@protoc_insertion_point(field_set:draiosproto.host.cpu_steal)
}
inline void host::add_cpu_steal(::google::protobuf::uint32 value) {
  cpu_steal_.Add(value);
  // @@protoc_insertion_point(field_add:draiosproto.host.cpu_steal)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
host::cpu_steal() const {
  // @@protoc_insertion_point(field_list:draiosproto.host.cpu_steal)
  return cpu_steal_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
host::mutable_cpu_steal() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.host.cpu_steal)
  return &cpu_steal_;
}

// required uint64 physical_memory_size_bytes = 4;
inline bool host::has_physical_memory_size_bytes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void host::set_has_physical_memory_size_bytes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void host::clear_has_physical_memory_size_bytes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void host::clear_physical_memory_size_bytes() {
  physical_memory_size_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_physical_memory_size_bytes();
}
inline ::google::protobuf::uint64 host::physical_memory_size_bytes() const {
  // @@protoc_insertion_point(field_get:draiosproto.host.physical_memory_size_bytes)
  return physical_memory_size_bytes_;
}
inline void host::set_physical_memory_size_bytes(::google::protobuf::uint64 value) {
  set_has_physical_memory_size_bytes();
  physical_memory_size_bytes_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.host.physical_memory_size_bytes)
}

// optional .draiosproto.time_categories tcounters = 5;
inline bool host::has_tcounters() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void host::set_has_tcounters() {
  _has_bits_[0] |= 0x00000020u;
}
inline void host::clear_has_tcounters() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void host::clear_tcounters() {
  if (tcounters_ != NULL) tcounters_->::draiosproto::time_categories::Clear();
  clear_has_tcounters();
}
inline const ::draiosproto::time_categories& host::tcounters() const {
  // @@protoc_insertion_point(field_get:draiosproto.host.tcounters)
  return tcounters_ != NULL ? *tcounters_
                         : *::draiosproto::time_categories::internal_default_instance();
}
inline ::draiosproto::time_categories* host::mutable_tcounters() {
  set_has_tcounters();
  if (tcounters_ == NULL) {
    tcounters_ = new ::draiosproto::time_categories;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.host.tcounters)
  return tcounters_;
}
inline ::draiosproto::time_categories* host::release_tcounters() {
  // @@protoc_insertion_point(field_release:draiosproto.host.tcounters)
  clear_has_tcounters();
  ::draiosproto::time_categories* temp = tcounters_;
  tcounters_ = NULL;
  return temp;
}
inline void host::set_allocated_tcounters(::draiosproto::time_categories* tcounters) {
  delete tcounters_;
  tcounters_ = tcounters;
  if (tcounters) {
    set_has_tcounters();
  } else {
    clear_has_tcounters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.host.tcounters)
}

// optional .draiosproto.transaction_breakdown_categories reqcounters = 12;
inline bool host::has_reqcounters() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void host::set_has_reqcounters() {
  _has_bits_[0] |= 0x00000040u;
}
inline void host::clear_has_reqcounters() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void host::clear_reqcounters() {
  if (reqcounters_ != NULL) reqcounters_->::draiosproto::transaction_breakdown_categories::Clear();
  clear_has_reqcounters();
}
inline const ::draiosproto::transaction_breakdown_categories& host::reqcounters() const {
  // @@protoc_insertion_point(field_get:draiosproto.host.reqcounters)
  return reqcounters_ != NULL ? *reqcounters_
                         : *::draiosproto::transaction_breakdown_categories::internal_default_instance();
}
inline ::draiosproto::transaction_breakdown_categories* host::mutable_reqcounters() {
  set_has_reqcounters();
  if (reqcounters_ == NULL) {
    reqcounters_ = new ::draiosproto::transaction_breakdown_categories;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.host.reqcounters)
  return reqcounters_;
}
inline ::draiosproto::transaction_breakdown_categories* host::release_reqcounters() {
  // @@protoc_insertion_point(field_release:draiosproto.host.reqcounters)
  clear_has_reqcounters();
  ::draiosproto::transaction_breakdown_categories* temp = reqcounters_;
  reqcounters_ = NULL;
  return temp;
}
inline void host::set_allocated_reqcounters(::draiosproto::transaction_breakdown_categories* reqcounters) {
  delete reqcounters_;
  reqcounters_ = reqcounters;
  if (reqcounters) {
    set_has_reqcounters();
  } else {
    clear_has_reqcounters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.host.reqcounters)
}

// optional .draiosproto.counter_time_bidirectional transaction_counters = 6;
inline bool host::has_transaction_counters() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void host::set_has_transaction_counters() {
  _has_bits_[0] |= 0x00000080u;
}
inline void host::clear_has_transaction_counters() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void host::clear_transaction_counters() {
  if (transaction_counters_ != NULL) transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& host::transaction_counters() const {
  // @@protoc_insertion_point(field_get:draiosproto.host.transaction_counters)
  return transaction_counters_ != NULL ? *transaction_counters_
                         : *::draiosproto::counter_time_bidirectional::internal_default_instance();
}
inline ::draiosproto::counter_time_bidirectional* host::mutable_transaction_counters() {
  set_has_transaction_counters();
  if (transaction_counters_ == NULL) {
    transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.host.transaction_counters)
  return transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* host::release_transaction_counters() {
  // @@protoc_insertion_point(field_release:draiosproto.host.transaction_counters)
  clear_has_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = transaction_counters_;
  transaction_counters_ = NULL;
  return temp;
}
inline void host::set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters) {
  delete transaction_counters_;
  transaction_counters_ = transaction_counters;
  if (transaction_counters) {
    set_has_transaction_counters();
  } else {
    clear_has_transaction_counters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.host.transaction_counters)
}

// optional .draiosproto.counter_time_bidirectional min_transaction_counters = 22;
inline bool host::has_min_transaction_counters() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void host::set_has_min_transaction_counters() {
  _has_bits_[0] |= 0x00000100u;
}
inline void host::clear_has_min_transaction_counters() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void host::clear_min_transaction_counters() {
  if (min_transaction_counters_ != NULL) min_transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_min_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& host::min_transaction_counters() const {
  // @@protoc_insertion_point(field_get:draiosproto.host.min_transaction_counters)
  return min_transaction_counters_ != NULL ? *min_transaction_counters_
                         : *::draiosproto::counter_time_bidirectional::internal_default_instance();
}
inline ::draiosproto::counter_time_bidirectional* host::mutable_min_transaction_counters() {
  set_has_min_transaction_counters();
  if (min_transaction_counters_ == NULL) {
    min_transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.host.min_transaction_counters)
  return min_transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* host::release_min_transaction_counters() {
  // @@protoc_insertion_point(field_release:draiosproto.host.min_transaction_counters)
  clear_has_min_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = min_transaction_counters_;
  min_transaction_counters_ = NULL;
  return temp;
}
inline void host::set_allocated_min_transaction_counters(::draiosproto::counter_time_bidirectional* min_transaction_counters) {
  delete min_transaction_counters_;
  min_transaction_counters_ = min_transaction_counters;
  if (min_transaction_counters) {
    set_has_min_transaction_counters();
  } else {
    clear_has_min_transaction_counters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.host.min_transaction_counters)
}

// optional .draiosproto.counter_time_bidirectional max_transaction_counters = 23;
inline bool host::has_max_transaction_counters() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void host::set_has_max_transaction_counters() {
  _has_bits_[0] |= 0x00000200u;
}
inline void host::clear_has_max_transaction_counters() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void host::clear_max_transaction_counters() {
  if (max_transaction_counters_ != NULL) max_transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_max_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& host::max_transaction_counters() const {
  // @@protoc_insertion_point(field_get:draiosproto.host.max_transaction_counters)
  return max_transaction_counters_ != NULL ? *max_transaction_counters_
                         : *::draiosproto::counter_time_bidirectional::internal_default_instance();
}
inline ::draiosproto::counter_time_bidirectional* host::mutable_max_transaction_counters() {
  set_has_max_transaction_counters();
  if (max_transaction_counters_ == NULL) {
    max_transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.host.max_transaction_counters)
  return max_transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* host::release_max_transaction_counters() {
  // @@protoc_insertion_point(field_release:draiosproto.host.max_transaction_counters)
  clear_has_max_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = max_transaction_counters_;
  max_transaction_counters_ = NULL;
  return temp;
}
inline void host::set_allocated_max_transaction_counters(::draiosproto::counter_time_bidirectional* max_transaction_counters) {
  delete max_transaction_counters_;
  max_transaction_counters_ = max_transaction_counters;
  if (max_transaction_counters) {
    set_has_max_transaction_counters();
  } else {
    clear_has_max_transaction_counters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.host.max_transaction_counters)
}

// optional uint64 transaction_processing_delay = 7;
inline bool host::has_transaction_processing_delay() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void host::set_has_transaction_processing_delay() {
  _has_bits_[0] |= 0x00000400u;
}
inline void host::clear_has_transaction_processing_delay() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void host::clear_transaction_processing_delay() {
  transaction_processing_delay_ = GOOGLE_ULONGLONG(0);
  clear_has_transaction_processing_delay();
}
inline ::google::protobuf::uint64 host::transaction_processing_delay() const {
  // @@protoc_insertion_point(field_get:draiosproto.host.transaction_processing_delay)
  return transaction_processing_delay_;
}
inline void host::set_transaction_processing_delay(::google::protobuf::uint64 value) {
  set_has_transaction_processing_delay();
  transaction_processing_delay_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.host.transaction_processing_delay)
}

// optional uint64 next_tiers_delay = 13;
inline bool host::has_next_tiers_delay() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void host::set_has_next_tiers_delay() {
  _has_bits_[0] |= 0x00000800u;
}
inline void host::clear_has_next_tiers_delay() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void host::clear_next_tiers_delay() {
  next_tiers_delay_ = GOOGLE_ULONGLONG(0);
  clear_has_next_tiers_delay();
}
inline ::google::protobuf::uint64 host::next_tiers_delay() const {
  // @@protoc_insertion_point(field_get:draiosproto.host.next_tiers_delay)
  return next_tiers_delay_;
}
inline void host::set_next_tiers_delay(::google::protobuf::uint64 value) {
  set_has_next_tiers_delay();
  next_tiers_delay_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.host.next_tiers_delay)
}

// optional .draiosproto.resource_categories resource_counters = 8;
inline bool host::has_resource_counters() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void host::set_has_resource_counters() {
  _has_bits_[0] |= 0x00001000u;
}
inline void host::clear_has_resource_counters() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void host::clear_resource_counters() {
  if (resource_counters_ != NULL) resource_counters_->::draiosproto::resource_categories::Clear();
  clear_has_resource_counters();
}
inline const ::draiosproto::resource_categories& host::resource_counters() const {
  // @@protoc_insertion_point(field_get:draiosproto.host.resource_counters)
  return resource_counters_ != NULL ? *resource_counters_
                         : *::draiosproto::resource_categories::internal_default_instance();
}
inline ::draiosproto::resource_categories* host::mutable_resource_counters() {
  set_has_resource_counters();
  if (resource_counters_ == NULL) {
    resource_counters_ = new ::draiosproto::resource_categories;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.host.resource_counters)
  return resource_counters_;
}
inline ::draiosproto::resource_categories* host::release_resource_counters() {
  // @@protoc_insertion_point(field_release:draiosproto.host.resource_counters)
  clear_has_resource_counters();
  ::draiosproto::resource_categories* temp = resource_counters_;
  resource_counters_ = NULL;
  return temp;
}
inline void host::set_allocated_resource_counters(::draiosproto::resource_categories* resource_counters) {
  delete resource_counters_;
  resource_counters_ = resource_counters;
  if (resource_counters) {
    set_has_resource_counters();
  } else {
    clear_has_resource_counters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.host.resource_counters)
}

// optional .draiosproto.counter_syscall_errors syscall_errors = 9;
inline bool host::has_syscall_errors() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void host::set_has_syscall_errors() {
  _has_bits_[0] |= 0x00002000u;
}
inline void host::clear_has_syscall_errors() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void host::clear_syscall_errors() {
  if (syscall_errors_ != NULL) syscall_errors_->::draiosproto::counter_syscall_errors::Clear();
  clear_has_syscall_errors();
}
inline const ::draiosproto::counter_syscall_errors& host::syscall_errors() const {
  // @@protoc_insertion_point(field_get:draiosproto.host.syscall_errors)
  return syscall_errors_ != NULL ? *syscall_errors_
                         : *::draiosproto::counter_syscall_errors::internal_default_instance();
}
inline ::draiosproto::counter_syscall_errors* host::mutable_syscall_errors() {
  set_has_syscall_errors();
  if (syscall_errors_ == NULL) {
    syscall_errors_ = new ::draiosproto::counter_syscall_errors;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.host.syscall_errors)
  return syscall_errors_;
}
inline ::draiosproto::counter_syscall_errors* host::release_syscall_errors() {
  // @@protoc_insertion_point(field_release:draiosproto.host.syscall_errors)
  clear_has_syscall_errors();
  ::draiosproto::counter_syscall_errors* temp = syscall_errors_;
  syscall_errors_ = NULL;
  return temp;
}
inline void host::set_allocated_syscall_errors(::draiosproto::counter_syscall_errors* syscall_errors) {
  delete syscall_errors_;
  syscall_errors_ = syscall_errors;
  if (syscall_errors) {
    set_has_syscall_errors();
  } else {
    clear_has_syscall_errors();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.host.syscall_errors)
}

// optional .draiosproto.counter_time_bytes external_io_net = 10;
inline bool host::has_external_io_net() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void host::set_has_external_io_net() {
  _has_bits_[0] |= 0x00004000u;
}
inline void host::clear_has_external_io_net() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void host::clear_external_io_net() {
  if (external_io_net_ != NULL) external_io_net_->::draiosproto::counter_time_bytes::Clear();
  clear_has_external_io_net();
}
inline const ::draiosproto::counter_time_bytes& host::external_io_net() const {
  // @@protoc_insertion_point(field_get:draiosproto.host.external_io_net)
  return external_io_net_ != NULL ? *external_io_net_
                         : *::draiosproto::counter_time_bytes::internal_default_instance();
}
inline ::draiosproto::counter_time_bytes* host::mutable_external_io_net() {
  set_has_external_io_net();
  if (external_io_net_ == NULL) {
    external_io_net_ = new ::draiosproto::counter_time_bytes;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.host.external_io_net)
  return external_io_net_;
}
inline ::draiosproto::counter_time_bytes* host::release_external_io_net() {
  // @@protoc_insertion_point(field_release:draiosproto.host.external_io_net)
  clear_has_external_io_net();
  ::draiosproto::counter_time_bytes* temp = external_io_net_;
  external_io_net_ = NULL;
  return temp;
}
inline void host::set_allocated_external_io_net(::draiosproto::counter_time_bytes* external_io_net) {
  delete external_io_net_;
  external_io_net_ = external_io_net;
  if (external_io_net) {
    set_has_external_io_net();
  } else {
    clear_has_external_io_net();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.host.external_io_net)
}

// repeated .draiosproto.network_by_port network_by_serverports = 24;
inline int host::network_by_serverports_size() const {
  return network_by_serverports_.size();
}
inline void host::clear_network_by_serverports() {
  network_by_serverports_.Clear();
}
inline const ::draiosproto::network_by_port& host::network_by_serverports(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.host.network_by_serverports)
  return network_by_serverports_.Get(index);
}
inline ::draiosproto::network_by_port* host::mutable_network_by_serverports(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.host.network_by_serverports)
  return network_by_serverports_.Mutable(index);
}
inline ::draiosproto::network_by_port* host::add_network_by_serverports() {
  // @@protoc_insertion_point(field_add:draiosproto.host.network_by_serverports)
  return network_by_serverports_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::network_by_port >*
host::mutable_network_by_serverports() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.host.network_by_serverports)
  return &network_by_serverports_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::network_by_port >&
host::network_by_serverports() const {
  // @@protoc_insertion_point(field_list:draiosproto.host.network_by_serverports)
  return network_by_serverports_;
}

// repeated uint32 cpu_idle = 25;
inline int host::cpu_idle_size() const {
  return cpu_idle_.size();
}
inline void host::clear_cpu_idle() {
  cpu_idle_.Clear();
}
inline ::google::protobuf::uint32 host::cpu_idle(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.host.cpu_idle)
  return cpu_idle_.Get(index);
}
inline void host::set_cpu_idle(int index, ::google::protobuf::uint32 value) {
  cpu_idle_.Set(index, value);
  // @@protoc_insertion_point(field_set:draiosproto.host.cpu_idle)
}
inline void host::add_cpu_idle(::google::protobuf::uint32 value) {
  cpu_idle_.Add(value);
  // @@protoc_insertion_point(field_add:draiosproto.host.cpu_idle)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
host::cpu_idle() const {
  // @@protoc_insertion_point(field_list:draiosproto.host.cpu_idle)
  return cpu_idle_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
host::mutable_cpu_idle() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.host.cpu_idle)
  return &cpu_idle_;
}

// optional uint64 uptime = 33;
inline bool host::has_uptime() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void host::set_has_uptime() {
  _has_bits_[0] |= 0x00020000u;
}
inline void host::clear_has_uptime() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void host::clear_uptime() {
  uptime_ = GOOGLE_ULONGLONG(0);
  clear_has_uptime();
}
inline ::google::protobuf::uint64 host::uptime() const {
  // @@protoc_insertion_point(field_get:draiosproto.host.uptime)
  return uptime_;
}
inline void host::set_uptime(::google::protobuf::uint64 value) {
  set_has_uptime();
  uptime_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.host.uptime)
}

// repeated uint32 system_cpu = 34;
inline int host::system_cpu_size() const {
  return system_cpu_.size();
}
inline void host::clear_system_cpu() {
  system_cpu_.Clear();
}
inline ::google::protobuf::uint32 host::system_cpu(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.host.system_cpu)
  return system_cpu_.Get(index);
}
inline void host::set_system_cpu(int index, ::google::protobuf::uint32 value) {
  system_cpu_.Set(index, value);
  // @@protoc_insertion_point(field_set:draiosproto.host.system_cpu)
}
inline void host::add_system_cpu(::google::protobuf::uint32 value) {
  system_cpu_.Add(value);
  // @@protoc_insertion_point(field_add:draiosproto.host.system_cpu)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
host::system_cpu() const {
  // @@protoc_insertion_point(field_list:draiosproto.host.system_cpu)
  return system_cpu_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
host::mutable_system_cpu() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.host.system_cpu)
  return &system_cpu_;
}

// repeated uint32 user_cpu = 35;
inline int host::user_cpu_size() const {
  return user_cpu_.size();
}
inline void host::clear_user_cpu() {
  user_cpu_.Clear();
}
inline ::google::protobuf::uint32 host::user_cpu(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.host.user_cpu)
  return user_cpu_.Get(index);
}
inline void host::set_user_cpu(int index, ::google::protobuf::uint32 value) {
  user_cpu_.Set(index, value);
  // @@protoc_insertion_point(field_set:draiosproto.host.user_cpu)
}
inline void host::add_user_cpu(::google::protobuf::uint32 value) {
  user_cpu_.Add(value);
  // @@protoc_insertion_point(field_add:draiosproto.host.user_cpu)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
host::user_cpu() const {
  // @@protoc_insertion_point(field_list:draiosproto.host.user_cpu)
  return user_cpu_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
host::mutable_user_cpu() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.host.user_cpu)
  return &user_cpu_;
}

// optional uint64 memory_bytes_available_kb = 36;
inline bool host::has_memory_bytes_available_kb() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void host::set_has_memory_bytes_available_kb() {
  _has_bits_[0] |= 0x00100000u;
}
inline void host::clear_has_memory_bytes_available_kb() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void host::clear_memory_bytes_available_kb() {
  memory_bytes_available_kb_ = GOOGLE_ULONGLONG(0);
  clear_has_memory_bytes_available_kb();
}
inline ::google::protobuf::uint64 host::memory_bytes_available_kb() const {
  // @@protoc_insertion_point(field_get:draiosproto.host.memory_bytes_available_kb)
  return memory_bytes_available_kb_;
}
inline void host::set_memory_bytes_available_kb(::google::protobuf::uint64 value) {
  set_has_memory_bytes_available_kb();
  memory_bytes_available_kb_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.host.memory_bytes_available_kb)
}

// repeated uint32 iowait_cpu = 37;
inline int host::iowait_cpu_size() const {
  return iowait_cpu_.size();
}
inline void host::clear_iowait_cpu() {
  iowait_cpu_.Clear();
}
inline ::google::protobuf::uint32 host::iowait_cpu(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.host.iowait_cpu)
  return iowait_cpu_.Get(index);
}
inline void host::set_iowait_cpu(int index, ::google::protobuf::uint32 value) {
  iowait_cpu_.Set(index, value);
  // @@protoc_insertion_point(field_set:draiosproto.host.iowait_cpu)
}
inline void host::add_iowait_cpu(::google::protobuf::uint32 value) {
  iowait_cpu_.Add(value);
  // @@protoc_insertion_point(field_add:draiosproto.host.iowait_cpu)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
host::iowait_cpu() const {
  // @@protoc_insertion_point(field_list:draiosproto.host.iowait_cpu)
  return iowait_cpu_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
host::mutable_iowait_cpu() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.host.iowait_cpu)
  return &iowait_cpu_;
}

// repeated uint32 nice_cpu = 38;
inline int host::nice_cpu_size() const {
  return nice_cpu_.size();
}
inline void host::clear_nice_cpu() {
  nice_cpu_.Clear();
}
inline ::google::protobuf::uint32 host::nice_cpu(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.host.nice_cpu)
  return nice_cpu_.Get(index);
}
inline void host::set_nice_cpu(int index, ::google::protobuf::uint32 value) {
  nice_cpu_.Set(index, value);
  // @@protoc_insertion_point(field_set:draiosproto.host.nice_cpu)
}
inline void host::add_nice_cpu(::google::protobuf::uint32 value) {
  nice_cpu_.Add(value);
  // @@protoc_insertion_point(field_add:draiosproto.host.nice_cpu)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
host::nice_cpu() const {
  // @@protoc_insertion_point(field_list:draiosproto.host.nice_cpu)
  return nice_cpu_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
host::mutable_nice_cpu() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.host.nice_cpu)
  return &nice_cpu_;
}

// optional uint32 system_load_1 = 41;
inline bool host::has_system_load_1() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void host::set_has_system_load_1() {
  _has_bits_[0] |= 0x00800000u;
}
inline void host::clear_has_system_load_1() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void host::clear_system_load_1() {
  system_load_1_ = 0u;
  clear_has_system_load_1();
}
inline ::google::protobuf::uint32 host::system_load_1() const {
  // @@protoc_insertion_point(field_get:draiosproto.host.system_load_1)
  return system_load_1_;
}
inline void host::set_system_load_1(::google::protobuf::uint32 value) {
  set_has_system_load_1();
  system_load_1_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.host.system_load_1)
}

// optional uint32 system_load_5 = 42;
inline bool host::has_system_load_5() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void host::set_has_system_load_5() {
  _has_bits_[0] |= 0x01000000u;
}
inline void host::clear_has_system_load_5() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void host::clear_system_load_5() {
  system_load_5_ = 0u;
  clear_has_system_load_5();
}
inline ::google::protobuf::uint32 host::system_load_5() const {
  // @@protoc_insertion_point(field_get:draiosproto.host.system_load_5)
  return system_load_5_;
}
inline void host::set_system_load_5(::google::protobuf::uint32 value) {
  set_has_system_load_5();
  system_load_5_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.host.system_load_5)
}

// optional uint32 system_load_15 = 43;
inline bool host::has_system_load_15() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void host::set_has_system_load_15() {
  _has_bits_[0] |= 0x02000000u;
}
inline void host::clear_has_system_load_15() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void host::clear_system_load_15() {
  system_load_15_ = 0u;
  clear_has_system_load_15();
}
inline ::google::protobuf::uint32 host::system_load_15() const {
  // @@protoc_insertion_point(field_get:draiosproto.host.system_load_15)
  return system_load_15_;
}
inline void host::set_system_load_15(::google::protobuf::uint32 value) {
  set_has_system_load_15();
  system_load_15_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.host.system_load_15)
}

inline const host* host::internal_default_instance() {
  return &host_default_instance_.get();
}
// -------------------------------------------------------------------

// process

// optional .draiosproto.process_details details = 2;
inline bool process::has_details() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void process::set_has_details() {
  _has_bits_[0] |= 0x00000001u;
}
inline void process::clear_has_details() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void process::clear_details() {
  if (details_ != NULL) details_->::draiosproto::process_details::Clear();
  clear_has_details();
}
inline const ::draiosproto::process_details& process::details() const {
  // @@protoc_insertion_point(field_get:draiosproto.process.details)
  return details_ != NULL ? *details_
                         : *::draiosproto::process_details::internal_default_instance();
}
inline ::draiosproto::process_details* process::mutable_details() {
  set_has_details();
  if (details_ == NULL) {
    details_ = new ::draiosproto::process_details;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.process.details)
  return details_;
}
inline ::draiosproto::process_details* process::release_details() {
  // @@protoc_insertion_point(field_release:draiosproto.process.details)
  clear_has_details();
  ::draiosproto::process_details* temp = details_;
  details_ = NULL;
  return temp;
}
inline void process::set_allocated_details(::draiosproto::process_details* details) {
  delete details_;
  details_ = details;
  if (details) {
    set_has_details();
  } else {
    clear_has_details();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.process.details)
}

// optional bool is_ipv4_transaction_server = 3;
inline bool process::has_is_ipv4_transaction_server() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void process::set_has_is_ipv4_transaction_server() {
  _has_bits_[0] |= 0x00000002u;
}
inline void process::clear_has_is_ipv4_transaction_server() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void process::clear_is_ipv4_transaction_server() {
  is_ipv4_transaction_server_ = false;
  clear_has_is_ipv4_transaction_server();
}
inline bool process::is_ipv4_transaction_server() const {
  // @@protoc_insertion_point(field_get:draiosproto.process.is_ipv4_transaction_server)
  return is_ipv4_transaction_server_;
}
inline void process::set_is_ipv4_transaction_server(bool value) {
  set_has_is_ipv4_transaction_server();
  is_ipv4_transaction_server_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.process.is_ipv4_transaction_server)
}

// optional bool is_unix_transaction_server = 4;
inline bool process::has_is_unix_transaction_server() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void process::set_has_is_unix_transaction_server() {
  _has_bits_[0] |= 0x00000004u;
}
inline void process::clear_has_is_unix_transaction_server() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void process::clear_is_unix_transaction_server() {
  is_unix_transaction_server_ = false;
  clear_has_is_unix_transaction_server();
}
inline bool process::is_unix_transaction_server() const {
  // @@protoc_insertion_point(field_get:draiosproto.process.is_unix_transaction_server)
  return is_unix_transaction_server_;
}
inline void process::set_is_unix_transaction_server(bool value) {
  set_has_is_unix_transaction_server();
  is_unix_transaction_server_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.process.is_unix_transaction_server)
}

// optional bool is_ipv4_transaction_client = 10;
inline bool process::has_is_ipv4_transaction_client() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void process::set_has_is_ipv4_transaction_client() {
  _has_bits_[0] |= 0x00000008u;
}
inline void process::clear_has_is_ipv4_transaction_client() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void process::clear_is_ipv4_transaction_client() {
  is_ipv4_transaction_client_ = false;
  clear_has_is_ipv4_transaction_client();
}
inline bool process::is_ipv4_transaction_client() const {
  // @@protoc_insertion_point(field_get:draiosproto.process.is_ipv4_transaction_client)
  return is_ipv4_transaction_client_;
}
inline void process::set_is_ipv4_transaction_client(bool value) {
  set_has_is_ipv4_transaction_client();
  is_ipv4_transaction_client_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.process.is_ipv4_transaction_client)
}

// optional bool is_unix_transaction_client = 11;
inline bool process::has_is_unix_transaction_client() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void process::set_has_is_unix_transaction_client() {
  _has_bits_[0] |= 0x00000010u;
}
inline void process::clear_has_is_unix_transaction_client() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void process::clear_is_unix_transaction_client() {
  is_unix_transaction_client_ = false;
  clear_has_is_unix_transaction_client();
}
inline bool process::is_unix_transaction_client() const {
  // @@protoc_insertion_point(field_get:draiosproto.process.is_unix_transaction_client)
  return is_unix_transaction_client_;
}
inline void process::set_is_unix_transaction_client(bool value) {
  set_has_is_unix_transaction_client();
  is_unix_transaction_client_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.process.is_unix_transaction_client)
}

// optional uint32 netrole = 13;
inline bool process::has_netrole() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void process::set_has_netrole() {
  _has_bits_[0] |= 0x00000020u;
}
inline void process::clear_has_netrole() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void process::clear_netrole() {
  netrole_ = 0u;
  clear_has_netrole();
}
inline ::google::protobuf::uint32 process::netrole() const {
  // @@protoc_insertion_point(field_get:draiosproto.process.netrole)
  return netrole_;
}
inline void process::set_netrole(::google::protobuf::uint32 value) {
  set_has_netrole();
  netrole_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.process.netrole)
}

// optional .draiosproto.time_categories tcounters = 5;
inline bool process::has_tcounters() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void process::set_has_tcounters() {
  _has_bits_[0] |= 0x00000040u;
}
inline void process::clear_has_tcounters() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void process::clear_tcounters() {
  if (tcounters_ != NULL) tcounters_->::draiosproto::time_categories::Clear();
  clear_has_tcounters();
}
inline const ::draiosproto::time_categories& process::tcounters() const {
  // @@protoc_insertion_point(field_get:draiosproto.process.tcounters)
  return tcounters_ != NULL ? *tcounters_
                         : *::draiosproto::time_categories::internal_default_instance();
}
inline ::draiosproto::time_categories* process::mutable_tcounters() {
  set_has_tcounters();
  if (tcounters_ == NULL) {
    tcounters_ = new ::draiosproto::time_categories;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.process.tcounters)
  return tcounters_;
}
inline ::draiosproto::time_categories* process::release_tcounters() {
  // @@protoc_insertion_point(field_release:draiosproto.process.tcounters)
  clear_has_tcounters();
  ::draiosproto::time_categories* temp = tcounters_;
  tcounters_ = NULL;
  return temp;
}
inline void process::set_allocated_tcounters(::draiosproto::time_categories* tcounters) {
  delete tcounters_;
  tcounters_ = tcounters;
  if (tcounters) {
    set_has_tcounters();
  } else {
    clear_has_tcounters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.process.tcounters)
}

// optional .draiosproto.counter_time_bidirectional transaction_counters = 6;
inline bool process::has_transaction_counters() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void process::set_has_transaction_counters() {
  _has_bits_[0] |= 0x00000080u;
}
inline void process::clear_has_transaction_counters() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void process::clear_transaction_counters() {
  if (transaction_counters_ != NULL) transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& process::transaction_counters() const {
  // @@protoc_insertion_point(field_get:draiosproto.process.transaction_counters)
  return transaction_counters_ != NULL ? *transaction_counters_
                         : *::draiosproto::counter_time_bidirectional::internal_default_instance();
}
inline ::draiosproto::counter_time_bidirectional* process::mutable_transaction_counters() {
  set_has_transaction_counters();
  if (transaction_counters_ == NULL) {
    transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.process.transaction_counters)
  return transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* process::release_transaction_counters() {
  // @@protoc_insertion_point(field_release:draiosproto.process.transaction_counters)
  clear_has_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = transaction_counters_;
  transaction_counters_ = NULL;
  return temp;
}
inline void process::set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters) {
  delete transaction_counters_;
  transaction_counters_ = transaction_counters;
  if (transaction_counters) {
    set_has_transaction_counters();
  } else {
    clear_has_transaction_counters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.process.transaction_counters)
}

// optional .draiosproto.counter_time_bidirectional min_transaction_counters = 18;
inline bool process::has_min_transaction_counters() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void process::set_has_min_transaction_counters() {
  _has_bits_[0] |= 0x00000100u;
}
inline void process::clear_has_min_transaction_counters() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void process::clear_min_transaction_counters() {
  if (min_transaction_counters_ != NULL) min_transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_min_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& process::min_transaction_counters() const {
  // @@protoc_insertion_point(field_get:draiosproto.process.min_transaction_counters)
  return min_transaction_counters_ != NULL ? *min_transaction_counters_
                         : *::draiosproto::counter_time_bidirectional::internal_default_instance();
}
inline ::draiosproto::counter_time_bidirectional* process::mutable_min_transaction_counters() {
  set_has_min_transaction_counters();
  if (min_transaction_counters_ == NULL) {
    min_transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.process.min_transaction_counters)
  return min_transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* process::release_min_transaction_counters() {
  // @@protoc_insertion_point(field_release:draiosproto.process.min_transaction_counters)
  clear_has_min_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = min_transaction_counters_;
  min_transaction_counters_ = NULL;
  return temp;
}
inline void process::set_allocated_min_transaction_counters(::draiosproto::counter_time_bidirectional* min_transaction_counters) {
  delete min_transaction_counters_;
  min_transaction_counters_ = min_transaction_counters;
  if (min_transaction_counters) {
    set_has_min_transaction_counters();
  } else {
    clear_has_min_transaction_counters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.process.min_transaction_counters)
}

// optional .draiosproto.counter_time_bidirectional max_transaction_counters = 19;
inline bool process::has_max_transaction_counters() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void process::set_has_max_transaction_counters() {
  _has_bits_[0] |= 0x00000200u;
}
inline void process::clear_has_max_transaction_counters() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void process::clear_max_transaction_counters() {
  if (max_transaction_counters_ != NULL) max_transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_max_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& process::max_transaction_counters() const {
  // @@protoc_insertion_point(field_get:draiosproto.process.max_transaction_counters)
  return max_transaction_counters_ != NULL ? *max_transaction_counters_
                         : *::draiosproto::counter_time_bidirectional::internal_default_instance();
}
inline ::draiosproto::counter_time_bidirectional* process::mutable_max_transaction_counters() {
  set_has_max_transaction_counters();
  if (max_transaction_counters_ == NULL) {
    max_transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.process.max_transaction_counters)
  return max_transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* process::release_max_transaction_counters() {
  // @@protoc_insertion_point(field_release:draiosproto.process.max_transaction_counters)
  clear_has_max_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = max_transaction_counters_;
  max_transaction_counters_ = NULL;
  return temp;
}
inline void process::set_allocated_max_transaction_counters(::draiosproto::counter_time_bidirectional* max_transaction_counters) {
  delete max_transaction_counters_;
  max_transaction_counters_ = max_transaction_counters;
  if (max_transaction_counters) {
    set_has_max_transaction_counters();
  } else {
    clear_has_max_transaction_counters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.process.max_transaction_counters)
}

// optional uint64 transaction_processing_delay = 7;
inline bool process::has_transaction_processing_delay() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void process::set_has_transaction_processing_delay() {
  _has_bits_[0] |= 0x00000400u;
}
inline void process::clear_has_transaction_processing_delay() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void process::clear_transaction_processing_delay() {
  transaction_processing_delay_ = GOOGLE_ULONGLONG(0);
  clear_has_transaction_processing_delay();
}
inline ::google::protobuf::uint64 process::transaction_processing_delay() const {
  // @@protoc_insertion_point(field_get:draiosproto.process.transaction_processing_delay)
  return transaction_processing_delay_;
}
inline void process::set_transaction_processing_delay(::google::protobuf::uint64 value) {
  set_has_transaction_processing_delay();
  transaction_processing_delay_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.process.transaction_processing_delay)
}

// optional uint64 next_tiers_delay = 12;
inline bool process::has_next_tiers_delay() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void process::set_has_next_tiers_delay() {
  _has_bits_[0] |= 0x00000800u;
}
inline void process::clear_has_next_tiers_delay() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void process::clear_next_tiers_delay() {
  next_tiers_delay_ = GOOGLE_ULONGLONG(0);
  clear_has_next_tiers_delay();
}
inline ::google::protobuf::uint64 process::next_tiers_delay() const {
  // @@protoc_insertion_point(field_get:draiosproto.process.next_tiers_delay)
  return next_tiers_delay_;
}
inline void process::set_next_tiers_delay(::google::protobuf::uint64 value) {
  set_has_next_tiers_delay();
  next_tiers_delay_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.process.next_tiers_delay)
}

// optional .draiosproto.resource_categories resource_counters = 8;
inline bool process::has_resource_counters() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void process::set_has_resource_counters() {
  _has_bits_[0] |= 0x00001000u;
}
inline void process::clear_has_resource_counters() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void process::clear_resource_counters() {
  if (resource_counters_ != NULL) resource_counters_->::draiosproto::resource_categories::Clear();
  clear_has_resource_counters();
}
inline const ::draiosproto::resource_categories& process::resource_counters() const {
  // @@protoc_insertion_point(field_get:draiosproto.process.resource_counters)
  return resource_counters_ != NULL ? *resource_counters_
                         : *::draiosproto::resource_categories::internal_default_instance();
}
inline ::draiosproto::resource_categories* process::mutable_resource_counters() {
  set_has_resource_counters();
  if (resource_counters_ == NULL) {
    resource_counters_ = new ::draiosproto::resource_categories;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.process.resource_counters)
  return resource_counters_;
}
inline ::draiosproto::resource_categories* process::release_resource_counters() {
  // @@protoc_insertion_point(field_release:draiosproto.process.resource_counters)
  clear_has_resource_counters();
  ::draiosproto::resource_categories* temp = resource_counters_;
  resource_counters_ = NULL;
  return temp;
}
inline void process::set_allocated_resource_counters(::draiosproto::resource_categories* resource_counters) {
  delete resource_counters_;
  resource_counters_ = resource_counters;
  if (resource_counters) {
    set_has_resource_counters();
  } else {
    clear_has_resource_counters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.process.resource_counters)
}

// optional .draiosproto.counter_syscall_errors syscall_errors = 9;
inline bool process::has_syscall_errors() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void process::set_has_syscall_errors() {
  _has_bits_[0] |= 0x00002000u;
}
inline void process::clear_has_syscall_errors() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void process::clear_syscall_errors() {
  if (syscall_errors_ != NULL) syscall_errors_->::draiosproto::counter_syscall_errors::Clear();
  clear_has_syscall_errors();
}
inline const ::draiosproto::counter_syscall_errors& process::syscall_errors() const {
  // @@protoc_insertion_point(field_get:draiosproto.process.syscall_errors)
  return syscall_errors_ != NULL ? *syscall_errors_
                         : *::draiosproto::counter_syscall_errors::internal_default_instance();
}
inline ::draiosproto::counter_syscall_errors* process::mutable_syscall_errors() {
  set_has_syscall_errors();
  if (syscall_errors_ == NULL) {
    syscall_errors_ = new ::draiosproto::counter_syscall_errors;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.process.syscall_errors)
  return syscall_errors_;
}
inline ::draiosproto::counter_syscall_errors* process::release_syscall_errors() {
  // @@protoc_insertion_point(field_release:draiosproto.process.syscall_errors)
  clear_has_syscall_errors();
  ::draiosproto::counter_syscall_errors* temp = syscall_errors_;
  syscall_errors_ = NULL;
  return temp;
}
inline void process::set_allocated_syscall_errors(::draiosproto::counter_syscall_errors* syscall_errors) {
  delete syscall_errors_;
  syscall_errors_ = syscall_errors;
  if (syscall_errors) {
    set_has_syscall_errors();
  } else {
    clear_has_syscall_errors();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.process.syscall_errors)
}

// optional .draiosproto.proto_info protos = 20;
inline bool process::has_protos() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void process::set_has_protos() {
  _has_bits_[0] |= 0x00004000u;
}
inline void process::clear_has_protos() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void process::clear_protos() {
  if (protos_ != NULL) protos_->::draiosproto::proto_info::Clear();
  clear_has_protos();
}
inline const ::draiosproto::proto_info& process::protos() const {
  // @@protoc_insertion_point(field_get:draiosproto.process.protos)
  return protos_ != NULL ? *protos_
                         : *::draiosproto::proto_info::internal_default_instance();
}
inline ::draiosproto::proto_info* process::mutable_protos() {
  set_has_protos();
  if (protos_ == NULL) {
    protos_ = new ::draiosproto::proto_info;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.process.protos)
  return protos_;
}
inline ::draiosproto::proto_info* process::release_protos() {
  // @@protoc_insertion_point(field_release:draiosproto.process.protos)
  clear_has_protos();
  ::draiosproto::proto_info* temp = protos_;
  protos_ = NULL;
  return temp;
}
inline void process::set_allocated_protos(::draiosproto::proto_info* protos) {
  delete protos_;
  protos_ = protos;
  if (protos) {
    set_has_protos();
  } else {
    clear_has_protos();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.process.protos)
}

// optional uint64 start_count = 21;
inline bool process::has_start_count() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void process::set_has_start_count() {
  _has_bits_[0] |= 0x00008000u;
}
inline void process::clear_has_start_count() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void process::clear_start_count() {
  start_count_ = GOOGLE_ULONGLONG(0);
  clear_has_start_count();
}
inline ::google::protobuf::uint64 process::start_count() const {
  // @@protoc_insertion_point(field_get:draiosproto.process.start_count)
  return start_count_;
}
inline void process::set_start_count(::google::protobuf::uint64 value) {
  set_has_start_count();
  start_count_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.process.start_count)
}

// optional uint64 count_processes = 23;
inline bool process::has_count_processes() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void process::set_has_count_processes() {
  _has_bits_[0] |= 0x00010000u;
}
inline void process::clear_has_count_processes() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void process::clear_count_processes() {
  count_processes_ = GOOGLE_ULONGLONG(0);
  clear_has_count_processes();
}
inline ::google::protobuf::uint64 process::count_processes() const {
  // @@protoc_insertion_point(field_get:draiosproto.process.count_processes)
  return count_processes_;
}
inline void process::set_count_processes(::google::protobuf::uint64 value) {
  set_has_count_processes();
  count_processes_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.process.count_processes)
}

inline const process* process::internal_default_instance() {
  return &process_default_instance_.get();
}
// -------------------------------------------------------------------

// program

// required .draiosproto.process procinfo = 1;
inline bool program::has_procinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void program::set_has_procinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void program::clear_has_procinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void program::clear_procinfo() {
  if (procinfo_ != NULL) procinfo_->::draiosproto::process::Clear();
  clear_has_procinfo();
}
inline const ::draiosproto::process& program::procinfo() const {
  // @@protoc_insertion_point(field_get:draiosproto.program.procinfo)
  return procinfo_ != NULL ? *procinfo_
                         : *::draiosproto::process::internal_default_instance();
}
inline ::draiosproto::process* program::mutable_procinfo() {
  set_has_procinfo();
  if (procinfo_ == NULL) {
    procinfo_ = new ::draiosproto::process;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.program.procinfo)
  return procinfo_;
}
inline ::draiosproto::process* program::release_procinfo() {
  // @@protoc_insertion_point(field_release:draiosproto.program.procinfo)
  clear_has_procinfo();
  ::draiosproto::process* temp = procinfo_;
  procinfo_ = NULL;
  return temp;
}
inline void program::set_allocated_procinfo(::draiosproto::process* procinfo) {
  delete procinfo_;
  procinfo_ = procinfo;
  if (procinfo) {
    set_has_procinfo();
  } else {
    clear_has_procinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.program.procinfo)
}

// repeated uint64 pids = 2;
inline int program::pids_size() const {
  return pids_.size();
}
inline void program::clear_pids() {
  pids_.Clear();
}
inline ::google::protobuf::uint64 program::pids(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.program.pids)
  return pids_.Get(index);
}
inline void program::set_pids(int index, ::google::protobuf::uint64 value) {
  pids_.Set(index, value);
  // @@protoc_insertion_point(field_set:draiosproto.program.pids)
}
inline void program::add_pids(::google::protobuf::uint64 value) {
  pids_.Add(value);
  // @@protoc_insertion_point(field_add:draiosproto.program.pids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
program::pids() const {
  // @@protoc_insertion_point(field_list:draiosproto.program.pids)
  return pids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
program::mutable_pids() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.program.pids)
  return &pids_;
}

inline const program* program::internal_default_instance() {
  return &program_default_instance_.get();
}
// -------------------------------------------------------------------

// ipv4tuple

// required uint32 sip = 1;
inline bool ipv4tuple::has_sip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ipv4tuple::set_has_sip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ipv4tuple::clear_has_sip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ipv4tuple::clear_sip() {
  sip_ = 0u;
  clear_has_sip();
}
inline ::google::protobuf::uint32 ipv4tuple::sip() const {
  // @@protoc_insertion_point(field_get:draiosproto.ipv4tuple.sip)
  return sip_;
}
inline void ipv4tuple::set_sip(::google::protobuf::uint32 value) {
  set_has_sip();
  sip_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.ipv4tuple.sip)
}

// required uint32 dip = 2;
inline bool ipv4tuple::has_dip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ipv4tuple::set_has_dip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ipv4tuple::clear_has_dip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ipv4tuple::clear_dip() {
  dip_ = 0u;
  clear_has_dip();
}
inline ::google::protobuf::uint32 ipv4tuple::dip() const {
  // @@protoc_insertion_point(field_get:draiosproto.ipv4tuple.dip)
  return dip_;
}
inline void ipv4tuple::set_dip(::google::protobuf::uint32 value) {
  set_has_dip();
  dip_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.ipv4tuple.dip)
}

// required uint32 sport = 3;
inline bool ipv4tuple::has_sport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ipv4tuple::set_has_sport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ipv4tuple::clear_has_sport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ipv4tuple::clear_sport() {
  sport_ = 0u;
  clear_has_sport();
}
inline ::google::protobuf::uint32 ipv4tuple::sport() const {
  // @@protoc_insertion_point(field_get:draiosproto.ipv4tuple.sport)
  return sport_;
}
inline void ipv4tuple::set_sport(::google::protobuf::uint32 value) {
  set_has_sport();
  sport_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.ipv4tuple.sport)
}

// required uint32 dport = 4;
inline bool ipv4tuple::has_dport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ipv4tuple::set_has_dport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ipv4tuple::clear_has_dport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ipv4tuple::clear_dport() {
  dport_ = 0u;
  clear_has_dport();
}
inline ::google::protobuf::uint32 ipv4tuple::dport() const {
  // @@protoc_insertion_point(field_get:draiosproto.ipv4tuple.dport)
  return dport_;
}
inline void ipv4tuple::set_dport(::google::protobuf::uint32 value) {
  set_has_dport();
  dport_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.ipv4tuple.dport)
}

// required uint32 l4proto = 5;
inline bool ipv4tuple::has_l4proto() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ipv4tuple::set_has_l4proto() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ipv4tuple::clear_has_l4proto() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ipv4tuple::clear_l4proto() {
  l4proto_ = 0u;
  clear_has_l4proto();
}
inline ::google::protobuf::uint32 ipv4tuple::l4proto() const {
  // @@protoc_insertion_point(field_get:draiosproto.ipv4tuple.l4proto)
  return l4proto_;
}
inline void ipv4tuple::set_l4proto(::google::protobuf::uint32 value) {
  set_has_l4proto();
  l4proto_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.ipv4tuple.l4proto)
}

inline const ipv4tuple* ipv4tuple::internal_default_instance() {
  return &ipv4tuple_default_instance_.get();
}
// -------------------------------------------------------------------

// ipv4_connection

// required .draiosproto.ipv4tuple tuple = 1;
inline bool ipv4_connection::has_tuple() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ipv4_connection::set_has_tuple() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ipv4_connection::clear_has_tuple() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ipv4_connection::clear_tuple() {
  if (tuple_ != NULL) tuple_->::draiosproto::ipv4tuple::Clear();
  clear_has_tuple();
}
inline const ::draiosproto::ipv4tuple& ipv4_connection::tuple() const {
  // @@protoc_insertion_point(field_get:draiosproto.ipv4_connection.tuple)
  return tuple_ != NULL ? *tuple_
                         : *::draiosproto::ipv4tuple::internal_default_instance();
}
inline ::draiosproto::ipv4tuple* ipv4_connection::mutable_tuple() {
  set_has_tuple();
  if (tuple_ == NULL) {
    tuple_ = new ::draiosproto::ipv4tuple;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.ipv4_connection.tuple)
  return tuple_;
}
inline ::draiosproto::ipv4tuple* ipv4_connection::release_tuple() {
  // @@protoc_insertion_point(field_release:draiosproto.ipv4_connection.tuple)
  clear_has_tuple();
  ::draiosproto::ipv4tuple* temp = tuple_;
  tuple_ = NULL;
  return temp;
}
inline void ipv4_connection::set_allocated_tuple(::draiosproto::ipv4tuple* tuple) {
  delete tuple_;
  tuple_ = tuple;
  if (tuple) {
    set_has_tuple();
  } else {
    clear_has_tuple();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.ipv4_connection.tuple)
}

// optional uint64 spid = 2;
inline bool ipv4_connection::has_spid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ipv4_connection::set_has_spid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ipv4_connection::clear_has_spid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ipv4_connection::clear_spid() {
  spid_ = GOOGLE_ULONGLONG(0);
  clear_has_spid();
}
inline ::google::protobuf::uint64 ipv4_connection::spid() const {
  // @@protoc_insertion_point(field_get:draiosproto.ipv4_connection.spid)
  return spid_;
}
inline void ipv4_connection::set_spid(::google::protobuf::uint64 value) {
  set_has_spid();
  spid_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.ipv4_connection.spid)
}

// optional uint64 dpid = 5;
inline bool ipv4_connection::has_dpid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ipv4_connection::set_has_dpid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ipv4_connection::clear_has_dpid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ipv4_connection::clear_dpid() {
  dpid_ = GOOGLE_ULONGLONG(0);
  clear_has_dpid();
}
inline ::google::protobuf::uint64 ipv4_connection::dpid() const {
  // @@protoc_insertion_point(field_get:draiosproto.ipv4_connection.dpid)
  return dpid_;
}
inline void ipv4_connection::set_dpid(::google::protobuf::uint64 value) {
  set_has_dpid();
  dpid_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.ipv4_connection.dpid)
}

// required .draiosproto.connection_categories counters = 8;
inline bool ipv4_connection::has_counters() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ipv4_connection::set_has_counters() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ipv4_connection::clear_has_counters() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ipv4_connection::clear_counters() {
  if (counters_ != NULL) counters_->::draiosproto::connection_categories::Clear();
  clear_has_counters();
}
inline const ::draiosproto::connection_categories& ipv4_connection::counters() const {
  // @@protoc_insertion_point(field_get:draiosproto.ipv4_connection.counters)
  return counters_ != NULL ? *counters_
                         : *::draiosproto::connection_categories::internal_default_instance();
}
inline ::draiosproto::connection_categories* ipv4_connection::mutable_counters() {
  set_has_counters();
  if (counters_ == NULL) {
    counters_ = new ::draiosproto::connection_categories;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.ipv4_connection.counters)
  return counters_;
}
inline ::draiosproto::connection_categories* ipv4_connection::release_counters() {
  // @@protoc_insertion_point(field_release:draiosproto.ipv4_connection.counters)
  clear_has_counters();
  ::draiosproto::connection_categories* temp = counters_;
  counters_ = NULL;
  return temp;
}
inline void ipv4_connection::set_allocated_counters(::draiosproto::connection_categories* counters) {
  delete counters_;
  counters_ = counters;
  if (counters) {
    set_has_counters();
  } else {
    clear_has_counters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.ipv4_connection.counters)
}

inline const ipv4_connection* ipv4_connection::internal_default_instance() {
  return &ipv4_connection_default_instance_.get();
}
// -------------------------------------------------------------------

// ipv4_network_interface

// required string name = 1;
inline bool ipv4_network_interface::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ipv4_network_interface::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ipv4_network_interface::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ipv4_network_interface::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ipv4_network_interface::name() const {
  // @@protoc_insertion_point(field_get:draiosproto.ipv4_network_interface.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ipv4_network_interface::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.ipv4_network_interface.name)
}
inline void ipv4_network_interface::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.ipv4_network_interface.name)
}
inline void ipv4_network_interface::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.ipv4_network_interface.name)
}
inline ::std::string* ipv4_network_interface::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:draiosproto.ipv4_network_interface.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ipv4_network_interface::release_name() {
  // @@protoc_insertion_point(field_release:draiosproto.ipv4_network_interface.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ipv4_network_interface::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.ipv4_network_interface.name)
}

// required uint32 addr = 2;
inline bool ipv4_network_interface::has_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ipv4_network_interface::set_has_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ipv4_network_interface::clear_has_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ipv4_network_interface::clear_addr() {
  addr_ = 0u;
  clear_has_addr();
}
inline ::google::protobuf::uint32 ipv4_network_interface::addr() const {
  // @@protoc_insertion_point(field_get:draiosproto.ipv4_network_interface.addr)
  return addr_;
}
inline void ipv4_network_interface::set_addr(::google::protobuf::uint32 value) {
  set_has_addr();
  addr_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.ipv4_network_interface.addr)
}

// required uint32 netmask = 3;
inline bool ipv4_network_interface::has_netmask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ipv4_network_interface::set_has_netmask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ipv4_network_interface::clear_has_netmask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ipv4_network_interface::clear_netmask() {
  netmask_ = 0u;
  clear_has_netmask();
}
inline ::google::protobuf::uint32 ipv4_network_interface::netmask() const {
  // @@protoc_insertion_point(field_get:draiosproto.ipv4_network_interface.netmask)
  return netmask_;
}
inline void ipv4_network_interface::set_netmask(::google::protobuf::uint32 value) {
  set_has_netmask();
  netmask_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.ipv4_network_interface.netmask)
}

// optional uint32 bcast = 4;
inline bool ipv4_network_interface::has_bcast() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ipv4_network_interface::set_has_bcast() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ipv4_network_interface::clear_has_bcast() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ipv4_network_interface::clear_bcast() {
  bcast_ = 0u;
  clear_has_bcast();
}
inline ::google::protobuf::uint32 ipv4_network_interface::bcast() const {
  // @@protoc_insertion_point(field_get:draiosproto.ipv4_network_interface.bcast)
  return bcast_;
}
inline void ipv4_network_interface::set_bcast(::google::protobuf::uint32 value) {
  set_has_bcast();
  bcast_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.ipv4_network_interface.bcast)
}

inline const ipv4_network_interface* ipv4_network_interface::internal_default_instance() {
  return &ipv4_network_interface_default_instance_.get();
}
// -------------------------------------------------------------------

// mounted_fs

// required string device = 1;
inline bool mounted_fs::has_device() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mounted_fs::set_has_device() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mounted_fs::clear_has_device() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mounted_fs::clear_device() {
  device_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device();
}
inline const ::std::string& mounted_fs::device() const {
  // @@protoc_insertion_point(field_get:draiosproto.mounted_fs.device)
  return device_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void mounted_fs::set_device(const ::std::string& value) {
  set_has_device();
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.mounted_fs.device)
}
inline void mounted_fs::set_device(const char* value) {
  set_has_device();
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.mounted_fs.device)
}
inline void mounted_fs::set_device(const char* value, size_t size) {
  set_has_device();
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.mounted_fs.device)
}
inline ::std::string* mounted_fs::mutable_device() {
  set_has_device();
  // @@protoc_insertion_point(field_mutable:draiosproto.mounted_fs.device)
  return device_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* mounted_fs::release_device() {
  // @@protoc_insertion_point(field_release:draiosproto.mounted_fs.device)
  clear_has_device();
  return device_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void mounted_fs::set_allocated_device(::std::string* device) {
  if (device != NULL) {
    set_has_device();
  } else {
    clear_has_device();
  }
  device_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.mounted_fs.device)
}

// required string mount_dir = 2;
inline bool mounted_fs::has_mount_dir() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mounted_fs::set_has_mount_dir() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mounted_fs::clear_has_mount_dir() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mounted_fs::clear_mount_dir() {
  mount_dir_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mount_dir();
}
inline const ::std::string& mounted_fs::mount_dir() const {
  // @@protoc_insertion_point(field_get:draiosproto.mounted_fs.mount_dir)
  return mount_dir_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void mounted_fs::set_mount_dir(const ::std::string& value) {
  set_has_mount_dir();
  mount_dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.mounted_fs.mount_dir)
}
inline void mounted_fs::set_mount_dir(const char* value) {
  set_has_mount_dir();
  mount_dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.mounted_fs.mount_dir)
}
inline void mounted_fs::set_mount_dir(const char* value, size_t size) {
  set_has_mount_dir();
  mount_dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.mounted_fs.mount_dir)
}
inline ::std::string* mounted_fs::mutable_mount_dir() {
  set_has_mount_dir();
  // @@protoc_insertion_point(field_mutable:draiosproto.mounted_fs.mount_dir)
  return mount_dir_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* mounted_fs::release_mount_dir() {
  // @@protoc_insertion_point(field_release:draiosproto.mounted_fs.mount_dir)
  clear_has_mount_dir();
  return mount_dir_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void mounted_fs::set_allocated_mount_dir(::std::string* mount_dir) {
  if (mount_dir != NULL) {
    set_has_mount_dir();
  } else {
    clear_has_mount_dir();
  }
  mount_dir_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mount_dir);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.mounted_fs.mount_dir)
}

// required string type = 3;
inline bool mounted_fs::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mounted_fs::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mounted_fs::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mounted_fs::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& mounted_fs::type() const {
  // @@protoc_insertion_point(field_get:draiosproto.mounted_fs.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void mounted_fs::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.mounted_fs.type)
}
inline void mounted_fs::set_type(const char* value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.mounted_fs.type)
}
inline void mounted_fs::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.mounted_fs.type)
}
inline ::std::string* mounted_fs::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:draiosproto.mounted_fs.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* mounted_fs::release_type() {
  // @@protoc_insertion_point(field_release:draiosproto.mounted_fs.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void mounted_fs::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.mounted_fs.type)
}

// required uint64 size_bytes = 4;
inline bool mounted_fs::has_size_bytes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void mounted_fs::set_has_size_bytes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void mounted_fs::clear_has_size_bytes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void mounted_fs::clear_size_bytes() {
  size_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_size_bytes();
}
inline ::google::protobuf::uint64 mounted_fs::size_bytes() const {
  // @@protoc_insertion_point(field_get:draiosproto.mounted_fs.size_bytes)
  return size_bytes_;
}
inline void mounted_fs::set_size_bytes(::google::protobuf::uint64 value) {
  set_has_size_bytes();
  size_bytes_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.mounted_fs.size_bytes)
}

// required uint64 used_bytes = 5;
inline bool mounted_fs::has_used_bytes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void mounted_fs::set_has_used_bytes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void mounted_fs::clear_has_used_bytes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void mounted_fs::clear_used_bytes() {
  used_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_used_bytes();
}
inline ::google::protobuf::uint64 mounted_fs::used_bytes() const {
  // @@protoc_insertion_point(field_get:draiosproto.mounted_fs.used_bytes)
  return used_bytes_;
}
inline void mounted_fs::set_used_bytes(::google::protobuf::uint64 value) {
  set_has_used_bytes();
  used_bytes_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.mounted_fs.used_bytes)
}

// required uint64 available_bytes = 6;
inline bool mounted_fs::has_available_bytes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void mounted_fs::set_has_available_bytes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void mounted_fs::clear_has_available_bytes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void mounted_fs::clear_available_bytes() {
  available_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_available_bytes();
}
inline ::google::protobuf::uint64 mounted_fs::available_bytes() const {
  // @@protoc_insertion_point(field_get:draiosproto.mounted_fs.available_bytes)
  return available_bytes_;
}
inline void mounted_fs::set_available_bytes(::google::protobuf::uint64 value) {
  set_has_available_bytes();
  available_bytes_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.mounted_fs.available_bytes)
}

// optional uint64 total_inodes = 10;
inline bool mounted_fs::has_total_inodes() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void mounted_fs::set_has_total_inodes() {
  _has_bits_[0] |= 0x00000040u;
}
inline void mounted_fs::clear_has_total_inodes() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void mounted_fs::clear_total_inodes() {
  total_inodes_ = GOOGLE_ULONGLONG(0);
  clear_has_total_inodes();
}
inline ::google::protobuf::uint64 mounted_fs::total_inodes() const {
  // @@protoc_insertion_point(field_get:draiosproto.mounted_fs.total_inodes)
  return total_inodes_;
}
inline void mounted_fs::set_total_inodes(::google::protobuf::uint64 value) {
  set_has_total_inodes();
  total_inodes_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.mounted_fs.total_inodes)
}

// optional uint64 used_inodes = 11;
inline bool mounted_fs::has_used_inodes() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void mounted_fs::set_has_used_inodes() {
  _has_bits_[0] |= 0x00000080u;
}
inline void mounted_fs::clear_has_used_inodes() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void mounted_fs::clear_used_inodes() {
  used_inodes_ = GOOGLE_ULONGLONG(0);
  clear_has_used_inodes();
}
inline ::google::protobuf::uint64 mounted_fs::used_inodes() const {
  // @@protoc_insertion_point(field_get:draiosproto.mounted_fs.used_inodes)
  return used_inodes_;
}
inline void mounted_fs::set_used_inodes(::google::protobuf::uint64 value) {
  set_has_used_inodes();
  used_inodes_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.mounted_fs.used_inodes)
}

inline const mounted_fs* mounted_fs::internal_default_instance() {
  return &mounted_fs_default_instance_.get();
}
// -------------------------------------------------------------------

// file_stat

// required string name = 1;
inline bool file_stat::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void file_stat::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void file_stat::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void file_stat::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& file_stat::name() const {
  // @@protoc_insertion_point(field_get:draiosproto.file_stat.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void file_stat::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.file_stat.name)
}
inline void file_stat::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.file_stat.name)
}
inline void file_stat::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.file_stat.name)
}
inline ::std::string* file_stat::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:draiosproto.file_stat.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* file_stat::release_name() {
  // @@protoc_insertion_point(field_release:draiosproto.file_stat.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void file_stat::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.file_stat.name)
}

// required uint32 bytes = 2;
inline bool file_stat::has_bytes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void file_stat::set_has_bytes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void file_stat::clear_has_bytes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void file_stat::clear_bytes() {
  bytes_ = 0u;
  clear_has_bytes();
}
inline ::google::protobuf::uint32 file_stat::bytes() const {
  // @@protoc_insertion_point(field_get:draiosproto.file_stat.bytes)
  return bytes_;
}
inline void file_stat::set_bytes(::google::protobuf::uint32 value) {
  set_has_bytes();
  bytes_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.file_stat.bytes)
}

// required uint64 time_ns = 3;
inline bool file_stat::has_time_ns() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void file_stat::set_has_time_ns() {
  _has_bits_[0] |= 0x00000004u;
}
inline void file_stat::clear_has_time_ns() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void file_stat::clear_time_ns() {
  time_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_time_ns();
}
inline ::google::protobuf::uint64 file_stat::time_ns() const {
  // @@protoc_insertion_point(field_get:draiosproto.file_stat.time_ns)
  return time_ns_;
}
inline void file_stat::set_time_ns(::google::protobuf::uint64 value) {
  set_has_time_ns();
  time_ns_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.file_stat.time_ns)
}

// required uint32 open_count = 4;
inline bool file_stat::has_open_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void file_stat::set_has_open_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void file_stat::clear_has_open_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void file_stat::clear_open_count() {
  open_count_ = 0u;
  clear_has_open_count();
}
inline ::google::protobuf::uint32 file_stat::open_count() const {
  // @@protoc_insertion_point(field_get:draiosproto.file_stat.open_count)
  return open_count_;
}
inline void file_stat::set_open_count(::google::protobuf::uint32 value) {
  set_has_open_count();
  open_count_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.file_stat.open_count)
}

// required uint32 errors = 5;
inline bool file_stat::has_errors() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void file_stat::set_has_errors() {
  _has_bits_[0] |= 0x00000010u;
}
inline void file_stat::clear_has_errors() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void file_stat::clear_errors() {
  errors_ = 0u;
  clear_has_errors();
}
inline ::google::protobuf::uint32 file_stat::errors() const {
  // @@protoc_insertion_point(field_get:draiosproto.file_stat.errors)
  return errors_;
}
inline void file_stat::set_errors(::google::protobuf::uint32 value) {
  set_has_errors();
  errors_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.file_stat.errors)
}

inline const file_stat* file_stat::internal_default_instance() {
  return &file_stat_default_instance_.get();
}
// -------------------------------------------------------------------

// container_port_mapping

// optional uint32 host_ip = 1;
inline bool container_port_mapping::has_host_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void container_port_mapping::set_has_host_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void container_port_mapping::clear_has_host_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void container_port_mapping::clear_host_ip() {
  host_ip_ = 0u;
  clear_has_host_ip();
}
inline ::google::protobuf::uint32 container_port_mapping::host_ip() const {
  // @@protoc_insertion_point(field_get:draiosproto.container_port_mapping.host_ip)
  return host_ip_;
}
inline void container_port_mapping::set_host_ip(::google::protobuf::uint32 value) {
  set_has_host_ip();
  host_ip_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.container_port_mapping.host_ip)
}

// optional uint32 host_port = 2;
inline bool container_port_mapping::has_host_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void container_port_mapping::set_has_host_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void container_port_mapping::clear_has_host_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void container_port_mapping::clear_host_port() {
  host_port_ = 0u;
  clear_has_host_port();
}
inline ::google::protobuf::uint32 container_port_mapping::host_port() const {
  // @@protoc_insertion_point(field_get:draiosproto.container_port_mapping.host_port)
  return host_port_;
}
inline void container_port_mapping::set_host_port(::google::protobuf::uint32 value) {
  set_has_host_port();
  host_port_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.container_port_mapping.host_port)
}

// optional uint32 container_ip = 3;
inline bool container_port_mapping::has_container_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void container_port_mapping::set_has_container_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void container_port_mapping::clear_has_container_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void container_port_mapping::clear_container_ip() {
  container_ip_ = 0u;
  clear_has_container_ip();
}
inline ::google::protobuf::uint32 container_port_mapping::container_ip() const {
  // @@protoc_insertion_point(field_get:draiosproto.container_port_mapping.container_ip)
  return container_ip_;
}
inline void container_port_mapping::set_container_ip(::google::protobuf::uint32 value) {
  set_has_container_ip();
  container_ip_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.container_port_mapping.container_ip)
}

// optional uint32 container_port = 4;
inline bool container_port_mapping::has_container_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void container_port_mapping::set_has_container_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void container_port_mapping::clear_has_container_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void container_port_mapping::clear_container_port() {
  container_port_ = 0u;
  clear_has_container_port();
}
inline ::google::protobuf::uint32 container_port_mapping::container_port() const {
  // @@protoc_insertion_point(field_get:draiosproto.container_port_mapping.container_port)
  return container_port_;
}
inline void container_port_mapping::set_container_port(::google::protobuf::uint32 value) {
  set_has_container_port();
  container_port_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.container_port_mapping.container_port)
}

inline const container_port_mapping* container_port_mapping::internal_default_instance() {
  return &container_port_mapping_default_instance_.get();
}
// -------------------------------------------------------------------

// container_label

// required string key = 1;
inline bool container_label::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void container_label::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void container_label::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void container_label::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& container_label::key() const {
  // @@protoc_insertion_point(field_get:draiosproto.container_label.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void container_label::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.container_label.key)
}
inline void container_label::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.container_label.key)
}
inline void container_label::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.container_label.key)
}
inline ::std::string* container_label::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:draiosproto.container_label.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* container_label::release_key() {
  // @@protoc_insertion_point(field_release:draiosproto.container_label.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void container_label::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.container_label.key)
}

// optional string value = 2;
inline bool container_label::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void container_label::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void container_label::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void container_label::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& container_label::value() const {
  // @@protoc_insertion_point(field_get:draiosproto.container_label.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void container_label::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.container_label.value)
}
inline void container_label::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.container_label.value)
}
inline void container_label::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.container_label.value)
}
inline ::std::string* container_label::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:draiosproto.container_label.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* container_label::release_value() {
  // @@protoc_insertion_point(field_release:draiosproto.container_label.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void container_label::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.container_label.value)
}

inline const container_label* container_label::internal_default_instance() {
  return &container_label_default_instance_.get();
}
// -------------------------------------------------------------------

// container

// required string id = 1;
inline bool container::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void container::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void container::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void container::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& container::id() const {
  // @@protoc_insertion_point(field_get:draiosproto.container.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void container::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.container.id)
}
inline void container::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.container.id)
}
inline void container::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.container.id)
}
inline ::std::string* container::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.container.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* container::release_id() {
  // @@protoc_insertion_point(field_release:draiosproto.container.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void container::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.container.id)
}

// optional .draiosproto.container_type type = 2;
inline bool container::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void container::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void container::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void container::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::draiosproto::container_type container::type() const {
  // @@protoc_insertion_point(field_get:draiosproto.container.type)
  return static_cast< ::draiosproto::container_type >(type_);
}
inline void container::set_type(::draiosproto::container_type value) {
  assert(::draiosproto::container_type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.container.type)
}

// optional string name = 3;
inline bool container::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void container::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void container::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void container::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& container::name() const {
  // @@protoc_insertion_point(field_get:draiosproto.container.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void container::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.container.name)
}
inline void container::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.container.name)
}
inline void container::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.container.name)
}
inline ::std::string* container::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:draiosproto.container.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* container::release_name() {
  // @@protoc_insertion_point(field_release:draiosproto.container.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void container::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.container.name)
}

// optional string image = 4;
inline bool container::has_image() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void container::set_has_image() {
  _has_bits_[0] |= 0x00000008u;
}
inline void container::clear_has_image() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void container::clear_image() {
  image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_image();
}
inline const ::std::string& container::image() const {
  // @@protoc_insertion_point(field_get:draiosproto.container.image)
  return image_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void container::set_image(const ::std::string& value) {
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.container.image)
}
inline void container::set_image(const char* value) {
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.container.image)
}
inline void container::set_image(const char* value, size_t size) {
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.container.image)
}
inline ::std::string* container::mutable_image() {
  set_has_image();
  // @@protoc_insertion_point(field_mutable:draiosproto.container.image)
  return image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* container::release_image() {
  // @@protoc_insertion_point(field_release:draiosproto.container.image)
  clear_has_image();
  return image_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void container::set_allocated_image(::std::string* image) {
  if (image != NULL) {
    set_has_image();
  } else {
    clear_has_image();
  }
  image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.container.image)
}

// optional .draiosproto.time_categories tcounters = 5;
inline bool container::has_tcounters() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void container::set_has_tcounters() {
  _has_bits_[0] |= 0x00000010u;
}
inline void container::clear_has_tcounters() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void container::clear_tcounters() {
  if (tcounters_ != NULL) tcounters_->::draiosproto::time_categories::Clear();
  clear_has_tcounters();
}
inline const ::draiosproto::time_categories& container::tcounters() const {
  // @@protoc_insertion_point(field_get:draiosproto.container.tcounters)
  return tcounters_ != NULL ? *tcounters_
                         : *::draiosproto::time_categories::internal_default_instance();
}
inline ::draiosproto::time_categories* container::mutable_tcounters() {
  set_has_tcounters();
  if (tcounters_ == NULL) {
    tcounters_ = new ::draiosproto::time_categories;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.container.tcounters)
  return tcounters_;
}
inline ::draiosproto::time_categories* container::release_tcounters() {
  // @@protoc_insertion_point(field_release:draiosproto.container.tcounters)
  clear_has_tcounters();
  ::draiosproto::time_categories* temp = tcounters_;
  tcounters_ = NULL;
  return temp;
}
inline void container::set_allocated_tcounters(::draiosproto::time_categories* tcounters) {
  delete tcounters_;
  tcounters_ = tcounters;
  if (tcounters) {
    set_has_tcounters();
  } else {
    clear_has_tcounters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.container.tcounters)
}

// optional .draiosproto.transaction_breakdown_categories reqcounters = 6;
inline bool container::has_reqcounters() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void container::set_has_reqcounters() {
  _has_bits_[0] |= 0x00000020u;
}
inline void container::clear_has_reqcounters() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void container::clear_reqcounters() {
  if (reqcounters_ != NULL) reqcounters_->::draiosproto::transaction_breakdown_categories::Clear();
  clear_has_reqcounters();
}
inline const ::draiosproto::transaction_breakdown_categories& container::reqcounters() const {
  // @@protoc_insertion_point(field_get:draiosproto.container.reqcounters)
  return reqcounters_ != NULL ? *reqcounters_
                         : *::draiosproto::transaction_breakdown_categories::internal_default_instance();
}
inline ::draiosproto::transaction_breakdown_categories* container::mutable_reqcounters() {
  set_has_reqcounters();
  if (reqcounters_ == NULL) {
    reqcounters_ = new ::draiosproto::transaction_breakdown_categories;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.container.reqcounters)
  return reqcounters_;
}
inline ::draiosproto::transaction_breakdown_categories* container::release_reqcounters() {
  // @@protoc_insertion_point(field_release:draiosproto.container.reqcounters)
  clear_has_reqcounters();
  ::draiosproto::transaction_breakdown_categories* temp = reqcounters_;
  reqcounters_ = NULL;
  return temp;
}
inline void container::set_allocated_reqcounters(::draiosproto::transaction_breakdown_categories* reqcounters) {
  delete reqcounters_;
  reqcounters_ = reqcounters;
  if (reqcounters) {
    set_has_reqcounters();
  } else {
    clear_has_reqcounters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.container.reqcounters)
}

// optional .draiosproto.counter_time_bidirectional transaction_counters = 7;
inline bool container::has_transaction_counters() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void container::set_has_transaction_counters() {
  _has_bits_[0] |= 0x00000040u;
}
inline void container::clear_has_transaction_counters() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void container::clear_transaction_counters() {
  if (transaction_counters_ != NULL) transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& container::transaction_counters() const {
  // @@protoc_insertion_point(field_get:draiosproto.container.transaction_counters)
  return transaction_counters_ != NULL ? *transaction_counters_
                         : *::draiosproto::counter_time_bidirectional::internal_default_instance();
}
inline ::draiosproto::counter_time_bidirectional* container::mutable_transaction_counters() {
  set_has_transaction_counters();
  if (transaction_counters_ == NULL) {
    transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.container.transaction_counters)
  return transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* container::release_transaction_counters() {
  // @@protoc_insertion_point(field_release:draiosproto.container.transaction_counters)
  clear_has_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = transaction_counters_;
  transaction_counters_ = NULL;
  return temp;
}
inline void container::set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters) {
  delete transaction_counters_;
  transaction_counters_ = transaction_counters;
  if (transaction_counters) {
    set_has_transaction_counters();
  } else {
    clear_has_transaction_counters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.container.transaction_counters)
}

// optional .draiosproto.counter_time_bidirectional min_transaction_counters = 8;
inline bool container::has_min_transaction_counters() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void container::set_has_min_transaction_counters() {
  _has_bits_[0] |= 0x00000080u;
}
inline void container::clear_has_min_transaction_counters() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void container::clear_min_transaction_counters() {
  if (min_transaction_counters_ != NULL) min_transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_min_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& container::min_transaction_counters() const {
  // @@protoc_insertion_point(field_get:draiosproto.container.min_transaction_counters)
  return min_transaction_counters_ != NULL ? *min_transaction_counters_
                         : *::draiosproto::counter_time_bidirectional::internal_default_instance();
}
inline ::draiosproto::counter_time_bidirectional* container::mutable_min_transaction_counters() {
  set_has_min_transaction_counters();
  if (min_transaction_counters_ == NULL) {
    min_transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.container.min_transaction_counters)
  return min_transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* container::release_min_transaction_counters() {
  // @@protoc_insertion_point(field_release:draiosproto.container.min_transaction_counters)
  clear_has_min_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = min_transaction_counters_;
  min_transaction_counters_ = NULL;
  return temp;
}
inline void container::set_allocated_min_transaction_counters(::draiosproto::counter_time_bidirectional* min_transaction_counters) {
  delete min_transaction_counters_;
  min_transaction_counters_ = min_transaction_counters;
  if (min_transaction_counters) {
    set_has_min_transaction_counters();
  } else {
    clear_has_min_transaction_counters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.container.min_transaction_counters)
}

// optional .draiosproto.counter_time_bidirectional max_transaction_counters = 9;
inline bool container::has_max_transaction_counters() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void container::set_has_max_transaction_counters() {
  _has_bits_[0] |= 0x00000100u;
}
inline void container::clear_has_max_transaction_counters() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void container::clear_max_transaction_counters() {
  if (max_transaction_counters_ != NULL) max_transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_max_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& container::max_transaction_counters() const {
  // @@protoc_insertion_point(field_get:draiosproto.container.max_transaction_counters)
  return max_transaction_counters_ != NULL ? *max_transaction_counters_
                         : *::draiosproto::counter_time_bidirectional::internal_default_instance();
}
inline ::draiosproto::counter_time_bidirectional* container::mutable_max_transaction_counters() {
  set_has_max_transaction_counters();
  if (max_transaction_counters_ == NULL) {
    max_transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.container.max_transaction_counters)
  return max_transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* container::release_max_transaction_counters() {
  // @@protoc_insertion_point(field_release:draiosproto.container.max_transaction_counters)
  clear_has_max_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = max_transaction_counters_;
  max_transaction_counters_ = NULL;
  return temp;
}
inline void container::set_allocated_max_transaction_counters(::draiosproto::counter_time_bidirectional* max_transaction_counters) {
  delete max_transaction_counters_;
  max_transaction_counters_ = max_transaction_counters;
  if (max_transaction_counters) {
    set_has_max_transaction_counters();
  } else {
    clear_has_max_transaction_counters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.container.max_transaction_counters)
}

// optional uint64 transaction_processing_delay = 10;
inline bool container::has_transaction_processing_delay() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void container::set_has_transaction_processing_delay() {
  _has_bits_[0] |= 0x00000200u;
}
inline void container::clear_has_transaction_processing_delay() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void container::clear_transaction_processing_delay() {
  transaction_processing_delay_ = GOOGLE_ULONGLONG(0);
  clear_has_transaction_processing_delay();
}
inline ::google::protobuf::uint64 container::transaction_processing_delay() const {
  // @@protoc_insertion_point(field_get:draiosproto.container.transaction_processing_delay)
  return transaction_processing_delay_;
}
inline void container::set_transaction_processing_delay(::google::protobuf::uint64 value) {
  set_has_transaction_processing_delay();
  transaction_processing_delay_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.container.transaction_processing_delay)
}

// optional uint64 next_tiers_delay = 12;
inline bool container::has_next_tiers_delay() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void container::set_has_next_tiers_delay() {
  _has_bits_[0] |= 0x00000400u;
}
inline void container::clear_has_next_tiers_delay() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void container::clear_next_tiers_delay() {
  next_tiers_delay_ = GOOGLE_ULONGLONG(0);
  clear_has_next_tiers_delay();
}
inline ::google::protobuf::uint64 container::next_tiers_delay() const {
  // @@protoc_insertion_point(field_get:draiosproto.container.next_tiers_delay)
  return next_tiers_delay_;
}
inline void container::set_next_tiers_delay(::google::protobuf::uint64 value) {
  set_has_next_tiers_delay();
  next_tiers_delay_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.container.next_tiers_delay)
}

// optional .draiosproto.resource_categories resource_counters = 13;
inline bool container::has_resource_counters() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void container::set_has_resource_counters() {
  _has_bits_[0] |= 0x00000800u;
}
inline void container::clear_has_resource_counters() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void container::clear_resource_counters() {
  if (resource_counters_ != NULL) resource_counters_->::draiosproto::resource_categories::Clear();
  clear_has_resource_counters();
}
inline const ::draiosproto::resource_categories& container::resource_counters() const {
  // @@protoc_insertion_point(field_get:draiosproto.container.resource_counters)
  return resource_counters_ != NULL ? *resource_counters_
                         : *::draiosproto::resource_categories::internal_default_instance();
}
inline ::draiosproto::resource_categories* container::mutable_resource_counters() {
  set_has_resource_counters();
  if (resource_counters_ == NULL) {
    resource_counters_ = new ::draiosproto::resource_categories;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.container.resource_counters)
  return resource_counters_;
}
inline ::draiosproto::resource_categories* container::release_resource_counters() {
  // @@protoc_insertion_point(field_release:draiosproto.container.resource_counters)
  clear_has_resource_counters();
  ::draiosproto::resource_categories* temp = resource_counters_;
  resource_counters_ = NULL;
  return temp;
}
inline void container::set_allocated_resource_counters(::draiosproto::resource_categories* resource_counters) {
  delete resource_counters_;
  resource_counters_ = resource_counters;
  if (resource_counters) {
    set_has_resource_counters();
  } else {
    clear_has_resource_counters();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.container.resource_counters)
}

// optional .draiosproto.counter_syscall_errors syscall_errors = 14;
inline bool container::has_syscall_errors() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void container::set_has_syscall_errors() {
  _has_bits_[0] |= 0x00001000u;
}
inline void container::clear_has_syscall_errors() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void container::clear_syscall_errors() {
  if (syscall_errors_ != NULL) syscall_errors_->::draiosproto::counter_syscall_errors::Clear();
  clear_has_syscall_errors();
}
inline const ::draiosproto::counter_syscall_errors& container::syscall_errors() const {
  // @@protoc_insertion_point(field_get:draiosproto.container.syscall_errors)
  return syscall_errors_ != NULL ? *syscall_errors_
                         : *::draiosproto::counter_syscall_errors::internal_default_instance();
}
inline ::draiosproto::counter_syscall_errors* container::mutable_syscall_errors() {
  set_has_syscall_errors();
  if (syscall_errors_ == NULL) {
    syscall_errors_ = new ::draiosproto::counter_syscall_errors;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.container.syscall_errors)
  return syscall_errors_;
}
inline ::draiosproto::counter_syscall_errors* container::release_syscall_errors() {
  // @@protoc_insertion_point(field_release:draiosproto.container.syscall_errors)
  clear_has_syscall_errors();
  ::draiosproto::counter_syscall_errors* temp = syscall_errors_;
  syscall_errors_ = NULL;
  return temp;
}
inline void container::set_allocated_syscall_errors(::draiosproto::counter_syscall_errors* syscall_errors) {
  delete syscall_errors_;
  syscall_errors_ = syscall_errors;
  if (syscall_errors) {
    set_has_syscall_errors();
  } else {
    clear_has_syscall_errors();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.container.syscall_errors)
}

// repeated .draiosproto.container_port_mapping port_mappings = 18;
inline int container::port_mappings_size() const {
  return port_mappings_.size();
}
inline void container::clear_port_mappings() {
  port_mappings_.Clear();
}
inline const ::draiosproto::container_port_mapping& container::port_mappings(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.container.port_mappings)
  return port_mappings_.Get(index);
}
inline ::draiosproto::container_port_mapping* container::mutable_port_mappings(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.container.port_mappings)
  return port_mappings_.Mutable(index);
}
inline ::draiosproto::container_port_mapping* container::add_port_mappings() {
  // @@protoc_insertion_point(field_add:draiosproto.container.port_mappings)
  return port_mappings_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::container_port_mapping >*
container::mutable_port_mappings() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.container.port_mappings)
  return &port_mappings_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::container_port_mapping >&
container::port_mappings() const {
  // @@protoc_insertion_point(field_list:draiosproto.container.port_mappings)
  return port_mappings_;
}

// optional .draiosproto.proto_info protos = 19;
inline bool container::has_protos() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void container::set_has_protos() {
  _has_bits_[0] |= 0x00004000u;
}
inline void container::clear_has_protos() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void container::clear_protos() {
  if (protos_ != NULL) protos_->::draiosproto::proto_info::Clear();
  clear_has_protos();
}
inline const ::draiosproto::proto_info& container::protos() const {
  // @@protoc_insertion_point(field_get:draiosproto.container.protos)
  return protos_ != NULL ? *protos_
                         : *::draiosproto::proto_info::internal_default_instance();
}
inline ::draiosproto::proto_info* container::mutable_protos() {
  set_has_protos();
  if (protos_ == NULL) {
    protos_ = new ::draiosproto::proto_info;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.container.protos)
  return protos_;
}
inline ::draiosproto::proto_info* container::release_protos() {
  // @@protoc_insertion_point(field_release:draiosproto.container.protos)
  clear_has_protos();
  ::draiosproto::proto_info* temp = protos_;
  protos_ = NULL;
  return temp;
}
inline void container::set_allocated_protos(::draiosproto::proto_info* protos) {
  delete protos_;
  protos_ = protos;
  if (protos) {
    set_has_protos();
  } else {
    clear_has_protos();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.container.protos)
}

// repeated .draiosproto.container_label labels = 20;
inline int container::labels_size() const {
  return labels_.size();
}
inline void container::clear_labels() {
  labels_.Clear();
}
inline const ::draiosproto::container_label& container::labels(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.container.labels)
  return labels_.Get(index);
}
inline ::draiosproto::container_label* container::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.container.labels)
  return labels_.Mutable(index);
}
inline ::draiosproto::container_label* container::add_labels() {
  // @@protoc_insertion_point(field_add:draiosproto.container.labels)
  return labels_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::container_label >*
container::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.container.labels)
  return &labels_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::container_label >&
container::labels() const {
  // @@protoc_insertion_point(field_list:draiosproto.container.labels)
  return labels_;
}

// repeated .draiosproto.mounted_fs mounts = 21;
inline int container::mounts_size() const {
  return mounts_.size();
}
inline void container::clear_mounts() {
  mounts_.Clear();
}
inline const ::draiosproto::mounted_fs& container::mounts(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.container.mounts)
  return mounts_.Get(index);
}
inline ::draiosproto::mounted_fs* container::mutable_mounts(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.container.mounts)
  return mounts_.Mutable(index);
}
inline ::draiosproto::mounted_fs* container::add_mounts() {
  // @@protoc_insertion_point(field_add:draiosproto.container.mounts)
  return mounts_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mounted_fs >*
container::mutable_mounts() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.container.mounts)
  return &mounts_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mounted_fs >&
container::mounts() const {
  // @@protoc_insertion_point(field_list:draiosproto.container.mounts)
  return mounts_;
}

// repeated .draiosproto.network_by_port network_by_serverports = 22;
inline int container::network_by_serverports_size() const {
  return network_by_serverports_.size();
}
inline void container::clear_network_by_serverports() {
  network_by_serverports_.Clear();
}
inline const ::draiosproto::network_by_port& container::network_by_serverports(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.container.network_by_serverports)
  return network_by_serverports_.Get(index);
}
inline ::draiosproto::network_by_port* container::mutable_network_by_serverports(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.container.network_by_serverports)
  return network_by_serverports_.Mutable(index);
}
inline ::draiosproto::network_by_port* container::add_network_by_serverports() {
  // @@protoc_insertion_point(field_add:draiosproto.container.network_by_serverports)
  return network_by_serverports_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::network_by_port >*
container::mutable_network_by_serverports() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.container.network_by_serverports)
  return &network_by_serverports_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::network_by_port >&
container::network_by_serverports() const {
  // @@protoc_insertion_point(field_list:draiosproto.container.network_by_serverports)
  return network_by_serverports_;
}

// optional string mesos_task_id = 23;
inline bool container::has_mesos_task_id() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void container::set_has_mesos_task_id() {
  _has_bits_[0] |= 0x00040000u;
}
inline void container::clear_has_mesos_task_id() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void container::clear_mesos_task_id() {
  mesos_task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mesos_task_id();
}
inline const ::std::string& container::mesos_task_id() const {
  // @@protoc_insertion_point(field_get:draiosproto.container.mesos_task_id)
  return mesos_task_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void container::set_mesos_task_id(const ::std::string& value) {
  set_has_mesos_task_id();
  mesos_task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.container.mesos_task_id)
}
inline void container::set_mesos_task_id(const char* value) {
  set_has_mesos_task_id();
  mesos_task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.container.mesos_task_id)
}
inline void container::set_mesos_task_id(const char* value, size_t size) {
  set_has_mesos_task_id();
  mesos_task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.container.mesos_task_id)
}
inline ::std::string* container::mutable_mesos_task_id() {
  set_has_mesos_task_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.container.mesos_task_id)
  return mesos_task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* container::release_mesos_task_id() {
  // @@protoc_insertion_point(field_release:draiosproto.container.mesos_task_id)
  clear_has_mesos_task_id();
  return mesos_task_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void container::set_allocated_mesos_task_id(::std::string* mesos_task_id) {
  if (mesos_task_id != NULL) {
    set_has_mesos_task_id();
  } else {
    clear_has_mesos_task_id();
  }
  mesos_task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mesos_task_id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.container.mesos_task_id)
}

// optional string image_id = 24;
inline bool container::has_image_id() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void container::set_has_image_id() {
  _has_bits_[0] |= 0x00080000u;
}
inline void container::clear_has_image_id() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void container::clear_image_id() {
  image_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_image_id();
}
inline const ::std::string& container::image_id() const {
  // @@protoc_insertion_point(field_get:draiosproto.container.image_id)
  return image_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void container::set_image_id(const ::std::string& value) {
  set_has_image_id();
  image_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.container.image_id)
}
inline void container::set_image_id(const char* value) {
  set_has_image_id();
  image_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.container.image_id)
}
inline void container::set_image_id(const char* value, size_t size) {
  set_has_image_id();
  image_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.container.image_id)
}
inline ::std::string* container::mutable_image_id() {
  set_has_image_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.container.image_id)
  return image_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* container::release_image_id() {
  // @@protoc_insertion_point(field_release:draiosproto.container.image_id)
  clear_has_image_id();
  return image_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void container::set_allocated_image_id(::std::string* image_id) {
  if (image_id != NULL) {
    set_has_image_id();
  } else {
    clear_has_image_id();
  }
  image_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image_id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.container.image_id)
}

inline const container* container::internal_default_instance() {
  return &container_default_instance_.get();
}
// -------------------------------------------------------------------

// k8s_pair

// required string key = 1;
inline bool k8s_pair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void k8s_pair::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void k8s_pair::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void k8s_pair::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& k8s_pair::key() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_pair.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void k8s_pair::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.k8s_pair.key)
}
inline void k8s_pair::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.k8s_pair.key)
}
inline void k8s_pair::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.k8s_pair.key)
}
inline ::std::string* k8s_pair::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_pair.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* k8s_pair::release_key() {
  // @@protoc_insertion_point(field_release:draiosproto.k8s_pair.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void k8s_pair::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.k8s_pair.key)
}

// required string value = 2;
inline bool k8s_pair::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void k8s_pair::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void k8s_pair::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void k8s_pair::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& k8s_pair::value() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_pair.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void k8s_pair::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.k8s_pair.value)
}
inline void k8s_pair::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.k8s_pair.value)
}
inline void k8s_pair::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.k8s_pair.value)
}
inline ::std::string* k8s_pair::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_pair.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* k8s_pair::release_value() {
  // @@protoc_insertion_point(field_release:draiosproto.k8s_pair.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void k8s_pair::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.k8s_pair.value)
}

inline const k8s_pair* k8s_pair::internal_default_instance() {
  return &k8s_pair_default_instance_.get();
}
// -------------------------------------------------------------------

// k8s_common

// required string name = 1;
inline bool k8s_common::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void k8s_common::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void k8s_common::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void k8s_common::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& k8s_common::name() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_common.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void k8s_common::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.k8s_common.name)
}
inline void k8s_common::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.k8s_common.name)
}
inline void k8s_common::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.k8s_common.name)
}
inline ::std::string* k8s_common::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_common.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* k8s_common::release_name() {
  // @@protoc_insertion_point(field_release:draiosproto.k8s_common.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void k8s_common::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.k8s_common.name)
}

// required string uid = 2;
inline bool k8s_common::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void k8s_common::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void k8s_common::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void k8s_common::clear_uid() {
  uid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uid();
}
inline const ::std::string& k8s_common::uid() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_common.uid)
  return uid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void k8s_common::set_uid(const ::std::string& value) {
  set_has_uid();
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.k8s_common.uid)
}
inline void k8s_common::set_uid(const char* value) {
  set_has_uid();
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.k8s_common.uid)
}
inline void k8s_common::set_uid(const char* value, size_t size) {
  set_has_uid();
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.k8s_common.uid)
}
inline ::std::string* k8s_common::mutable_uid() {
  set_has_uid();
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_common.uid)
  return uid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* k8s_common::release_uid() {
  // @@protoc_insertion_point(field_release:draiosproto.k8s_common.uid)
  clear_has_uid();
  return uid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void k8s_common::set_allocated_uid(::std::string* uid) {
  if (uid != NULL) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  uid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uid);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.k8s_common.uid)
}

// optional string namespace = 3;
inline bool k8s_common::has_namespace_() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void k8s_common::set_has_namespace_() {
  _has_bits_[0] |= 0x00000004u;
}
inline void k8s_common::clear_has_namespace_() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void k8s_common::clear_namespace_() {
  namespace__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_namespace_();
}
inline const ::std::string& k8s_common::namespace_() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_common.namespace)
  return namespace__.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void k8s_common::set_namespace_(const ::std::string& value) {
  set_has_namespace_();
  namespace__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.k8s_common.namespace)
}
inline void k8s_common::set_namespace_(const char* value) {
  set_has_namespace_();
  namespace__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.k8s_common.namespace)
}
inline void k8s_common::set_namespace_(const char* value, size_t size) {
  set_has_namespace_();
  namespace__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.k8s_common.namespace)
}
inline ::std::string* k8s_common::mutable_namespace_() {
  set_has_namespace_();
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_common.namespace)
  return namespace__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* k8s_common::release_namespace_() {
  // @@protoc_insertion_point(field_release:draiosproto.k8s_common.namespace)
  clear_has_namespace_();
  return namespace__.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void k8s_common::set_allocated_namespace_(::std::string* namespace_) {
  if (namespace_ != NULL) {
    set_has_namespace_();
  } else {
    clear_has_namespace_();
  }
  namespace__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), namespace_);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.k8s_common.namespace)
}

// repeated .draiosproto.k8s_pair labels = 4;
inline int k8s_common::labels_size() const {
  return labels_.size();
}
inline void k8s_common::clear_labels() {
  labels_.Clear();
}
inline const ::draiosproto::k8s_pair& k8s_common::labels(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_common.labels)
  return labels_.Get(index);
}
inline ::draiosproto::k8s_pair* k8s_common::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_common.labels)
  return labels_.Mutable(index);
}
inline ::draiosproto::k8s_pair* k8s_common::add_labels() {
  // @@protoc_insertion_point(field_add:draiosproto.k8s_common.labels)
  return labels_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pair >*
k8s_common::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.k8s_common.labels)
  return &labels_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pair >&
k8s_common::labels() const {
  // @@protoc_insertion_point(field_list:draiosproto.k8s_common.labels)
  return labels_;
}

// repeated .draiosproto.k8s_pair selectors = 5;
inline int k8s_common::selectors_size() const {
  return selectors_.size();
}
inline void k8s_common::clear_selectors() {
  selectors_.Clear();
}
inline const ::draiosproto::k8s_pair& k8s_common::selectors(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_common.selectors)
  return selectors_.Get(index);
}
inline ::draiosproto::k8s_pair* k8s_common::mutable_selectors(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_common.selectors)
  return selectors_.Mutable(index);
}
inline ::draiosproto::k8s_pair* k8s_common::add_selectors() {
  // @@protoc_insertion_point(field_add:draiosproto.k8s_common.selectors)
  return selectors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pair >*
k8s_common::mutable_selectors() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.k8s_common.selectors)
  return &selectors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pair >&
k8s_common::selectors() const {
  // @@protoc_insertion_point(field_list:draiosproto.k8s_common.selectors)
  return selectors_;
}

inline const k8s_common* k8s_common::internal_default_instance() {
  return &k8s_common_default_instance_.get();
}
// -------------------------------------------------------------------

// k8s_namespace

// required .draiosproto.k8s_common common = 1;
inline bool k8s_namespace::has_common() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void k8s_namespace::set_has_common() {
  _has_bits_[0] |= 0x00000001u;
}
inline void k8s_namespace::clear_has_common() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void k8s_namespace::clear_common() {
  if (common_ != NULL) common_->::draiosproto::k8s_common::Clear();
  clear_has_common();
}
inline const ::draiosproto::k8s_common& k8s_namespace::common() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_namespace.common)
  return common_ != NULL ? *common_
                         : *::draiosproto::k8s_common::internal_default_instance();
}
inline ::draiosproto::k8s_common* k8s_namespace::mutable_common() {
  set_has_common();
  if (common_ == NULL) {
    common_ = new ::draiosproto::k8s_common;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_namespace.common)
  return common_;
}
inline ::draiosproto::k8s_common* k8s_namespace::release_common() {
  // @@protoc_insertion_point(field_release:draiosproto.k8s_namespace.common)
  clear_has_common();
  ::draiosproto::k8s_common* temp = common_;
  common_ = NULL;
  return temp;
}
inline void k8s_namespace::set_allocated_common(::draiosproto::k8s_common* common) {
  delete common_;
  common_ = common;
  if (common) {
    set_has_common();
  } else {
    clear_has_common();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.k8s_namespace.common)
}

inline const k8s_namespace* k8s_namespace::internal_default_instance() {
  return &k8s_namespace_default_instance_.get();
}
// -------------------------------------------------------------------

// k8s_node

// required .draiosproto.k8s_common common = 1;
inline bool k8s_node::has_common() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void k8s_node::set_has_common() {
  _has_bits_[0] |= 0x00000001u;
}
inline void k8s_node::clear_has_common() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void k8s_node::clear_common() {
  if (common_ != NULL) common_->::draiosproto::k8s_common::Clear();
  clear_has_common();
}
inline const ::draiosproto::k8s_common& k8s_node::common() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_node.common)
  return common_ != NULL ? *common_
                         : *::draiosproto::k8s_common::internal_default_instance();
}
inline ::draiosproto::k8s_common* k8s_node::mutable_common() {
  set_has_common();
  if (common_ == NULL) {
    common_ = new ::draiosproto::k8s_common;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_node.common)
  return common_;
}
inline ::draiosproto::k8s_common* k8s_node::release_common() {
  // @@protoc_insertion_point(field_release:draiosproto.k8s_node.common)
  clear_has_common();
  ::draiosproto::k8s_common* temp = common_;
  common_ = NULL;
  return temp;
}
inline void k8s_node::set_allocated_common(::draiosproto::k8s_common* common) {
  delete common_;
  common_ = common;
  if (common) {
    set_has_common();
  } else {
    clear_has_common();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.k8s_node.common)
}

// repeated string host_ips = 2;
inline int k8s_node::host_ips_size() const {
  return host_ips_.size();
}
inline void k8s_node::clear_host_ips() {
  host_ips_.Clear();
}
inline const ::std::string& k8s_node::host_ips(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_node.host_ips)
  return host_ips_.Get(index);
}
inline ::std::string* k8s_node::mutable_host_ips(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_node.host_ips)
  return host_ips_.Mutable(index);
}
inline void k8s_node::set_host_ips(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:draiosproto.k8s_node.host_ips)
  host_ips_.Mutable(index)->assign(value);
}
inline void k8s_node::set_host_ips(int index, const char* value) {
  host_ips_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:draiosproto.k8s_node.host_ips)
}
inline void k8s_node::set_host_ips(int index, const char* value, size_t size) {
  host_ips_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:draiosproto.k8s_node.host_ips)
}
inline ::std::string* k8s_node::add_host_ips() {
  // @@protoc_insertion_point(field_add_mutable:draiosproto.k8s_node.host_ips)
  return host_ips_.Add();
}
inline void k8s_node::add_host_ips(const ::std::string& value) {
  host_ips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:draiosproto.k8s_node.host_ips)
}
inline void k8s_node::add_host_ips(const char* value) {
  host_ips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:draiosproto.k8s_node.host_ips)
}
inline void k8s_node::add_host_ips(const char* value, size_t size) {
  host_ips_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:draiosproto.k8s_node.host_ips)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
k8s_node::host_ips() const {
  // @@protoc_insertion_point(field_list:draiosproto.k8s_node.host_ips)
  return host_ips_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
k8s_node::mutable_host_ips() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.k8s_node.host_ips)
  return &host_ips_;
}

inline const k8s_node* k8s_node::internal_default_instance() {
  return &k8s_node_default_instance_.get();
}
// -------------------------------------------------------------------

// k8s_pod

// required .draiosproto.k8s_common common = 1;
inline bool k8s_pod::has_common() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void k8s_pod::set_has_common() {
  _has_bits_[0] |= 0x00000001u;
}
inline void k8s_pod::clear_has_common() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void k8s_pod::clear_common() {
  if (common_ != NULL) common_->::draiosproto::k8s_common::Clear();
  clear_has_common();
}
inline const ::draiosproto::k8s_common& k8s_pod::common() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_pod.common)
  return common_ != NULL ? *common_
                         : *::draiosproto::k8s_common::internal_default_instance();
}
inline ::draiosproto::k8s_common* k8s_pod::mutable_common() {
  set_has_common();
  if (common_ == NULL) {
    common_ = new ::draiosproto::k8s_common;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_pod.common)
  return common_;
}
inline ::draiosproto::k8s_common* k8s_pod::release_common() {
  // @@protoc_insertion_point(field_release:draiosproto.k8s_pod.common)
  clear_has_common();
  ::draiosproto::k8s_common* temp = common_;
  common_ = NULL;
  return temp;
}
inline void k8s_pod::set_allocated_common(::draiosproto::k8s_common* common) {
  delete common_;
  common_ = common;
  if (common) {
    set_has_common();
  } else {
    clear_has_common();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.k8s_pod.common)
}

// repeated string container_ids = 2;
inline int k8s_pod::container_ids_size() const {
  return container_ids_.size();
}
inline void k8s_pod::clear_container_ids() {
  container_ids_.Clear();
}
inline const ::std::string& k8s_pod::container_ids(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_pod.container_ids)
  return container_ids_.Get(index);
}
inline ::std::string* k8s_pod::mutable_container_ids(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_pod.container_ids)
  return container_ids_.Mutable(index);
}
inline void k8s_pod::set_container_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:draiosproto.k8s_pod.container_ids)
  container_ids_.Mutable(index)->assign(value);
}
inline void k8s_pod::set_container_ids(int index, const char* value) {
  container_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:draiosproto.k8s_pod.container_ids)
}
inline void k8s_pod::set_container_ids(int index, const char* value, size_t size) {
  container_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:draiosproto.k8s_pod.container_ids)
}
inline ::std::string* k8s_pod::add_container_ids() {
  // @@protoc_insertion_point(field_add_mutable:draiosproto.k8s_pod.container_ids)
  return container_ids_.Add();
}
inline void k8s_pod::add_container_ids(const ::std::string& value) {
  container_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:draiosproto.k8s_pod.container_ids)
}
inline void k8s_pod::add_container_ids(const char* value) {
  container_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:draiosproto.k8s_pod.container_ids)
}
inline void k8s_pod::add_container_ids(const char* value, size_t size) {
  container_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:draiosproto.k8s_pod.container_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
k8s_pod::container_ids() const {
  // @@protoc_insertion_point(field_list:draiosproto.k8s_pod.container_ids)
  return container_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
k8s_pod::mutable_container_ids() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.k8s_pod.container_ids)
  return &container_ids_;
}

// optional string node_name = 3;
inline bool k8s_pod::has_node_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void k8s_pod::set_has_node_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void k8s_pod::clear_has_node_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void k8s_pod::clear_node_name() {
  node_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_node_name();
}
inline const ::std::string& k8s_pod::node_name() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_pod.node_name)
  return node_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void k8s_pod::set_node_name(const ::std::string& value) {
  set_has_node_name();
  node_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.k8s_pod.node_name)
}
inline void k8s_pod::set_node_name(const char* value) {
  set_has_node_name();
  node_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.k8s_pod.node_name)
}
inline void k8s_pod::set_node_name(const char* value, size_t size) {
  set_has_node_name();
  node_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.k8s_pod.node_name)
}
inline ::std::string* k8s_pod::mutable_node_name() {
  set_has_node_name();
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_pod.node_name)
  return node_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* k8s_pod::release_node_name() {
  // @@protoc_insertion_point(field_release:draiosproto.k8s_pod.node_name)
  clear_has_node_name();
  return node_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void k8s_pod::set_allocated_node_name(::std::string* node_name) {
  if (node_name != NULL) {
    set_has_node_name();
  } else {
    clear_has_node_name();
  }
  node_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_name);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.k8s_pod.node_name)
}

// optional string host_ip = 4;
inline bool k8s_pod::has_host_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void k8s_pod::set_has_host_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void k8s_pod::clear_has_host_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void k8s_pod::clear_host_ip() {
  host_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_host_ip();
}
inline const ::std::string& k8s_pod::host_ip() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_pod.host_ip)
  return host_ip_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void k8s_pod::set_host_ip(const ::std::string& value) {
  set_has_host_ip();
  host_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.k8s_pod.host_ip)
}
inline void k8s_pod::set_host_ip(const char* value) {
  set_has_host_ip();
  host_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.k8s_pod.host_ip)
}
inline void k8s_pod::set_host_ip(const char* value, size_t size) {
  set_has_host_ip();
  host_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.k8s_pod.host_ip)
}
inline ::std::string* k8s_pod::mutable_host_ip() {
  set_has_host_ip();
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_pod.host_ip)
  return host_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* k8s_pod::release_host_ip() {
  // @@protoc_insertion_point(field_release:draiosproto.k8s_pod.host_ip)
  clear_has_host_ip();
  return host_ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void k8s_pod::set_allocated_host_ip(::std::string* host_ip) {
  if (host_ip != NULL) {
    set_has_host_ip();
  } else {
    clear_has_host_ip();
  }
  host_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host_ip);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.k8s_pod.host_ip)
}

// optional string internal_ip = 5;
inline bool k8s_pod::has_internal_ip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void k8s_pod::set_has_internal_ip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void k8s_pod::clear_has_internal_ip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void k8s_pod::clear_internal_ip() {
  internal_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_internal_ip();
}
inline const ::std::string& k8s_pod::internal_ip() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_pod.internal_ip)
  return internal_ip_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void k8s_pod::set_internal_ip(const ::std::string& value) {
  set_has_internal_ip();
  internal_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.k8s_pod.internal_ip)
}
inline void k8s_pod::set_internal_ip(const char* value) {
  set_has_internal_ip();
  internal_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.k8s_pod.internal_ip)
}
inline void k8s_pod::set_internal_ip(const char* value, size_t size) {
  set_has_internal_ip();
  internal_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.k8s_pod.internal_ip)
}
inline ::std::string* k8s_pod::mutable_internal_ip() {
  set_has_internal_ip();
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_pod.internal_ip)
  return internal_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* k8s_pod::release_internal_ip() {
  // @@protoc_insertion_point(field_release:draiosproto.k8s_pod.internal_ip)
  clear_has_internal_ip();
  return internal_ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void k8s_pod::set_allocated_internal_ip(::std::string* internal_ip) {
  if (internal_ip != NULL) {
    set_has_internal_ip();
  } else {
    clear_has_internal_ip();
  }
  internal_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), internal_ip);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.k8s_pod.internal_ip)
}

// optional uint32 restart_count = 6;
inline bool k8s_pod::has_restart_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void k8s_pod::set_has_restart_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void k8s_pod::clear_has_restart_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void k8s_pod::clear_restart_count() {
  restart_count_ = 0u;
  clear_has_restart_count();
}
inline ::google::protobuf::uint32 k8s_pod::restart_count() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_pod.restart_count)
  return restart_count_;
}
inline void k8s_pod::set_restart_count(::google::protobuf::uint32 value) {
  set_has_restart_count();
  restart_count_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.k8s_pod.restart_count)
}

inline const k8s_pod* k8s_pod::internal_default_instance() {
  return &k8s_pod_default_instance_.get();
}
// -------------------------------------------------------------------

// k8s_replication_controller

// required .draiosproto.k8s_common common = 1;
inline bool k8s_replication_controller::has_common() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void k8s_replication_controller::set_has_common() {
  _has_bits_[0] |= 0x00000001u;
}
inline void k8s_replication_controller::clear_has_common() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void k8s_replication_controller::clear_common() {
  if (common_ != NULL) common_->::draiosproto::k8s_common::Clear();
  clear_has_common();
}
inline const ::draiosproto::k8s_common& k8s_replication_controller::common() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_replication_controller.common)
  return common_ != NULL ? *common_
                         : *::draiosproto::k8s_common::internal_default_instance();
}
inline ::draiosproto::k8s_common* k8s_replication_controller::mutable_common() {
  set_has_common();
  if (common_ == NULL) {
    common_ = new ::draiosproto::k8s_common;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_replication_controller.common)
  return common_;
}
inline ::draiosproto::k8s_common* k8s_replication_controller::release_common() {
  // @@protoc_insertion_point(field_release:draiosproto.k8s_replication_controller.common)
  clear_has_common();
  ::draiosproto::k8s_common* temp = common_;
  common_ = NULL;
  return temp;
}
inline void k8s_replication_controller::set_allocated_common(::draiosproto::k8s_common* common) {
  delete common_;
  common_ = common;
  if (common) {
    set_has_common();
  } else {
    clear_has_common();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.k8s_replication_controller.common)
}

// optional uint32 replicas_desired = 2;
inline bool k8s_replication_controller::has_replicas_desired() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void k8s_replication_controller::set_has_replicas_desired() {
  _has_bits_[0] |= 0x00000002u;
}
inline void k8s_replication_controller::clear_has_replicas_desired() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void k8s_replication_controller::clear_replicas_desired() {
  replicas_desired_ = 0u;
  clear_has_replicas_desired();
}
inline ::google::protobuf::uint32 k8s_replication_controller::replicas_desired() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_replication_controller.replicas_desired)
  return replicas_desired_;
}
inline void k8s_replication_controller::set_replicas_desired(::google::protobuf::uint32 value) {
  set_has_replicas_desired();
  replicas_desired_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.k8s_replication_controller.replicas_desired)
}

// optional uint32 replicas_running = 3;
inline bool k8s_replication_controller::has_replicas_running() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void k8s_replication_controller::set_has_replicas_running() {
  _has_bits_[0] |= 0x00000004u;
}
inline void k8s_replication_controller::clear_has_replicas_running() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void k8s_replication_controller::clear_replicas_running() {
  replicas_running_ = 0u;
  clear_has_replicas_running();
}
inline ::google::protobuf::uint32 k8s_replication_controller::replicas_running() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_replication_controller.replicas_running)
  return replicas_running_;
}
inline void k8s_replication_controller::set_replicas_running(::google::protobuf::uint32 value) {
  set_has_replicas_running();
  replicas_running_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.k8s_replication_controller.replicas_running)
}

inline const k8s_replication_controller* k8s_replication_controller::internal_default_instance() {
  return &k8s_replication_controller_default_instance_.get();
}
// -------------------------------------------------------------------

// k8s_replica_set

// required .draiosproto.k8s_common common = 1;
inline bool k8s_replica_set::has_common() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void k8s_replica_set::set_has_common() {
  _has_bits_[0] |= 0x00000001u;
}
inline void k8s_replica_set::clear_has_common() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void k8s_replica_set::clear_common() {
  if (common_ != NULL) common_->::draiosproto::k8s_common::Clear();
  clear_has_common();
}
inline const ::draiosproto::k8s_common& k8s_replica_set::common() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_replica_set.common)
  return common_ != NULL ? *common_
                         : *::draiosproto::k8s_common::internal_default_instance();
}
inline ::draiosproto::k8s_common* k8s_replica_set::mutable_common() {
  set_has_common();
  if (common_ == NULL) {
    common_ = new ::draiosproto::k8s_common;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_replica_set.common)
  return common_;
}
inline ::draiosproto::k8s_common* k8s_replica_set::release_common() {
  // @@protoc_insertion_point(field_release:draiosproto.k8s_replica_set.common)
  clear_has_common();
  ::draiosproto::k8s_common* temp = common_;
  common_ = NULL;
  return temp;
}
inline void k8s_replica_set::set_allocated_common(::draiosproto::k8s_common* common) {
  delete common_;
  common_ = common;
  if (common) {
    set_has_common();
  } else {
    clear_has_common();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.k8s_replica_set.common)
}

// optional uint32 replicas_desired = 2;
inline bool k8s_replica_set::has_replicas_desired() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void k8s_replica_set::set_has_replicas_desired() {
  _has_bits_[0] |= 0x00000002u;
}
inline void k8s_replica_set::clear_has_replicas_desired() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void k8s_replica_set::clear_replicas_desired() {
  replicas_desired_ = 0u;
  clear_has_replicas_desired();
}
inline ::google::protobuf::uint32 k8s_replica_set::replicas_desired() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_replica_set.replicas_desired)
  return replicas_desired_;
}
inline void k8s_replica_set::set_replicas_desired(::google::protobuf::uint32 value) {
  set_has_replicas_desired();
  replicas_desired_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.k8s_replica_set.replicas_desired)
}

// optional uint32 replicas_running = 3;
inline bool k8s_replica_set::has_replicas_running() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void k8s_replica_set::set_has_replicas_running() {
  _has_bits_[0] |= 0x00000004u;
}
inline void k8s_replica_set::clear_has_replicas_running() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void k8s_replica_set::clear_replicas_running() {
  replicas_running_ = 0u;
  clear_has_replicas_running();
}
inline ::google::protobuf::uint32 k8s_replica_set::replicas_running() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_replica_set.replicas_running)
  return replicas_running_;
}
inline void k8s_replica_set::set_replicas_running(::google::protobuf::uint32 value) {
  set_has_replicas_running();
  replicas_running_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.k8s_replica_set.replicas_running)
}

inline const k8s_replica_set* k8s_replica_set::internal_default_instance() {
  return &k8s_replica_set_default_instance_.get();
}
// -------------------------------------------------------------------

// k8s_service_net_port

// required uint32 port = 1;
inline bool k8s_service_net_port::has_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void k8s_service_net_port::set_has_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void k8s_service_net_port::clear_has_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void k8s_service_net_port::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 k8s_service_net_port::port() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_service.net_port.port)
  return port_;
}
inline void k8s_service_net_port::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.k8s_service.net_port.port)
}

// required uint32 target_port = 2;
inline bool k8s_service_net_port::has_target_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void k8s_service_net_port::set_has_target_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void k8s_service_net_port::clear_has_target_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void k8s_service_net_port::clear_target_port() {
  target_port_ = 0u;
  clear_has_target_port();
}
inline ::google::protobuf::uint32 k8s_service_net_port::target_port() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_service.net_port.target_port)
  return target_port_;
}
inline void k8s_service_net_port::set_target_port(::google::protobuf::uint32 value) {
  set_has_target_port();
  target_port_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.k8s_service.net_port.target_port)
}

// optional string protocol = 3;
inline bool k8s_service_net_port::has_protocol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void k8s_service_net_port::set_has_protocol() {
  _has_bits_[0] |= 0x00000004u;
}
inline void k8s_service_net_port::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void k8s_service_net_port::clear_protocol() {
  protocol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_protocol();
}
inline const ::std::string& k8s_service_net_port::protocol() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_service.net_port.protocol)
  return protocol_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void k8s_service_net_port::set_protocol(const ::std::string& value) {
  set_has_protocol();
  protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.k8s_service.net_port.protocol)
}
inline void k8s_service_net_port::set_protocol(const char* value) {
  set_has_protocol();
  protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.k8s_service.net_port.protocol)
}
inline void k8s_service_net_port::set_protocol(const char* value, size_t size) {
  set_has_protocol();
  protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.k8s_service.net_port.protocol)
}
inline ::std::string* k8s_service_net_port::mutable_protocol() {
  set_has_protocol();
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_service.net_port.protocol)
  return protocol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* k8s_service_net_port::release_protocol() {
  // @@protoc_insertion_point(field_release:draiosproto.k8s_service.net_port.protocol)
  clear_has_protocol();
  return protocol_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void k8s_service_net_port::set_allocated_protocol(::std::string* protocol) {
  if (protocol != NULL) {
    set_has_protocol();
  } else {
    clear_has_protocol();
  }
  protocol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), protocol);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.k8s_service.net_port.protocol)
}

// optional uint32 node_port = 4;
inline bool k8s_service_net_port::has_node_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void k8s_service_net_port::set_has_node_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void k8s_service_net_port::clear_has_node_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void k8s_service_net_port::clear_node_port() {
  node_port_ = 0u;
  clear_has_node_port();
}
inline ::google::protobuf::uint32 k8s_service_net_port::node_port() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_service.net_port.node_port)
  return node_port_;
}
inline void k8s_service_net_port::set_node_port(::google::protobuf::uint32 value) {
  set_has_node_port();
  node_port_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.k8s_service.net_port.node_port)
}

inline const k8s_service_net_port* k8s_service_net_port::internal_default_instance() {
  return &k8s_service_net_port_default_instance_.get();
}
// -------------------------------------------------------------------

// k8s_service

// required .draiosproto.k8s_common common = 1;
inline bool k8s_service::has_common() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void k8s_service::set_has_common() {
  _has_bits_[0] |= 0x00000001u;
}
inline void k8s_service::clear_has_common() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void k8s_service::clear_common() {
  if (common_ != NULL) common_->::draiosproto::k8s_common::Clear();
  clear_has_common();
}
inline const ::draiosproto::k8s_common& k8s_service::common() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_service.common)
  return common_ != NULL ? *common_
                         : *::draiosproto::k8s_common::internal_default_instance();
}
inline ::draiosproto::k8s_common* k8s_service::mutable_common() {
  set_has_common();
  if (common_ == NULL) {
    common_ = new ::draiosproto::k8s_common;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_service.common)
  return common_;
}
inline ::draiosproto::k8s_common* k8s_service::release_common() {
  // @@protoc_insertion_point(field_release:draiosproto.k8s_service.common)
  clear_has_common();
  ::draiosproto::k8s_common* temp = common_;
  common_ = NULL;
  return temp;
}
inline void k8s_service::set_allocated_common(::draiosproto::k8s_common* common) {
  delete common_;
  common_ = common;
  if (common) {
    set_has_common();
  } else {
    clear_has_common();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.k8s_service.common)
}

// optional string cluster_ip = 2;
inline bool k8s_service::has_cluster_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void k8s_service::set_has_cluster_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void k8s_service::clear_has_cluster_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void k8s_service::clear_cluster_ip() {
  cluster_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_cluster_ip();
}
inline const ::std::string& k8s_service::cluster_ip() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_service.cluster_ip)
  return cluster_ip_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void k8s_service::set_cluster_ip(const ::std::string& value) {
  set_has_cluster_ip();
  cluster_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.k8s_service.cluster_ip)
}
inline void k8s_service::set_cluster_ip(const char* value) {
  set_has_cluster_ip();
  cluster_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.k8s_service.cluster_ip)
}
inline void k8s_service::set_cluster_ip(const char* value, size_t size) {
  set_has_cluster_ip();
  cluster_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.k8s_service.cluster_ip)
}
inline ::std::string* k8s_service::mutable_cluster_ip() {
  set_has_cluster_ip();
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_service.cluster_ip)
  return cluster_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* k8s_service::release_cluster_ip() {
  // @@protoc_insertion_point(field_release:draiosproto.k8s_service.cluster_ip)
  clear_has_cluster_ip();
  return cluster_ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void k8s_service::set_allocated_cluster_ip(::std::string* cluster_ip) {
  if (cluster_ip != NULL) {
    set_has_cluster_ip();
  } else {
    clear_has_cluster_ip();
  }
  cluster_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cluster_ip);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.k8s_service.cluster_ip)
}

// repeated .draiosproto.k8s_service.net_port ports = 3;
inline int k8s_service::ports_size() const {
  return ports_.size();
}
inline void k8s_service::clear_ports() {
  ports_.Clear();
}
inline const ::draiosproto::k8s_service_net_port& k8s_service::ports(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_service.ports)
  return ports_.Get(index);
}
inline ::draiosproto::k8s_service_net_port* k8s_service::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_service.ports)
  return ports_.Mutable(index);
}
inline ::draiosproto::k8s_service_net_port* k8s_service::add_ports() {
  // @@protoc_insertion_point(field_add:draiosproto.k8s_service.ports)
  return ports_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_service_net_port >*
k8s_service::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.k8s_service.ports)
  return &ports_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_service_net_port >&
k8s_service::ports() const {
  // @@protoc_insertion_point(field_list:draiosproto.k8s_service.ports)
  return ports_;
}

inline const k8s_service* k8s_service::internal_default_instance() {
  return &k8s_service_default_instance_.get();
}
// -------------------------------------------------------------------

// k8s_deployment

// required .draiosproto.k8s_common common = 1;
inline bool k8s_deployment::has_common() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void k8s_deployment::set_has_common() {
  _has_bits_[0] |= 0x00000001u;
}
inline void k8s_deployment::clear_has_common() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void k8s_deployment::clear_common() {
  if (common_ != NULL) common_->::draiosproto::k8s_common::Clear();
  clear_has_common();
}
inline const ::draiosproto::k8s_common& k8s_deployment::common() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_deployment.common)
  return common_ != NULL ? *common_
                         : *::draiosproto::k8s_common::internal_default_instance();
}
inline ::draiosproto::k8s_common* k8s_deployment::mutable_common() {
  set_has_common();
  if (common_ == NULL) {
    common_ = new ::draiosproto::k8s_common;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_deployment.common)
  return common_;
}
inline ::draiosproto::k8s_common* k8s_deployment::release_common() {
  // @@protoc_insertion_point(field_release:draiosproto.k8s_deployment.common)
  clear_has_common();
  ::draiosproto::k8s_common* temp = common_;
  common_ = NULL;
  return temp;
}
inline void k8s_deployment::set_allocated_common(::draiosproto::k8s_common* common) {
  delete common_;
  common_ = common;
  if (common) {
    set_has_common();
  } else {
    clear_has_common();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.k8s_deployment.common)
}

// optional uint32 replicas_desired = 2;
inline bool k8s_deployment::has_replicas_desired() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void k8s_deployment::set_has_replicas_desired() {
  _has_bits_[0] |= 0x00000002u;
}
inline void k8s_deployment::clear_has_replicas_desired() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void k8s_deployment::clear_replicas_desired() {
  replicas_desired_ = 0u;
  clear_has_replicas_desired();
}
inline ::google::protobuf::uint32 k8s_deployment::replicas_desired() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_deployment.replicas_desired)
  return replicas_desired_;
}
inline void k8s_deployment::set_replicas_desired(::google::protobuf::uint32 value) {
  set_has_replicas_desired();
  replicas_desired_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.k8s_deployment.replicas_desired)
}

// optional uint32 replicas_running = 3;
inline bool k8s_deployment::has_replicas_running() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void k8s_deployment::set_has_replicas_running() {
  _has_bits_[0] |= 0x00000004u;
}
inline void k8s_deployment::clear_has_replicas_running() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void k8s_deployment::clear_replicas_running() {
  replicas_running_ = 0u;
  clear_has_replicas_running();
}
inline ::google::protobuf::uint32 k8s_deployment::replicas_running() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_deployment.replicas_running)
  return replicas_running_;
}
inline void k8s_deployment::set_replicas_running(::google::protobuf::uint32 value) {
  set_has_replicas_running();
  replicas_running_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.k8s_deployment.replicas_running)
}

inline const k8s_deployment* k8s_deployment::internal_default_instance() {
  return &k8s_deployment_default_instance_.get();
}
// -------------------------------------------------------------------

// k8s_daemonset

// required .draiosproto.k8s_common common = 1;
inline bool k8s_daemonset::has_common() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void k8s_daemonset::set_has_common() {
  _has_bits_[0] |= 0x00000001u;
}
inline void k8s_daemonset::clear_has_common() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void k8s_daemonset::clear_common() {
  if (common_ != NULL) common_->::draiosproto::k8s_common::Clear();
  clear_has_common();
}
inline const ::draiosproto::k8s_common& k8s_daemonset::common() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_daemonset.common)
  return common_ != NULL ? *common_
                         : *::draiosproto::k8s_common::internal_default_instance();
}
inline ::draiosproto::k8s_common* k8s_daemonset::mutable_common() {
  set_has_common();
  if (common_ == NULL) {
    common_ = new ::draiosproto::k8s_common;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_daemonset.common)
  return common_;
}
inline ::draiosproto::k8s_common* k8s_daemonset::release_common() {
  // @@protoc_insertion_point(field_release:draiosproto.k8s_daemonset.common)
  clear_has_common();
  ::draiosproto::k8s_common* temp = common_;
  common_ = NULL;
  return temp;
}
inline void k8s_daemonset::set_allocated_common(::draiosproto::k8s_common* common) {
  delete common_;
  common_ = common;
  if (common) {
    set_has_common();
  } else {
    clear_has_common();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.k8s_daemonset.common)
}

// optional uint32 current_scheduled = 2;
inline bool k8s_daemonset::has_current_scheduled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void k8s_daemonset::set_has_current_scheduled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void k8s_daemonset::clear_has_current_scheduled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void k8s_daemonset::clear_current_scheduled() {
  current_scheduled_ = 0u;
  clear_has_current_scheduled();
}
inline ::google::protobuf::uint32 k8s_daemonset::current_scheduled() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_daemonset.current_scheduled)
  return current_scheduled_;
}
inline void k8s_daemonset::set_current_scheduled(::google::protobuf::uint32 value) {
  set_has_current_scheduled();
  current_scheduled_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.k8s_daemonset.current_scheduled)
}

// optional uint32 desired_scheduled = 3;
inline bool k8s_daemonset::has_desired_scheduled() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void k8s_daemonset::set_has_desired_scheduled() {
  _has_bits_[0] |= 0x00000004u;
}
inline void k8s_daemonset::clear_has_desired_scheduled() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void k8s_daemonset::clear_desired_scheduled() {
  desired_scheduled_ = 0u;
  clear_has_desired_scheduled();
}
inline ::google::protobuf::uint32 k8s_daemonset::desired_scheduled() const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_daemonset.desired_scheduled)
  return desired_scheduled_;
}
inline void k8s_daemonset::set_desired_scheduled(::google::protobuf::uint32 value) {
  set_has_desired_scheduled();
  desired_scheduled_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.k8s_daemonset.desired_scheduled)
}

inline const k8s_daemonset* k8s_daemonset::internal_default_instance() {
  return &k8s_daemonset_default_instance_.get();
}
// -------------------------------------------------------------------

// k8s_state

// repeated .draiosproto.k8s_namespace namespaces = 1;
inline int k8s_state::namespaces_size() const {
  return namespaces_.size();
}
inline void k8s_state::clear_namespaces() {
  namespaces_.Clear();
}
inline const ::draiosproto::k8s_namespace& k8s_state::namespaces(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_state.namespaces)
  return namespaces_.Get(index);
}
inline ::draiosproto::k8s_namespace* k8s_state::mutable_namespaces(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_state.namespaces)
  return namespaces_.Mutable(index);
}
inline ::draiosproto::k8s_namespace* k8s_state::add_namespaces() {
  // @@protoc_insertion_point(field_add:draiosproto.k8s_state.namespaces)
  return namespaces_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_namespace >*
k8s_state::mutable_namespaces() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.k8s_state.namespaces)
  return &namespaces_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_namespace >&
k8s_state::namespaces() const {
  // @@protoc_insertion_point(field_list:draiosproto.k8s_state.namespaces)
  return namespaces_;
}

// repeated .draiosproto.k8s_node nodes = 2;
inline int k8s_state::nodes_size() const {
  return nodes_.size();
}
inline void k8s_state::clear_nodes() {
  nodes_.Clear();
}
inline const ::draiosproto::k8s_node& k8s_state::nodes(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_state.nodes)
  return nodes_.Get(index);
}
inline ::draiosproto::k8s_node* k8s_state::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_state.nodes)
  return nodes_.Mutable(index);
}
inline ::draiosproto::k8s_node* k8s_state::add_nodes() {
  // @@protoc_insertion_point(field_add:draiosproto.k8s_state.nodes)
  return nodes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_node >*
k8s_state::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.k8s_state.nodes)
  return &nodes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_node >&
k8s_state::nodes() const {
  // @@protoc_insertion_point(field_list:draiosproto.k8s_state.nodes)
  return nodes_;
}

// repeated .draiosproto.k8s_pod pods = 3;
inline int k8s_state::pods_size() const {
  return pods_.size();
}
inline void k8s_state::clear_pods() {
  pods_.Clear();
}
inline const ::draiosproto::k8s_pod& k8s_state::pods(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_state.pods)
  return pods_.Get(index);
}
inline ::draiosproto::k8s_pod* k8s_state::mutable_pods(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_state.pods)
  return pods_.Mutable(index);
}
inline ::draiosproto::k8s_pod* k8s_state::add_pods() {
  // @@protoc_insertion_point(field_add:draiosproto.k8s_state.pods)
  return pods_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pod >*
k8s_state::mutable_pods() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.k8s_state.pods)
  return &pods_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pod >&
k8s_state::pods() const {
  // @@protoc_insertion_point(field_list:draiosproto.k8s_state.pods)
  return pods_;
}

// repeated .draiosproto.k8s_replication_controller controllers = 4;
inline int k8s_state::controllers_size() const {
  return controllers_.size();
}
inline void k8s_state::clear_controllers() {
  controllers_.Clear();
}
inline const ::draiosproto::k8s_replication_controller& k8s_state::controllers(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_state.controllers)
  return controllers_.Get(index);
}
inline ::draiosproto::k8s_replication_controller* k8s_state::mutable_controllers(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_state.controllers)
  return controllers_.Mutable(index);
}
inline ::draiosproto::k8s_replication_controller* k8s_state::add_controllers() {
  // @@protoc_insertion_point(field_add:draiosproto.k8s_state.controllers)
  return controllers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_replication_controller >*
k8s_state::mutable_controllers() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.k8s_state.controllers)
  return &controllers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_replication_controller >&
k8s_state::controllers() const {
  // @@protoc_insertion_point(field_list:draiosproto.k8s_state.controllers)
  return controllers_;
}

// repeated .draiosproto.k8s_service services = 5;
inline int k8s_state::services_size() const {
  return services_.size();
}
inline void k8s_state::clear_services() {
  services_.Clear();
}
inline const ::draiosproto::k8s_service& k8s_state::services(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_state.services)
  return services_.Get(index);
}
inline ::draiosproto::k8s_service* k8s_state::mutable_services(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_state.services)
  return services_.Mutable(index);
}
inline ::draiosproto::k8s_service* k8s_state::add_services() {
  // @@protoc_insertion_point(field_add:draiosproto.k8s_state.services)
  return services_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_service >*
k8s_state::mutable_services() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.k8s_state.services)
  return &services_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_service >&
k8s_state::services() const {
  // @@protoc_insertion_point(field_list:draiosproto.k8s_state.services)
  return services_;
}

// repeated .draiosproto.k8s_replica_set replica_sets = 6;
inline int k8s_state::replica_sets_size() const {
  return replica_sets_.size();
}
inline void k8s_state::clear_replica_sets() {
  replica_sets_.Clear();
}
inline const ::draiosproto::k8s_replica_set& k8s_state::replica_sets(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_state.replica_sets)
  return replica_sets_.Get(index);
}
inline ::draiosproto::k8s_replica_set* k8s_state::mutable_replica_sets(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_state.replica_sets)
  return replica_sets_.Mutable(index);
}
inline ::draiosproto::k8s_replica_set* k8s_state::add_replica_sets() {
  // @@protoc_insertion_point(field_add:draiosproto.k8s_state.replica_sets)
  return replica_sets_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_replica_set >*
k8s_state::mutable_replica_sets() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.k8s_state.replica_sets)
  return &replica_sets_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_replica_set >&
k8s_state::replica_sets() const {
  // @@protoc_insertion_point(field_list:draiosproto.k8s_state.replica_sets)
  return replica_sets_;
}

// repeated .draiosproto.k8s_deployment deployments = 7;
inline int k8s_state::deployments_size() const {
  return deployments_.size();
}
inline void k8s_state::clear_deployments() {
  deployments_.Clear();
}
inline const ::draiosproto::k8s_deployment& k8s_state::deployments(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_state.deployments)
  return deployments_.Get(index);
}
inline ::draiosproto::k8s_deployment* k8s_state::mutable_deployments(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_state.deployments)
  return deployments_.Mutable(index);
}
inline ::draiosproto::k8s_deployment* k8s_state::add_deployments() {
  // @@protoc_insertion_point(field_add:draiosproto.k8s_state.deployments)
  return deployments_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_deployment >*
k8s_state::mutable_deployments() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.k8s_state.deployments)
  return &deployments_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_deployment >&
k8s_state::deployments() const {
  // @@protoc_insertion_point(field_list:draiosproto.k8s_state.deployments)
  return deployments_;
}

// repeated .draiosproto.k8s_daemonset daemonsets = 8;
inline int k8s_state::daemonsets_size() const {
  return daemonsets_.size();
}
inline void k8s_state::clear_daemonsets() {
  daemonsets_.Clear();
}
inline const ::draiosproto::k8s_daemonset& k8s_state::daemonsets(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.k8s_state.daemonsets)
  return daemonsets_.Get(index);
}
inline ::draiosproto::k8s_daemonset* k8s_state::mutable_daemonsets(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.k8s_state.daemonsets)
  return daemonsets_.Mutable(index);
}
inline ::draiosproto::k8s_daemonset* k8s_state::add_daemonsets() {
  // @@protoc_insertion_point(field_add:draiosproto.k8s_state.daemonsets)
  return daemonsets_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_daemonset >*
k8s_state::mutable_daemonsets() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.k8s_state.daemonsets)
  return &daemonsets_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_daemonset >&
k8s_state::daemonsets() const {
  // @@protoc_insertion_point(field_list:draiosproto.k8s_state.daemonsets)
  return daemonsets_;
}

inline const k8s_state* k8s_state::internal_default_instance() {
  return &k8s_state_default_instance_.get();
}
// -------------------------------------------------------------------

// mesos_pair

// required string key = 1;
inline bool mesos_pair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mesos_pair::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mesos_pair::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mesos_pair::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& mesos_pair::key() const {
  // @@protoc_insertion_point(field_get:draiosproto.mesos_pair.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void mesos_pair::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.mesos_pair.key)
}
inline void mesos_pair::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.mesos_pair.key)
}
inline void mesos_pair::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.mesos_pair.key)
}
inline ::std::string* mesos_pair::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:draiosproto.mesos_pair.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* mesos_pair::release_key() {
  // @@protoc_insertion_point(field_release:draiosproto.mesos_pair.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void mesos_pair::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.mesos_pair.key)
}

// required string value = 2;
inline bool mesos_pair::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mesos_pair::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mesos_pair::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mesos_pair::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& mesos_pair::value() const {
  // @@protoc_insertion_point(field_get:draiosproto.mesos_pair.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void mesos_pair::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.mesos_pair.value)
}
inline void mesos_pair::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.mesos_pair.value)
}
inline void mesos_pair::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.mesos_pair.value)
}
inline ::std::string* mesos_pair::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:draiosproto.mesos_pair.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* mesos_pair::release_value() {
  // @@protoc_insertion_point(field_release:draiosproto.mesos_pair.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void mesos_pair::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.mesos_pair.value)
}

inline const mesos_pair* mesos_pair::internal_default_instance() {
  return &mesos_pair_default_instance_.get();
}
// -------------------------------------------------------------------

// mesos_common

// required string uid = 1;
inline bool mesos_common::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mesos_common::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mesos_common::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mesos_common::clear_uid() {
  uid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uid();
}
inline const ::std::string& mesos_common::uid() const {
  // @@protoc_insertion_point(field_get:draiosproto.mesos_common.uid)
  return uid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void mesos_common::set_uid(const ::std::string& value) {
  set_has_uid();
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.mesos_common.uid)
}
inline void mesos_common::set_uid(const char* value) {
  set_has_uid();
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.mesos_common.uid)
}
inline void mesos_common::set_uid(const char* value, size_t size) {
  set_has_uid();
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.mesos_common.uid)
}
inline ::std::string* mesos_common::mutable_uid() {
  set_has_uid();
  // @@protoc_insertion_point(field_mutable:draiosproto.mesos_common.uid)
  return uid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* mesos_common::release_uid() {
  // @@protoc_insertion_point(field_release:draiosproto.mesos_common.uid)
  clear_has_uid();
  return uid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void mesos_common::set_allocated_uid(::std::string* uid) {
  if (uid != NULL) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  uid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uid);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.mesos_common.uid)
}

// optional string name = 2;
inline bool mesos_common::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mesos_common::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mesos_common::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mesos_common::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& mesos_common::name() const {
  // @@protoc_insertion_point(field_get:draiosproto.mesos_common.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void mesos_common::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.mesos_common.name)
}
inline void mesos_common::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.mesos_common.name)
}
inline void mesos_common::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.mesos_common.name)
}
inline ::std::string* mesos_common::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:draiosproto.mesos_common.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* mesos_common::release_name() {
  // @@protoc_insertion_point(field_release:draiosproto.mesos_common.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void mesos_common::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.mesos_common.name)
}

// repeated .draiosproto.mesos_pair labels = 3;
inline int mesos_common::labels_size() const {
  return labels_.size();
}
inline void mesos_common::clear_labels() {
  labels_.Clear();
}
inline const ::draiosproto::mesos_pair& mesos_common::labels(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.mesos_common.labels)
  return labels_.Get(index);
}
inline ::draiosproto::mesos_pair* mesos_common::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.mesos_common.labels)
  return labels_.Mutable(index);
}
inline ::draiosproto::mesos_pair* mesos_common::add_labels() {
  // @@protoc_insertion_point(field_add:draiosproto.mesos_common.labels)
  return labels_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_pair >*
mesos_common::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.mesos_common.labels)
  return &labels_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_pair >&
mesos_common::labels() const {
  // @@protoc_insertion_point(field_list:draiosproto.mesos_common.labels)
  return labels_;
}

inline const mesos_common* mesos_common::internal_default_instance() {
  return &mesos_common_default_instance_.get();
}
// -------------------------------------------------------------------

// mesos_task

// required .draiosproto.mesos_common common = 1;
inline bool mesos_task::has_common() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mesos_task::set_has_common() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mesos_task::clear_has_common() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mesos_task::clear_common() {
  if (common_ != NULL) common_->::draiosproto::mesos_common::Clear();
  clear_has_common();
}
inline const ::draiosproto::mesos_common& mesos_task::common() const {
  // @@protoc_insertion_point(field_get:draiosproto.mesos_task.common)
  return common_ != NULL ? *common_
                         : *::draiosproto::mesos_common::internal_default_instance();
}
inline ::draiosproto::mesos_common* mesos_task::mutable_common() {
  set_has_common();
  if (common_ == NULL) {
    common_ = new ::draiosproto::mesos_common;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.mesos_task.common)
  return common_;
}
inline ::draiosproto::mesos_common* mesos_task::release_common() {
  // @@protoc_insertion_point(field_release:draiosproto.mesos_task.common)
  clear_has_common();
  ::draiosproto::mesos_common* temp = common_;
  common_ = NULL;
  return temp;
}
inline void mesos_task::set_allocated_common(::draiosproto::mesos_common* common) {
  delete common_;
  common_ = common;
  if (common) {
    set_has_common();
  } else {
    clear_has_common();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.mesos_task.common)
}

// required string slave_id = 2;
inline bool mesos_task::has_slave_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mesos_task::set_has_slave_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mesos_task::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mesos_task::clear_slave_id() {
  slave_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_slave_id();
}
inline const ::std::string& mesos_task::slave_id() const {
  // @@protoc_insertion_point(field_get:draiosproto.mesos_task.slave_id)
  return slave_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void mesos_task::set_slave_id(const ::std::string& value) {
  set_has_slave_id();
  slave_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.mesos_task.slave_id)
}
inline void mesos_task::set_slave_id(const char* value) {
  set_has_slave_id();
  slave_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.mesos_task.slave_id)
}
inline void mesos_task::set_slave_id(const char* value, size_t size) {
  set_has_slave_id();
  slave_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.mesos_task.slave_id)
}
inline ::std::string* mesos_task::mutable_slave_id() {
  set_has_slave_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.mesos_task.slave_id)
  return slave_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* mesos_task::release_slave_id() {
  // @@protoc_insertion_point(field_release:draiosproto.mesos_task.slave_id)
  clear_has_slave_id();
  return slave_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void mesos_task::set_allocated_slave_id(::std::string* slave_id) {
  if (slave_id != NULL) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  slave_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), slave_id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.mesos_task.slave_id)
}

inline const mesos_task* mesos_task::internal_default_instance() {
  return &mesos_task_default_instance_.get();
}
// -------------------------------------------------------------------

// marathon_app

// required string id = 1;
inline bool marathon_app::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void marathon_app::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void marathon_app::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void marathon_app::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& marathon_app::id() const {
  // @@protoc_insertion_point(field_get:draiosproto.marathon_app.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void marathon_app::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.marathon_app.id)
}
inline void marathon_app::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.marathon_app.id)
}
inline void marathon_app::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.marathon_app.id)
}
inline ::std::string* marathon_app::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.marathon_app.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* marathon_app::release_id() {
  // @@protoc_insertion_point(field_release:draiosproto.marathon_app.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void marathon_app::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.marathon_app.id)
}

// repeated string task_ids = 2;
inline int marathon_app::task_ids_size() const {
  return task_ids_.size();
}
inline void marathon_app::clear_task_ids() {
  task_ids_.Clear();
}
inline const ::std::string& marathon_app::task_ids(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.marathon_app.task_ids)
  return task_ids_.Get(index);
}
inline ::std::string* marathon_app::mutable_task_ids(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.marathon_app.task_ids)
  return task_ids_.Mutable(index);
}
inline void marathon_app::set_task_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:draiosproto.marathon_app.task_ids)
  task_ids_.Mutable(index)->assign(value);
}
inline void marathon_app::set_task_ids(int index, const char* value) {
  task_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:draiosproto.marathon_app.task_ids)
}
inline void marathon_app::set_task_ids(int index, const char* value, size_t size) {
  task_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:draiosproto.marathon_app.task_ids)
}
inline ::std::string* marathon_app::add_task_ids() {
  // @@protoc_insertion_point(field_add_mutable:draiosproto.marathon_app.task_ids)
  return task_ids_.Add();
}
inline void marathon_app::add_task_ids(const ::std::string& value) {
  task_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:draiosproto.marathon_app.task_ids)
}
inline void marathon_app::add_task_ids(const char* value) {
  task_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:draiosproto.marathon_app.task_ids)
}
inline void marathon_app::add_task_ids(const char* value, size_t size) {
  task_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:draiosproto.marathon_app.task_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
marathon_app::task_ids() const {
  // @@protoc_insertion_point(field_list:draiosproto.marathon_app.task_ids)
  return task_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
marathon_app::mutable_task_ids() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.marathon_app.task_ids)
  return &task_ids_;
}

inline const marathon_app* marathon_app::internal_default_instance() {
  return &marathon_app_default_instance_.get();
}
// -------------------------------------------------------------------

// marathon_group

// required string id = 1;
inline bool marathon_group::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void marathon_group::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void marathon_group::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void marathon_group::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& marathon_group::id() const {
  // @@protoc_insertion_point(field_get:draiosproto.marathon_group.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void marathon_group::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.marathon_group.id)
}
inline void marathon_group::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.marathon_group.id)
}
inline void marathon_group::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.marathon_group.id)
}
inline ::std::string* marathon_group::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.marathon_group.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* marathon_group::release_id() {
  // @@protoc_insertion_point(field_release:draiosproto.marathon_group.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void marathon_group::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.marathon_group.id)
}

// repeated .draiosproto.marathon_app apps = 2;
inline int marathon_group::apps_size() const {
  return apps_.size();
}
inline void marathon_group::clear_apps() {
  apps_.Clear();
}
inline const ::draiosproto::marathon_app& marathon_group::apps(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.marathon_group.apps)
  return apps_.Get(index);
}
inline ::draiosproto::marathon_app* marathon_group::mutable_apps(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.marathon_group.apps)
  return apps_.Mutable(index);
}
inline ::draiosproto::marathon_app* marathon_group::add_apps() {
  // @@protoc_insertion_point(field_add:draiosproto.marathon_group.apps)
  return apps_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_app >*
marathon_group::mutable_apps() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.marathon_group.apps)
  return &apps_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_app >&
marathon_group::apps() const {
  // @@protoc_insertion_point(field_list:draiosproto.marathon_group.apps)
  return apps_;
}

// repeated .draiosproto.marathon_group groups = 3;
inline int marathon_group::groups_size() const {
  return groups_.size();
}
inline void marathon_group::clear_groups() {
  groups_.Clear();
}
inline const ::draiosproto::marathon_group& marathon_group::groups(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.marathon_group.groups)
  return groups_.Get(index);
}
inline ::draiosproto::marathon_group* marathon_group::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.marathon_group.groups)
  return groups_.Mutable(index);
}
inline ::draiosproto::marathon_group* marathon_group::add_groups() {
  // @@protoc_insertion_point(field_add:draiosproto.marathon_group.groups)
  return groups_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_group >*
marathon_group::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.marathon_group.groups)
  return &groups_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_group >&
marathon_group::groups() const {
  // @@protoc_insertion_point(field_list:draiosproto.marathon_group.groups)
  return groups_;
}

inline const marathon_group* marathon_group::internal_default_instance() {
  return &marathon_group_default_instance_.get();
}
// -------------------------------------------------------------------

// mesos_framework

// required .draiosproto.mesos_common common = 1;
inline bool mesos_framework::has_common() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mesos_framework::set_has_common() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mesos_framework::clear_has_common() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mesos_framework::clear_common() {
  if (common_ != NULL) common_->::draiosproto::mesos_common::Clear();
  clear_has_common();
}
inline const ::draiosproto::mesos_common& mesos_framework::common() const {
  // @@protoc_insertion_point(field_get:draiosproto.mesos_framework.common)
  return common_ != NULL ? *common_
                         : *::draiosproto::mesos_common::internal_default_instance();
}
inline ::draiosproto::mesos_common* mesos_framework::mutable_common() {
  set_has_common();
  if (common_ == NULL) {
    common_ = new ::draiosproto::mesos_common;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.mesos_framework.common)
  return common_;
}
inline ::draiosproto::mesos_common* mesos_framework::release_common() {
  // @@protoc_insertion_point(field_release:draiosproto.mesos_framework.common)
  clear_has_common();
  ::draiosproto::mesos_common* temp = common_;
  common_ = NULL;
  return temp;
}
inline void mesos_framework::set_allocated_common(::draiosproto::mesos_common* common) {
  delete common_;
  common_ = common;
  if (common) {
    set_has_common();
  } else {
    clear_has_common();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.mesos_framework.common)
}

// repeated .draiosproto.mesos_task tasks = 2;
inline int mesos_framework::tasks_size() const {
  return tasks_.size();
}
inline void mesos_framework::clear_tasks() {
  tasks_.Clear();
}
inline const ::draiosproto::mesos_task& mesos_framework::tasks(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.mesos_framework.tasks)
  return tasks_.Get(index);
}
inline ::draiosproto::mesos_task* mesos_framework::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.mesos_framework.tasks)
  return tasks_.Mutable(index);
}
inline ::draiosproto::mesos_task* mesos_framework::add_tasks() {
  // @@protoc_insertion_point(field_add:draiosproto.mesos_framework.tasks)
  return tasks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_task >*
mesos_framework::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.mesos_framework.tasks)
  return &tasks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_task >&
mesos_framework::tasks() const {
  // @@protoc_insertion_point(field_list:draiosproto.mesos_framework.tasks)
  return tasks_;
}

inline const mesos_framework* mesos_framework::internal_default_instance() {
  return &mesos_framework_default_instance_.get();
}
// -------------------------------------------------------------------

// mesos_slave

// required .draiosproto.mesos_common common = 1;
inline bool mesos_slave::has_common() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mesos_slave::set_has_common() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mesos_slave::clear_has_common() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mesos_slave::clear_common() {
  if (common_ != NULL) common_->::draiosproto::mesos_common::Clear();
  clear_has_common();
}
inline const ::draiosproto::mesos_common& mesos_slave::common() const {
  // @@protoc_insertion_point(field_get:draiosproto.mesos_slave.common)
  return common_ != NULL ? *common_
                         : *::draiosproto::mesos_common::internal_default_instance();
}
inline ::draiosproto::mesos_common* mesos_slave::mutable_common() {
  set_has_common();
  if (common_ == NULL) {
    common_ = new ::draiosproto::mesos_common;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.mesos_slave.common)
  return common_;
}
inline ::draiosproto::mesos_common* mesos_slave::release_common() {
  // @@protoc_insertion_point(field_release:draiosproto.mesos_slave.common)
  clear_has_common();
  ::draiosproto::mesos_common* temp = common_;
  common_ = NULL;
  return temp;
}
inline void mesos_slave::set_allocated_common(::draiosproto::mesos_common* common) {
  delete common_;
  common_ = common;
  if (common) {
    set_has_common();
  } else {
    clear_has_common();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.mesos_slave.common)
}

inline const mesos_slave* mesos_slave::internal_default_instance() {
  return &mesos_slave_default_instance_.get();
}
// -------------------------------------------------------------------

// mesos_state

// repeated .draiosproto.mesos_framework frameworks = 1;
inline int mesos_state::frameworks_size() const {
  return frameworks_.size();
}
inline void mesos_state::clear_frameworks() {
  frameworks_.Clear();
}
inline const ::draiosproto::mesos_framework& mesos_state::frameworks(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.mesos_state.frameworks)
  return frameworks_.Get(index);
}
inline ::draiosproto::mesos_framework* mesos_state::mutable_frameworks(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.mesos_state.frameworks)
  return frameworks_.Mutable(index);
}
inline ::draiosproto::mesos_framework* mesos_state::add_frameworks() {
  // @@protoc_insertion_point(field_add:draiosproto.mesos_state.frameworks)
  return frameworks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_framework >*
mesos_state::mutable_frameworks() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.mesos_state.frameworks)
  return &frameworks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_framework >&
mesos_state::frameworks() const {
  // @@protoc_insertion_point(field_list:draiosproto.mesos_state.frameworks)
  return frameworks_;
}

// repeated .draiosproto.marathon_group groups = 2;
inline int mesos_state::groups_size() const {
  return groups_.size();
}
inline void mesos_state::clear_groups() {
  groups_.Clear();
}
inline const ::draiosproto::marathon_group& mesos_state::groups(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.mesos_state.groups)
  return groups_.Get(index);
}
inline ::draiosproto::marathon_group* mesos_state::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.mesos_state.groups)
  return groups_.Mutable(index);
}
inline ::draiosproto::marathon_group* mesos_state::add_groups() {
  // @@protoc_insertion_point(field_add:draiosproto.mesos_state.groups)
  return groups_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_group >*
mesos_state::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.mesos_state.groups)
  return &groups_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_group >&
mesos_state::groups() const {
  // @@protoc_insertion_point(field_list:draiosproto.mesos_state.groups)
  return groups_;
}

// repeated .draiosproto.mesos_slave slaves = 3;
inline int mesos_state::slaves_size() const {
  return slaves_.size();
}
inline void mesos_state::clear_slaves() {
  slaves_.Clear();
}
inline const ::draiosproto::mesos_slave& mesos_state::slaves(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.mesos_state.slaves)
  return slaves_.Get(index);
}
inline ::draiosproto::mesos_slave* mesos_state::mutable_slaves(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.mesos_state.slaves)
  return slaves_.Mutable(index);
}
inline ::draiosproto::mesos_slave* mesos_state::add_slaves() {
  // @@protoc_insertion_point(field_add:draiosproto.mesos_state.slaves)
  return slaves_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_slave >*
mesos_state::mutable_slaves() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.mesos_state.slaves)
  return &slaves_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_slave >&
mesos_state::slaves() const {
  // @@protoc_insertion_point(field_list:draiosproto.mesos_state.slaves)
  return slaves_;
}

inline const mesos_state* mesos_state::internal_default_instance() {
  return &mesos_state_default_instance_.get();
}
// -------------------------------------------------------------------

// metrics

// required uint64 timestamp_ns = 1;
inline bool metrics::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void metrics::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void metrics::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void metrics::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 metrics::timestamp_ns() const {
  // @@protoc_insertion_point(field_get:draiosproto.metrics.timestamp_ns)
  return timestamp_ns_;
}
inline void metrics::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.metrics.timestamp_ns)
}

// required string machine_id = 2;
inline bool metrics::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void metrics::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void metrics::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void metrics::clear_machine_id() {
  machine_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_machine_id();
}
inline const ::std::string& metrics::machine_id() const {
  // @@protoc_insertion_point(field_get:draiosproto.metrics.machine_id)
  return machine_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void metrics::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.metrics.machine_id)
}
inline void metrics::set_machine_id(const char* value) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.metrics.machine_id)
}
inline void metrics::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.metrics.machine_id)
}
inline ::std::string* metrics::mutable_machine_id() {
  set_has_machine_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.metrics.machine_id)
  return machine_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* metrics::release_machine_id() {
  // @@protoc_insertion_point(field_release:draiosproto.metrics.machine_id)
  clear_has_machine_id();
  return machine_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void metrics::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id != NULL) {
    set_has_machine_id();
  } else {
    clear_has_machine_id();
  }
  machine_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine_id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.metrics.machine_id)
}

// optional string customer_id = 3;
inline bool metrics::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void metrics::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void metrics::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void metrics::clear_customer_id() {
  customer_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_customer_id();
}
inline const ::std::string& metrics::customer_id() const {
  // @@protoc_insertion_point(field_get:draiosproto.metrics.customer_id)
  return customer_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void metrics::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.metrics.customer_id)
}
inline void metrics::set_customer_id(const char* value) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.metrics.customer_id)
}
inline void metrics::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.metrics.customer_id)
}
inline ::std::string* metrics::mutable_customer_id() {
  set_has_customer_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.metrics.customer_id)
  return customer_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* metrics::release_customer_id() {
  // @@protoc_insertion_point(field_release:draiosproto.metrics.customer_id)
  clear_has_customer_id();
  return customer_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void metrics::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id != NULL) {
    set_has_customer_id();
  } else {
    clear_has_customer_id();
  }
  customer_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), customer_id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.metrics.customer_id)
}

// optional uint32 sampling_ratio = 10;
inline bool metrics::has_sampling_ratio() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void metrics::set_has_sampling_ratio() {
  _has_bits_[0] |= 0x00000008u;
}
inline void metrics::clear_has_sampling_ratio() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void metrics::clear_sampling_ratio() {
  sampling_ratio_ = 0u;
  clear_has_sampling_ratio();
}
inline ::google::protobuf::uint32 metrics::sampling_ratio() const {
  // @@protoc_insertion_point(field_get:draiosproto.metrics.sampling_ratio)
  return sampling_ratio_;
}
inline void metrics::set_sampling_ratio(::google::protobuf::uint32 value) {
  set_has_sampling_ratio();
  sampling_ratio_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.metrics.sampling_ratio)
}

// optional string host_custom_name = 11;
inline bool metrics::has_host_custom_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void metrics::set_has_host_custom_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void metrics::clear_has_host_custom_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void metrics::clear_host_custom_name() {
  host_custom_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_host_custom_name();
}
inline const ::std::string& metrics::host_custom_name() const {
  // @@protoc_insertion_point(field_get:draiosproto.metrics.host_custom_name)
  return host_custom_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void metrics::set_host_custom_name(const ::std::string& value) {
  set_has_host_custom_name();
  host_custom_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.metrics.host_custom_name)
}
inline void metrics::set_host_custom_name(const char* value) {
  set_has_host_custom_name();
  host_custom_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.metrics.host_custom_name)
}
inline void metrics::set_host_custom_name(const char* value, size_t size) {
  set_has_host_custom_name();
  host_custom_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.metrics.host_custom_name)
}
inline ::std::string* metrics::mutable_host_custom_name() {
  set_has_host_custom_name();
  // @@protoc_insertion_point(field_mutable:draiosproto.metrics.host_custom_name)
  return host_custom_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* metrics::release_host_custom_name() {
  // @@protoc_insertion_point(field_release:draiosproto.metrics.host_custom_name)
  clear_has_host_custom_name();
  return host_custom_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void metrics::set_allocated_host_custom_name(::std::string* host_custom_name) {
  if (host_custom_name != NULL) {
    set_has_host_custom_name();
  } else {
    clear_has_host_custom_name();
  }
  host_custom_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host_custom_name);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.metrics.host_custom_name)
}

// optional string host_tags = 12;
inline bool metrics::has_host_tags() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void metrics::set_has_host_tags() {
  _has_bits_[0] |= 0x00000020u;
}
inline void metrics::clear_has_host_tags() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void metrics::clear_host_tags() {
  host_tags_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_host_tags();
}
inline const ::std::string& metrics::host_tags() const {
  // @@protoc_insertion_point(field_get:draiosproto.metrics.host_tags)
  return host_tags_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void metrics::set_host_tags(const ::std::string& value) {
  set_has_host_tags();
  host_tags_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.metrics.host_tags)
}
inline void metrics::set_host_tags(const char* value) {
  set_has_host_tags();
  host_tags_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.metrics.host_tags)
}
inline void metrics::set_host_tags(const char* value, size_t size) {
  set_has_host_tags();
  host_tags_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.metrics.host_tags)
}
inline ::std::string* metrics::mutable_host_tags() {
  set_has_host_tags();
  // @@protoc_insertion_point(field_mutable:draiosproto.metrics.host_tags)
  return host_tags_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* metrics::release_host_tags() {
  // @@protoc_insertion_point(field_release:draiosproto.metrics.host_tags)
  clear_has_host_tags();
  return host_tags_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void metrics::set_allocated_host_tags(::std::string* host_tags) {
  if (host_tags != NULL) {
    set_has_host_tags();
  } else {
    clear_has_host_tags();
  }
  host_tags_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host_tags);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.metrics.host_tags)
}

// optional bool is_host_hidden = 14;
inline bool metrics::has_is_host_hidden() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void metrics::set_has_is_host_hidden() {
  _has_bits_[0] |= 0x00000040u;
}
inline void metrics::clear_has_is_host_hidden() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void metrics::clear_is_host_hidden() {
  is_host_hidden_ = false;
  clear_has_is_host_hidden();
}
inline bool metrics::is_host_hidden() const {
  // @@protoc_insertion_point(field_get:draiosproto.metrics.is_host_hidden)
  return is_host_hidden_;
}
inline void metrics::set_is_host_hidden(bool value) {
  set_has_is_host_hidden();
  is_host_hidden_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.metrics.is_host_hidden)
}

// optional string hidden_processes = 15;
inline bool metrics::has_hidden_processes() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void metrics::set_has_hidden_processes() {
  _has_bits_[0] |= 0x00000080u;
}
inline void metrics::clear_has_hidden_processes() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void metrics::clear_hidden_processes() {
  hidden_processes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hidden_processes();
}
inline const ::std::string& metrics::hidden_processes() const {
  // @@protoc_insertion_point(field_get:draiosproto.metrics.hidden_processes)
  return hidden_processes_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void metrics::set_hidden_processes(const ::std::string& value) {
  set_has_hidden_processes();
  hidden_processes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.metrics.hidden_processes)
}
inline void metrics::set_hidden_processes(const char* value) {
  set_has_hidden_processes();
  hidden_processes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.metrics.hidden_processes)
}
inline void metrics::set_hidden_processes(const char* value, size_t size) {
  set_has_hidden_processes();
  hidden_processes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.metrics.hidden_processes)
}
inline ::std::string* metrics::mutable_hidden_processes() {
  set_has_hidden_processes();
  // @@protoc_insertion_point(field_mutable:draiosproto.metrics.hidden_processes)
  return hidden_processes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* metrics::release_hidden_processes() {
  // @@protoc_insertion_point(field_release:draiosproto.metrics.hidden_processes)
  clear_has_hidden_processes();
  return hidden_processes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void metrics::set_allocated_hidden_processes(::std::string* hidden_processes) {
  if (hidden_processes != NULL) {
    set_has_hidden_processes();
  } else {
    clear_has_hidden_processes();
  }
  hidden_processes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hidden_processes);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.metrics.hidden_processes)
}

// optional string version = 16;
inline bool metrics::has_version() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void metrics::set_has_version() {
  _has_bits_[0] |= 0x00000100u;
}
inline void metrics::clear_has_version() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void metrics::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& metrics::version() const {
  // @@protoc_insertion_point(field_get:draiosproto.metrics.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void metrics::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.metrics.version)
}
inline void metrics::set_version(const char* value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.metrics.version)
}
inline void metrics::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.metrics.version)
}
inline ::std::string* metrics::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:draiosproto.metrics.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* metrics::release_version() {
  // @@protoc_insertion_point(field_release:draiosproto.metrics.version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void metrics::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.metrics.version)
}

// optional string instance_id = 21;
inline bool metrics::has_instance_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void metrics::set_has_instance_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void metrics::clear_has_instance_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void metrics::clear_instance_id() {
  instance_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_instance_id();
}
inline const ::std::string& metrics::instance_id() const {
  // @@protoc_insertion_point(field_get:draiosproto.metrics.instance_id)
  return instance_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void metrics::set_instance_id(const ::std::string& value) {
  set_has_instance_id();
  instance_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.metrics.instance_id)
}
inline void metrics::set_instance_id(const char* value) {
  set_has_instance_id();
  instance_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.metrics.instance_id)
}
inline void metrics::set_instance_id(const char* value, size_t size) {
  set_has_instance_id();
  instance_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.metrics.instance_id)
}
inline ::std::string* metrics::mutable_instance_id() {
  set_has_instance_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.metrics.instance_id)
  return instance_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* metrics::release_instance_id() {
  // @@protoc_insertion_point(field_release:draiosproto.metrics.instance_id)
  clear_has_instance_id();
  return instance_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void metrics::set_allocated_instance_id(::std::string* instance_id) {
  if (instance_id != NULL) {
    set_has_instance_id();
  } else {
    clear_has_instance_id();
  }
  instance_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), instance_id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.metrics.instance_id)
}

// optional .draiosproto.host hostinfo = 4;
inline bool metrics::has_hostinfo() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void metrics::set_has_hostinfo() {
  _has_bits_[0] |= 0x00000400u;
}
inline void metrics::clear_has_hostinfo() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void metrics::clear_hostinfo() {
  if (hostinfo_ != NULL) hostinfo_->::draiosproto::host::Clear();
  clear_has_hostinfo();
}
inline const ::draiosproto::host& metrics::hostinfo() const {
  // @@protoc_insertion_point(field_get:draiosproto.metrics.hostinfo)
  return hostinfo_ != NULL ? *hostinfo_
                         : *::draiosproto::host::internal_default_instance();
}
inline ::draiosproto::host* metrics::mutable_hostinfo() {
  set_has_hostinfo();
  if (hostinfo_ == NULL) {
    hostinfo_ = new ::draiosproto::host;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.metrics.hostinfo)
  return hostinfo_;
}
inline ::draiosproto::host* metrics::release_hostinfo() {
  // @@protoc_insertion_point(field_release:draiosproto.metrics.hostinfo)
  clear_has_hostinfo();
  ::draiosproto::host* temp = hostinfo_;
  hostinfo_ = NULL;
  return temp;
}
inline void metrics::set_allocated_hostinfo(::draiosproto::host* hostinfo) {
  delete hostinfo_;
  hostinfo_ = hostinfo;
  if (hostinfo) {
    set_has_hostinfo();
  } else {
    clear_has_hostinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.metrics.hostinfo)
}

// repeated .draiosproto.program programs = 9;
inline int metrics::programs_size() const {
  return programs_.size();
}
inline void metrics::clear_programs() {
  programs_.Clear();
}
inline const ::draiosproto::program& metrics::programs(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.metrics.programs)
  return programs_.Get(index);
}
inline ::draiosproto::program* metrics::mutable_programs(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.metrics.programs)
  return programs_.Mutable(index);
}
inline ::draiosproto::program* metrics::add_programs() {
  // @@protoc_insertion_point(field_add:draiosproto.metrics.programs)
  return programs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::program >*
metrics::mutable_programs() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.metrics.programs)
  return &programs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::program >&
metrics::programs() const {
  // @@protoc_insertion_point(field_list:draiosproto.metrics.programs)
  return programs_;
}

// repeated .draiosproto.ipv4_connection ipv4_connections = 7;
inline int metrics::ipv4_connections_size() const {
  return ipv4_connections_.size();
}
inline void metrics::clear_ipv4_connections() {
  ipv4_connections_.Clear();
}
inline const ::draiosproto::ipv4_connection& metrics::ipv4_connections(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.metrics.ipv4_connections)
  return ipv4_connections_.Get(index);
}
inline ::draiosproto::ipv4_connection* metrics::mutable_ipv4_connections(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.metrics.ipv4_connections)
  return ipv4_connections_.Mutable(index);
}
inline ::draiosproto::ipv4_connection* metrics::add_ipv4_connections() {
  // @@protoc_insertion_point(field_add:draiosproto.metrics.ipv4_connections)
  return ipv4_connections_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_connection >*
metrics::mutable_ipv4_connections() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.metrics.ipv4_connections)
  return &ipv4_connections_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_connection >&
metrics::ipv4_connections() const {
  // @@protoc_insertion_point(field_list:draiosproto.metrics.ipv4_connections)
  return ipv4_connections_;
}

// repeated .draiosproto.ipv4_network_interface ipv4_network_interfaces = 8;
inline int metrics::ipv4_network_interfaces_size() const {
  return ipv4_network_interfaces_.size();
}
inline void metrics::clear_ipv4_network_interfaces() {
  ipv4_network_interfaces_.Clear();
}
inline const ::draiosproto::ipv4_network_interface& metrics::ipv4_network_interfaces(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.metrics.ipv4_network_interfaces)
  return ipv4_network_interfaces_.Get(index);
}
inline ::draiosproto::ipv4_network_interface* metrics::mutable_ipv4_network_interfaces(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.metrics.ipv4_network_interfaces)
  return ipv4_network_interfaces_.Mutable(index);
}
inline ::draiosproto::ipv4_network_interface* metrics::add_ipv4_network_interfaces() {
  // @@protoc_insertion_point(field_add:draiosproto.metrics.ipv4_network_interfaces)
  return ipv4_network_interfaces_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_network_interface >*
metrics::mutable_ipv4_network_interfaces() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.metrics.ipv4_network_interfaces)
  return &ipv4_network_interfaces_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_network_interface >&
metrics::ipv4_network_interfaces() const {
  // @@protoc_insertion_point(field_list:draiosproto.metrics.ipv4_network_interfaces)
  return ipv4_network_interfaces_;
}

// repeated .draiosproto.command_details commands = 17;
inline int metrics::commands_size() const {
  return commands_.size();
}
inline void metrics::clear_commands() {
  commands_.Clear();
}
inline const ::draiosproto::command_details& metrics::commands(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.metrics.commands)
  return commands_.Get(index);
}
inline ::draiosproto::command_details* metrics::mutable_commands(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.metrics.commands)
  return commands_.Mutable(index);
}
inline ::draiosproto::command_details* metrics::add_commands() {
  // @@protoc_insertion_point(field_add:draiosproto.metrics.commands)
  return commands_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::command_details >*
metrics::mutable_commands() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.metrics.commands)
  return &commands_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::command_details >&
metrics::commands() const {
  // @@protoc_insertion_point(field_list:draiosproto.metrics.commands)
  return commands_;
}

// repeated .draiosproto.mounted_fs mounts = 18;
inline int metrics::mounts_size() const {
  return mounts_.size();
}
inline void metrics::clear_mounts() {
  mounts_.Clear();
}
inline const ::draiosproto::mounted_fs& metrics::mounts(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.metrics.mounts)
  return mounts_.Get(index);
}
inline ::draiosproto::mounted_fs* metrics::mutable_mounts(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.metrics.mounts)
  return mounts_.Mutable(index);
}
inline ::draiosproto::mounted_fs* metrics::add_mounts() {
  // @@protoc_insertion_point(field_add:draiosproto.metrics.mounts)
  return mounts_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mounted_fs >*
metrics::mutable_mounts() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.metrics.mounts)
  return &mounts_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mounted_fs >&
metrics::mounts() const {
  // @@protoc_insertion_point(field_list:draiosproto.metrics.mounts)
  return mounts_;
}

// repeated .draiosproto.file_stat top_files = 19;
inline int metrics::top_files_size() const {
  return top_files_.size();
}
inline void metrics::clear_top_files() {
  top_files_.Clear();
}
inline const ::draiosproto::file_stat& metrics::top_files(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.metrics.top_files)
  return top_files_.Get(index);
}
inline ::draiosproto::file_stat* metrics::mutable_top_files(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.metrics.top_files)
  return top_files_.Mutable(index);
}
inline ::draiosproto::file_stat* metrics::add_top_files() {
  // @@protoc_insertion_point(field_add:draiosproto.metrics.top_files)
  return top_files_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::file_stat >*
metrics::mutable_top_files() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.metrics.top_files)
  return &top_files_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::file_stat >&
metrics::top_files() const {
  // @@protoc_insertion_point(field_list:draiosproto.metrics.top_files)
  return top_files_;
}

// optional .draiosproto.proto_info protos = 20;
inline bool metrics::has_protos() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void metrics::set_has_protos() {
  _has_bits_[0] |= 0x00020000u;
}
inline void metrics::clear_has_protos() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void metrics::clear_protos() {
  if (protos_ != NULL) protos_->::draiosproto::proto_info::Clear();
  clear_has_protos();
}
inline const ::draiosproto::proto_info& metrics::protos() const {
  // @@protoc_insertion_point(field_get:draiosproto.metrics.protos)
  return protos_ != NULL ? *protos_
                         : *::draiosproto::proto_info::internal_default_instance();
}
inline ::draiosproto::proto_info* metrics::mutable_protos() {
  set_has_protos();
  if (protos_ == NULL) {
    protos_ = new ::draiosproto::proto_info;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.metrics.protos)
  return protos_;
}
inline ::draiosproto::proto_info* metrics::release_protos() {
  // @@protoc_insertion_point(field_release:draiosproto.metrics.protos)
  clear_has_protos();
  ::draiosproto::proto_info* temp = protos_;
  protos_ = NULL;
  return temp;
}
inline void metrics::set_allocated_protos(::draiosproto::proto_info* protos) {
  delete protos_;
  protos_ = protos;
  if (protos) {
    set_has_protos();
  } else {
    clear_has_protos();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.metrics.protos)
}

// repeated .draiosproto.container containers = 22;
inline int metrics::containers_size() const {
  return containers_.size();
}
inline void metrics::clear_containers() {
  containers_.Clear();
}
inline const ::draiosproto::container& metrics::containers(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.metrics.containers)
  return containers_.Get(index);
}
inline ::draiosproto::container* metrics::mutable_containers(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.metrics.containers)
  return containers_.Mutable(index);
}
inline ::draiosproto::container* metrics::add_containers() {
  // @@protoc_insertion_point(field_add:draiosproto.metrics.containers)
  return containers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::container >*
metrics::mutable_containers() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.metrics.containers)
  return &containers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::container >&
metrics::containers() const {
  // @@protoc_insertion_point(field_list:draiosproto.metrics.containers)
  return containers_;
}

// optional .draiosproto.k8s_state kubernetes = 24;
inline bool metrics::has_kubernetes() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void metrics::set_has_kubernetes() {
  _has_bits_[0] |= 0x00080000u;
}
inline void metrics::clear_has_kubernetes() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void metrics::clear_kubernetes() {
  if (kubernetes_ != NULL) kubernetes_->::draiosproto::k8s_state::Clear();
  clear_has_kubernetes();
}
inline const ::draiosproto::k8s_state& metrics::kubernetes() const {
  // @@protoc_insertion_point(field_get:draiosproto.metrics.kubernetes)
  return kubernetes_ != NULL ? *kubernetes_
                         : *::draiosproto::k8s_state::internal_default_instance();
}
inline ::draiosproto::k8s_state* metrics::mutable_kubernetes() {
  set_has_kubernetes();
  if (kubernetes_ == NULL) {
    kubernetes_ = new ::draiosproto::k8s_state;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.metrics.kubernetes)
  return kubernetes_;
}
inline ::draiosproto::k8s_state* metrics::release_kubernetes() {
  // @@protoc_insertion_point(field_release:draiosproto.metrics.kubernetes)
  clear_has_kubernetes();
  ::draiosproto::k8s_state* temp = kubernetes_;
  kubernetes_ = NULL;
  return temp;
}
inline void metrics::set_allocated_kubernetes(::draiosproto::k8s_state* kubernetes) {
  delete kubernetes_;
  kubernetes_ = kubernetes;
  if (kubernetes) {
    set_has_kubernetes();
  } else {
    clear_has_kubernetes();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.metrics.kubernetes)
}

// optional .draiosproto.mesos_state mesos = 25;
inline bool metrics::has_mesos() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void metrics::set_has_mesos() {
  _has_bits_[0] |= 0x00100000u;
}
inline void metrics::clear_has_mesos() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void metrics::clear_mesos() {
  if (mesos_ != NULL) mesos_->::draiosproto::mesos_state::Clear();
  clear_has_mesos();
}
inline const ::draiosproto::mesos_state& metrics::mesos() const {
  // @@protoc_insertion_point(field_get:draiosproto.metrics.mesos)
  return mesos_ != NULL ? *mesos_
                         : *::draiosproto::mesos_state::internal_default_instance();
}
inline ::draiosproto::mesos_state* metrics::mutable_mesos() {
  set_has_mesos();
  if (mesos_ == NULL) {
    mesos_ = new ::draiosproto::mesos_state;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.metrics.mesos)
  return mesos_;
}
inline ::draiosproto::mesos_state* metrics::release_mesos() {
  // @@protoc_insertion_point(field_release:draiosproto.metrics.mesos)
  clear_has_mesos();
  ::draiosproto::mesos_state* temp = mesos_;
  mesos_ = NULL;
  return temp;
}
inline void metrics::set_allocated_mesos(::draiosproto::mesos_state* mesos) {
  delete mesos_;
  mesos_ = mesos;
  if (mesos) {
    set_has_mesos();
  } else {
    clear_has_mesos();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.metrics.mesos)
}

// repeated .draiosproto.agent_event events = 26;
inline int metrics::events_size() const {
  return events_.size();
}
inline void metrics::clear_events() {
  events_.Clear();
}
inline const ::draiosproto::agent_event& metrics::events(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.metrics.events)
  return events_.Get(index);
}
inline ::draiosproto::agent_event* metrics::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.metrics.events)
  return events_.Mutable(index);
}
inline ::draiosproto::agent_event* metrics::add_events() {
  // @@protoc_insertion_point(field_add:draiosproto.metrics.events)
  return events_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::agent_event >*
metrics::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.metrics.events)
  return &events_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::agent_event >&
metrics::events() const {
  // @@protoc_insertion_point(field_list:draiosproto.metrics.events)
  return events_;
}

// optional .draiosproto.falco_baseline falcobl = 27;
inline bool metrics::has_falcobl() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void metrics::set_has_falcobl() {
  _has_bits_[0] |= 0x00400000u;
}
inline void metrics::clear_has_falcobl() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void metrics::clear_falcobl() {
  if (falcobl_ != NULL) falcobl_->::draiosproto::falco_baseline::Clear();
  clear_has_falcobl();
}
inline const ::draiosproto::falco_baseline& metrics::falcobl() const {
  // @@protoc_insertion_point(field_get:draiosproto.metrics.falcobl)
  return falcobl_ != NULL ? *falcobl_
                         : *::draiosproto::falco_baseline::internal_default_instance();
}
inline ::draiosproto::falco_baseline* metrics::mutable_falcobl() {
  set_has_falcobl();
  if (falcobl_ == NULL) {
    falcobl_ = new ::draiosproto::falco_baseline;
  }
  // @@protoc_insertion_point(field_mutable:draiosproto.metrics.falcobl)
  return falcobl_;
}
inline ::draiosproto::falco_baseline* metrics::release_falcobl() {
  // @@protoc_insertion_point(field_release:draiosproto.metrics.falcobl)
  clear_has_falcobl();
  ::draiosproto::falco_baseline* temp = falcobl_;
  falcobl_ = NULL;
  return temp;
}
inline void metrics::set_allocated_falcobl(::draiosproto::falco_baseline* falcobl) {
  delete falcobl_;
  falcobl_ = falcobl;
  if (falcobl) {
    set_has_falcobl();
  } else {
    clear_has_falcobl();
  }
  // @@protoc_insertion_point(field_set_allocated:draiosproto.metrics.falcobl)
}

inline const metrics* metrics::internal_default_instance() {
  return &metrics_default_instance_.get();
}
// -------------------------------------------------------------------

// dump_request_start

// required uint64 timestamp_ns = 1;
inline bool dump_request_start::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dump_request_start::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dump_request_start::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dump_request_start::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 dump_request_start::timestamp_ns() const {
  // @@protoc_insertion_point(field_get:draiosproto.dump_request_start.timestamp_ns)
  return timestamp_ns_;
}
inline void dump_request_start::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.dump_request_start.timestamp_ns)
}

// required string machine_id = 2;
inline bool dump_request_start::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dump_request_start::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dump_request_start::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dump_request_start::clear_machine_id() {
  machine_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_machine_id();
}
inline const ::std::string& dump_request_start::machine_id() const {
  // @@protoc_insertion_point(field_get:draiosproto.dump_request_start.machine_id)
  return machine_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dump_request_start::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.dump_request_start.machine_id)
}
inline void dump_request_start::set_machine_id(const char* value) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.dump_request_start.machine_id)
}
inline void dump_request_start::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.dump_request_start.machine_id)
}
inline ::std::string* dump_request_start::mutable_machine_id() {
  set_has_machine_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.dump_request_start.machine_id)
  return machine_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* dump_request_start::release_machine_id() {
  // @@protoc_insertion_point(field_release:draiosproto.dump_request_start.machine_id)
  clear_has_machine_id();
  return machine_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dump_request_start::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id != NULL) {
    set_has_machine_id();
  } else {
    clear_has_machine_id();
  }
  machine_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine_id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.dump_request_start.machine_id)
}

// optional string customer_id = 3;
inline bool dump_request_start::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dump_request_start::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dump_request_start::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dump_request_start::clear_customer_id() {
  customer_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_customer_id();
}
inline const ::std::string& dump_request_start::customer_id() const {
  // @@protoc_insertion_point(field_get:draiosproto.dump_request_start.customer_id)
  return customer_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dump_request_start::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.dump_request_start.customer_id)
}
inline void dump_request_start::set_customer_id(const char* value) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.dump_request_start.customer_id)
}
inline void dump_request_start::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.dump_request_start.customer_id)
}
inline ::std::string* dump_request_start::mutable_customer_id() {
  set_has_customer_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.dump_request_start.customer_id)
  return customer_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* dump_request_start::release_customer_id() {
  // @@protoc_insertion_point(field_release:draiosproto.dump_request_start.customer_id)
  clear_has_customer_id();
  return customer_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dump_request_start::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id != NULL) {
    set_has_customer_id();
  } else {
    clear_has_customer_id();
  }
  customer_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), customer_id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.dump_request_start.customer_id)
}

// optional uint64 duration_ns = 4;
inline bool dump_request_start::has_duration_ns() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dump_request_start::set_has_duration_ns() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dump_request_start::clear_has_duration_ns() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dump_request_start::clear_duration_ns() {
  duration_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_duration_ns();
}
inline ::google::protobuf::uint64 dump_request_start::duration_ns() const {
  // @@protoc_insertion_point(field_get:draiosproto.dump_request_start.duration_ns)
  return duration_ns_;
}
inline void dump_request_start::set_duration_ns(::google::protobuf::uint64 value) {
  set_has_duration_ns();
  duration_ns_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.dump_request_start.duration_ns)
}

// optional string filters = 5;
inline bool dump_request_start::has_filters() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void dump_request_start::set_has_filters() {
  _has_bits_[0] |= 0x00000010u;
}
inline void dump_request_start::clear_has_filters() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void dump_request_start::clear_filters() {
  filters_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_filters();
}
inline const ::std::string& dump_request_start::filters() const {
  // @@protoc_insertion_point(field_get:draiosproto.dump_request_start.filters)
  return filters_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dump_request_start::set_filters(const ::std::string& value) {
  set_has_filters();
  filters_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.dump_request_start.filters)
}
inline void dump_request_start::set_filters(const char* value) {
  set_has_filters();
  filters_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.dump_request_start.filters)
}
inline void dump_request_start::set_filters(const char* value, size_t size) {
  set_has_filters();
  filters_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.dump_request_start.filters)
}
inline ::std::string* dump_request_start::mutable_filters() {
  set_has_filters();
  // @@protoc_insertion_point(field_mutable:draiosproto.dump_request_start.filters)
  return filters_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* dump_request_start::release_filters() {
  // @@protoc_insertion_point(field_release:draiosproto.dump_request_start.filters)
  clear_has_filters();
  return filters_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dump_request_start::set_allocated_filters(::std::string* filters) {
  if (filters != NULL) {
    set_has_filters();
  } else {
    clear_has_filters();
  }
  filters_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filters);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.dump_request_start.filters)
}

// optional uint64 max_size = 7;
inline bool dump_request_start::has_max_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void dump_request_start::set_has_max_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void dump_request_start::clear_has_max_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void dump_request_start::clear_max_size() {
  max_size_ = GOOGLE_ULONGLONG(0);
  clear_has_max_size();
}
inline ::google::protobuf::uint64 dump_request_start::max_size() const {
  // @@protoc_insertion_point(field_get:draiosproto.dump_request_start.max_size)
  return max_size_;
}
inline void dump_request_start::set_max_size(::google::protobuf::uint64 value) {
  set_has_max_size();
  max_size_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.dump_request_start.max_size)
}

// required string token = 6;
inline bool dump_request_start::has_token() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void dump_request_start::set_has_token() {
  _has_bits_[0] |= 0x00000040u;
}
inline void dump_request_start::clear_has_token() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void dump_request_start::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_token();
}
inline const ::std::string& dump_request_start::token() const {
  // @@protoc_insertion_point(field_get:draiosproto.dump_request_start.token)
  return token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dump_request_start::set_token(const ::std::string& value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.dump_request_start.token)
}
inline void dump_request_start::set_token(const char* value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.dump_request_start.token)
}
inline void dump_request_start::set_token(const char* value, size_t size) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.dump_request_start.token)
}
inline ::std::string* dump_request_start::mutable_token() {
  set_has_token();
  // @@protoc_insertion_point(field_mutable:draiosproto.dump_request_start.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* dump_request_start::release_token() {
  // @@protoc_insertion_point(field_release:draiosproto.dump_request_start.token)
  clear_has_token();
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dump_request_start::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    set_has_token();
  } else {
    clear_has_token();
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.dump_request_start.token)
}

inline const dump_request_start* dump_request_start::internal_default_instance() {
  return &dump_request_start_default_instance_.get();
}
// -------------------------------------------------------------------

// dump_request_stop

// required uint64 timestamp_ns = 1;
inline bool dump_request_stop::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dump_request_stop::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dump_request_stop::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dump_request_stop::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 dump_request_stop::timestamp_ns() const {
  // @@protoc_insertion_point(field_get:draiosproto.dump_request_stop.timestamp_ns)
  return timestamp_ns_;
}
inline void dump_request_stop::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.dump_request_stop.timestamp_ns)
}

// required string machine_id = 2;
inline bool dump_request_stop::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dump_request_stop::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dump_request_stop::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dump_request_stop::clear_machine_id() {
  machine_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_machine_id();
}
inline const ::std::string& dump_request_stop::machine_id() const {
  // @@protoc_insertion_point(field_get:draiosproto.dump_request_stop.machine_id)
  return machine_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dump_request_stop::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.dump_request_stop.machine_id)
}
inline void dump_request_stop::set_machine_id(const char* value) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.dump_request_stop.machine_id)
}
inline void dump_request_stop::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.dump_request_stop.machine_id)
}
inline ::std::string* dump_request_stop::mutable_machine_id() {
  set_has_machine_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.dump_request_stop.machine_id)
  return machine_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* dump_request_stop::release_machine_id() {
  // @@protoc_insertion_point(field_release:draiosproto.dump_request_stop.machine_id)
  clear_has_machine_id();
  return machine_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dump_request_stop::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id != NULL) {
    set_has_machine_id();
  } else {
    clear_has_machine_id();
  }
  machine_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine_id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.dump_request_stop.machine_id)
}

// optional string customer_id = 3;
inline bool dump_request_stop::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dump_request_stop::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dump_request_stop::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dump_request_stop::clear_customer_id() {
  customer_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_customer_id();
}
inline const ::std::string& dump_request_stop::customer_id() const {
  // @@protoc_insertion_point(field_get:draiosproto.dump_request_stop.customer_id)
  return customer_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dump_request_stop::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.dump_request_stop.customer_id)
}
inline void dump_request_stop::set_customer_id(const char* value) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.dump_request_stop.customer_id)
}
inline void dump_request_stop::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.dump_request_stop.customer_id)
}
inline ::std::string* dump_request_stop::mutable_customer_id() {
  set_has_customer_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.dump_request_stop.customer_id)
  return customer_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* dump_request_stop::release_customer_id() {
  // @@protoc_insertion_point(field_release:draiosproto.dump_request_stop.customer_id)
  clear_has_customer_id();
  return customer_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dump_request_stop::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id != NULL) {
    set_has_customer_id();
  } else {
    clear_has_customer_id();
  }
  customer_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), customer_id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.dump_request_stop.customer_id)
}

// required string token = 4;
inline bool dump_request_stop::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dump_request_stop::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dump_request_stop::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dump_request_stop::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_token();
}
inline const ::std::string& dump_request_stop::token() const {
  // @@protoc_insertion_point(field_get:draiosproto.dump_request_stop.token)
  return token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dump_request_stop::set_token(const ::std::string& value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.dump_request_stop.token)
}
inline void dump_request_stop::set_token(const char* value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.dump_request_stop.token)
}
inline void dump_request_stop::set_token(const char* value, size_t size) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.dump_request_stop.token)
}
inline ::std::string* dump_request_stop::mutable_token() {
  set_has_token();
  // @@protoc_insertion_point(field_mutable:draiosproto.dump_request_stop.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* dump_request_stop::release_token() {
  // @@protoc_insertion_point(field_release:draiosproto.dump_request_stop.token)
  clear_has_token();
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dump_request_stop::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    set_has_token();
  } else {
    clear_has_token();
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.dump_request_stop.token)
}

inline const dump_request_stop* dump_request_stop::internal_default_instance() {
  return &dump_request_stop_default_instance_.get();
}
// -------------------------------------------------------------------

// dump_response

// required uint64 timestamp_ns = 1;
inline bool dump_response::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dump_response::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dump_response::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dump_response::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 dump_response::timestamp_ns() const {
  // @@protoc_insertion_point(field_get:draiosproto.dump_response.timestamp_ns)
  return timestamp_ns_;
}
inline void dump_response::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.dump_response.timestamp_ns)
}

// required string machine_id = 2;
inline bool dump_response::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dump_response::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dump_response::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dump_response::clear_machine_id() {
  machine_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_machine_id();
}
inline const ::std::string& dump_response::machine_id() const {
  // @@protoc_insertion_point(field_get:draiosproto.dump_response.machine_id)
  return machine_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dump_response::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.dump_response.machine_id)
}
inline void dump_response::set_machine_id(const char* value) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.dump_response.machine_id)
}
inline void dump_response::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.dump_response.machine_id)
}
inline ::std::string* dump_response::mutable_machine_id() {
  set_has_machine_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.dump_response.machine_id)
  return machine_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* dump_response::release_machine_id() {
  // @@protoc_insertion_point(field_release:draiosproto.dump_response.machine_id)
  clear_has_machine_id();
  return machine_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dump_response::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id != NULL) {
    set_has_machine_id();
  } else {
    clear_has_machine_id();
  }
  machine_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine_id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.dump_response.machine_id)
}

// optional string customer_id = 3;
inline bool dump_response::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dump_response::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dump_response::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dump_response::clear_customer_id() {
  customer_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_customer_id();
}
inline const ::std::string& dump_response::customer_id() const {
  // @@protoc_insertion_point(field_get:draiosproto.dump_response.customer_id)
  return customer_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dump_response::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.dump_response.customer_id)
}
inline void dump_response::set_customer_id(const char* value) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.dump_response.customer_id)
}
inline void dump_response::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.dump_response.customer_id)
}
inline ::std::string* dump_response::mutable_customer_id() {
  set_has_customer_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.dump_response.customer_id)
  return customer_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* dump_response::release_customer_id() {
  // @@protoc_insertion_point(field_release:draiosproto.dump_response.customer_id)
  clear_has_customer_id();
  return customer_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dump_response::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id != NULL) {
    set_has_customer_id();
  } else {
    clear_has_customer_id();
  }
  customer_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), customer_id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.dump_response.customer_id)
}

// optional uint32 chunk_no = 7;
inline bool dump_response::has_chunk_no() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dump_response::set_has_chunk_no() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dump_response::clear_has_chunk_no() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dump_response::clear_chunk_no() {
  chunk_no_ = 0u;
  clear_has_chunk_no();
}
inline ::google::protobuf::uint32 dump_response::chunk_no() const {
  // @@protoc_insertion_point(field_get:draiosproto.dump_response.chunk_no)
  return chunk_no_;
}
inline void dump_response::set_chunk_no(::google::protobuf::uint32 value) {
  set_has_chunk_no();
  chunk_no_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.dump_response.chunk_no)
}

// optional bool final_chunk = 8;
inline bool dump_response::has_final_chunk() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void dump_response::set_has_final_chunk() {
  _has_bits_[0] |= 0x00000010u;
}
inline void dump_response::clear_has_final_chunk() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void dump_response::clear_final_chunk() {
  final_chunk_ = false;
  clear_has_final_chunk();
}
inline bool dump_response::final_chunk() const {
  // @@protoc_insertion_point(field_get:draiosproto.dump_response.final_chunk)
  return final_chunk_;
}
inline void dump_response::set_final_chunk(bool value) {
  set_has_final_chunk();
  final_chunk_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.dump_response.final_chunk)
}

// optional bool keep_alive = 9;
inline bool dump_response::has_keep_alive() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void dump_response::set_has_keep_alive() {
  _has_bits_[0] |= 0x00000020u;
}
inline void dump_response::clear_has_keep_alive() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void dump_response::clear_keep_alive() {
  keep_alive_ = false;
  clear_has_keep_alive();
}
inline bool dump_response::keep_alive() const {
  // @@protoc_insertion_point(field_get:draiosproto.dump_response.keep_alive)
  return keep_alive_;
}
inline void dump_response::set_keep_alive(bool value) {
  set_has_keep_alive();
  keep_alive_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.dump_response.keep_alive)
}

// optional bytes content = 4;
inline bool dump_response::has_content() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void dump_response::set_has_content() {
  _has_bits_[0] |= 0x00000040u;
}
inline void dump_response::clear_has_content() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void dump_response::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_content();
}
inline const ::std::string& dump_response::content() const {
  // @@protoc_insertion_point(field_get:draiosproto.dump_response.content)
  return content_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dump_response::set_content(const ::std::string& value) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.dump_response.content)
}
inline void dump_response::set_content(const char* value) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.dump_response.content)
}
inline void dump_response::set_content(const void* value, size_t size) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.dump_response.content)
}
inline ::std::string* dump_response::mutable_content() {
  set_has_content();
  // @@protoc_insertion_point(field_mutable:draiosproto.dump_response.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* dump_response::release_content() {
  // @@protoc_insertion_point(field_release:draiosproto.dump_response.content)
  clear_has_content();
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dump_response::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    set_has_content();
  } else {
    clear_has_content();
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.dump_response.content)
}

// optional uint64 final_size_bytes = 10;
inline bool dump_response::has_final_size_bytes() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void dump_response::set_has_final_size_bytes() {
  _has_bits_[0] |= 0x00000080u;
}
inline void dump_response::clear_has_final_size_bytes() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void dump_response::clear_final_size_bytes() {
  final_size_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_final_size_bytes();
}
inline ::google::protobuf::uint64 dump_response::final_size_bytes() const {
  // @@protoc_insertion_point(field_get:draiosproto.dump_response.final_size_bytes)
  return final_size_bytes_;
}
inline void dump_response::set_final_size_bytes(::google::protobuf::uint64 value) {
  set_has_final_size_bytes();
  final_size_bytes_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.dump_response.final_size_bytes)
}

// optional string error = 5;
inline bool dump_response::has_error() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void dump_response::set_has_error() {
  _has_bits_[0] |= 0x00000100u;
}
inline void dump_response::clear_has_error() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void dump_response::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error();
}
inline const ::std::string& dump_response::error() const {
  // @@protoc_insertion_point(field_get:draiosproto.dump_response.error)
  return error_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dump_response::set_error(const ::std::string& value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.dump_response.error)
}
inline void dump_response::set_error(const char* value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.dump_response.error)
}
inline void dump_response::set_error(const char* value, size_t size) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.dump_response.error)
}
inline ::std::string* dump_response::mutable_error() {
  set_has_error();
  // @@protoc_insertion_point(field_mutable:draiosproto.dump_response.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* dump_response::release_error() {
  // @@protoc_insertion_point(field_release:draiosproto.dump_response.error)
  clear_has_error();
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dump_response::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    set_has_error();
  } else {
    clear_has_error();
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.dump_response.error)
}

// required string token = 6;
inline bool dump_response::has_token() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void dump_response::set_has_token() {
  _has_bits_[0] |= 0x00000200u;
}
inline void dump_response::clear_has_token() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void dump_response::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_token();
}
inline const ::std::string& dump_response::token() const {
  // @@protoc_insertion_point(field_get:draiosproto.dump_response.token)
  return token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dump_response::set_token(const ::std::string& value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.dump_response.token)
}
inline void dump_response::set_token(const char* value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.dump_response.token)
}
inline void dump_response::set_token(const char* value, size_t size) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.dump_response.token)
}
inline ::std::string* dump_response::mutable_token() {
  set_has_token();
  // @@protoc_insertion_point(field_mutable:draiosproto.dump_response.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* dump_response::release_token() {
  // @@protoc_insertion_point(field_release:draiosproto.dump_response.token)
  clear_has_token();
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dump_response::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    set_has_token();
  } else {
    clear_has_token();
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.dump_response.token)
}

inline const dump_response* dump_response::internal_default_instance() {
  return &dump_response_default_instance_.get();
}
// -------------------------------------------------------------------

// ssh_open_channel

// required uint64 timestamp_ns = 1;
inline bool ssh_open_channel::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ssh_open_channel::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ssh_open_channel::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ssh_open_channel::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 ssh_open_channel::timestamp_ns() const {
  // @@protoc_insertion_point(field_get:draiosproto.ssh_open_channel.timestamp_ns)
  return timestamp_ns_;
}
inline void ssh_open_channel::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.ssh_open_channel.timestamp_ns)
}

// required string machine_id = 2;
inline bool ssh_open_channel::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ssh_open_channel::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ssh_open_channel::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ssh_open_channel::clear_machine_id() {
  machine_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_machine_id();
}
inline const ::std::string& ssh_open_channel::machine_id() const {
  // @@protoc_insertion_point(field_get:draiosproto.ssh_open_channel.machine_id)
  return machine_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_open_channel::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.ssh_open_channel.machine_id)
}
inline void ssh_open_channel::set_machine_id(const char* value) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.ssh_open_channel.machine_id)
}
inline void ssh_open_channel::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.ssh_open_channel.machine_id)
}
inline ::std::string* ssh_open_channel::mutable_machine_id() {
  set_has_machine_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.ssh_open_channel.machine_id)
  return machine_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ssh_open_channel::release_machine_id() {
  // @@protoc_insertion_point(field_release:draiosproto.ssh_open_channel.machine_id)
  clear_has_machine_id();
  return machine_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_open_channel::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id != NULL) {
    set_has_machine_id();
  } else {
    clear_has_machine_id();
  }
  machine_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine_id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.ssh_open_channel.machine_id)
}

// optional string customer_id = 3;
inline bool ssh_open_channel::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ssh_open_channel::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ssh_open_channel::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ssh_open_channel::clear_customer_id() {
  customer_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_customer_id();
}
inline const ::std::string& ssh_open_channel::customer_id() const {
  // @@protoc_insertion_point(field_get:draiosproto.ssh_open_channel.customer_id)
  return customer_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_open_channel::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.ssh_open_channel.customer_id)
}
inline void ssh_open_channel::set_customer_id(const char* value) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.ssh_open_channel.customer_id)
}
inline void ssh_open_channel::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.ssh_open_channel.customer_id)
}
inline ::std::string* ssh_open_channel::mutable_customer_id() {
  set_has_customer_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.ssh_open_channel.customer_id)
  return customer_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ssh_open_channel::release_customer_id() {
  // @@protoc_insertion_point(field_release:draiosproto.ssh_open_channel.customer_id)
  clear_has_customer_id();
  return customer_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_open_channel::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id != NULL) {
    set_has_customer_id();
  } else {
    clear_has_customer_id();
  }
  customer_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), customer_id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.ssh_open_channel.customer_id)
}

// required string token = 4;
inline bool ssh_open_channel::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ssh_open_channel::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ssh_open_channel::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ssh_open_channel::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_token();
}
inline const ::std::string& ssh_open_channel::token() const {
  // @@protoc_insertion_point(field_get:draiosproto.ssh_open_channel.token)
  return token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_open_channel::set_token(const ::std::string& value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.ssh_open_channel.token)
}
inline void ssh_open_channel::set_token(const char* value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.ssh_open_channel.token)
}
inline void ssh_open_channel::set_token(const char* value, size_t size) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.ssh_open_channel.token)
}
inline ::std::string* ssh_open_channel::mutable_token() {
  set_has_token();
  // @@protoc_insertion_point(field_mutable:draiosproto.ssh_open_channel.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ssh_open_channel::release_token() {
  // @@protoc_insertion_point(field_release:draiosproto.ssh_open_channel.token)
  clear_has_token();
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_open_channel::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    set_has_token();
  } else {
    clear_has_token();
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.ssh_open_channel.token)
}

// required string user = 5;
inline bool ssh_open_channel::has_user() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ssh_open_channel::set_has_user() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ssh_open_channel::clear_has_user() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ssh_open_channel::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user();
}
inline const ::std::string& ssh_open_channel::user() const {
  // @@protoc_insertion_point(field_get:draiosproto.ssh_open_channel.user)
  return user_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_open_channel::set_user(const ::std::string& value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.ssh_open_channel.user)
}
inline void ssh_open_channel::set_user(const char* value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.ssh_open_channel.user)
}
inline void ssh_open_channel::set_user(const char* value, size_t size) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.ssh_open_channel.user)
}
inline ::std::string* ssh_open_channel::mutable_user() {
  set_has_user();
  // @@protoc_insertion_point(field_mutable:draiosproto.ssh_open_channel.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ssh_open_channel::release_user() {
  // @@protoc_insertion_point(field_release:draiosproto.ssh_open_channel.user)
  clear_has_user();
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_open_channel::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.ssh_open_channel.user)
}

// optional string password = 6;
inline bool ssh_open_channel::has_password() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ssh_open_channel::set_has_password() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ssh_open_channel::clear_has_password() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ssh_open_channel::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& ssh_open_channel::password() const {
  // @@protoc_insertion_point(field_get:draiosproto.ssh_open_channel.password)
  return password_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_open_channel::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.ssh_open_channel.password)
}
inline void ssh_open_channel::set_password(const char* value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.ssh_open_channel.password)
}
inline void ssh_open_channel::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.ssh_open_channel.password)
}
inline ::std::string* ssh_open_channel::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:draiosproto.ssh_open_channel.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ssh_open_channel::release_password() {
  // @@protoc_insertion_point(field_release:draiosproto.ssh_open_channel.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_open_channel::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.ssh_open_channel.password)
}

// optional string key = 7;
inline bool ssh_open_channel::has_key() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ssh_open_channel::set_has_key() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ssh_open_channel::clear_has_key() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ssh_open_channel::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& ssh_open_channel::key() const {
  // @@protoc_insertion_point(field_get:draiosproto.ssh_open_channel.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_open_channel::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.ssh_open_channel.key)
}
inline void ssh_open_channel::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.ssh_open_channel.key)
}
inline void ssh_open_channel::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.ssh_open_channel.key)
}
inline ::std::string* ssh_open_channel::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:draiosproto.ssh_open_channel.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ssh_open_channel::release_key() {
  // @@protoc_insertion_point(field_release:draiosproto.ssh_open_channel.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_open_channel::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.ssh_open_channel.key)
}

// optional string passphrase = 8;
inline bool ssh_open_channel::has_passphrase() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ssh_open_channel::set_has_passphrase() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ssh_open_channel::clear_has_passphrase() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ssh_open_channel::clear_passphrase() {
  passphrase_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_passphrase();
}
inline const ::std::string& ssh_open_channel::passphrase() const {
  // @@protoc_insertion_point(field_get:draiosproto.ssh_open_channel.passphrase)
  return passphrase_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_open_channel::set_passphrase(const ::std::string& value) {
  set_has_passphrase();
  passphrase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.ssh_open_channel.passphrase)
}
inline void ssh_open_channel::set_passphrase(const char* value) {
  set_has_passphrase();
  passphrase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.ssh_open_channel.passphrase)
}
inline void ssh_open_channel::set_passphrase(const char* value, size_t size) {
  set_has_passphrase();
  passphrase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.ssh_open_channel.passphrase)
}
inline ::std::string* ssh_open_channel::mutable_passphrase() {
  set_has_passphrase();
  // @@protoc_insertion_point(field_mutable:draiosproto.ssh_open_channel.passphrase)
  return passphrase_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ssh_open_channel::release_passphrase() {
  // @@protoc_insertion_point(field_release:draiosproto.ssh_open_channel.passphrase)
  clear_has_passphrase();
  return passphrase_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_open_channel::set_allocated_passphrase(::std::string* passphrase) {
  if (passphrase != NULL) {
    set_has_passphrase();
  } else {
    clear_has_passphrase();
  }
  passphrase_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), passphrase);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.ssh_open_channel.passphrase)
}

// optional uint32 port = 9;
inline bool ssh_open_channel::has_port() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ssh_open_channel::set_has_port() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ssh_open_channel::clear_has_port() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ssh_open_channel::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 ssh_open_channel::port() const {
  // @@protoc_insertion_point(field_get:draiosproto.ssh_open_channel.port)
  return port_;
}
inline void ssh_open_channel::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.ssh_open_channel.port)
}

inline const ssh_open_channel* ssh_open_channel::internal_default_instance() {
  return &ssh_open_channel_default_instance_.get();
}
// -------------------------------------------------------------------

// ssh_data

// required uint64 timestamp_ns = 1;
inline bool ssh_data::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ssh_data::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ssh_data::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ssh_data::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 ssh_data::timestamp_ns() const {
  // @@protoc_insertion_point(field_get:draiosproto.ssh_data.timestamp_ns)
  return timestamp_ns_;
}
inline void ssh_data::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.ssh_data.timestamp_ns)
}

// required string machine_id = 2;
inline bool ssh_data::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ssh_data::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ssh_data::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ssh_data::clear_machine_id() {
  machine_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_machine_id();
}
inline const ::std::string& ssh_data::machine_id() const {
  // @@protoc_insertion_point(field_get:draiosproto.ssh_data.machine_id)
  return machine_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_data::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.ssh_data.machine_id)
}
inline void ssh_data::set_machine_id(const char* value) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.ssh_data.machine_id)
}
inline void ssh_data::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.ssh_data.machine_id)
}
inline ::std::string* ssh_data::mutable_machine_id() {
  set_has_machine_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.ssh_data.machine_id)
  return machine_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ssh_data::release_machine_id() {
  // @@protoc_insertion_point(field_release:draiosproto.ssh_data.machine_id)
  clear_has_machine_id();
  return machine_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_data::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id != NULL) {
    set_has_machine_id();
  } else {
    clear_has_machine_id();
  }
  machine_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine_id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.ssh_data.machine_id)
}

// optional string customer_id = 3;
inline bool ssh_data::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ssh_data::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ssh_data::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ssh_data::clear_customer_id() {
  customer_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_customer_id();
}
inline const ::std::string& ssh_data::customer_id() const {
  // @@protoc_insertion_point(field_get:draiosproto.ssh_data.customer_id)
  return customer_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_data::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.ssh_data.customer_id)
}
inline void ssh_data::set_customer_id(const char* value) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.ssh_data.customer_id)
}
inline void ssh_data::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.ssh_data.customer_id)
}
inline ::std::string* ssh_data::mutable_customer_id() {
  set_has_customer_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.ssh_data.customer_id)
  return customer_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ssh_data::release_customer_id() {
  // @@protoc_insertion_point(field_release:draiosproto.ssh_data.customer_id)
  clear_has_customer_id();
  return customer_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_data::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id != NULL) {
    set_has_customer_id();
  } else {
    clear_has_customer_id();
  }
  customer_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), customer_id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.ssh_data.customer_id)
}

// required string token = 4;
inline bool ssh_data::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ssh_data::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ssh_data::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ssh_data::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_token();
}
inline const ::std::string& ssh_data::token() const {
  // @@protoc_insertion_point(field_get:draiosproto.ssh_data.token)
  return token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_data::set_token(const ::std::string& value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.ssh_data.token)
}
inline void ssh_data::set_token(const char* value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.ssh_data.token)
}
inline void ssh_data::set_token(const char* value, size_t size) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.ssh_data.token)
}
inline ::std::string* ssh_data::mutable_token() {
  set_has_token();
  // @@protoc_insertion_point(field_mutable:draiosproto.ssh_data.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ssh_data::release_token() {
  // @@protoc_insertion_point(field_release:draiosproto.ssh_data.token)
  clear_has_token();
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_data::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    set_has_token();
  } else {
    clear_has_token();
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.ssh_data.token)
}

// optional bytes data = 5;
inline bool ssh_data::has_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ssh_data::set_has_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ssh_data::clear_has_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ssh_data::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& ssh_data::data() const {
  // @@protoc_insertion_point(field_get:draiosproto.ssh_data.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_data::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.ssh_data.data)
}
inline void ssh_data::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.ssh_data.data)
}
inline void ssh_data::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.ssh_data.data)
}
inline ::std::string* ssh_data::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:draiosproto.ssh_data.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ssh_data::release_data() {
  // @@protoc_insertion_point(field_release:draiosproto.ssh_data.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_data::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.ssh_data.data)
}

// optional string error = 6;
inline bool ssh_data::has_error() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ssh_data::set_has_error() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ssh_data::clear_has_error() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ssh_data::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error();
}
inline const ::std::string& ssh_data::error() const {
  // @@protoc_insertion_point(field_get:draiosproto.ssh_data.error)
  return error_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_data::set_error(const ::std::string& value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.ssh_data.error)
}
inline void ssh_data::set_error(const char* value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.ssh_data.error)
}
inline void ssh_data::set_error(const char* value, size_t size) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.ssh_data.error)
}
inline ::std::string* ssh_data::mutable_error() {
  set_has_error();
  // @@protoc_insertion_point(field_mutable:draiosproto.ssh_data.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ssh_data::release_error() {
  // @@protoc_insertion_point(field_release:draiosproto.ssh_data.error)
  clear_has_error();
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_data::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    set_has_error();
  } else {
    clear_has_error();
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.ssh_data.error)
}

// optional int32 exit_status = 7;
inline bool ssh_data::has_exit_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ssh_data::set_has_exit_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ssh_data::clear_has_exit_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ssh_data::clear_exit_status() {
  exit_status_ = 0;
  clear_has_exit_status();
}
inline ::google::protobuf::int32 ssh_data::exit_status() const {
  // @@protoc_insertion_point(field_get:draiosproto.ssh_data.exit_status)
  return exit_status_;
}
inline void ssh_data::set_exit_status(::google::protobuf::int32 value) {
  set_has_exit_status();
  exit_status_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.ssh_data.exit_status)
}

inline const ssh_data* ssh_data::internal_default_instance() {
  return &ssh_data_default_instance_.get();
}
// -------------------------------------------------------------------

// ssh_close_channel

// required uint64 timestamp_ns = 1;
inline bool ssh_close_channel::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ssh_close_channel::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ssh_close_channel::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ssh_close_channel::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 ssh_close_channel::timestamp_ns() const {
  // @@protoc_insertion_point(field_get:draiosproto.ssh_close_channel.timestamp_ns)
  return timestamp_ns_;
}
inline void ssh_close_channel::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.ssh_close_channel.timestamp_ns)
}

// required string machine_id = 2;
inline bool ssh_close_channel::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ssh_close_channel::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ssh_close_channel::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ssh_close_channel::clear_machine_id() {
  machine_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_machine_id();
}
inline const ::std::string& ssh_close_channel::machine_id() const {
  // @@protoc_insertion_point(field_get:draiosproto.ssh_close_channel.machine_id)
  return machine_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_close_channel::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.ssh_close_channel.machine_id)
}
inline void ssh_close_channel::set_machine_id(const char* value) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.ssh_close_channel.machine_id)
}
inline void ssh_close_channel::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.ssh_close_channel.machine_id)
}
inline ::std::string* ssh_close_channel::mutable_machine_id() {
  set_has_machine_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.ssh_close_channel.machine_id)
  return machine_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ssh_close_channel::release_machine_id() {
  // @@protoc_insertion_point(field_release:draiosproto.ssh_close_channel.machine_id)
  clear_has_machine_id();
  return machine_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_close_channel::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id != NULL) {
    set_has_machine_id();
  } else {
    clear_has_machine_id();
  }
  machine_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine_id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.ssh_close_channel.machine_id)
}

// optional string customer_id = 3;
inline bool ssh_close_channel::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ssh_close_channel::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ssh_close_channel::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ssh_close_channel::clear_customer_id() {
  customer_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_customer_id();
}
inline const ::std::string& ssh_close_channel::customer_id() const {
  // @@protoc_insertion_point(field_get:draiosproto.ssh_close_channel.customer_id)
  return customer_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_close_channel::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.ssh_close_channel.customer_id)
}
inline void ssh_close_channel::set_customer_id(const char* value) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.ssh_close_channel.customer_id)
}
inline void ssh_close_channel::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.ssh_close_channel.customer_id)
}
inline ::std::string* ssh_close_channel::mutable_customer_id() {
  set_has_customer_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.ssh_close_channel.customer_id)
  return customer_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ssh_close_channel::release_customer_id() {
  // @@protoc_insertion_point(field_release:draiosproto.ssh_close_channel.customer_id)
  clear_has_customer_id();
  return customer_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_close_channel::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id != NULL) {
    set_has_customer_id();
  } else {
    clear_has_customer_id();
  }
  customer_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), customer_id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.ssh_close_channel.customer_id)
}

// required string token = 4;
inline bool ssh_close_channel::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ssh_close_channel::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ssh_close_channel::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ssh_close_channel::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_token();
}
inline const ::std::string& ssh_close_channel::token() const {
  // @@protoc_insertion_point(field_get:draiosproto.ssh_close_channel.token)
  return token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_close_channel::set_token(const ::std::string& value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.ssh_close_channel.token)
}
inline void ssh_close_channel::set_token(const char* value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.ssh_close_channel.token)
}
inline void ssh_close_channel::set_token(const char* value, size_t size) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.ssh_close_channel.token)
}
inline ::std::string* ssh_close_channel::mutable_token() {
  set_has_token();
  // @@protoc_insertion_point(field_mutable:draiosproto.ssh_close_channel.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ssh_close_channel::release_token() {
  // @@protoc_insertion_point(field_release:draiosproto.ssh_close_channel.token)
  clear_has_token();
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ssh_close_channel::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    set_has_token();
  } else {
    clear_has_token();
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.ssh_close_channel.token)
}

inline const ssh_close_channel* ssh_close_channel::internal_default_instance() {
  return &ssh_close_channel_default_instance_.get();
}
// -------------------------------------------------------------------

// auto_update_request

// required uint64 timestamp_ns = 1;
inline bool auto_update_request::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void auto_update_request::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void auto_update_request::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void auto_update_request::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 auto_update_request::timestamp_ns() const {
  // @@protoc_insertion_point(field_get:draiosproto.auto_update_request.timestamp_ns)
  return timestamp_ns_;
}
inline void auto_update_request::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.auto_update_request.timestamp_ns)
}

// required string machine_id = 2;
inline bool auto_update_request::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void auto_update_request::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void auto_update_request::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void auto_update_request::clear_machine_id() {
  machine_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_machine_id();
}
inline const ::std::string& auto_update_request::machine_id() const {
  // @@protoc_insertion_point(field_get:draiosproto.auto_update_request.machine_id)
  return machine_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void auto_update_request::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.auto_update_request.machine_id)
}
inline void auto_update_request::set_machine_id(const char* value) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.auto_update_request.machine_id)
}
inline void auto_update_request::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.auto_update_request.machine_id)
}
inline ::std::string* auto_update_request::mutable_machine_id() {
  set_has_machine_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.auto_update_request.machine_id)
  return machine_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* auto_update_request::release_machine_id() {
  // @@protoc_insertion_point(field_release:draiosproto.auto_update_request.machine_id)
  clear_has_machine_id();
  return machine_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void auto_update_request::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id != NULL) {
    set_has_machine_id();
  } else {
    clear_has_machine_id();
  }
  machine_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine_id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.auto_update_request.machine_id)
}

// optional string customer_id = 3;
inline bool auto_update_request::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void auto_update_request::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void auto_update_request::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void auto_update_request::clear_customer_id() {
  customer_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_customer_id();
}
inline const ::std::string& auto_update_request::customer_id() const {
  // @@protoc_insertion_point(field_get:draiosproto.auto_update_request.customer_id)
  return customer_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void auto_update_request::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.auto_update_request.customer_id)
}
inline void auto_update_request::set_customer_id(const char* value) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.auto_update_request.customer_id)
}
inline void auto_update_request::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.auto_update_request.customer_id)
}
inline ::std::string* auto_update_request::mutable_customer_id() {
  set_has_customer_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.auto_update_request.customer_id)
  return customer_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* auto_update_request::release_customer_id() {
  // @@protoc_insertion_point(field_release:draiosproto.auto_update_request.customer_id)
  clear_has_customer_id();
  return customer_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void auto_update_request::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id != NULL) {
    set_has_customer_id();
  } else {
    clear_has_customer_id();
  }
  customer_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), customer_id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.auto_update_request.customer_id)
}

inline const auto_update_request* auto_update_request::internal_default_instance() {
  return &auto_update_request_default_instance_.get();
}
// -------------------------------------------------------------------

// dirty_shutdown_report

// required uint64 timestamp_ns = 1;
inline bool dirty_shutdown_report::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dirty_shutdown_report::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dirty_shutdown_report::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dirty_shutdown_report::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 dirty_shutdown_report::timestamp_ns() const {
  // @@protoc_insertion_point(field_get:draiosproto.dirty_shutdown_report.timestamp_ns)
  return timestamp_ns_;
}
inline void dirty_shutdown_report::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.dirty_shutdown_report.timestamp_ns)
}

// required string machine_id = 2;
inline bool dirty_shutdown_report::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dirty_shutdown_report::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dirty_shutdown_report::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dirty_shutdown_report::clear_machine_id() {
  machine_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_machine_id();
}
inline const ::std::string& dirty_shutdown_report::machine_id() const {
  // @@protoc_insertion_point(field_get:draiosproto.dirty_shutdown_report.machine_id)
  return machine_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dirty_shutdown_report::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.dirty_shutdown_report.machine_id)
}
inline void dirty_shutdown_report::set_machine_id(const char* value) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.dirty_shutdown_report.machine_id)
}
inline void dirty_shutdown_report::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.dirty_shutdown_report.machine_id)
}
inline ::std::string* dirty_shutdown_report::mutable_machine_id() {
  set_has_machine_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.dirty_shutdown_report.machine_id)
  return machine_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* dirty_shutdown_report::release_machine_id() {
  // @@protoc_insertion_point(field_release:draiosproto.dirty_shutdown_report.machine_id)
  clear_has_machine_id();
  return machine_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dirty_shutdown_report::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id != NULL) {
    set_has_machine_id();
  } else {
    clear_has_machine_id();
  }
  machine_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine_id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.dirty_shutdown_report.machine_id)
}

// optional string customer_id = 3;
inline bool dirty_shutdown_report::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dirty_shutdown_report::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dirty_shutdown_report::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dirty_shutdown_report::clear_customer_id() {
  customer_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_customer_id();
}
inline const ::std::string& dirty_shutdown_report::customer_id() const {
  // @@protoc_insertion_point(field_get:draiosproto.dirty_shutdown_report.customer_id)
  return customer_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dirty_shutdown_report::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.dirty_shutdown_report.customer_id)
}
inline void dirty_shutdown_report::set_customer_id(const char* value) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.dirty_shutdown_report.customer_id)
}
inline void dirty_shutdown_report::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  customer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.dirty_shutdown_report.customer_id)
}
inline ::std::string* dirty_shutdown_report::mutable_customer_id() {
  set_has_customer_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.dirty_shutdown_report.customer_id)
  return customer_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* dirty_shutdown_report::release_customer_id() {
  // @@protoc_insertion_point(field_release:draiosproto.dirty_shutdown_report.customer_id)
  clear_has_customer_id();
  return customer_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dirty_shutdown_report::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id != NULL) {
    set_has_customer_id();
  } else {
    clear_has_customer_id();
  }
  customer_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), customer_id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.dirty_shutdown_report.customer_id)
}

// required string log = 4;
inline bool dirty_shutdown_report::has_log() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dirty_shutdown_report::set_has_log() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dirty_shutdown_report::clear_has_log() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dirty_shutdown_report::clear_log() {
  log_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_log();
}
inline const ::std::string& dirty_shutdown_report::log() const {
  // @@protoc_insertion_point(field_get:draiosproto.dirty_shutdown_report.log)
  return log_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dirty_shutdown_report::set_log(const ::std::string& value) {
  set_has_log();
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.dirty_shutdown_report.log)
}
inline void dirty_shutdown_report::set_log(const char* value) {
  set_has_log();
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.dirty_shutdown_report.log)
}
inline void dirty_shutdown_report::set_log(const char* value, size_t size) {
  set_has_log();
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.dirty_shutdown_report.log)
}
inline ::std::string* dirty_shutdown_report::mutable_log() {
  set_has_log();
  // @@protoc_insertion_point(field_mutable:draiosproto.dirty_shutdown_report.log)
  return log_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* dirty_shutdown_report::release_log() {
  // @@protoc_insertion_point(field_release:draiosproto.dirty_shutdown_report.log)
  clear_has_log();
  return log_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dirty_shutdown_report::set_allocated_log(::std::string* log) {
  if (log != NULL) {
    set_has_log();
  } else {
    clear_has_log();
  }
  log_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), log);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.dirty_shutdown_report.log)
}

inline const dirty_shutdown_report* dirty_shutdown_report::internal_default_instance() {
  return &dirty_shutdown_report_default_instance_.get();
}
// -------------------------------------------------------------------

// key_value

// required string key = 1;
inline bool key_value::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void key_value::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void key_value::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void key_value::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& key_value::key() const {
  // @@protoc_insertion_point(field_get:draiosproto.key_value.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void key_value::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.key_value.key)
}
inline void key_value::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.key_value.key)
}
inline void key_value::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.key_value.key)
}
inline ::std::string* key_value::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:draiosproto.key_value.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* key_value::release_key() {
  // @@protoc_insertion_point(field_release:draiosproto.key_value.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void key_value::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.key_value.key)
}

// required string value = 2;
inline bool key_value::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void key_value::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void key_value::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void key_value::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& key_value::value() const {
  // @@protoc_insertion_point(field_get:draiosproto.key_value.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void key_value::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.key_value.value)
}
inline void key_value::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.key_value.value)
}
inline void key_value::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.key_value.value)
}
inline ::std::string* key_value::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:draiosproto.key_value.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* key_value::release_value() {
  // @@protoc_insertion_point(field_release:draiosproto.key_value.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void key_value::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.key_value.value)
}

inline const key_value* key_value::internal_default_instance() {
  return &key_value_default_instance_.get();
}
// -------------------------------------------------------------------

// agent_event

// optional uint64 timestamp_sec = 1;
inline bool agent_event::has_timestamp_sec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void agent_event::set_has_timestamp_sec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void agent_event::clear_has_timestamp_sec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void agent_event::clear_timestamp_sec() {
  timestamp_sec_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_sec();
}
inline ::google::protobuf::uint64 agent_event::timestamp_sec() const {
  // @@protoc_insertion_point(field_get:draiosproto.agent_event.timestamp_sec)
  return timestamp_sec_;
}
inline void agent_event::set_timestamp_sec(::google::protobuf::uint64 value) {
  set_has_timestamp_sec();
  timestamp_sec_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.agent_event.timestamp_sec)
}

// optional string scope = 2;
inline bool agent_event::has_scope() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void agent_event::set_has_scope() {
  _has_bits_[0] |= 0x00000002u;
}
inline void agent_event::clear_has_scope() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void agent_event::clear_scope() {
  scope_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_scope();
}
inline const ::std::string& agent_event::scope() const {
  // @@protoc_insertion_point(field_get:draiosproto.agent_event.scope)
  return scope_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void agent_event::set_scope(const ::std::string& value) {
  set_has_scope();
  scope_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.agent_event.scope)
}
inline void agent_event::set_scope(const char* value) {
  set_has_scope();
  scope_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.agent_event.scope)
}
inline void agent_event::set_scope(const char* value, size_t size) {
  set_has_scope();
  scope_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.agent_event.scope)
}
inline ::std::string* agent_event::mutable_scope() {
  set_has_scope();
  // @@protoc_insertion_point(field_mutable:draiosproto.agent_event.scope)
  return scope_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* agent_event::release_scope() {
  // @@protoc_insertion_point(field_release:draiosproto.agent_event.scope)
  clear_has_scope();
  return scope_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void agent_event::set_allocated_scope(::std::string* scope) {
  if (scope != NULL) {
    set_has_scope();
  } else {
    clear_has_scope();
  }
  scope_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), scope);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.agent_event.scope)
}

// optional string title = 3;
inline bool agent_event::has_title() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void agent_event::set_has_title() {
  _has_bits_[0] |= 0x00000004u;
}
inline void agent_event::clear_has_title() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void agent_event::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_title();
}
inline const ::std::string& agent_event::title() const {
  // @@protoc_insertion_point(field_get:draiosproto.agent_event.title)
  return title_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void agent_event::set_title(const ::std::string& value) {
  set_has_title();
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.agent_event.title)
}
inline void agent_event::set_title(const char* value) {
  set_has_title();
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.agent_event.title)
}
inline void agent_event::set_title(const char* value, size_t size) {
  set_has_title();
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.agent_event.title)
}
inline ::std::string* agent_event::mutable_title() {
  set_has_title();
  // @@protoc_insertion_point(field_mutable:draiosproto.agent_event.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* agent_event::release_title() {
  // @@protoc_insertion_point(field_release:draiosproto.agent_event.title)
  clear_has_title();
  return title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void agent_event::set_allocated_title(::std::string* title) {
  if (title != NULL) {
    set_has_title();
  } else {
    clear_has_title();
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.agent_event.title)
}

// optional string description = 4;
inline bool agent_event::has_description() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void agent_event::set_has_description() {
  _has_bits_[0] |= 0x00000008u;
}
inline void agent_event::clear_has_description() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void agent_event::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& agent_event::description() const {
  // @@protoc_insertion_point(field_get:draiosproto.agent_event.description)
  return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void agent_event::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.agent_event.description)
}
inline void agent_event::set_description(const char* value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.agent_event.description)
}
inline void agent_event::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.agent_event.description)
}
inline ::std::string* agent_event::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:draiosproto.agent_event.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* agent_event::release_description() {
  // @@protoc_insertion_point(field_release:draiosproto.agent_event.description)
  clear_has_description();
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void agent_event::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.agent_event.description)
}

// optional uint32 severity = 5;
inline bool agent_event::has_severity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void agent_event::set_has_severity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void agent_event::clear_has_severity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void agent_event::clear_severity() {
  severity_ = 0u;
  clear_has_severity();
}
inline ::google::protobuf::uint32 agent_event::severity() const {
  // @@protoc_insertion_point(field_get:draiosproto.agent_event.severity)
  return severity_;
}
inline void agent_event::set_severity(::google::protobuf::uint32 value) {
  set_has_severity();
  severity_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.agent_event.severity)
}

// repeated .draiosproto.key_value tags = 6;
inline int agent_event::tags_size() const {
  return tags_.size();
}
inline void agent_event::clear_tags() {
  tags_.Clear();
}
inline const ::draiosproto::key_value& agent_event::tags(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.agent_event.tags)
  return tags_.Get(index);
}
inline ::draiosproto::key_value* agent_event::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.agent_event.tags)
  return tags_.Mutable(index);
}
inline ::draiosproto::key_value* agent_event::add_tags() {
  // @@protoc_insertion_point(field_add:draiosproto.agent_event.tags)
  return tags_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::key_value >*
agent_event::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.agent_event.tags)
  return &tags_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::key_value >&
agent_event::tags() const {
  // @@protoc_insertion_point(field_list:draiosproto.agent_event.tags)
  return tags_;
}

inline const agent_event* agent_event::internal_default_instance() {
  return &agent_event_default_instance_.get();
}
// -------------------------------------------------------------------

// config_file

// optional string name = 1;
inline bool config_file::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void config_file::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void config_file::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void config_file::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& config_file::name() const {
  // @@protoc_insertion_point(field_get:draiosproto.config_file.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void config_file::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.config_file.name)
}
inline void config_file::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.config_file.name)
}
inline void config_file::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.config_file.name)
}
inline ::std::string* config_file::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:draiosproto.config_file.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* config_file::release_name() {
  // @@protoc_insertion_point(field_release:draiosproto.config_file.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void config_file::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.config_file.name)
}

// optional string content = 2;
inline bool config_file::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void config_file::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void config_file::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void config_file::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_content();
}
inline const ::std::string& config_file::content() const {
  // @@protoc_insertion_point(field_get:draiosproto.config_file.content)
  return content_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void config_file::set_content(const ::std::string& value) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.config_file.content)
}
inline void config_file::set_content(const char* value) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.config_file.content)
}
inline void config_file::set_content(const char* value, size_t size) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.config_file.content)
}
inline ::std::string* config_file::mutable_content() {
  set_has_content();
  // @@protoc_insertion_point(field_mutable:draiosproto.config_file.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* config_file::release_content() {
  // @@protoc_insertion_point(field_release:draiosproto.config_file.content)
  clear_has_content();
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void config_file::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    set_has_content();
  } else {
    clear_has_content();
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.config_file.content)
}

inline const config_file* config_file::internal_default_instance() {
  return &config_file_default_instance_.get();
}
// -------------------------------------------------------------------

// config_data

// repeated .draiosproto.config_file config_files = 1;
inline int config_data::config_files_size() const {
  return config_files_.size();
}
inline void config_data::clear_config_files() {
  config_files_.Clear();
}
inline const ::draiosproto::config_file& config_data::config_files(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.config_data.config_files)
  return config_files_.Get(index);
}
inline ::draiosproto::config_file* config_data::mutable_config_files(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.config_data.config_files)
  return config_files_.Mutable(index);
}
inline ::draiosproto::config_file* config_data::add_config_files() {
  // @@protoc_insertion_point(field_add:draiosproto.config_data.config_files)
  return config_files_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::config_file >*
config_data::mutable_config_files() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.config_data.config_files)
  return &config_files_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::config_file >&
config_data::config_files() const {
  // @@protoc_insertion_point(field_list:draiosproto.config_data.config_files)
  return config_files_;
}

inline const config_data* config_data::internal_default_instance() {
  return &config_data_default_instance_.get();
}
// -------------------------------------------------------------------

// error_message

// optional .draiosproto.error_type type = 1;
inline bool error_message::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void error_message::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void error_message::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void error_message::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::draiosproto::error_type error_message::type() const {
  // @@protoc_insertion_point(field_get:draiosproto.error_message.type)
  return static_cast< ::draiosproto::error_type >(type_);
}
inline void error_message::set_type(::draiosproto::error_type value) {
  assert(::draiosproto::error_type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.error_message.type)
}

// optional string description = 2;
inline bool error_message::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void error_message::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void error_message::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void error_message::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& error_message::description() const {
  // @@protoc_insertion_point(field_get:draiosproto.error_message.description)
  return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void error_message::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.error_message.description)
}
inline void error_message::set_description(const char* value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.error_message.description)
}
inline void error_message::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.error_message.description)
}
inline ::std::string* error_message::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:draiosproto.error_message.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* error_message::release_description() {
  // @@protoc_insertion_point(field_release:draiosproto.error_message.description)
  clear_has_description();
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void error_message::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.error_message.description)
}

inline const error_message* error_message::internal_default_instance() {
  return &error_message_default_instance_.get();
}
// -------------------------------------------------------------------

// falco_subcategory

// required string name = 1;
inline bool falco_subcategory::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void falco_subcategory::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void falco_subcategory::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void falco_subcategory::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& falco_subcategory::name() const {
  // @@protoc_insertion_point(field_get:draiosproto.falco_subcategory.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void falco_subcategory::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.falco_subcategory.name)
}
inline void falco_subcategory::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.falco_subcategory.name)
}
inline void falco_subcategory::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.falco_subcategory.name)
}
inline ::std::string* falco_subcategory::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:draiosproto.falco_subcategory.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* falco_subcategory::release_name() {
  // @@protoc_insertion_point(field_release:draiosproto.falco_subcategory.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void falco_subcategory::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.falco_subcategory.name)
}

// repeated string d = 2;
inline int falco_subcategory::d_size() const {
  return d_.size();
}
inline void falco_subcategory::clear_d() {
  d_.Clear();
}
inline const ::std::string& falco_subcategory::d(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.falco_subcategory.d)
  return d_.Get(index);
}
inline ::std::string* falco_subcategory::mutable_d(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.falco_subcategory.d)
  return d_.Mutable(index);
}
inline void falco_subcategory::set_d(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:draiosproto.falco_subcategory.d)
  d_.Mutable(index)->assign(value);
}
inline void falco_subcategory::set_d(int index, const char* value) {
  d_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:draiosproto.falco_subcategory.d)
}
inline void falco_subcategory::set_d(int index, const char* value, size_t size) {
  d_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:draiosproto.falco_subcategory.d)
}
inline ::std::string* falco_subcategory::add_d() {
  // @@protoc_insertion_point(field_add_mutable:draiosproto.falco_subcategory.d)
  return d_.Add();
}
inline void falco_subcategory::add_d(const ::std::string& value) {
  d_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:draiosproto.falco_subcategory.d)
}
inline void falco_subcategory::add_d(const char* value) {
  d_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:draiosproto.falco_subcategory.d)
}
inline void falco_subcategory::add_d(const char* value, size_t size) {
  d_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:draiosproto.falco_subcategory.d)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
falco_subcategory::d() const {
  // @@protoc_insertion_point(field_list:draiosproto.falco_subcategory.d)
  return d_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
falco_subcategory::mutable_d() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.falco_subcategory.d)
  return &d_;
}

// optional bool full = 3;
inline bool falco_subcategory::has_full() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void falco_subcategory::set_has_full() {
  _has_bits_[0] |= 0x00000004u;
}
inline void falco_subcategory::clear_has_full() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void falco_subcategory::clear_full() {
  full_ = false;
  clear_has_full();
}
inline bool falco_subcategory::full() const {
  // @@protoc_insertion_point(field_get:draiosproto.falco_subcategory.full)
  return full_;
}
inline void falco_subcategory::set_full(bool value) {
  set_has_full();
  full_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.falco_subcategory.full)
}

inline const falco_subcategory* falco_subcategory::internal_default_instance() {
  return &falco_subcategory_default_instance_.get();
}
// -------------------------------------------------------------------

// falco_subcategory_container

// repeated .draiosproto.falco_subcategory subcats = 1;
inline int falco_subcategory_container::subcats_size() const {
  return subcats_.size();
}
inline void falco_subcategory_container::clear_subcats() {
  subcats_.Clear();
}
inline const ::draiosproto::falco_subcategory& falco_subcategory_container::subcats(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.falco_subcategory_container.subcats)
  return subcats_.Get(index);
}
inline ::draiosproto::falco_subcategory* falco_subcategory_container::mutable_subcats(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.falco_subcategory_container.subcats)
  return subcats_.Mutable(index);
}
inline ::draiosproto::falco_subcategory* falco_subcategory_container::add_subcats() {
  // @@protoc_insertion_point(field_add:draiosproto.falco_subcategory_container.subcats)
  return subcats_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_subcategory >*
falco_subcategory_container::mutable_subcats() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.falco_subcategory_container.subcats)
  return &subcats_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_subcategory >&
falco_subcategory_container::subcats() const {
  // @@protoc_insertion_point(field_list:draiosproto.falco_subcategory_container.subcats)
  return subcats_;
}

inline const falco_subcategory_container* falco_subcategory_container::internal_default_instance() {
  return &falco_subcategory_container_default_instance_.get();
}
// -------------------------------------------------------------------

// falco_category

// required string name = 1;
inline bool falco_category::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void falco_category::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void falco_category::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void falco_category::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& falco_category::name() const {
  // @@protoc_insertion_point(field_get:draiosproto.falco_category.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void falco_category::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.falco_category.name)
}
inline void falco_category::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.falco_category.name)
}
inline void falco_category::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.falco_category.name)
}
inline ::std::string* falco_category::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:draiosproto.falco_category.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* falco_category::release_name() {
  // @@protoc_insertion_point(field_release:draiosproto.falco_category.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void falco_category::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.falco_category.name)
}

// repeated .draiosproto.falco_subcategory_container startup_subcats = 2;
inline int falco_category::startup_subcats_size() const {
  return startup_subcats_.size();
}
inline void falco_category::clear_startup_subcats() {
  startup_subcats_.Clear();
}
inline const ::draiosproto::falco_subcategory_container& falco_category::startup_subcats(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.falco_category.startup_subcats)
  return startup_subcats_.Get(index);
}
inline ::draiosproto::falco_subcategory_container* falco_category::mutable_startup_subcats(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.falco_category.startup_subcats)
  return startup_subcats_.Mutable(index);
}
inline ::draiosproto::falco_subcategory_container* falco_category::add_startup_subcats() {
  // @@protoc_insertion_point(field_add:draiosproto.falco_category.startup_subcats)
  return startup_subcats_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_subcategory_container >*
falco_category::mutable_startup_subcats() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.falco_category.startup_subcats)
  return &startup_subcats_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_subcategory_container >&
falco_category::startup_subcats() const {
  // @@protoc_insertion_point(field_list:draiosproto.falco_category.startup_subcats)
  return startup_subcats_;
}

// repeated .draiosproto.falco_subcategory_container regular_subcats = 3;
inline int falco_category::regular_subcats_size() const {
  return regular_subcats_.size();
}
inline void falco_category::clear_regular_subcats() {
  regular_subcats_.Clear();
}
inline const ::draiosproto::falco_subcategory_container& falco_category::regular_subcats(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.falco_category.regular_subcats)
  return regular_subcats_.Get(index);
}
inline ::draiosproto::falco_subcategory_container* falco_category::mutable_regular_subcats(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.falco_category.regular_subcats)
  return regular_subcats_.Mutable(index);
}
inline ::draiosproto::falco_subcategory_container* falco_category::add_regular_subcats() {
  // @@protoc_insertion_point(field_add:draiosproto.falco_category.regular_subcats)
  return regular_subcats_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_subcategory_container >*
falco_category::mutable_regular_subcats() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.falco_category.regular_subcats)
  return &regular_subcats_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_subcategory_container >&
falco_category::regular_subcats() const {
  // @@protoc_insertion_point(field_list:draiosproto.falco_category.regular_subcats)
  return regular_subcats_;
}

inline const falco_category* falco_category::internal_default_instance() {
  return &falco_category_default_instance_.get();
}
// -------------------------------------------------------------------

// falco_prog

// required string comm = 1;
inline bool falco_prog::has_comm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void falco_prog::set_has_comm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void falco_prog::clear_has_comm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void falco_prog::clear_comm() {
  comm_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comm();
}
inline const ::std::string& falco_prog::comm() const {
  // @@protoc_insertion_point(field_get:draiosproto.falco_prog.comm)
  return comm_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void falco_prog::set_comm(const ::std::string& value) {
  set_has_comm();
  comm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.falco_prog.comm)
}
inline void falco_prog::set_comm(const char* value) {
  set_has_comm();
  comm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.falco_prog.comm)
}
inline void falco_prog::set_comm(const char* value, size_t size) {
  set_has_comm();
  comm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.falco_prog.comm)
}
inline ::std::string* falco_prog::mutable_comm() {
  set_has_comm();
  // @@protoc_insertion_point(field_mutable:draiosproto.falco_prog.comm)
  return comm_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* falco_prog::release_comm() {
  // @@protoc_insertion_point(field_release:draiosproto.falco_prog.comm)
  clear_has_comm();
  return comm_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void falco_prog::set_allocated_comm(::std::string* comm) {
  if (comm != NULL) {
    set_has_comm();
  } else {
    clear_has_comm();
  }
  comm_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comm);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.falco_prog.comm)
}

// required string exe = 2;
inline bool falco_prog::has_exe() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void falco_prog::set_has_exe() {
  _has_bits_[0] |= 0x00000002u;
}
inline void falco_prog::clear_has_exe() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void falco_prog::clear_exe() {
  exe_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exe();
}
inline const ::std::string& falco_prog::exe() const {
  // @@protoc_insertion_point(field_get:draiosproto.falco_prog.exe)
  return exe_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void falco_prog::set_exe(const ::std::string& value) {
  set_has_exe();
  exe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.falco_prog.exe)
}
inline void falco_prog::set_exe(const char* value) {
  set_has_exe();
  exe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.falco_prog.exe)
}
inline void falco_prog::set_exe(const char* value, size_t size) {
  set_has_exe();
  exe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.falco_prog.exe)
}
inline ::std::string* falco_prog::mutable_exe() {
  set_has_exe();
  // @@protoc_insertion_point(field_mutable:draiosproto.falco_prog.exe)
  return exe_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* falco_prog::release_exe() {
  // @@protoc_insertion_point(field_release:draiosproto.falco_prog.exe)
  clear_has_exe();
  return exe_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void falco_prog::set_allocated_exe(::std::string* exe) {
  if (exe != NULL) {
    set_has_exe();
  } else {
    clear_has_exe();
  }
  exe_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exe);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.falco_prog.exe)
}

// repeated string args = 3;
inline int falco_prog::args_size() const {
  return args_.size();
}
inline void falco_prog::clear_args() {
  args_.Clear();
}
inline const ::std::string& falco_prog::args(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.falco_prog.args)
  return args_.Get(index);
}
inline ::std::string* falco_prog::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.falco_prog.args)
  return args_.Mutable(index);
}
inline void falco_prog::set_args(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:draiosproto.falco_prog.args)
  args_.Mutable(index)->assign(value);
}
inline void falco_prog::set_args(int index, const char* value) {
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:draiosproto.falco_prog.args)
}
inline void falco_prog::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:draiosproto.falco_prog.args)
}
inline ::std::string* falco_prog::add_args() {
  // @@protoc_insertion_point(field_add_mutable:draiosproto.falco_prog.args)
  return args_.Add();
}
inline void falco_prog::add_args(const ::std::string& value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:draiosproto.falco_prog.args)
}
inline void falco_prog::add_args(const char* value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:draiosproto.falco_prog.args)
}
inline void falco_prog::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:draiosproto.falco_prog.args)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
falco_prog::args() const {
  // @@protoc_insertion_point(field_list:draiosproto.falco_prog.args)
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
falco_prog::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.falco_prog.args)
  return &args_;
}

// required uint64 user_id = 4;
inline bool falco_prog::has_user_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void falco_prog::set_has_user_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void falco_prog::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void falco_prog::clear_user_id() {
  user_id_ = GOOGLE_ULONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::uint64 falco_prog::user_id() const {
  // @@protoc_insertion_point(field_get:draiosproto.falco_prog.user_id)
  return user_id_;
}
inline void falco_prog::set_user_id(::google::protobuf::uint64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:draiosproto.falco_prog.user_id)
}

// optional string container_id = 5;
inline bool falco_prog::has_container_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void falco_prog::set_has_container_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void falco_prog::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void falco_prog::clear_container_id() {
  container_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_container_id();
}
inline const ::std::string& falco_prog::container_id() const {
  // @@protoc_insertion_point(field_get:draiosproto.falco_prog.container_id)
  return container_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void falco_prog::set_container_id(const ::std::string& value) {
  set_has_container_id();
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.falco_prog.container_id)
}
inline void falco_prog::set_container_id(const char* value) {
  set_has_container_id();
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.falco_prog.container_id)
}
inline void falco_prog::set_container_id(const char* value, size_t size) {
  set_has_container_id();
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.falco_prog.container_id)
}
inline ::std::string* falco_prog::mutable_container_id() {
  set_has_container_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.falco_prog.container_id)
  return container_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* falco_prog::release_container_id() {
  // @@protoc_insertion_point(field_release:draiosproto.falco_prog.container_id)
  clear_has_container_id();
  return container_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void falco_prog::set_allocated_container_id(::std::string* container_id) {
  if (container_id != NULL) {
    set_has_container_id();
  } else {
    clear_has_container_id();
  }
  container_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), container_id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.falco_prog.container_id)
}

// repeated .draiosproto.falco_category cats = 6;
inline int falco_prog::cats_size() const {
  return cats_.size();
}
inline void falco_prog::clear_cats() {
  cats_.Clear();
}
inline const ::draiosproto::falco_category& falco_prog::cats(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.falco_prog.cats)
  return cats_.Get(index);
}
inline ::draiosproto::falco_category* falco_prog::mutable_cats(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.falco_prog.cats)
  return cats_.Mutable(index);
}
inline ::draiosproto::falco_category* falco_prog::add_cats() {
  // @@protoc_insertion_point(field_add:draiosproto.falco_prog.cats)
  return cats_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_category >*
falco_prog::mutable_cats() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.falco_prog.cats)
  return &cats_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_category >&
falco_prog::cats() const {
  // @@protoc_insertion_point(field_list:draiosproto.falco_prog.cats)
  return cats_;
}

inline const falco_prog* falco_prog::internal_default_instance() {
  return &falco_prog_default_instance_.get();
}
// -------------------------------------------------------------------

// falco_container

// required string id = 1;
inline bool falco_container::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void falco_container::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void falco_container::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void falco_container::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& falco_container::id() const {
  // @@protoc_insertion_point(field_get:draiosproto.falco_container.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void falco_container::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.falco_container.id)
}
inline void falco_container::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.falco_container.id)
}
inline void falco_container::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.falco_container.id)
}
inline ::std::string* falco_container::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.falco_container.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* falco_container::release_id() {
  // @@protoc_insertion_point(field_release:draiosproto.falco_container.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void falco_container::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.falco_container.id)
}

// required string name = 2;
inline bool falco_container::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void falco_container::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void falco_container::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void falco_container::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& falco_container::name() const {
  // @@protoc_insertion_point(field_get:draiosproto.falco_container.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void falco_container::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.falco_container.name)
}
inline void falco_container::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.falco_container.name)
}
inline void falco_container::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.falco_container.name)
}
inline ::std::string* falco_container::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:draiosproto.falco_container.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* falco_container::release_name() {
  // @@protoc_insertion_point(field_release:draiosproto.falco_container.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void falco_container::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.falco_container.name)
}

// optional string image_name = 3;
inline bool falco_container::has_image_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void falco_container::set_has_image_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void falco_container::clear_has_image_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void falco_container::clear_image_name() {
  image_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_image_name();
}
inline const ::std::string& falco_container::image_name() const {
  // @@protoc_insertion_point(field_get:draiosproto.falco_container.image_name)
  return image_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void falco_container::set_image_name(const ::std::string& value) {
  set_has_image_name();
  image_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.falco_container.image_name)
}
inline void falco_container::set_image_name(const char* value) {
  set_has_image_name();
  image_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.falco_container.image_name)
}
inline void falco_container::set_image_name(const char* value, size_t size) {
  set_has_image_name();
  image_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.falco_container.image_name)
}
inline ::std::string* falco_container::mutable_image_name() {
  set_has_image_name();
  // @@protoc_insertion_point(field_mutable:draiosproto.falco_container.image_name)
  return image_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* falco_container::release_image_name() {
  // @@protoc_insertion_point(field_release:draiosproto.falco_container.image_name)
  clear_has_image_name();
  return image_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void falco_container::set_allocated_image_name(::std::string* image_name) {
  if (image_name != NULL) {
    set_has_image_name();
  } else {
    clear_has_image_name();
  }
  image_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image_name);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.falco_container.image_name)
}

// optional string image_id = 4;
inline bool falco_container::has_image_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void falco_container::set_has_image_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void falco_container::clear_has_image_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void falco_container::clear_image_id() {
  image_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_image_id();
}
inline const ::std::string& falco_container::image_id() const {
  // @@protoc_insertion_point(field_get:draiosproto.falco_container.image_id)
  return image_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void falco_container::set_image_id(const ::std::string& value) {
  set_has_image_id();
  image_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:draiosproto.falco_container.image_id)
}
inline void falco_container::set_image_id(const char* value) {
  set_has_image_id();
  image_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:draiosproto.falco_container.image_id)
}
inline void falco_container::set_image_id(const char* value, size_t size) {
  set_has_image_id();
  image_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:draiosproto.falco_container.image_id)
}
inline ::std::string* falco_container::mutable_image_id() {
  set_has_image_id();
  // @@protoc_insertion_point(field_mutable:draiosproto.falco_container.image_id)
  return image_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* falco_container::release_image_id() {
  // @@protoc_insertion_point(field_release:draiosproto.falco_container.image_id)
  clear_has_image_id();
  return image_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void falco_container::set_allocated_image_id(::std::string* image_id) {
  if (image_id != NULL) {
    set_has_image_id();
  } else {
    clear_has_image_id();
  }
  image_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image_id);
  // @@protoc_insertion_point(field_set_allocated:draiosproto.falco_container.image_id)
}

inline const falco_container* falco_container::internal_default_instance() {
  return &falco_container_default_instance_.get();
}
// -------------------------------------------------------------------

// falco_baseline

// repeated .draiosproto.falco_prog progs = 1;
inline int falco_baseline::progs_size() const {
  return progs_.size();
}
inline void falco_baseline::clear_progs() {
  progs_.Clear();
}
inline const ::draiosproto::falco_prog& falco_baseline::progs(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.falco_baseline.progs)
  return progs_.Get(index);
}
inline ::draiosproto::falco_prog* falco_baseline::mutable_progs(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.falco_baseline.progs)
  return progs_.Mutable(index);
}
inline ::draiosproto::falco_prog* falco_baseline::add_progs() {
  // @@protoc_insertion_point(field_add:draiosproto.falco_baseline.progs)
  return progs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_prog >*
falco_baseline::mutable_progs() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.falco_baseline.progs)
  return &progs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_prog >&
falco_baseline::progs() const {
  // @@protoc_insertion_point(field_list:draiosproto.falco_baseline.progs)
  return progs_;
}

// repeated .draiosproto.falco_container containers = 2;
inline int falco_baseline::containers_size() const {
  return containers_.size();
}
inline void falco_baseline::clear_containers() {
  containers_.Clear();
}
inline const ::draiosproto::falco_container& falco_baseline::containers(int index) const {
  // @@protoc_insertion_point(field_get:draiosproto.falco_baseline.containers)
  return containers_.Get(index);
}
inline ::draiosproto::falco_container* falco_baseline::mutable_containers(int index) {
  // @@protoc_insertion_point(field_mutable:draiosproto.falco_baseline.containers)
  return containers_.Mutable(index);
}
inline ::draiosproto::falco_container* falco_baseline::add_containers() {
  // @@protoc_insertion_point(field_add:draiosproto.falco_baseline.containers)
  return containers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_container >*
falco_baseline::mutable_containers() {
  // @@protoc_insertion_point(field_mutable_list:draiosproto.falco_baseline.containers)
  return &containers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::falco_container >&
falco_baseline::containers() const {
  // @@protoc_insertion_point(field_list:draiosproto.falco_baseline.containers)
  return containers_;
}

inline const falco_baseline* falco_baseline::internal_default_instance() {
  return &falco_baseline_default_instance_.get();
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace draiosproto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::draiosproto::sql_statement_type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::draiosproto::sql_statement_type>() {
  return ::draiosproto::sql_statement_type_descriptor();
}
template <> struct is_proto_enum< ::draiosproto::mongodb_op_type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::draiosproto::mongodb_op_type>() {
  return ::draiosproto::mongodb_op_type_descriptor();
}
template <> struct is_proto_enum< ::draiosproto::unit> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::draiosproto::unit>() {
  return ::draiosproto::unit_descriptor();
}
template <> struct is_proto_enum< ::draiosproto::scale> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::draiosproto::scale>() {
  return ::draiosproto::scale_descriptor();
}
template <> struct is_proto_enum< ::draiosproto::jmx_metric_type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::draiosproto::jmx_metric_type>() {
  return ::draiosproto::jmx_metric_type_descriptor();
}
template <> struct is_proto_enum< ::draiosproto::statsd_metric_type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::draiosproto::statsd_metric_type>() {
  return ::draiosproto::statsd_metric_type_descriptor();
}
template <> struct is_proto_enum< ::draiosproto::app_metric_type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::draiosproto::app_metric_type>() {
  return ::draiosproto::app_metric_type_descriptor();
}
template <> struct is_proto_enum< ::draiosproto::app_check_value> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::draiosproto::app_check_value>() {
  return ::draiosproto::app_check_value_descriptor();
}
template <> struct is_proto_enum< ::draiosproto::networkrole> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::draiosproto::networkrole>() {
  return ::draiosproto::networkrole_descriptor();
}
template <> struct is_proto_enum< ::draiosproto::message_type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::draiosproto::message_type>() {
  return ::draiosproto::message_type_descriptor();
}
template <> struct is_proto_enum< ::draiosproto::container_type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::draiosproto::container_type>() {
  return ::draiosproto::container_type_descriptor();
}
template <> struct is_proto_enum< ::draiosproto::error_type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::draiosproto::error_type>() {
  return ::draiosproto::error_type_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_draios_2eproto__INCLUDED
