package draiosproto;

option optimize_for = SPEED;
option java_package = "com.draios.model.protobuf";
option java_outer_classname = "Agent";

message counter_time {
    required uint32 count = 1;
    required uint64 time_ns = 2;
    optional uint32 time_percentage = 3;
}

message counter_time_bidirectional {
    required uint32 count_in = 1;
    required uint32 count_out = 2;
    required uint64 time_ns_in = 3;
    required uint64 time_ns_out = 4;
}

message counter_bytes {
    required uint32 count_in = 1;
    required uint32 count_out = 2;
    required uint32 bytes_in = 3;
    required uint32 bytes_out = 4;
}

message counter_time_bytes {
    required uint64 time_ns_in = 1;
    required uint64 time_ns_out = 2;
    required uint64 time_ns_other = 3;
    required uint32 count_in = 4;
    required uint32 count_out = 5;
    required uint32 count_other = 6;
    required uint32 bytes_in = 7;
    required uint32 bytes_out = 8;
    required uint32 bytes_other = 9;
    optional uint32 time_percentage_in = 10;
    optional uint32 time_percentage_out = 11;
    optional uint32 time_percentage_other = 12;
}

message time_categories {
    optional counter_time unknown = 1;
    optional counter_time other = 2;
    optional counter_time file = 3;
    optional counter_time net = 4;
    optional counter_time ipc = 5;
    optional counter_time memory = 6;
    optional counter_time process = 7;
    optional counter_time sleep = 8;
    optional counter_time system = 9;
    optional counter_time signal = 10;
    optional counter_time user = 11;
    optional counter_time time = 12;
    optional counter_time_bytes io_file = 13;
    optional counter_time_bytes io_net = 14;
    optional counter_time_bytes io_other = 15;
    optional counter_time wait = 16;
    optional counter_time processing = 17;
}

//
// Stores how time is spent serving requests by the host
//
message transaction_breakdown_categories {
    optional counter_time other = 2;
    optional counter_time_bytes io_file = 13;
    optional counter_time_bytes io_net = 14;
    optional counter_time processing = 17;
}

message counter_syscall_errors {
    required uint32 count = 1; // Syscall errors count
    repeated uint32 top_error_codes = 2; // Error codes that were generated the most
    optional uint32 count_file = 4; // Number of file errors
    optional uint32 count_file_open = 5;    // Number of file open errors
    optional uint32 count_net = 6;  // Number of network errors
}

message resource_categories {
    optional uint32 capacity_score = 1; // the request capacity score for this process or host. 0 means all the capacity is available, 10000 means that the entity (host or process) has reached the maximum mumber of requests it can serve.
    optional uint32 stolen_capacity_score = 6; // the percentage of request capacity that is not available because of CPU steal. 0 means there was no CPU steal during the sample. 100 means that all the capacity was stolen and the machine essentially couldn't run.
    optional uint32 connection_queue_usage_pct = 2; // if this process or host is serving connections, the occupation of the connection queue FOR THE WORST THREAD IN THIS PROCESS OR HOST (0=empty, 100=full)
    optional uint32 fd_usage_pct = 3; // the ratio (open FDs / total available FDs) FOR THE WORST THREAD IN THIS PROCESS OR HOST. 0 means no FD in use, 100 means FD limit reached.
    optional uint32 cpu_pct = 4; // CPU load of a process (including all the childs). Not present for the host.
    optional uint32 resident_memory_usage_kb = 5; // resident non-swapped memory (as kb).
    optional uint32 virtual_memory_usage_kb = 13; // total virtual memory (as kb). Not present for the host and container.
    optional uint32 swap_memory_usage_kb = 14; // swapped memory (as kb).
    optional uint64 major_pagefaults = 15; // number of major page faults since last sample.
    optional uint64 minor_pagefaults = 16; // number of minor page faults since last sample.
    optional uint32 fd_count = 21; // Total number of FDs
}

message connection_categories {
    optional counter_bytes server = 1; // client-side metrics
    optional counter_bytes client = 2; // server-side metrics
    optional counter_time_bidirectional transaction_counters = 3; // The transaction counters for this connection
    optional counter_time_bidirectional min_transaction_counters = 18; // The fastest transaction counters for this connection
    optional counter_time_bidirectional max_transaction_counters = 19; // The slowest transaction counters for this connection
    optional uint32 n_aggregated_connections = 4; // If this is an aggregated connection, the number of real connections it represents
}

message process_details {
    required string comm = 1; // Command name (e.g. "top")
    required string exe = 2; // argv[0] (e.g. "sshd: gianluca@pts/4")
    repeated string args = 3; // Command line arguments (e.g. "-d1")
    optional string container_id = 4;
}

//
// Description of a command executed on the machine
//
message command_details {
    required uint64 timestamp = 1;
    required uint32 count = 2; // How many times this command has been repeated during the sample interval
    required string cmdline = 3; // Program command line (e.g. "top -d1")
    required string exe = 4; // Full executable name (e.g. "/bin/top")
    optional string parentcomm = 5; // Name of the command that launched this one (e.g. "bash")
}

//
// Counters for a protocol-related dimension, like a URL or a query
//
message counter_proto_entry {
    required uint32 ncalls = 1;
    required uint64 time_tot = 2;
    required uint64 time_max = 3;
    required uint64 bytes_in = 4;
    required uint64 bytes_out = 5;
    required uint32 nerrors = 6;
}

//
// URL information
//
message url_details {
    //
    // The URL, in the following format "TYPEADDR<:PORT>/PATH", e.g. "p172.16.189.128:9000/api/data".
    // Note: possible values foy type are:
    //   n for NONE
    //   g for GET
    //   p for POST
    //   o for OPTIONS
    //   h for HEAD
    //   P for PUT
    //   d for DELETE
    //   t for TRACE
    //   c for CONNECT
    //
    required string url = 1; 
    required counter_proto_entry counters = 2;
}

message status_code_details {
    required uint32 status_code = 1;
    required uint32 ncalls = 2;
}

//
// HTTP protocol information
//
message http_info {
    repeated url_details server_urls = 1;
    repeated url_details client_urls = 2;
    repeated status_code_details client_status_codes = 3;
    repeated status_code_details server_status_codes = 4;
}

//
// SQL query information
//
message sql_entry_details {
    required string name = 1;
    required counter_proto_entry counters = 2;
}

//
// SQL statement information
//
enum sql_statement_type {
    SOP_NONE = 0;
    SOP_SELECT = 1;
    SOP_INSERT = 2;
    SOP_SET = 3;
    SOP_CREATE = 4;
    SOP_DELETE = 5;
    SOP_DROP = 6;
    SOP_REPLACE = 7;
    SOP_UPDATE = 8;
    SOP_USE = 9;
    SOP_SHOW = 10;
    SOP_LOCK = 11;
    SOP_UNLOCK = 12;
    SOP_ALTER = 13;
}

message sql_query_type_details {
    required sql_statement_type type = 1;
    required counter_proto_entry counters = 2;
}

//
// SQL protocol information
//
message sql_info {
    repeated sql_entry_details server_queries = 1; // the top server-side queries
    repeated sql_entry_details client_queries = 2; // the top client-side queries
    repeated sql_query_type_details server_query_types = 3; // the top server-side query types (e.g. SELECT, INSERT...)
    repeated sql_query_type_details client_query_types = 4; // the top client-side query types (e.g. SELECT, INSERT...)
    repeated sql_entry_details server_tables = 5; // the top server-side queries
    repeated sql_entry_details client_tables = 6; // the top client-side queries
}

message mongodb_collection_details {
    required string name = 1;
    required counter_proto_entry counters = 2;
}

enum mongodb_op_type {
    MONGODB_OP_NONE = 0;
    MONGODB_OP_INSERT = 1;
    MONGODB_OP_UPDATE = 2;
    MONGODB_OP_DELETE = 3;
    MONGODB_OP_GET_MORE = 4;
    MONGODB_OP_KILL_CURSORS = 5;
    MONGODB_OP_FIND = 6;
    MONGODB_OP_AGGREGATE = 7;
    MONGODB_OP_COMMAND = 8;
    MONGODB_OP_COUNT = 9;
    MONGODB_OP_DISTINCT = 10;
    MONGODB_OP_MAP_REDUCE = 11;
    MONGODB_OP_GEO_NEAR = 12;
    MONGODB_OP_GEO_SEARCH = 13;
    MONGODB_OP_FIND_AND_MODIFY = 14;
}

message mongodb_op_type_details {
    required mongodb_op_type op = 1;
    required counter_proto_entry counters = 2;
}

message mongodb_info {
    repeated mongodb_op_type_details servers_ops = 1;
    repeated mongodb_op_type_details client_ops = 2;
    repeated mongodb_collection_details server_collections = 3;
    repeated mongodb_collection_details client_collections = 4;
}

//
// General protocol information
//
message proto_info {
    optional http_info http = 1;
    optional sql_info mysql = 2;
    optional sql_info postgres = 3;
    optional mongodb_info mongodb = 4;
}

//
// HOST
// global host info.
//
message host {
    optional string hostname = 1; // The name of the host sending the data
    optional uint32 num_cpus = 2; // Number of CPUs in the system
    repeated uint32 cpu_loads = 3; // Array of CPU loads (0 to 100), with an entry for each CPU, with the
    repeated uint32 cpu_steal = 11; // Array of CPU loads (0 to 100), with an entry for each CPU, with the
    required uint64 physical_memory_size_bytes = 4; // Physical RAM size
    optional time_categories tcounters = 5; // The time counters for this thread
    optional transaction_breakdown_categories reqcounters = 12; // how time is spent when serving requests
    optional counter_time_bidirectional transaction_counters = 6; // The transaction counters for the whole host
    optional counter_time_bidirectional min_transaction_counters = 22; // The fastest transaction counters for the whole host
    optional counter_time_bidirectional max_transaction_counters = 23; // The slowest transaction counters for the whole host
    optional uint64 transaction_processing_delay = 7; // the delay introduced by this host when processing transactions.
    // It's calculated by subtracting outgoing connection time from incoming connection time.
    optional uint64 merged_server_delay = 14; // the total merged time of all the incoming requests.
    optional uint64 next_tiers_delay = 13; // the delay introduced by this host's next tiers when processing transactions.
    optional resource_categories resource_counters = 8; // The resource counters for this process
    optional counter_syscall_errors syscall_errors = 9; // Syscall error counter
    optional counter_time_bytes external_io_net = 10; // The I/O statistics filtered so that only the activity with the external world is used
}

//
// PROCESS
// info for a process, i.e. a collection of threads.
// NOTE: this is process info only, when emitting threads, the main thread of a process will have a
// separate thread message with tid=process pid.
//
enum networkrole {
    NONE = 0; // set if this thread serves IPv4 transactions coming from the same machine.
    IS_LOCAL_IPV4_SERVER = 1; // set if this thread serves IPv4 transactions coming from the same machine.
    IS_REMOTE_IPV4_SERVER = 2; // set if this thread serves IPv4 transactions coming from another machine.
    IS_UNIX_SERVER = 4; // set if this thread serves unix transactions.
    IS_LOCAL_IPV4_CLIENT = 8; // set if this thread creates IPv4 transactions toward localhost.
    IS_REMOTE_IPV4_CLIENT = 16; // set if this thread creates IPv4 transactions toward another host.
    IS_UNIX_CLIENT = 32; // set if this thread creates unix transactions.
}

message process {
    optional process_details details = 2; // names and string constants relative to this process
    optional bool is_ipv4_transaction_server = 3; // True if this process has served at least one IPv4 transaction.
    optional bool is_unix_transaction_server = 4; // True if this process has served at least one unix transaction.
    optional bool is_ipv4_transaction_client = 10; // True if this process has been the client for at least one IPv4 transaction.
    optional bool is_unix_transaction_client = 11; // True if this process has been the client for at least one unix transaction.
    optional uint32 netrole = 13;
    optional time_categories tcounters = 5; // The time counters for this thread.
    optional counter_time_bidirectional transaction_counters = 6; // The transaction counters for this process.
    optional counter_time_bidirectional min_transaction_counters = 18; // The fastest transaction counters for this process.
    optional counter_time_bidirectional max_transaction_counters = 19; // The slowest transaction counters for this process.
    optional uint64 transaction_processing_delay = 7; // the delay introduced by this process when processing transactions.
    // It's calculated by subtracting outgoing connection time from incoming connection time.
    optional uint64 merged_server_delay = 14; // the total merged time of all the incoming requests.
    optional uint64 next_tiers_delay = 12; // the delay introduced by this process' next tiers when processing transactions.
    optional resource_categories resource_counters = 8; // The resource counters for this process
    optional counter_syscall_errors syscall_errors = 9; // Syscall error counter
    optional proto_info protos = 20; // Information about protocols that have been decoded
}

//
// PROGRAM
// info for a program, i.e. a collection of processes with the same name and the same creator.
//
message program {
    required process procinfo = 1; // Inofrmation about this program
    repeated uint64 pids = 2; // The list of processes that are part of this program
}

//
// IPv4 CONNECTION
//
message ipv4tuple {
    required uint32 sip = 1;
    required uint32 dip = 2;
    required uint32 sport = 3;
    required uint32 dport = 4;
    required uint32 l4proto = 5;
}

message ipv4_connection {
    required ipv4tuple tuple = 1;

    optional uint64 spid = 2; // The pid of the client
    optional uint64 dpid = 5; // The pid of the server

    required connection_categories counters = 8; // the metrics for this connection
}

//
// NETWORK INTERFACE
//
message ipv4_network_interface {
    required string name = 1; // ifconfig entry name, e.g. eth0
    required uint32 addr = 2; // IP address
    required uint32 netmask = 3; // netmask
    optional uint32 bcast = 4; // broadcast address
}

//
// MESSAGE TYPES
//
enum message_type {
    METRICS = 1;
    DUMP_REQUEST_START = 2;
    DUMP_REQUEST_STOP = 4;
    DUMP_RESPONSE = 3;
    SSH_OPEN_CHANNEL = 6;
    SSH_CLOSE_CHANNEL = 7;
    SSH_DATA = 8;
    AUTO_UPDATE_REQUEST = 9;
    DIRTY_SHUTDOWN_REPORT = 10;
}

//
// MOUNTED FILE SYSTEM
//
message mounted_fs {
    required string device = 1;
    required string mount_dir = 2;
    required string type = 3;
    required uint64 size_bytes = 4;
    required uint64 used_bytes = 5;
    required uint64 available_bytes = 6;
}

//
// TOP FILE STATISTICS
//
message file_stat {
    required string name = 1;
    required uint32 bytes = 2;
    required uint64 time_ns = 3;
    required uint32 open_count = 4;
    required uint32 errors = 5;
}

enum container_type {
    DOCKER = 1;
    LXC = 2;
    LIBVIRT_LXC = 3;
}

message container {
    required string id = 1;
    optional container_type type = 2;
    optional string name = 3;
    optional string image = 4;
    optional time_categories tcounters = 5; // The time counters for this thread
    optional transaction_breakdown_categories reqcounters = 6; // how time is spent when serving requests
    optional counter_time_bidirectional transaction_counters = 7; // The transaction counters for the whole host
    optional counter_time_bidirectional min_transaction_counters = 8; // The fastest transaction counters for the whole host
    optional counter_time_bidirectional max_transaction_counters = 9; // The slowest transaction counters for the whole host
    optional uint64 transaction_processing_delay = 10; // the delay introduced by this host when processing transactions.
    // It's calculated by subtracting outgoing connection time from incoming connection time.
    optional uint64 merged_server_delay = 11; // the total merged time of all the incoming requests.
    optional uint64 next_tiers_delay = 12; // the delay introduced by this host's next tiers when processing transactions.
    optional resource_categories resource_counters = 13; // The resource counters for this process
    optional counter_syscall_errors syscall_errors = 14; // Syscall error counter
}

//
// ENTRY POINT MESSAGE
//
message metrics {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    required host hostinfo = 4; // The list of processes
    repeated program programs = 9; // The list of programs
    repeated process processes = 5; // The list of processes
    repeated ipv4_connection ipv4_connections = 7; // The list of IPv4 connections
    repeated ipv4_network_interface ipv4_network_interfaces = 8; // The list of the machine network interfaces
    optional uint32 sampling_ratio = 10; // The sampling ratio when subsampling. If not present, assume 1, which means no subsampling.
    optional string host_custom_name = 11; // This machines's user-set custom name for the draios map.
    optional string host_tags = 12; // This machines's user-set list of tags for the draios map. 
    optional string host_custom_map = 13; // This machines's user-set custom map for the draios UI. 
    optional bool is_host_hidden = 14; // This machines's user-set visibility flag for the draios map. 
    optional string hidden_processes = 15; // Comma-sparated list of process names that the user wants to hide in the draios map. 
    optional string version = 16; // Agent/libsanalyzer/sysdig version
    optional string instance_id = 21; // AWS instance id
    repeated command_details commands = 17; // List of commands executed during the sample.
    repeated mounted_fs mounts = 18; // List of mounted file systems
    repeated file_stat top_files = 19; // Top files
    optional proto_info protos = 20; // Information about protocols that have been decoded
    repeated container containers = 22;
}

message dump_request_start {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    optional uint64 duration_ns = 4; // The duration for the capture in ns
    optional string filters = 5; // Dump filters
    optional uint64 max_size = 7; // Max size
    required string token = 6; // The token associated with the request
}

message dump_request_stop {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    required string token = 4; // The token associated with the request
}

message dump_response {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    optional uint32 chunk_no = 7; // Index of the current chunk, starting from 0
    optional bool final_chunk = 8; // True if this is the last chunk
    optional bool keep_alive = 9; // True if this is a keep alive packet
    optional bytes content = 4; // The binary dump file
    optional uint64 final_size_bytes = 10; // Final size of the trace file
    optional string error = 5; // Dump errors
    required string token = 6; // The token associated with the request
}

message ssh_open_channel {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    required string token = 4; // The token associated with the request
    required string user = 5;
    optional string password = 6;
    optional string key = 7;
    optional string passphrase = 8;
    optional uint32 port = 9;
}

message ssh_data {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    required string token = 4; // The token associated with the request
    optional bytes data = 5; // Std input/output/error according to where this is sent from
    optional string error = 6;
    optional int32 exit_status = 7;
}

message ssh_close_channel {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    required string token = 4; // The token associated with the request
}

message auto_update_request {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
}

message dirty_shutdown_report {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    required string log = 4; // The log portion
}
