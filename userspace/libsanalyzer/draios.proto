package draiosproto;

option optimize_for = SPEED;
option java_package = "com.draios.model.protobuf";
option java_outer_classname = "Agent";

message counter_time {
    required uint32 count = 1;
    required uint64 time_ns = 2;
    optional uint32 time_percentage = 3;
}

message counter_time_bidirectional {
    required uint32 count_in = 1;
    required uint32 count_out = 2;
    required uint64 time_ns_in = 3;
    required uint64 time_ns_out = 4;
}

message counter_bytes {
    required uint32 count_in = 1;
    required uint32 count_out = 2;
    required uint32 bytes_in = 3;
    required uint32 bytes_out = 4;
}

message counter_time_bytes {
    required uint64 time_ns_in = 1;
    required uint64 time_ns_out = 2;
    required uint64 time_ns_other = 3;
    required uint32 count_in = 4;
    required uint32 count_out = 5;
    required uint32 count_other = 6;
    required uint32 bytes_in = 7;
    required uint32 bytes_out = 8;
    required uint32 bytes_other = 9;
    optional uint32 time_percentage_in = 10;
    optional uint32 time_percentage_out = 11;
    optional uint32 time_percentage_other = 12;
}

message time_categories {
    optional counter_time unknown = 1;
    optional counter_time other = 2;
    optional counter_time file = 3;
    optional counter_time net = 4;
    optional counter_time ipc = 5;
    optional counter_time memory = 6;
    optional counter_time process = 7;
    optional counter_time sleep = 8;
    optional counter_time system = 9;
    optional counter_time signal = 10;
    optional counter_time user = 11;
    optional counter_time time = 12;
    optional counter_time_bytes io_file = 13;
    optional counter_time_bytes io_net = 14;
    optional counter_time_bytes io_other = 15;
    optional counter_time wait = 16;
    optional counter_time processing = 17;
}

//
// Stores how time is spent serving requests by the host
//
message transaction_breakdown_categories {
    optional counter_time other = 2;
    optional counter_time_bytes io_file = 13;
    optional counter_time_bytes io_net = 14;
    optional counter_time processing = 17;
}

message counter_syscall_errors {
    required uint32 count = 1; // Syscall errors count
    repeated uint32 top_error_codes = 2; // Error codes that were generated the most
    optional uint32 count_file = 4; // Number of file errors
    optional uint32 count_file_open = 5;    // Number of file open errors
    optional uint32 count_net = 6;  // Number of network errors
}

message resource_categories {
    optional uint32 capacity_score = 1; // the request capacity score for this process or host. 0 means all the capacity is available, 10000 means that the entity (host or process) has reached the maximum mumber of requests it can serve.
    optional uint32 stolen_capacity_score = 6; // the percentage of request capacity that is not available because of CPU steal. 0 means there was no CPU steal during the sample. 100 means that all the capacity was stolen and the machine essentially couldn't run.
    optional uint32 connection_queue_usage_pct = 2; // if this process or host is serving connections, the occupation of the connection queue FOR THE WORST THREAD IN THIS PROCESS OR HOST (0=empty, 100=full)
    optional uint32 fd_usage_pct = 3; // the ratio (open FDs / total available FDs) FOR THE WORST THREAD IN THIS PROCESS OR HOST. 0 means no FD in use, 100 means FD limit reached.
    optional uint32 cpu_pct = 4; // CPU load of a process (including all the childs). Not present for the host.
    optional uint32 resident_memory_usage_kb = 5; // resident non-swapped memory (as kb).
    optional uint32 virtual_memory_usage_kb = 13; // total virtual memory (as kb). Not present for the host and container.
    optional uint32 swap_memory_usage_kb = 14; // swapped memory usage (as kb).
    optional uint64 major_pagefaults = 15; // number of major page faults since last sample.
    optional uint64 minor_pagefaults = 16; // number of minor page faults since last sample.
    optional uint32 fd_count = 21; // Total number of FDs
    optional uint32 cpu_shares = 24;
    optional uint32 cpu_shares_usage_pct = 25; // CPU % of a container in terms of the limit assigned to it
    optional uint32 memory_limit_kb = 26; // Max Resident memory allowed for a container
    optional uint32 swap_limit_kb = 27; // Max swap memory allowed for a container
    optional uint32 cpu_quota_used_pct = 28;
    optional uint32 swap_memory_total_kb = 29; // swapped memory total (as kb).
    optional uint32 swap_memory_available_kb = 30;  // swapped memory available (as kb).
    optional uint64 count_processes = 31;  // total processes
    optional uint64 proc_start_count = 32; // started processes
}

message connection_categories {
    optional counter_bytes server = 1; // client-side metrics
    optional counter_bytes client = 2; // server-side metrics
    optional counter_time_bidirectional transaction_counters = 3; // The transaction counters for this connection
    optional counter_time_bidirectional min_transaction_counters = 18; // The fastest transaction counters for this connection
    optional counter_time_bidirectional max_transaction_counters = 19; // The slowest transaction counters for this connection
    optional uint32 n_aggregated_connections = 4; // If this is an aggregated connection, the number of real connections it represents
}

message process_details {
    required string comm = 1; // Command name (e.g. "top")
    required string exe = 2; // argv[0] (e.g. "sshd: gianluca@pts/4")
    repeated string args = 3; // Command line arguments (e.g. "-d1")
    optional string container_id = 4;
}

//
// Description of a command executed on the machine
//
message command_details {
    required uint64 timestamp = 1;
    required uint32 count = 2; // How many times this command has been repeated during the sample interval
    required string cmdline = 3; // Program command line (e.g. "top -d1")
    required string exe = 4; // Full executable name (e.g. "/bin/top")
    optional string parentcomm = 5; // Name of the command that launched this one (e.g. "bash")
}

//
// Counters for a protocol-related dimension, like a URL or a query
//
message counter_proto_entry {
    required uint32 ncalls = 1;
    required uint64 time_tot = 2;
    required uint64 time_max = 3;
    required uint64 bytes_in = 4;
    required uint64 bytes_out = 5;
    required uint32 nerrors = 6;
}

//
// URL information
//
message url_details {
    //
    // The URL, in the following format "TYPEADDR<:PORT>/PATH", e.g. "p172.16.189.128:9000/api/data".
    // Note: possible values foy type are:
    //   n for NONE
    //   g for GET
    //   p for POST
    //   o for OPTIONS
    //   h for HEAD
    //   P for PUT
    //   d for DELETE
    //   t for TRACE
    //   c for CONNECT
    //
    required string url = 1; 
    required counter_proto_entry counters = 2;
}

message status_code_details {
    required uint32 status_code = 1;
    required uint32 ncalls = 2;
}

//
// HTTP protocol information
//
message http_info {
    repeated url_details server_urls = 1;
    repeated url_details client_urls = 2;
    repeated status_code_details client_status_codes = 3;
    repeated status_code_details server_status_codes = 4;
}

//
// SQL query information
//
message sql_entry_details {
    required string name = 1;
    required counter_proto_entry counters = 2;
}

//
// SQL statement information
//
enum sql_statement_type {
    SOP_NONE = 0;
    SOP_SELECT = 1;
    SOP_INSERT = 2;
    SOP_SET = 3;
    SOP_CREATE = 4;
    SOP_DELETE = 5;
    SOP_DROP = 6;
    SOP_REPLACE = 7;
    SOP_UPDATE = 8;
    SOP_USE = 9;
    SOP_SHOW = 10;
    SOP_LOCK = 11;
    SOP_UNLOCK = 12;
    SOP_ALTER = 13;
}

message sql_query_type_details {
    required sql_statement_type type = 1;
    required counter_proto_entry counters = 2;
}

//
// SQL protocol information
//
message sql_info {
    repeated sql_entry_details server_queries = 1; // the top server-side queries
    repeated sql_entry_details client_queries = 2; // the top client-side queries
    repeated sql_query_type_details server_query_types = 3; // the top server-side query types (e.g. SELECT, INSERT...)
    repeated sql_query_type_details client_query_types = 4; // the top client-side query types (e.g. SELECT, INSERT...)
    repeated sql_entry_details server_tables = 5; // the top server-side queries
    repeated sql_entry_details client_tables = 6; // the top client-side queries
}

message mongodb_collection_details {
    required string name = 1;
    required counter_proto_entry counters = 2;
}

enum mongodb_op_type {
    MONGODB_OP_NONE = 0;
    MONGODB_OP_INSERT = 1;
    MONGODB_OP_UPDATE = 2;
    MONGODB_OP_DELETE = 3;
    MONGODB_OP_GET_MORE = 4;
    MONGODB_OP_KILL_CURSORS = 5;
    MONGODB_OP_FIND = 6;
    MONGODB_OP_AGGREGATE = 7;
    MONGODB_OP_COMMAND = 8;
    MONGODB_OP_COUNT = 9;
    MONGODB_OP_DISTINCT = 10;
    MONGODB_OP_MAP_REDUCE = 11;
    MONGODB_OP_GEO_NEAR = 12;
    MONGODB_OP_GEO_SEARCH = 13;
    MONGODB_OP_FIND_AND_MODIFY = 14;
}

message mongodb_op_type_details {
    required mongodb_op_type op = 1;
    required counter_proto_entry counters = 2;
}

message mongodb_info {
    repeated mongodb_op_type_details servers_ops = 1;
    repeated mongodb_op_type_details client_ops = 2;
    repeated mongodb_collection_details server_collections = 3;
    repeated mongodb_collection_details client_collections = 4;
}

enum unit {
    UNIT_NONE = 0;
    UNIT_SECOND = 1;
    UNIT_BYTE = 2;
    UNIT_PERCENT = 3;
}

enum scale {
    SCALE_NONE = 0;

    SCALE_MILLI = 1;
    SCALE_MICRO = 2;
    SCALE_NANO = 3;
    SCALE_MINUTE = 4;
    SCALE_HOUR = 5;
    SCALE_DAY = 6;

    SCALE_KILO = 7;
    SCALE_MEGA = 8;
    SCALE_GIGA = 9;
    SCALE_TERA = 10;
    SCALE_KIBI = 11;
    SCALE_MEBI = 12;
    SCALE_GIBI = 13;
    SCALE_TEBI = 14;

    SCALE_PERCENT_0_1 = 15;
}

enum jmx_metric_type {
    JMX_METRIC_TYPE_COUNTER = 1;
    JMX_METRIC_TYPE_GAUGE = 2;
}

message jmx_attribute {
    optional string name = 1;
    optional double value = 2;
    optional string alias = 5;
    optional jmx_metric_type type = 7;
    optional unit unit = 8;
    optional scale scale = 9;
    repeated jmx_attribute subattributes = 3;
}

message jmx_bean {
    optional string name = 1;
    repeated jmx_attribute attributes = 2;
}

message java_info {
    optional string process_name = 1;
    repeated jmx_bean beans = 2;
}

enum statsd_metric_type {
    STATSD_COUNT = 1;
    STATSD_HISTOGRAM = 2;
    STATSD_GAUGE = 3;
    STATSD_SET = 4;
}

message statsd_tag {
    required string key = 1;
    optional string value = 2;
}

message statsd_metric {
    optional string name = 1;
    repeated statsd_tag tags = 2;
    optional statsd_metric_type type = 3;

    // Valid on COUNT, GAUGE and SET
    optional double value = 4;

    // Valid only on HISTOGRAM type
    optional double sum = 5;
    optional double min = 6;
    optional double max = 7;
    optional double count = 8;
    optional double median = 9;
    optional double percentile_95 = 10;
    optional double percentile_99 = 11;
}

message statsd_info {
    // May be used in the future to add metadata
    repeated statsd_metric statsd_metrics = 1;
}

enum app_metric_type {
    APP_METRIC_TYPE_GAUGE = 1;
    APP_METRIC_TYPE_RATE = 2;
}

message app_tag {
    required string key = 1;
    optional string value = 2;
}

message app_metric {
    optional string name = 1;
    optional app_metric_type type = 2;

    // Valid on GAUGE and RATE
    optional double value = 3;
    repeated app_tag tags = 4;
}

enum app_check_value {
    APP_CHECK_VALUE_OK = 0;
    APP_CHECK_VALUE_WARNING = 1;
    APP_CHECK_VALUE_CRITICAL = 2;
    APP_CHECK_VALUE_UNKNOWN = 3;
}

message app_check {
    optional string name = 1;
    optional app_check_value value = 2;
    repeated app_tag tags = 3;
}

message app_info {
    optional string process_name = 1;
    repeated app_metric metrics = 2;
    repeated app_check checks = 3;
}

//
// General protocol information
//
message proto_info {
    optional http_info http = 1;
    optional sql_info mysql = 2;
    optional sql_info postgres = 3;
    optional mongodb_info mongodb = 4;
    optional java_info java = 5; // These are not protocols but as backend is structured is better to save here these info
    optional statsd_info statsd = 6;
    optional app_info app = 7;
}

message network_by_port {
    required uint32 port = 1;
    required connection_categories counters = 2; 
}

//
// HOST
// global host info.
//
message host {
    optional string hostname = 1; // The name of the host sending the data
    optional uint32 num_cpus = 2; // Number of CPUs in the system
    repeated uint32 cpu_loads = 3; // Array of CPU loads (0 to 100), with an entry for each CPU
    repeated uint32 cpu_steal = 11; // Array of CPU loads (0 to 100), with an entry for each CPU
    required uint64 physical_memory_size_bytes = 4; // Physical RAM size
    optional time_categories tcounters = 5; // The time counters for this thread
    optional transaction_breakdown_categories reqcounters = 12; // how time is spent when serving requests
    optional counter_time_bidirectional transaction_counters = 6; // The transaction counters for the whole host
    optional counter_time_bidirectional min_transaction_counters = 22; // The fastest transaction counters for the whole host
    optional counter_time_bidirectional max_transaction_counters = 23; // The slowest transaction counters for the whole host
    optional uint64 transaction_processing_delay = 7; // the delay introduced by this host when processing transactions.
    // It's calculated by subtracting outgoing connection time from incoming connection time.
    // NEVER USED optional uint64 merged_server_delay = 14; // the total merged time of all the incoming requests.
    optional uint64 next_tiers_delay = 13; // the delay introduced by this host's next tiers when processing transactions.
    optional resource_categories resource_counters = 8; // The resource counters for this process
    optional counter_syscall_errors syscall_errors = 9; // Syscall error counter
    optional counter_time_bytes external_io_net = 10; // The I/O statistics filtered so that only the activity with the external world is used
    repeated network_by_port network_by_serverports = 24;
    repeated uint32 cpu_idle = 25;  // cpu_idle
    optional double system_load = 32; // system load
    optional uint64 uptime = 33;  // uptime to calculate the reboot
    repeated uint32 system_cpu = 34;  // system_cpu
    repeated uint32 user_cpu = 35;  // user_cpu
    optional uint64 memory_bytes_available_kb = 36;  // memory bytes available as kb
    repeated uint32 iowait_cpu = 37;  // iowait_cpu
    repeated uint32 nice_cpu = 38;  // nice_cpu
}

//
// PROCESS
// info for a process, i.e. a collection of threads.
// NOTE: this is process info only, when emitting threads, the main thread of a process will have a
// separate thread message with tid=process pid.
//
enum networkrole {
    NONE = 0; // set if this thread serves IPv4 transactions coming from the same machine.
    IS_LOCAL_IPV4_SERVER = 1; // set if this thread serves IPv4 transactions coming from the same machine.
    IS_REMOTE_IPV4_SERVER = 2; // set if this thread serves IPv4 transactions coming from another machine.
    IS_UNIX_SERVER = 4; // set if this thread serves unix transactions.
    IS_LOCAL_IPV4_CLIENT = 8; // set if this thread creates IPv4 transactions toward localhost.
    IS_REMOTE_IPV4_CLIENT = 16; // set if this thread creates IPv4 transactions toward another host.
    IS_UNIX_CLIENT = 32; // set if this thread creates unix transactions.
}

message process {
    optional process_details details = 2; // names and string constants relative to this process
    optional bool is_ipv4_transaction_server = 3; // True if this process has served at least one IPv4 transaction.
    optional bool is_unix_transaction_server = 4; // True if this process has served at least one unix transaction.
    optional bool is_ipv4_transaction_client = 10; // True if this process has been the client for at least one IPv4 transaction.
    optional bool is_unix_transaction_client = 11; // True if this process has been the client for at least one unix transaction.
    optional uint32 netrole = 13;
    optional time_categories tcounters = 5; // The time counters for this thread.
    optional counter_time_bidirectional transaction_counters = 6; // The transaction counters for this process.
    optional counter_time_bidirectional min_transaction_counters = 18; // The fastest transaction counters for this process.
    optional counter_time_bidirectional max_transaction_counters = 19; // The slowest transaction counters for this process.
    optional uint64 transaction_processing_delay = 7; // the delay introduced by this process when processing transactions.
    // It's calculated by subtracting outgoing connection time from incoming connection time.
    // NEVER USED optional uint64 merged_server_delay = 14; // the total merged time of all the incoming requests.
    optional uint64 next_tiers_delay = 12; // the delay introduced by this process' next tiers when processing transactions.
    optional resource_categories resource_counters = 8; // The resource counters for this process
    optional counter_syscall_errors syscall_errors = 9; // Syscall error counter
    optional proto_info protos = 20; // Information about protocols that have been decoded
    optional uint64 start_count = 21; // start processes
    optional uint64 count_processes = 23; // number of instances with same command line
}

//
// PROGRAM
// info for a program, i.e. a collection of processes with the same name and the same creator.
//
message program {
    required process procinfo = 1; // Inofrmation about this program
    repeated uint64 pids = 2; // The list of processes that are part of this program
}

//
// IPv4 CONNECTION
//
message ipv4tuple {
    required uint32 sip = 1;
    required uint32 dip = 2;
    required uint32 sport = 3;
    required uint32 dport = 4;
    required uint32 l4proto = 5;
}

message ipv4_connection {
    required ipv4tuple tuple = 1;

    optional uint64 spid = 2; // The pid of the client
    optional uint64 dpid = 5; // The pid of the server

    required connection_categories counters = 8; // the metrics for this connection
}

//
// NETWORK INTERFACE
//
message ipv4_network_interface {
    required string name = 1; // ifconfig entry name, e.g. eth0
    required uint32 addr = 2; // IP address
    required uint32 netmask = 3; // netmask
    optional uint32 bcast = 4; // broadcast address
}

//
// MESSAGE TYPES
//
enum message_type {
    METRICS = 1;
    DUMP_REQUEST_START = 2;
    DUMP_REQUEST_STOP = 4;
    DUMP_RESPONSE = 3;
    SSH_OPEN_CHANNEL = 6;
    SSH_CLOSE_CHANNEL = 7;
    SSH_DATA = 8;
    AUTO_UPDATE_REQUEST = 9;
    DIRTY_SHUTDOWN_REPORT = 10;
    CONFIG_DATA = 11;
}

//
// MOUNTED FILE SYSTEM
//
message mounted_fs {
    required string device = 1;
    required string mount_dir = 2;
    required string type = 3;
    required uint64 size_bytes = 4;
    required uint64 used_bytes = 5;
    required uint64 available_bytes = 6;
    optional uint64 total_inodes = 10;
    optional uint64 used_inodes = 11;
}

//
// TOP FILE STATISTICS
//
message file_stat {
    required string name = 1;
    required uint32 bytes = 2;
    required uint64 time_ns = 3;
    required uint32 open_count = 4;
    required uint32 errors = 5;
}

enum container_type {
    DOCKER = 1;
    LXC = 2;
    LIBVIRT_LXC = 3;
    MESOS = 4;
    RKT = 5;
}

message container_port_mapping {
    optional uint32 host_ip = 1;
    optional uint32 host_port = 2;
    optional uint32 container_ip = 3;
    optional uint32 container_port = 4;
}

message container_label {
    required string key = 1;
    optional string value = 2;
}

message container {
    required string id = 1;
    optional container_type type = 2;
    optional string name = 3;
    optional string image = 4;
    optional time_categories tcounters = 5; // The time counters for this thread
    optional transaction_breakdown_categories reqcounters = 6; // how time is spent when serving requests
    optional counter_time_bidirectional transaction_counters = 7; // The transaction counters for the whole host
    optional counter_time_bidirectional min_transaction_counters = 8; // The fastest transaction counters for the whole host
    optional counter_time_bidirectional max_transaction_counters = 9; // The slowest transaction counters for the whole host
    optional uint64 transaction_processing_delay = 10; // the delay introduced by this host when processing transactions.
    // It's calculated by subtracting outgoing connection time from incoming connection time.
    // NEVER USED optional uint64 merged_server_delay = 11; // the total merged time of all the incoming requests.
    optional uint64 next_tiers_delay = 12; // the delay introduced by this host's next tiers when processing transactions.
    optional resource_categories resource_counters = 13; // The resource counters for this process
    optional counter_syscall_errors syscall_errors = 14; // Syscall error counter
    repeated container_port_mapping port_mappings = 18;
    optional proto_info protos = 19;
    repeated container_label labels = 20;
    repeated mounted_fs mounts = 21;
    repeated network_by_port network_by_serverports = 22;
    optional string mesos_task_id = 23;
}

//
// KUBERNETES
//
message k8s_pair {
    required string key = 1;
    required string value = 2;
}

message k8s_common {
    required string name = 1;
    required string uid = 2;
    optional string namespace = 3;
    repeated k8s_pair labels = 4;
    repeated k8s_pair selectors = 5;
}

message k8s_namespace {
    required k8s_common common = 1;
}

message k8s_node {
    required k8s_common common = 1;
    repeated string host_ips = 2;
    // TODO pod_count
}

message k8s_pod {
    required k8s_common common = 1;
    repeated string container_ids = 2;
    optional string node_name = 3;
    optional string host_ip = 4;
    optional string internal_ip = 5;
    optional uint32 restart_count = 6;
}

message k8s_replication_controller {
    required k8s_common common = 1;
    optional uint32 replicas_desired = 2;
    optional uint32 replicas_running = 3;
}

message k8s_replica_set {
    required k8s_common common = 1;
    optional uint32 replicas_desired = 2;
    optional uint32 replicas_running = 3;
}

message k8s_service {
    message net_port {
        required uint32 port = 1;
        required uint32 target_port = 2;
        optional string protocol = 3;
        optional uint32 node_port = 4;
    }
    required k8s_common common = 1;
    optional string cluster_ip = 2;
    repeated net_port ports = 3;
}

message k8s_deployment {
    required k8s_common common = 1;
    optional uint32 replicas_desired = 2;
    optional uint32 replicas_running = 3;
}

message k8s_daemonset {
    required k8s_common common = 1;
    optional uint32 current_scheduled = 2;
    optional uint32 desired_scheduled = 3;
}

message k8s_state {
    repeated k8s_namespace namespaces = 1;
    repeated k8s_node nodes = 2;
    repeated k8s_pod pods = 3;
    repeated k8s_replication_controller controllers = 4;
    repeated k8s_service services = 5;
    repeated k8s_replica_set replica_sets = 6;
    repeated k8s_deployment deployments = 7;
    repeated k8s_daemonset daemonsets = 8;
}

//
// MESOS
//

message mesos_pair {
    required string key = 1;
    required string value = 2;
}

message mesos_common {
    required string uid = 1;
    optional string name = 2;
    repeated mesos_pair labels = 3;
}

message mesos_task {
    required mesos_common common = 1;
    required string slave_id = 2;
}

message marathon_app {
    required string id = 1;
    repeated string task_ids = 2;
}

message marathon_group {
    required string id = 1;
    repeated marathon_app apps = 2;
    repeated marathon_group groups = 3;
}

message mesos_framework {
    required mesos_common common = 1;
    repeated mesos_task tasks = 2;
}

message mesos_slave {
    required mesos_common common = 1;
}

message mesos_state {
    repeated mesos_framework frameworks = 1;
    repeated marathon_group groups = 2;
    repeated mesos_slave slaves = 3;
}

// ENTRY POINT MESSAGE
//
message metrics {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    optional uint32 sampling_ratio = 10; // The sampling ratio when subsampling. If not present, assume 1, which means no subsampling.
    optional string host_custom_name = 11; // This machines's user-set custom name for the draios map.
    optional string host_tags = 12; // This machines's user-set list of tags for the draios map.
    // NEVER USED optional string host_custom_map = 13; // This machines's user-set custom map for the draios UI.
    optional bool is_host_hidden = 14; // This machines's user-set visibility flag for the draios map.
    optional string hidden_processes = 15; // Comma-sparated list of process names that the user wants to hide in the draios map.
    optional string version = 16; // Agent/libsanalyzer/sysdig version
    optional string instance_id = 21; // AWS instance id

    optional host hostinfo = 4; // The list of processes
    repeated program programs = 9; // The list of programs
    // NEVER USED repeated process processes = 5; // The list of processes
    repeated ipv4_connection ipv4_connections = 7; // The list of IPv4 connections
    repeated ipv4_network_interface ipv4_network_interfaces = 8; // The list of the machine network interfaces
    repeated command_details commands = 17; // List of commands executed during the sample.
    repeated mounted_fs mounts = 18; // List of mounted file systems
    repeated file_stat top_files = 19; // Top files
    optional proto_info protos = 20; // Information about protocols that have been decoded
    repeated container containers = 22;
    // NEVER USED (used by back-end) repeated string machine_ids = 23; //machine IDs aggregated for this group
    optional k8s_state kubernetes = 24; // kubernetes cluster state
    optional mesos_state mesos = 25; // mesos cluster state
    repeated agent_event events = 26; // user-configured events
    optional falco_baseline falcobl = 27; // baseline information for falco
}

message dump_request_start {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    optional uint64 duration_ns = 4; // The duration for the capture in ns
    optional string filters = 5; // Dump filters
    optional uint64 max_size = 7; // Max size
    required string token = 6; // The token associated with the request
}

message dump_request_stop {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    required string token = 4; // The token associated with the request
}

message dump_response {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    optional uint32 chunk_no = 7; // Index of the current chunk, starting from 0
    optional bool final_chunk = 8; // True if this is the last chunk
    optional bool keep_alive = 9; // True if this is a keep alive packet
    optional bytes content = 4; // The binary dump file
    optional uint64 final_size_bytes = 10; // Final size of the trace file
    optional string error = 5; // Dump errors
    required string token = 6; // The token associated with the request
}

message ssh_open_channel {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    required string token = 4; // The token associated with the request
    required string user = 5;
    optional string password = 6;
    optional string key = 7;
    optional string passphrase = 8;
    optional uint32 port = 9;
}

message ssh_data {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    required string token = 4; // The token associated with the request
    optional bytes data = 5; // Std input/output/error according to where this is sent from
    optional string error = 6;
    optional int32 exit_status = 7;
}

message ssh_close_channel {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    required string token = 4; // The token associated with the request
}

message auto_update_request {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
}

message dirty_shutdown_report {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    required string log = 4; // The log portion
}

message key_value {
    required string key = 1;
    required string value = 2;
}

message agent_event {
    optional uint64 timestamp_sec = 1; // The message timestamp, in sec from epoch
    optional string scope = 2;
    optional string title = 3;
    optional string description = 4;
    optional uint32 severity = 5;
    repeated key_value tags = 6;
}

message config_file {
    optional string name = 1;
    optional string content = 2;
}

message config_data {
    repeated config_file config_files = 1;
}

//
// FALCO BASELINE
//
message falco_subcategory {
    required string name = 1;
    repeated string d = 2;
    optional bool full = 3;
}

message falco_subcategory_container {
    repeated falco_subcategory subcats = 1;
}

message falco_category {
    required string name = 1;
    repeated falco_subcategory_container startup_subcats = 2;
    repeated falco_subcategory_container regular_subcats = 3;
}

message falco_prog {
    required string comm = 1;
    required string exe = 2;
    repeated string args = 3;
    required uint64 user_id = 4;
    optional string container_id = 5;
    repeated falco_category cats = 6;
}

message falco_container {
    required string id = 1;
    required string name = 2;
    optional string image_name = 3;
    optional string image_id = 4;
}

message falco_baseline {
    repeated falco_prog progs = 1;
    repeated falco_container containers = 2;
}
