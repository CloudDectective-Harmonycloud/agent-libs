#include "secure_audit.h"

#include "common_logger.h"
#include "feature_manager.h"
#include "secure_helper.h"

#include <tuples.h>

namespace
{
COMMON_LOGGER();
const uint32_t LOCAL_IP_ADDRESS = 16777343;  // 127.0.0.1
const int DEFAULT_AUDIT_FREQUENCY_S = 10;
const uint64_t FREQUENCY_THRESHOLD_NS = 100000000;  // 100 ms

uint64_t seconds_to_ns(const int seconds)
{
	return ((uint64_t)seconds * ONE_SECOND_IN_NS);
}
}  // namespace

type_config<bool> secure_audit::c_secure_audit_executed_commands_enabled(
    false,
    "If true, secure_audit reports executed commands",
    "secure_audit_streams",
    "executed_commands");

// Per-second Per-container limit
type_config<int> secure_audit::c_secure_audit_executed_commands_per_container_limit(
    30,
    "The maximum number of executed commands that secure_audit will report per second, "
    "per-container",
    "secure_audit_streams",
    "executed_commands_per_container_limit");

type_config<bool> secure_audit::c_secure_audit_connections_enabled(
    false,
    "If true, secure_audit will report new connections",
    "secure_audit_streams",
    "connections");

type_config<bool> secure_audit::c_secure_audit_connections_local(
    false,
    "If secure audit connection monitoring is enabled and this is true, secure_audit will report "
    "loopback connections",
    "secure_audit_streams",
    "connections_local");

type_config<bool> secure_audit::c_secure_audit_connections_cmdline(
    false,
    "If true, secure_audit will enrich connections with command lines of the process starting the "
    "connection itself",
    "secure_audit_streams",
    "connections_cmdline");

type_config<int> secure_audit::c_secure_audit_connections_cmdline_maxlen(
    30,
    "If secure_audit command line reporting is enabled, the maximum length of each command line "
    "that secure_audit will report",
    "secure_audit_streams",
    "connections_cmdline_maxlen");

type_config<bool> secure_audit::c_secure_audit_connections_only_interactive(
    true,
    "If true, secure_audit will send out connections only generated by interactive shells",
    "secure_audit_streams",
    "connections_only_interactive");

type_config<bool> secure_audit::c_secure_audit_file_writes_enabled(
    false,
    "If true, secure_audit will report files opened for writing",
    "secure_audit_streams",
    "file_writes");

type_config<bool> secure_audit::c_secure_audit_file_writes_cmdline(
    false,
    "If true, secure_audit will enrich files opened for writing with command lines of the process "
    "opening them",
    "secure_audit_streams",
    "file_writes_cmdline");

type_config<bool> secure_audit::c_secure_audit_file_writes_only_interactive(
    true,
    "If true, secure_audit will send out file writes only generated by interactive shells",
    "secure_audit_streams",
    "file_writes_only_interactive");

type_config<std::vector<std::string>> secure_audit::c_secure_audit_file_writes_exclude(
    {},
    "Files to be excluded from secure audit events",
    "secure_audit_streams",
    "file_writes_exclude");

type_config<bool> secure_audit::c_secure_audit_k8s_audit_enabled(
    false,
    "If true, secure_audit will monitor k8s audit events",
    "secure_audit_streams",
    "k8s_audit");

type_config<int>::mutable_ptr secure_audit::c_secure_audit_frequency =
    type_config_builder<int>(DEFAULT_AUDIT_FREQUENCY_S,
                             "If secure audit is enabled, set the protobuf frequency in seconds (0 "
                             "means at every flush)",
                             "secure_audit_streams",
                             "frequency")
        .min(1)
        .max(30 * 60)  // 30 min
        .build_mutable();

type_config<int> secure_audit::c_secure_audit_executed_commands_limit(
    1000,
    "limit on numbers of executed commands in every message sent - 0 means no limit",
    "secure_audit_streams",
    "executed_commands_limit");

type_config<int> secure_audit::c_secure_audit_connections_limit(
    1000,
    "limit on numbers of connections in every message sent - 0 means no limit",
    "secure_audit_streams",
    "connections_limit");

type_config<int> secure_audit::c_secure_audit_file_accesses_limit(
    1000,
    "limit on numbers of file access events in every message sent - 0 means no limit",
    "secure_audit_streams",
    "file_accesses_limit");

type_config<int> secure_audit::c_secure_audit_k8s_limit(
    200,
    "limit on numbers of k8s audit in every message sent - 0 means no limit"
    "secure_audit_streams",
    "k8s_limit");

type_config<bool> secure_audit::c_audit_labels_enabled(true,
                                                       "Activity Audit Labels enabled",
                                                       "audit_labels",
                                                       "enabled");

type_config<int> secure_audit::c_audit_labels_max_agent_tags(
    30,
    "Audit Labels - Max agent tags to be considered",
    "audit_labels",
    "max_agent_tags");

type_config<std::vector<std::string>> secure_audit::c_audit_labels_include({},
                                                                           "Audit Labels included",
                                                                           "audit_labels",
                                                                           "include");

type_config<std::vector<std::string>> secure_audit::c_audit_labels_exclude({},
                                                                           "Audit Labels excluded",
                                                                           "audit_labels",
                                                                           "exclude");

const std::vector<std::string> secure_audit::BLACKLISTED_FILES({"/dev/null", "/dev/tty"});

secure_audit::secure_audit()
    : m_secure_audit_batch(new secure::Audit),
      m_get_events_interval(make_unique<run_on_interval>(seconds_to_ns(DEFAULT_AUDIT_FREQUENCY_S),
                                                         FREQUENCY_THRESHOLD_NS)),
      m_secure_audit_filter(std::make_shared<secure_audit_filter>()),
      m_executed_commands_count(0),
      m_connections_count(0),
      m_k8s_audit_count(0),
      m_file_accesses_count(0),
      m_executed_commands_dropped_count(0),
      m_connections_dropped_count(0),
      m_k8s_audit_dropped_count(0),
      m_file_accesses_dropped_count(0),
      m_connections_not_interactive_dropped_count(0),
      m_file_accesses_not_interactive_dropped_count(0),
      m_k8s_audit_enrich_errors_count(0)
{
	clear();
	configure_audit_labels_set();
}

void secure_audit::init(sinsp_ipv4_connection_manager* conn,
                        sinsp_analyzer_fd_listener* analyzer_fd_listener,
                        infrastructure_state* infra_state,
                        sinsp_configuration* configuration)
{
	m_connection_manager = conn;
	m_analyzer_fd_listener = analyzer_fd_listener;

	m_get_events_interval->interval(seconds_to_ns(c_secure_audit_frequency->get_value()));
	m_get_events_interval->threshold(FREQUENCY_THRESHOLD_NS);

	m_infra_state = infra_state;
	m_sinsp_configuration = configuration;

	if (c_secure_audit_connections_enabled.get_value())
	{
		if (m_connection_manager == nullptr)
		{
			SINSP_WARNING("secure_audit failed registering add connection callback");
			return;
		}

		// Register callback
		m_connection_manager->subscribe_on_new_tcp_connection(
		    [this](const _ipv4tuple& tuple,
		           sinsp_connection& conn,
		           sinsp_connection::state_transition transition) {
			    emit_connection_async(tuple, conn, transition);
		    });
	}

	if (c_secure_audit_file_writes_enabled.get_value())
	{
		auto file_writes_exclude_config = c_secure_audit_file_writes_exclude.get_value();
		for (auto pattern : file_writes_exclude_config)
		{
			wildcard_filter<std::string> filter(
			    false,
			    pattern,
			    [](const std::string& arg) -> const std::string& { return arg; });
			m_file_writes_exclude_filters.push_back(filter);
		}

		if (analyzer_fd_listener == nullptr)
		{
			SINSP_WARNING("secure_audit failed registering add fd listener callback");
			return;
		}

		// Register callback
		analyzer_fd_listener->subscribe_on_file_open_write(
		    [this](thread_analyzer_info* tinfo,
		           uint64_t ts,
		           const std::string& fullpath,
		           uint32_t flags) { emit_file_access_async(tinfo, ts, fullpath, flags); });
	}
}

secure_audit::~secure_audit()
{
	delete m_secure_audit_batch;
}

void secure_audit::set_data_handler(secure_audit_data_ready_handler* handler)
{
	m_audit_data_handler = handler;
}

void secure_audit::set_internal_metrics(secure_audit_internal_metrics* internal_metrics)
{
	m_audit_internal_metrics = internal_metrics;
}

const secure::Audit* secure_audit::get_events(uint64_t timestamp)
{
	if (!feature_manager::instance().get_enabled(SECURE_AUDIT))
	{
		return nullptr;
	}

	if (m_secure_audit_batch->connections_size() == 0 &&
	    m_secure_audit_batch->executed_commands_size() == 0 &&
	    m_secure_audit_batch->k8s_audits_size() == 0 &&
	    m_secure_audit_batch->file_accesses_size() == 0)
	{
		LOG_DEBUG("No secure audit messages generated");
		return nullptr;
	}
	m_secure_audit_batch->set_timestamp(timestamp);
	m_secure_audit_batch->set_hostname(sinsp_gethostname());
	return m_secure_audit_batch;
}

void secure_audit::clear()
{
	m_secure_audit_batch->Clear();
}

void secure_audit::flush(uint64_t ts)
{
	secure_audit_sent = false;
	secure_audit_run = false;

	m_get_events_interval->run(
	    [this, ts]() {
		    uint64_t flush_start_time = sinsp_utils::get_current_time_ns();
		    secure_audit_run = true;

		    auto secure_audits = get_events(ts);

		    if (secure_audits)
		    {
			    m_audit_data_handler->secure_audit_data_ready(ts, secure_audits);
			    secure_audit_sent = true;
		    }

		    clear();

		    uint64_t flush_time_ms =
		        (sinsp_utils::get_current_time_ns() - flush_start_time) / 1000000;

		    if (secure_audit_sent)
		    {
			    m_audit_internal_metrics->set_secure_audit_internal_metrics(1, flush_time_ms);
			    LOG_INFO("secure_audit: flushing fl.ms=%ld ", flush_time_ms);
		    }
		    m_audit_internal_metrics->set_secure_audit_sent_counters(
		        m_executed_commands_count,
		        m_connections_count,
		        m_k8s_audit_count,
		        m_file_accesses_count,
		        m_executed_commands_dropped_count,
		        m_connections_dropped_count,
		        m_k8s_audit_dropped_count,
		        m_file_accesses_dropped_count,
		        m_connections_not_interactive_dropped_count,
		        m_file_accesses_not_interactive_dropped_count,
		        m_k8s_audit_enrich_errors_count);
		    reset_counters();
	    },
	    ts);

	if (!secure_audit_sent)
	{
		m_audit_internal_metrics->set_secure_audit_internal_metrics(0, 0);
	}
	if (!secure_audit_run)
	{
		m_audit_internal_metrics->set_secure_audit_sent_counters(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
	}
}

void secure_audit::reset_counters()
{
	m_executed_commands_count = 0;
	m_executed_commands_dropped_count = 0;
	m_connections_count = 0;
	m_connections_dropped_count = 0;
	m_k8s_audit_count = 0;
	m_k8s_audit_dropped_count = 0;
	m_connections_not_interactive_dropped_count = 0;
	m_k8s_audit_enrich_errors_count = 0;
	m_file_accesses_count = 0;
	m_file_accesses_dropped_count = 0;
	m_file_accesses_not_interactive_dropped_count = 0;
}

secure::CommandCategory command_category_to_secure_audit_enum(draiosproto::command_category& tcat)
{
	// Explicitly converting to point out mismatches
	secure::CommandCategory cat;

	switch (tcat)
	{
	case draiosproto::CAT_NONE:
		cat = secure::CommandCategory::COMMAND_CATEGORY_NONE;
		break;
	case draiosproto::CAT_CONTAINER:
		cat = secure::CommandCategory::COMMAND_CATEGORY_CONTAINER;
		break;
	case draiosproto::CAT_HEALTHCHECK:
		cat = secure::CommandCategory::COMMAND_CATEGORY_HEALTHCHECK;
		break;
	case draiosproto::CAT_LIVENESS_PROBE:
		cat = secure::CommandCategory::COMMAND_CATEGORY_LIVENESS_PROBE;
		break;
	case draiosproto::CAT_READINESS_PROBE:
		cat = secure::CommandCategory::COMMAND_CATEGORY_READINESS_PROBE;
		break;
	default:
		LOG_ERROR("Unknown command category, using CAT_NONE");
		cat = secure::CommandCategory::COMMAND_CATEGORY_NONE;
	}

	return cat;
}

bool executed_command_cmp_secure(const sinsp_executed_command& src,
                                 const sinsp_executed_command& dst)
{
	return (src.m_ts < dst.m_ts);
}

void secure_audit::emit_commands_audit(
    std::unordered_map<std::string, std::vector<sinsp_executed_command>>* executed_commands)
{
	if (!(feature_manager::instance().get_enabled(SECURE_AUDIT) &&
	      c_secure_audit_executed_commands_enabled.get_value()))
	{
		return;
	}

	int executed_commands_size_initial = m_secure_audit_batch->executed_commands_size();

	std::unordered_map<std::string, std::vector<sinsp_executed_command>>::iterator it =
	    executed_commands->begin();

	while (it != executed_commands->end())
	{
		emit_commands_audit_item(&(it->second), it->first);
		it++;
	}

	int executed_commands_size_final = m_secure_audit_batch->executed_commands_size();

	LOG_DEBUG("secure_audit: emit commands audit (%d) - batch size (%d -> %d)",
	          executed_commands_size_final - executed_commands_size_initial,
	          executed_commands_size_initial,
	          executed_commands_size_final);
}

void secure_audit::emit_commands_audit_item(vector<sinsp_executed_command>* commands,
                                            const std::string& container_id)
{
	if (commands->size() != 0)
	{
		// when executed commands limit is reached, just discard the whole bucket of commands for
		// this container avoid to go through sort(), increment dropped count with a rough
		// estimation of commands count.
		if (c_secure_audit_executed_commands_limit.get_value() != 0 &&
		    m_executed_commands_count >= c_secure_audit_executed_commands_limit.get_value())
		{
			m_executed_commands_dropped_count += commands->size();
			return;
		}

		sort(commands->begin(), commands->end(), executed_command_cmp_secure);

		//
		// if there are too many commands, try to aggregate by command line
		//
		uint32_t cmdcnt = 0;

		vector<sinsp_executed_command>::iterator it;

		for (it = commands->begin(); it != commands->end(); ++it)
		{
			if (!(it->m_flags & sinsp_executed_command::FL_EXCLUDED))
			{
				cmdcnt++;
			}
		}

		if (c_secure_audit_executed_commands_per_container_limit.get_value() != 0 &&
		    cmdcnt > c_secure_audit_executed_commands_per_container_limit.get_value())
		{
			map<string, sinsp_executed_command*> cmdlines;

			for (it = commands->begin(); it != commands->end(); ++it)
			{
				if (!(it->m_flags & sinsp_executed_command::FL_EXCLUDED))
				{
					map<string, sinsp_executed_command*>::iterator eit =
					    cmdlines.find(it->m_cmdline);
					if (eit == cmdlines.end())
					{
						cmdlines[it->m_cmdline] = &(*it);
					}
					else
					{
						eit->second->m_count++;
						it->m_flags |= sinsp_executed_command::FL_EXCLUDED;
					}
				}
			}
		}

		//
		// if there are STILL too many commands, try to aggregate by executable
		//
		cmdcnt = 0;

		for (it = commands->begin(); it != commands->end(); ++it)
		{
			if (!(it->m_flags & sinsp_executed_command::FL_EXCLUDED))
			{
				cmdcnt++;
			}
		}

		if (c_secure_audit_executed_commands_per_container_limit.get_value() != 0 &&
		    cmdcnt > c_secure_audit_executed_commands_per_container_limit.get_value())
		{
			map<string, sinsp_executed_command*> exes;

			for (it = commands->begin(); it != commands->end(); ++it)
			{
				if (!(it->m_flags & sinsp_executed_command::FL_EXCLUDED))
				{
					map<string, sinsp_executed_command*>::iterator eit = exes.find(it->m_exe);
					if (eit == exes.end())
					{
						exes[it->m_exe] = &(*it);
						it->m_flags |= sinsp_executed_command::FL_EXEONLY;
					}
					else
					{
						eit->second->m_count += it->m_count;
						it->m_flags |= sinsp_executed_command::FL_EXCLUDED;
					}
				}
			}
		}

		cmdcnt = 0;
		for (it = commands->begin(); it != commands->end(); ++it)
		{
			if (!(it->m_flags & sinsp_executed_command::FL_EXCLUDED))
			{
				if (c_secure_audit_executed_commands_limit.get_value() != 0 &&
				    (m_executed_commands_count >=
				     c_secure_audit_executed_commands_limit.get_value()))
				{
					m_executed_commands_dropped_count++;
					continue;
				}

				if (c_secure_audit_executed_commands_per_container_limit.get_value() != 0 &&
				    cmdcnt >= c_secure_audit_executed_commands_per_container_limit.get_value())
				{
					m_executed_commands_dropped_count++;
					continue;
				}

				if (m_secure_audit_filter->discard_activity_audit_command(container_id,
				                                                          it->m_cwd,
				                                                          it->m_cmdline,
				                                                          it->m_comm,
				                                                          it->m_pid,
				                                                          it->m_ts))
				{
					LOG_TRACE(
					    "secure audit filter - discarding command - cid(%s) cwd(%s) cmdline(%s) "
					    "comm(%s) pid(%ld)",
					    container_id.c_str(),
					    it->m_cwd.c_str(),
					    it->m_cmdline.c_str(),
					    it->m_comm.c_str(),
					    (long)it->m_pid);
					continue;
				}

				auto pb_command_audit = m_secure_audit_batch->add_executed_commands();

				m_executed_commands_count++;
				cmdcnt++;
				pb_command_audit->set_timestamp(it->m_ts);
				pb_command_audit->set_count(it->m_count);
				pb_command_audit->set_login_shell_id(it->m_shell_id);
				pb_command_audit->set_login_shell_distance(it->m_login_shell_distance);
				pb_command_audit->set_comm(it->m_comm);
				pb_command_audit->set_pid(it->m_pid);
				pb_command_audit->set_ppid(it->m_ppid);
				pb_command_audit->set_uid(it->m_uid);
				pb_command_audit->set_cwd(it->m_cwd);
				pb_command_audit->set_tty(it->m_tty);

				pb_command_audit->set_category(
				    command_category_to_secure_audit_enum(it->m_category));

				pb_command_audit->set_container_id(container_id);

				if (it->m_flags & sinsp_executed_command::FL_EXEONLY)
				{
					pb_command_audit->set_cmdline(it->m_exe);
				}
				else
				{
					pb_command_audit->set_cmdline(it->m_cmdline);
				}

				if (c_audit_labels_enabled.get_value())
				{
					set_audit_labels(pb_command_audit->container_id(),
					                 pb_command_audit->mutable_audit_labels());
				}
			}
		}
	}
}

secure::ConnectionStatus connection_status(int errorcode)
{
	return errorcode == 0 ? secure::ConnectionStatus::CONNECTION_STATUS_ESTABLISHED
	                      : secure::ConnectionStatus::CONNECTION_STATUS_FAILED;
}

void secure_audit::append_connection(connection_type type,
                                     const sinsp_connection::state_transition transition,
                                     const _ipv4tuple& tuple,
                                     sinsp_connection& conn)
{
	// Avoid to emit local connections (src or dst 127.0.0.1)
	if (!c_secure_audit_connections_local.get_value() &&
	    (tuple.m_fields.m_sip == LOCAL_IP_ADDRESS || tuple.m_fields.m_dip == LOCAL_IP_ADDRESS))
	{
		return;
	}

	thread_analyzer_info* tinfo = nullptr;
	if (type == connection_type::SRC)
	{
		tinfo = dynamic_cast<thread_analyzer_info*>(conn.m_sproc.get()->get_main_thread());
	}
	else
	{
		tinfo = dynamic_cast<thread_analyzer_info*>(conn.m_dproc.get()->get_main_thread());
	}

	if (c_secure_audit_connections_only_interactive.get_value())
	{
		if (tinfo == nullptr)
		{
			return;
		}

		if ((tinfo != nullptr) && (!(tinfo->m_th_analysis_flags &
		                             thread_analyzer_info::flags::AF_IS_INTERACTIVE_COMMAND)))
		{
			m_connections_not_interactive_dropped_count++;
			return;
		}
	}

	secure::ConnectionStatus conn_status = connection_status(transition.error_code);

	if (!secure_helper::is_valid_tuple(tuple))
	{
		return;
	}

	if (type == connection_type::SRC)
	{
		if (m_secure_audit_filter->discard_activity_audit_connection(
		        conn.m_sproc.get()->m_container_id,
		        conn.m_sproc->get_comm(),
		        conn.m_spid,
		        transition.timestamp))
		{
			LOG_TRACE(
			    "secure audit filter - discarding connection - cid(%s) proc(%s) pid(%ld) ts(%ld)",
			    conn.m_sproc.get()->m_container_id.c_str(),
			    conn.m_sproc->get_comm().c_str(),
			    (long)conn.m_spid,
			    (long)transition.timestamp);
			return;
		}
	}
	if (type == connection_type::DST)
	{
		if (m_secure_audit_filter->discard_activity_audit_connection(
		        conn.m_dproc.get()->m_container_id,
		        conn.m_dproc->get_comm(),
		        conn.m_dpid,
		        transition.timestamp))
		{
			LOG_TRACE(
			    "secure audit filter - discarding connection - cid(%s) proc(%s) pid(%ld) ts(%ld)",
			    conn.m_dproc.get()->m_container_id.c_str(),
			    conn.m_dproc->get_comm().c_str(),
			    (long)conn.m_dpid,
			    (long)transition.timestamp);
			return;
		}
	}

	auto pb_conn = m_secure_audit_batch->add_connections();

	m_connections_count++;

	pb_conn->set_client_ipv4(ntohl(tuple.m_fields.m_sip));
	pb_conn->set_client_port(tuple.m_fields.m_sport);

	pb_conn->set_l4_protocol(secure_helper::scap_l4_to_ip_l4(tuple.m_fields.m_l4proto));

	pb_conn->set_server_ipv4(ntohl(tuple.m_fields.m_dip));
	pb_conn->set_server_port(tuple.m_fields.m_dport);

	pb_conn->set_status(conn_status);
	pb_conn->set_error_code(transition.error_code);
	pb_conn->set_timestamp(transition.timestamp);

	std::string cmdline;

	if (type == connection_type::SRC)
	{
		pb_conn->set_client_pid(conn.m_spid);

		if (conn.m_sproc != nullptr)
		{
			pb_conn->set_comm(conn.m_sproc->get_comm());
			pb_conn->set_tty(conn.m_sproc->m_tty);
			pb_conn->set_container_id(conn.m_sproc.get()->m_container_id);
			if (c_secure_audit_connections_cmdline.get_value())
			{
				sinsp_threadinfo::populate_cmdline(cmdline, conn.m_sproc.get());
			}
		}
	}
	else if (type == connection_type::DST)
	{
		pb_conn->set_server_pid(conn.m_dpid);

		if (conn.m_dproc != nullptr)
		{
			pb_conn->set_comm(conn.m_dproc->get_comm());
			pb_conn->set_tty(conn.m_dproc->m_tty);
			pb_conn->set_container_id(conn.m_dproc.get()->m_container_id);
			if (c_secure_audit_connections_cmdline.get_value())
			{
				sinsp_threadinfo::populate_cmdline(cmdline, conn.m_dproc.get());
			}
		}
	}

	if (c_secure_audit_connections_cmdline.get_value() && !cmdline.empty())
	{
		if (c_secure_audit_connections_cmdline_maxlen.get_value() != 0 &&
		    cmdline.length() > c_secure_audit_connections_cmdline_maxlen.get_value())
		{
			cmdline.resize(c_secure_audit_connections_cmdline_maxlen.get_value());
		}
		pb_conn->set_cmdline(cmdline);
	}

	if (c_audit_labels_enabled.get_value())
	{
		set_audit_labels(pb_conn->container_id(), pb_conn->mutable_audit_labels());
	}
}

void secure_audit::emit_connection_async(const _ipv4tuple& tuple,
                                         sinsp_connection& conn,
                                         sinsp_connection::state_transition transition)
{
	if (!(feature_manager::instance().get_enabled(SECURE_AUDIT) &&
	      c_secure_audit_connections_enabled.get_value()))
	{
		return;
	}

	if (c_secure_audit_connections_limit.get_value() != 0 &&
	    (m_connections_count >= c_secure_audit_connections_limit.get_value()))
	{
		m_connections_dropped_count++;
		return;
	}

	// If client_and_server connection, consider it as a server_only
	// A client_only connection should already been processed first, so metadata (pid, comm,
	// container) related to client side should already been emitted
	if (conn.is_client_and_server())
	{
		append_connection(connection_type::DST, transition, tuple, conn);
	}
	else
	{
		if (conn.is_client_only())
		{
			append_connection(connection_type::SRC, transition, tuple, conn);
		}
		if (conn.is_server_only())
		{
			append_connection(connection_type::DST, transition, tuple, conn);
		}
	}
}

void secure_audit::emit_file_access_async(thread_analyzer_info* tinfo,
                                          uint64_t ts,
                                          const std::string& fullpath,
                                          uint32_t flags)
{
	if (!feature_manager::instance().get_enabled(SECURE_AUDIT) ||
	    !c_secure_audit_file_writes_enabled.get_value())
	{
		return;
	}

	if (c_secure_audit_file_accesses_limit.get_value() != 0 &&
	    (m_file_accesses_count >= c_secure_audit_file_accesses_limit.get_value()))
	{
		m_file_accesses_dropped_count++;
		return;
	}

	if (c_secure_audit_file_writes_only_interactive.get_value())
	{
		if (tinfo == nullptr)
		{
			return;
		}

		if (!(tinfo->m_th_analysis_flags & thread_analyzer_info::flags::AF_IS_INTERACTIVE_COMMAND))
		{
			m_file_accesses_not_interactive_dropped_count++;
			return;
		}
	}

	if (std::find(secure_audit::BLACKLISTED_FILES.begin(),
	              secure_audit::BLACKLISTED_FILES.end(),
	              fullpath) != secure_audit::BLACKLISTED_FILES.end())
	{
		return;
	}

	auto idx = fullpath.find_last_of('/');
	if (idx == std::string::npos)
	{
		// invalid file name
		return;
	}

	auto file_writes_exclude = c_secure_audit_file_writes_exclude.get_value();
	bool filter_out_exclude = true;
	bool filter_out_high_priority = false;
	for (auto filter : m_file_writes_exclude_filters)
	{
		if (filter.matches(fullpath, filter_out_exclude, filter_out_high_priority, nullptr))
		{
			return;
		}
	}

	auto file_name = fullpath.substr(idx + 1);
	auto directory = fullpath.substr(0, idx) + "/";

	std::string permissions;
	if (flags & PPM_O_RDONLY)
	{
		permissions = permissions + "r";
	}

	if (flags & PPM_O_WRONLY)
	{
		permissions = permissions + "w";
	}

	if (m_secure_audit_filter->discard_activity_audit_file(tinfo->m_container_id,
	                                                       tinfo->get_comm(),
	                                                       tinfo->m_pid,
	                                                       ts))
	{
		LOG_TRACE("secure audit filter - discarding file - cid(%s) proc(%s) pid(%ld) ts(%ld)",
		          tinfo->m_container_id.c_str(),
		          tinfo->get_comm().c_str(),
		          (long)tinfo->m_pid,
		          (long)ts);
		return;
	}

	auto pb_file = m_secure_audit_batch->add_file_accesses();

	pb_file->set_directory(directory);
	pb_file->set_file_name(file_name);
	pb_file->set_permissions(permissions);
	pb_file->set_pid(tinfo->m_pid);
	pb_file->set_timestamp(ts);
	pb_file->set_comm(tinfo->get_comm());
	pb_file->set_container_id(tinfo->m_container_id);
	pb_file->set_tty(tinfo->m_tty);

	if (c_secure_audit_file_writes_cmdline.get_value())
	{
		std::string cmdline;
		sinsp_threadinfo::populate_cmdline(cmdline, tinfo);
		if (!cmdline.empty())
		{
			pb_file->set_cmdline(cmdline);
		}
	}

	if (c_audit_labels_enabled.get_value())
	{
		set_audit_labels(pb_file->container_id(), pb_file->mutable_audit_labels());
	}

	m_file_accesses_count++;
}

void secure_audit::filter_and_append_k8s_audit(
    const nlohmann::json& j,
    std::vector<std::string>& k8s_active_filters,
    std::unordered_map<std::string, std::unordered_map<std::string, std::string>>& k8s_filters,
    infrastructure_state* infra_state)
{
	if (!(feature_manager::instance().get_enabled(SECURE_AUDIT) &&
	      c_secure_audit_k8s_audit_enabled.get_value()))
	{
		return;
	}

	if (filter_k8s_audit(j, k8s_active_filters, k8s_filters))
	{
		if (c_secure_audit_k8s_limit.get_value() != 0 &&
		    (m_k8s_audit_count > c_secure_audit_k8s_limit.get_value()))
		{
			m_k8s_audit_dropped_count++;
			return;
		}

		auto pb_k8s_audit = m_secure_audit_batch->add_k8s_audits();
		pb_k8s_audit->set_blob(j.dump());

		bool ok = infra_state != nullptr;
		try
		{
			nlohmann::json::json_pointer r_jptr("/objectRef/resource");
			if (ok && j.at(r_jptr) == "pods")
			{
				// if the object of this audit event is a pod,
				// get its container.id and host.hostName
				// from infrastructure state
				nlohmann::json::json_pointer ns_jptr("/objectRef/namespace"),
				    n_jptr("/objectRef/name");
				std::string pod_uid = infra_state->get_k8s_pod_uid(j.at(ns_jptr), j.at(n_jptr));
				if ((ok = !pod_uid.empty()))
				{
					// hostname retrieval
					std::string hostname;
					infrastructure_state::uid_t uid = make_pair("k8s_pod", pod_uid);

					ok &= infra_state->find_tag(uid, "host.hostName", hostname);

					pb_k8s_audit->set_hostname(hostname);

					// containerID retrieval from the pod container name

					// sadly we have to parse the pod container name from the requestURI,
					// there's no other way to retrieve it from the audit event
					nlohmann::json::json_pointer req_jptr("/requestURI");
					std::string requestURI = j.at(req_jptr);

					std::size_t pos = requestURI.find("container=");
					if (pos != std::string::npos)
					{
						std::string pod_container_name =
						    requestURI.substr(pos - 1 + sizeof("container="));
						pos = pod_container_name.find("&");
						if (pos != std::string::npos)
						{
							pod_container_name.resize(pos);
						}

						std::string container_id =
						    infra_state->get_container_id_from_k8s_pod_and_k8s_pod_name(
						        uid,
						        pod_container_name);
						pb_k8s_audit->set_container_id(container_id);
						ok &= !container_id.empty();
						if (ok && c_audit_labels_enabled.get_value())
						{
							set_audit_labels(pb_k8s_audit->container_id(),
							                 pb_k8s_audit->mutable_audit_labels());
						}
					}
				}
			}
		}
		catch (nlohmann::json::out_of_range&)
		{
			// nothing we can do here, container ID and/or hostname will be empty
			ok = false;
		}

		if (!ok)
		{
			m_k8s_audit_enrich_errors_count++;
		}

		m_k8s_audit_count++;
	}
}

bool secure_audit::filter_k8s_audit(
    const nlohmann::json& j,
    std::vector<std::string>& k8s_active_filters,
    std::unordered_map<std::string, std::unordered_map<std::string, std::string>>& k8s_filters)
{
	// Iterate over active filters
	for (auto active_filter : k8s_active_filters)
	{
		// For each filter do not match and break if at least one condition is not matched
		bool all_matched = true;

		// If filter has at least one field consider the filter valid
		if (k8s_filters[active_filter].size() == 0)
		{
			all_matched = false;
		}

		for (auto filter_item : k8s_filters[active_filter])
		{
			try
			{
				nlohmann::json::json_pointer jptr(filter_item.first);

				if (j.at(jptr) != filter_item.second)
				{
					all_matched = false;
					break;
				}
			}
			catch (nlohmann::json::out_of_range&)
			{
				all_matched = false;
				break;
			}
		}

		if (all_matched)
		{
			return true;
		}
	}

	return false;
}

void secure_audit::set_audit_labels(const std::string& container_id,
                                    google::protobuf::Map<std::string, std::string>* audit_labels)
{
	// Host Name
	set_audit_label(audit_labels, "host.hostName", sinsp_gethostname());

	if (m_sinsp_configuration != nullptr)
	{
		// AWS Instance ID
		set_audit_label(audit_labels, "aws.instanceId", m_sinsp_configuration->get_instance_id());

		// AWS Account ID
		set_audit_label(audit_labels, "aws.accountId", m_sinsp_configuration->get_account_id());

		// AWS Region
		set_audit_label(audit_labels, "aws.region", m_sinsp_configuration->get_region());
	}

	// Agent Tags
	if (m_audit_labels.find("agent.tag") != m_audit_labels.end())
	{
		std::vector<std::string> tags = sinsp_split(
		    configuration_manager::instance().get_config<std::string>("tags")->get_value(),
		    ',');

		std::string tag_prefix = "agent.tag.";

		int count_tags = 0;
		for (auto& pair : tags)
		{
			if (count_tags >= c_audit_labels_max_agent_tags.get_value())
			{
				break;
			}
			// tags are available in pair in the format key:value
			// in case of multiple ":" are found the first one will be considered the separator
			// between key and value
			auto found = pair.find(":");

			if (found != std::string::npos)
			{
				auto tag_key = pair.substr(0, found);
				// Do not include hardcoded "sysdig_secure.enabled" tag
				if (tag_key != "sysdig_secure.enabled")
				{
					auto tag_value = pair.substr(found + 1, std::string::npos);
					(*audit_labels)[tag_prefix + tag_key] = tag_value;
					count_tags++;
				}
			}
		}
	}

	// Infrastructure Lookup for Kubernetes Labels
	infrastructure_state::uid_t uid;
	uid = std::make_pair("container", container_id);

	std::unordered_map<std::string, std::string> event_labels;
	if (m_infra_state != nullptr)
	{
		m_infra_state->find_tag_list(uid, m_audit_labels, event_labels);

		for (auto& it : event_labels)
		{
			(*audit_labels)[it.first] = std::move(it.second);
		}

		// Kubernetes Cluster Name
		if (m_audit_labels.find("kubernetes.cluster.name") != m_audit_labels.end())
		{
			// kubernetes.cluster.name should be pushed only if the event is related to k8s
			// Use Pod Name label to check it
			if (event_labels.find("kubernetes.pod.name") != event_labels.end())
			{
				set_audit_label(audit_labels,
				                "kubernetes.cluster.name",
				                m_infra_state->get_k8s_cluster_name());
			}
		}
	}
}

void secure_audit::set_audit_label(google::protobuf::Map<std::string, std::string>* audit_labels,
                                   std::string key,
                                   std::string value)
{
	if (m_audit_labels.find(key) != m_audit_labels.end())
	{
		if (!value.empty())
		{
			(*audit_labels)[key] = value;
		}
	}
}

// the list of audit labels comes pre-populated with a default set of labels.
// it's possible to add additional labels to the list through the include list.
// it's also possible to remove some of the pre-configured labels with the exclude list.
// if a key is present in both include and exclude lists, exclude it
void secure_audit::configure_audit_labels_set()
{
	for (const auto& s : c_audit_labels_include.get_value())
	{
		m_audit_labels.insert(s);
	}
	for (const auto& s : c_audit_labels_exclude.get_value())
	{
		m_audit_labels.erase(s);
	}
}