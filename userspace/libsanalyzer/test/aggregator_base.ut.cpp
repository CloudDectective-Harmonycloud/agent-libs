#include <gtest.h>

#include <fstream>
#include <iostream>

#include "aggregator_limits.h"
#include "aggregator_overrides.h"
#include "draios.pb.h"
#include "draios.proto.h"

// The purpose of this suite of tests is NOT to test any specific message, but test
// that instances of each "type" of aggregation generated by the generator actually works
// right. Individual messages are validated in another test. In a perfect world, we have
// a dummy protobuf that explicitly does all these things, but that's a bit annoying to make.
TEST(aggregator_base, single_numeric_aggregated)
{
	message_aggregator_builder_impl builder;
	counter_time_message_aggregator aggregator(builder);

	auto input = new draiosproto::counter_time();
	auto output = new draiosproto::counter_time();

	input->set_count(4);
	aggregator.aggregate(*input, *output, false);
	EXPECT_EQ(output->aggr_count().max(), 4);
	EXPECT_EQ(output->aggr_count().min(), 4);
	EXPECT_EQ(output->aggr_count().sum(), 4);
	EXPECT_EQ(output->aggr_count().weight(), 1);
	EXPECT_EQ(output->count(), 0);

	input->set_count(100);
	aggregator.aggregate(*input, *output, false);
	EXPECT_EQ(output->aggr_count().max(), 100);
	EXPECT_EQ(output->aggr_count().min(), 4);
	EXPECT_EQ(output->aggr_count().sum(), 104);
	EXPECT_EQ(output->aggr_count().weight(), 2);

	// test that we don't have bogus references
	delete input;
	EXPECT_EQ(output->aggr_count().max(), 100);
	EXPECT_EQ(output->aggr_count().min(), 4);
	EXPECT_EQ(output->aggr_count().sum(), 104);
	EXPECT_EQ(output->aggr_count().weight(), 2);

	delete output;
}

TEST(aggregator_base, single_numeric_aggregated_in_place)
{
	message_aggregator_builder_impl builder;
	counter_time_message_aggregator aggregator(builder);

	auto output = new draiosproto::counter_time();

	output->set_count(4);
	aggregator.aggregate(*output, *output, true);
	EXPECT_EQ(output->aggr_count().max(), 4);
	EXPECT_EQ(output->aggr_count().min(), 4);
	EXPECT_EQ(output->aggr_count().sum(), 4);
	EXPECT_EQ(output->aggr_count().weight(), 1);
	EXPECT_EQ(output->count(), 0);

	delete output;
}

TEST(aggregator_base, repeated_numeric_aggregated)
{
	message_aggregator_builder_impl builder;
	host_message_aggregator aggregator(builder);

	auto input = new draiosproto::host();
	auto output = new draiosproto::host();

	input->add_cpu_loads(3);
	input->add_cpu_loads(4);
	aggregator.aggregate(*input, *output, false);
	EXPECT_EQ(output->aggr_cpu_loads().sum()[0], 3);
	EXPECT_EQ(output->aggr_cpu_loads().min()[0], 3);
	EXPECT_EQ(output->aggr_cpu_loads().max()[0], 3);
	EXPECT_EQ(output->aggr_cpu_loads().sum()[1], 4);
	EXPECT_EQ(output->aggr_cpu_loads().min()[1], 4);
	EXPECT_EQ(output->aggr_cpu_loads().max()[1], 4);
	EXPECT_EQ(output->aggr_cpu_loads().weight(), 1);
	EXPECT_EQ(output->cpu_loads().size(), 0);

	auto input2 = new draiosproto::host();
	input2->add_cpu_loads(100);
	input2->add_cpu_loads(200);
	aggregator.aggregate(*input2, *output, false);
	EXPECT_EQ(output->aggr_cpu_loads().sum()[0], 103);
	EXPECT_EQ(output->aggr_cpu_loads().min()[0], 3);
	EXPECT_EQ(output->aggr_cpu_loads().max()[0], 100);
	EXPECT_EQ(output->aggr_cpu_loads().sum()[1], 204);
	EXPECT_EQ(output->aggr_cpu_loads().min()[1], 4);
	EXPECT_EQ(output->aggr_cpu_loads().max()[1], 200);
	EXPECT_EQ(output->aggr_cpu_loads().weight(), 2);

	delete input;
	delete input2;
	EXPECT_EQ(output->aggr_cpu_loads().sum()[0], 103);
	EXPECT_EQ(output->aggr_cpu_loads().min()[0], 3);
	EXPECT_EQ(output->aggr_cpu_loads().max()[0], 100);
	EXPECT_EQ(output->aggr_cpu_loads().sum()[1], 204);
	EXPECT_EQ(output->aggr_cpu_loads().min()[1], 4);
	EXPECT_EQ(output->aggr_cpu_loads().max()[1], 200);
	EXPECT_EQ(output->aggr_cpu_loads().weight(), 2);

	delete output;
}

TEST(aggregator_base, repeated_numeric_aggregated_in_place)
{
	message_aggregator_builder_impl builder;
	host_message_aggregator aggregator(builder);

	auto output = new draiosproto::host();

	output->add_cpu_loads(3);
	output->add_cpu_loads(4);
	aggregator.aggregate(*output, *output, true);
	EXPECT_EQ(output->aggr_cpu_loads().sum()[0], 3);
	EXPECT_EQ(output->aggr_cpu_loads().min()[0], 3);
	EXPECT_EQ(output->aggr_cpu_loads().max()[0], 3);
	EXPECT_EQ(output->aggr_cpu_loads().sum()[1], 4);
	EXPECT_EQ(output->aggr_cpu_loads().min()[1], 4);
	EXPECT_EQ(output->aggr_cpu_loads().max()[1], 4);
	EXPECT_EQ(output->aggr_cpu_loads().weight(), 1);
	EXPECT_EQ(output->cpu_loads().size(), 0);

	delete output;
}

TEST(aggregator_base, single_message)
{
	message_aggregator_builder_impl builder;
	time_categories_message_aggregator aggregator(builder);

	auto input = new draiosproto::time_categories();
	auto output = new draiosproto::time_categories();

	input->mutable_unknown()->set_count(5);
	aggregator.aggregate(*input, *output, false);
	EXPECT_EQ(output->unknown().aggr_count().weight(), 1);

	auto input2 = new draiosproto::time_categories();
	input2->mutable_unknown()->set_count(5);
	aggregator.aggregate(*input2, *output, false);
	EXPECT_EQ(output->unknown().aggr_count().weight(), 2);

	delete input;
	delete input2;
	EXPECT_EQ(output->unknown().aggr_count().weight(), 2);

	delete output;
}

TEST(aggregator_base, single_message_in_place)
{
	message_aggregator_builder_impl builder;
	time_categories_message_aggregator aggregator(builder);

	auto output = new draiosproto::time_categories();

	output->mutable_unknown()->set_count(5);
	aggregator.aggregate(*output, *output, true);
	EXPECT_EQ(output->unknown().aggr_count().weight(), 1);
	EXPECT_EQ(output->unknown().count(), 0);  // double check that in_place got forwarded

	delete output;
}

TEST(aggregator_base, repeated_numeric)
{
	message_aggregator_builder_impl builder;
	counter_syscall_errors_message_aggregator aggregator(builder);

	auto input = new draiosproto::counter_syscall_errors();
	auto output = new draiosproto::counter_syscall_errors();

	input->add_top_error_codes(5);
	input->add_top_error_codes(2);
	aggregator.aggregate(*input, *output, false);
	EXPECT_EQ(output->top_error_codes().size(), 2);
	EXPECT_EQ(output->top_error_codes()[0], 5);
	EXPECT_EQ(output->top_error_codes()[1], 2);

	auto input2 = new draiosproto::counter_syscall_errors();
	input2->add_top_error_codes(2);
	input2->add_top_error_codes(1);
	input2->add_top_error_codes(5);
	aggregator.aggregate(*input2, *output, false);
	EXPECT_EQ(output->top_error_codes().size(), 3);
	EXPECT_EQ(output->top_error_codes()[0], 5);
	EXPECT_EQ(output->top_error_codes()[1], 2);
	EXPECT_EQ(output->top_error_codes()[2], 1);

	delete input;
	delete input2;
	EXPECT_EQ(output->top_error_codes().size(), 3);
	EXPECT_EQ(output->top_error_codes()[0], 5);
	EXPECT_EQ(output->top_error_codes()[1], 2);
	EXPECT_EQ(output->top_error_codes()[2], 1);

	delete output;

	// double check that we still work after reset
	// If it is not reset properly, this might block
	// the addition of a previously added element
	aggregator.reset();
	input = new draiosproto::counter_syscall_errors();
	output = new draiosproto::counter_syscall_errors();
	input->add_top_error_codes(5);
	aggregator.aggregate(*input, *output, false);
	EXPECT_EQ(output->top_error_codes().size(), 1);
	EXPECT_EQ(output->top_error_codes()[0], 5);
	delete input;
	delete output;
}

TEST(aggregator_base, repeated_numeric_in_place)
{
	message_aggregator_builder_impl builder;
	counter_syscall_errors_message_aggregator aggregator(builder);

	auto output = new draiosproto::counter_syscall_errors();

	output->add_top_error_codes(5);
	output->add_top_error_codes(2);
	aggregator.aggregate(*output, *output, true);
	EXPECT_EQ(output->top_error_codes().size(), 2);
	EXPECT_EQ(output->top_error_codes()[0], 5);
	EXPECT_EQ(output->top_error_codes()[1], 2);

	output->clear_top_error_codes();
	aggregator.reset();

	// entire list the same
	output->add_top_error_codes(5);
	output->add_top_error_codes(5);
	output->add_top_error_codes(5);
	aggregator.aggregate(*output, *output, true);
	EXPECT_EQ(output->top_error_codes().size(), 1);
	EXPECT_EQ(output->top_error_codes()[0], 5);

	output->clear_top_error_codes();
	aggregator.reset();

	// duplicate entries at head of list
	output->add_top_error_codes(5);
	output->add_top_error_codes(5);
	output->add_top_error_codes(2);
	aggregator.aggregate(*output, *output, true);
	EXPECT_EQ(output->top_error_codes().size(), 2);
	EXPECT_EQ(output->top_error_codes()[0], 5);
	EXPECT_EQ(output->top_error_codes()[1], 2);

	output->clear_top_error_codes();
	aggregator.reset();

	// duplicate entries at tail of list
	output->add_top_error_codes(5);
	output->add_top_error_codes(2);
	output->add_top_error_codes(2);
	aggregator.aggregate(*output, *output, true);
	EXPECT_EQ(output->top_error_codes().size(), 2);
	EXPECT_EQ(output->top_error_codes()[0], 5);
	EXPECT_EQ(output->top_error_codes()[1], 2);

	output->clear_top_error_codes();
	aggregator.reset();

	// duplicate entries in middle of list
	output->add_top_error_codes(5);
	output->add_top_error_codes(2);
	output->add_top_error_codes(2);
	output->add_top_error_codes(7);
	aggregator.aggregate(*output, *output, true);
	EXPECT_EQ(output->top_error_codes().size(), 3);
	EXPECT_EQ(output->top_error_codes()[0], 5);
	EXPECT_EQ(output->top_error_codes()[1], 2);
	EXPECT_EQ(output->top_error_codes()[2], 7);

	output->clear_top_error_codes();
	aggregator.reset();

	// multiple duplicate entries
	output->add_top_error_codes(5);
	output->add_top_error_codes(5);
	output->add_top_error_codes(2);
	output->add_top_error_codes(2);
	output->add_top_error_codes(7);
	output->add_top_error_codes(7);
	aggregator.aggregate(*output, *output, true);
	EXPECT_EQ(output->top_error_codes().size(), 3);
	EXPECT_EQ(output->top_error_codes()[0], 5);
	EXPECT_EQ(output->top_error_codes()[1], 7);
	EXPECT_EQ(output->top_error_codes()[2], 2);

	// aggregation into previous-in-place output buffer works as expected
	auto input = new draiosproto::counter_syscall_errors();
	input->add_top_error_codes(7);
	input->add_top_error_codes(2);
	input->add_top_error_codes(9);
	input->add_top_error_codes(5);
	aggregator.aggregate(*input, *output, false);
	EXPECT_EQ(output->top_error_codes().size(), 4);
	EXPECT_EQ(output->top_error_codes()[0], 5);
	EXPECT_EQ(output->top_error_codes()[1], 7);
	EXPECT_EQ(output->top_error_codes()[2], 2);
	EXPECT_EQ(output->top_error_codes()[3], 9);

	delete input;
	EXPECT_EQ(output->top_error_codes().size(), 4);
	EXPECT_EQ(output->top_error_codes()[0], 5);
	EXPECT_EQ(output->top_error_codes()[1], 7);
	EXPECT_EQ(output->top_error_codes()[2], 2);
	EXPECT_EQ(output->top_error_codes()[3], 9);

	delete output;
}

TEST(aggregator_base, repeated_string)
{
	message_aggregator_builder_impl builder;
	marathon_app_message_aggregator aggregator(builder);

	auto input = new draiosproto::marathon_app();
	auto output = new draiosproto::marathon_app();

	input->add_task_ids("5");
	input->add_task_ids("2");
	aggregator.aggregate(*input, *output, false);
	EXPECT_EQ(output->task_ids().size(), 2);
	EXPECT_EQ(output->task_ids()[0], "5");
	EXPECT_EQ(output->task_ids()[1], "2");

	auto input2 = new draiosproto::marathon_app();
	input2->add_task_ids("2");
	input2->add_task_ids("1");
	input2->add_task_ids("5");
	aggregator.aggregate(*input2, *output, false);
	EXPECT_EQ(output->task_ids().size(), 3);
	EXPECT_EQ(output->task_ids()[0], "5");
	EXPECT_EQ(output->task_ids()[1], "2");
	EXPECT_EQ(output->task_ids()[2], "1");

	delete input;
	delete input2;
	EXPECT_EQ(output->task_ids().size(), 3);
	EXPECT_EQ(output->task_ids()[0], "5");
	EXPECT_EQ(output->task_ids()[1], "2");
	EXPECT_EQ(output->task_ids()[2], "1");

	delete output;

	// double check that we still work after reset
	// If it is not reset properly, this might block
	// the addition of a previously added element
	aggregator.reset();
	input = new draiosproto::marathon_app();
	output = new draiosproto::marathon_app();
	input->add_task_ids("5");
	aggregator.aggregate(*input, *output, false);
	EXPECT_EQ(output->task_ids().size(), 1);
	EXPECT_EQ(output->task_ids()[0], "5");
	delete input;
	delete output;
}

TEST(aggregator_base, repeated_string_in_place)
{
	message_aggregator_builder_impl builder;
	marathon_app_message_aggregator aggregator(builder);

	auto output = new draiosproto::marathon_app();

	output->add_task_ids("5");
	output->add_task_ids("2");
	aggregator.aggregate(*output, *output, true);
	EXPECT_EQ(output->task_ids().size(), 2);
	EXPECT_EQ(output->task_ids()[0], "5");
	EXPECT_EQ(output->task_ids()[1], "2");

	output->clear_task_ids();
	aggregator.reset();

	// entire list the same
	output->add_task_ids("5");
	output->add_task_ids("5");
	output->add_task_ids("5");
	aggregator.aggregate(*output, *output, true);
	EXPECT_EQ(output->task_ids().size(), 1);
	EXPECT_EQ(output->task_ids()[0], "5");

	output->clear_task_ids();
	aggregator.reset();

	// duplicate entries at head of list
	output->add_task_ids("5");
	output->add_task_ids("5");
	output->add_task_ids("2");
	aggregator.aggregate(*output, *output, true);
	EXPECT_EQ(output->task_ids().size(), 2);
	EXPECT_EQ(output->task_ids()[0], "5");
	EXPECT_EQ(output->task_ids()[1], "2");

	output->clear_task_ids();
	aggregator.reset();

	// duplicate entries at tail of list
	output->add_task_ids("5");
	output->add_task_ids("2");
	output->add_task_ids("2");
	aggregator.aggregate(*output, *output, true);
	EXPECT_EQ(output->task_ids().size(), 2);
	EXPECT_EQ(output->task_ids()[0], "5");
	EXPECT_EQ(output->task_ids()[1], "2");

	output->clear_task_ids();
	aggregator.reset();

	// duplicate entries in middle of list
	output->add_task_ids("5");
	output->add_task_ids("2");
	output->add_task_ids("2");
	output->add_task_ids("7");
	aggregator.aggregate(*output, *output, true);
	EXPECT_EQ(output->task_ids().size(), 3);
	EXPECT_EQ(output->task_ids()[0], "5");
	EXPECT_EQ(output->task_ids()[1], "2");
	EXPECT_EQ(output->task_ids()[2], "7");

	output->clear_task_ids();
	aggregator.reset();

	// multiple duplicate entries
	output->add_task_ids("5");
	output->add_task_ids("5");
	output->add_task_ids("2");
	output->add_task_ids("2");
	output->add_task_ids("7");
	output->add_task_ids("7");
	aggregator.aggregate(*output, *output, true);
	EXPECT_EQ(output->task_ids().size(), 3);
	EXPECT_EQ(output->task_ids()[0], "5");
	EXPECT_EQ(output->task_ids()[1], "7");
	EXPECT_EQ(output->task_ids()[2], "2");

	// aggregation into previous-in-place output buffer works as expected
	auto input = new draiosproto::marathon_app();
	input->add_task_ids("7");
	input->add_task_ids("2");
	input->add_task_ids("9");
	input->add_task_ids("5");
	aggregator.aggregate(*input, *output, false);
	EXPECT_EQ(output->task_ids().size(), 4);
	EXPECT_EQ(output->task_ids()[0], "5");
	EXPECT_EQ(output->task_ids()[1], "7");
	EXPECT_EQ(output->task_ids()[2], "2");
	EXPECT_EQ(output->task_ids()[3], "9");

	delete input;
	EXPECT_EQ(output->task_ids().size(), 4);
	EXPECT_EQ(output->task_ids()[0], "5");
	EXPECT_EQ(output->task_ids()[1], "7");
	EXPECT_EQ(output->task_ids()[2], "2");
	EXPECT_EQ(output->task_ids()[3], "9");

	delete output;
}

TEST(aggregator_base, single_numeric)
{
	message_aggregator_builder_impl builder;
	counter_percentile_message_aggregator aggregator(builder);

	auto input = new draiosproto::counter_percentile();
	auto output = new draiosproto::counter_percentile();

	input->set_percentile(3);
	aggregator.aggregate(*input, *output, false);
	EXPECT_EQ(output->percentile(), 3);

	delete input;
	EXPECT_EQ(output->percentile(), 3);

	input = new draiosproto::counter_percentile();
	input->set_percentile(5);
	aggregator.aggregate(*input, *output, false);
	EXPECT_EQ(output->percentile(), 3);

	delete input;
	delete output;
}

TEST(aggregator_base, single_numeric_in_place)
{
	message_aggregator_builder_impl builder;
	counter_percentile_message_aggregator aggregator(builder);

	auto output = new draiosproto::counter_percentile();

	output->set_percentile(3);
	aggregator.aggregate(*output, *output, false);
	EXPECT_EQ(output->percentile(), 3);
	delete output;
}

TEST(aggregator_base, single_string)
{
	message_aggregator_builder_impl builder;
	process_details_message_aggregator aggregator(builder);

	auto input = new draiosproto::process_details();
	auto output = new draiosproto::process_details();

	input->set_comm("3");
	aggregator.aggregate(*input, *output, false);
	EXPECT_EQ(output->comm(), "3");

	delete input;
	EXPECT_EQ(output->comm(), "3");

	input = new draiosproto::process_details();
	input->set_comm("5");
	aggregator.aggregate(*input, *output, false);
	EXPECT_EQ(output->comm(), "3");

	delete input;
	delete output;
}

TEST(aggregator_base, single_string_in_place)
{
	message_aggregator_builder_impl builder;
	process_details_message_aggregator aggregator(builder);

	auto output = new draiosproto::process_details();

	output->set_comm("3");
	aggregator.aggregate(*output, *output, true);
	EXPECT_EQ(output->comm(), "3");
	delete output;
}

TEST(aggregator_base, repeated_message)
{
	message_aggregator_builder_impl builder;
	counter_time_message_aggregator aggregator(builder);

	auto input = new draiosproto::counter_time();
	auto output = new draiosproto::counter_time();

	input->add_percentile()->set_percentile(1);
	input->add_percentile()->set_percentile(2);
	input->add_percentile()->set_percentile(2);
	aggregator.aggregate(*input, *output, false);
	EXPECT_EQ(output->percentile().size(), 2);
	EXPECT_EQ(output->percentile()[0].percentile(), 1);
	EXPECT_EQ(output->percentile()[1].percentile(), 2);

	auto input2 = new draiosproto::counter_time();
	input2->add_percentile()->set_percentile(2);
	input2->add_percentile()->set_percentile(3);
	input2->add_percentile()->set_percentile(1);
	aggregator.aggregate(*input2, *output, false);
	ASSERT_EQ(output->percentile().size(), 3);
	EXPECT_EQ(output->percentile()[0].percentile(), 1);
	EXPECT_EQ(output->percentile()[1].percentile(), 2);
	EXPECT_EQ(output->percentile()[2].percentile(), 3);

	delete input;
	delete input2;
	EXPECT_EQ(output->percentile().size(), 3);
	EXPECT_EQ(output->percentile()[0].percentile(), 1);
	EXPECT_EQ(output->percentile()[1].percentile(), 2);
	EXPECT_EQ(output->percentile()[2].percentile(), 3);

	output->clear_percentile();
	aggregator.reset();
	input = new draiosproto::counter_time();

	input->add_percentile()->set_percentile(1);
	aggregator.aggregate(*input, *output, false);
	EXPECT_EQ(output->percentile().size(), 1);
	EXPECT_EQ(output->percentile()[0].percentile(), 1);

	delete input;
	delete output;
}

TEST(aggregator_base, repeated_message_in_place)
{
	message_aggregator_builder_impl builder;
	counter_time_message_aggregator aggregator(builder);

	auto output = new draiosproto::counter_time();

	output->add_percentile()->set_percentile(5);
	output->add_percentile()->set_percentile(2);
	aggregator.aggregate(*output, *output, true);
	EXPECT_EQ(output->percentile().size(), 2);
	EXPECT_EQ(output->percentile()[0].percentile(), 5);
	EXPECT_EQ(output->percentile()[1].percentile(), 2);

	output->clear_percentile();
	aggregator.reset();

	// entire list the same
	output->add_percentile()->set_percentile(5);
	output->add_percentile()->set_percentile(5);
	output->add_percentile()->set_percentile(5);
	aggregator.aggregate(*output, *output, true);
	EXPECT_EQ(output->percentile().size(), 1);
	EXPECT_EQ(output->percentile()[0].percentile(), 5);

	output->clear_percentile();
	aggregator.reset();

	// duplicate entries at head of list
	output->add_percentile()->set_percentile(5);
	output->add_percentile()->set_percentile(5);
	output->add_percentile()->set_percentile(2);
	aggregator.aggregate(*output, *output, true);
	EXPECT_EQ(output->percentile().size(), 2);
	EXPECT_EQ(output->percentile()[0].percentile(), 5);
	EXPECT_EQ(output->percentile()[1].percentile(), 2);

	output->clear_percentile();
	aggregator.reset();

	// duplicate entries at tail of list
	output->add_percentile()->set_percentile(5);
	output->add_percentile()->set_percentile(2);
	output->add_percentile()->set_percentile(2);
	aggregator.aggregate(*output, *output, true);
	EXPECT_EQ(output->percentile().size(), 2);
	EXPECT_EQ(output->percentile()[0].percentile(), 5);
	EXPECT_EQ(output->percentile()[1].percentile(), 2);

	output->clear_percentile();
	aggregator.reset();

	// duplicate entries in middle of list
	output->add_percentile()->set_percentile(5);
	output->add_percentile()->set_percentile(2);
	output->add_percentile()->set_percentile(2);
	output->add_percentile()->set_percentile(7);
	aggregator.aggregate(*output, *output, true);
	EXPECT_EQ(output->percentile().size(), 3);
	EXPECT_EQ(output->percentile()[0].percentile(), 5);
	EXPECT_EQ(output->percentile()[1].percentile(), 2);
	EXPECT_EQ(output->percentile()[2].percentile(), 7);

	output->clear_percentile();
	aggregator.reset();

	// multiple duplicate entries
	output->add_percentile()->set_percentile(5);
	output->add_percentile()->set_percentile(5);
	output->add_percentile()->set_percentile(2);
	output->add_percentile()->set_percentile(2);
	output->add_percentile()->set_percentile(7);
	output->add_percentile()->set_percentile(7);
	aggregator.aggregate(*output, *output, true);
	EXPECT_EQ(output->percentile().size(), 3);
	EXPECT_EQ(output->percentile()[0].percentile(), 5);
	EXPECT_EQ(output->percentile()[1].percentile(), 7);
	EXPECT_EQ(output->percentile()[2].percentile(), 2);

	// aggregation into previous-in-place output buffer works as expected
	auto input = new draiosproto::counter_time();
	input->add_percentile()->set_percentile(7);
	input->add_percentile()->set_percentile(2);
	input->add_percentile()->set_percentile(9);
	input->add_percentile()->set_percentile(5);
	aggregator.aggregate(*input, *output, false);
	EXPECT_EQ(output->percentile().size(), 4);
	EXPECT_EQ(output->percentile()[0].percentile(), 5);
	EXPECT_EQ(output->percentile()[1].percentile(), 7);
	EXPECT_EQ(output->percentile()[2].percentile(), 2);
	EXPECT_EQ(output->percentile()[3].percentile(), 9);

	delete input;
	EXPECT_EQ(output->percentile().size(), 4);
	EXPECT_EQ(output->percentile()[0].percentile(), 5);
	EXPECT_EQ(output->percentile()[1].percentile(), 7);
	EXPECT_EQ(output->percentile()[2].percentile(), 2);
	EXPECT_EQ(output->percentile()[3].percentile(), 9);

	delete output;
}

// one-off to test a case previously missed where the recursive call
// on a duplicate message in place was happening incorrectly
TEST(aggregator_base, repeated_message_in_place_duplicate_recursion)
{
	message_aggregator_builder_impl builder;
	metrics_message_aggregator aggregator(builder);

	auto output = new draiosproto::metrics;

	auto in = output->add_ipv4_connections();
	in->mutable_tuple()->set_sip(1);
	in->mutable_counters()->set_n_aggregated_connections(1);
	in = output->add_ipv4_connections();
	in->mutable_tuple()->set_sip(1);
	in->mutable_counters()->set_n_aggregated_connections(2);
	aggregator.aggregate(*output, *output, true);
	EXPECT_EQ(output->ipv4_connections().size(), 1);
	EXPECT_EQ(output->ipv4_connections()[0].counters().aggr_n_aggregated_connections().sum(), 3);
	delete output;
}

TEST(aggregator_base, repeated_message_unique)
{
	message_aggregator_builder_impl builder;
	prom_metric_message_aggregator aggregator(builder);

	auto input = new draiosproto::prom_metric();
	auto output = new draiosproto::prom_metric();

	input->add_tags()->set_key("1");
	(*input->mutable_tags())[0].set_value("1");
	input->add_tags()->set_key("2");
	(*input->mutable_tags())[1].set_value("2");

	aggregator.aggregate(*input, *output, false);
	ASSERT_EQ(output->tags().size(), 2);
	EXPECT_EQ(output->tags()[0].key(), "1");
	EXPECT_EQ(output->tags()[0].value(), "1");
	EXPECT_EQ(output->tags()[1].key(), "2");
	EXPECT_EQ(output->tags()[1].value(), "2");

	// check that deleting input doesn't invalidate anything
	delete input;
	EXPECT_EQ(output->tags().size(), 2);
	EXPECT_EQ(output->tags()[0].key(), "1");
	EXPECT_EQ(output->tags()[0].value(), "1");
	EXPECT_EQ(output->tags()[1].key(), "2");
	EXPECT_EQ(output->tags()[1].value(), "2");

	// aggregate a new thing in, check that it works
	input = new draiosproto::prom_metric();
	input->add_tags()->set_key("2");
	(*input->mutable_tags())[0].set_value("2");
	input->add_tags()->set_key("3");
	aggregator.aggregate(*input, *output, false);
	EXPECT_EQ(output->tags().size(), 3);
	EXPECT_EQ(output->tags()[0].key(), "1");
	EXPECT_EQ(output->tags()[1].key(), "2");
	EXPECT_EQ(output->tags()[1].value(), "2");
	EXPECT_EQ(output->tags()[2].key(), "3");

	// Same key, different value should be a new tag
	delete input;
	input = new draiosproto::prom_metric();
	input->add_tags()->set_key("2");
	(*input->mutable_tags())[0].set_value("3");
	aggregator.aggregate(*input, *output, false);
	EXPECT_EQ(output->tags().size(), 4);
	EXPECT_EQ(output->tags()[0].key(), "1");
	EXPECT_EQ(output->tags()[1].key(), "2");
	EXPECT_EQ(output->tags()[1].value(), "2");
	EXPECT_EQ(output->tags()[2].key(), "3");
	EXPECT_EQ(output->tags()[3].key(), "2");
	EXPECT_EQ(output->tags()[3].value(), "3");

	delete input;
	EXPECT_EQ(output->tags().size(), 4);
	EXPECT_EQ(output->tags()[0].key(), "1");
	EXPECT_EQ(output->tags()[1].key(), "2");
	EXPECT_EQ(output->tags()[1].value(), "2");
	EXPECT_EQ(output->tags()[2].key(), "3");
	EXPECT_EQ(output->tags()[3].key(), "2");
	EXPECT_EQ(output->tags()[3].value(), "3");

	delete output;
}

TEST(aggregator_base, repeated_message_unique_in_place)
{
	message_aggregator_builder_impl builder;
	prom_metric_message_aggregator aggregator(builder);

	auto output = new draiosproto::prom_metric();

	output->add_tags()->set_key("1");
	(*output->mutable_tags())[0].set_value("1");
	output->add_tags()->set_key("2");
	(*output->mutable_tags())[1].set_value("2");

	aggregator.aggregate(*output, *output, true);
	ASSERT_EQ(output->tags().size(), 2);
	EXPECT_EQ(output->tags()[0].key(), "1");
	EXPECT_EQ(output->tags()[0].value(), "1");
	EXPECT_EQ(output->tags()[1].key(), "2");
	EXPECT_EQ(output->tags()[1].value(), "2");

	// aggregate a new thing in, check that it works (we'll create the map now)
	auto input = new draiosproto::prom_metric();
	input->add_tags()->set_key("2");
	(*input->mutable_tags())[0].set_value("3");
	input->add_tags()->set_key("3");
	aggregator.aggregate(*input, *output, false);
	EXPECT_EQ(output->tags().size(), 4);
	EXPECT_EQ(output->tags()[0].key(), "1");
	EXPECT_EQ(output->tags()[1].key(), "2");
	EXPECT_EQ(output->tags()[1].value(), "2");
	EXPECT_EQ(output->tags()[2].key(), "2");
	EXPECT_EQ(output->tags()[2].value(), "3");
	EXPECT_EQ(output->tags()[3].key(), "3");

	delete input;
	EXPECT_EQ(output->tags().size(), 4);
	EXPECT_EQ(output->tags()[0].key(), "1");
	EXPECT_EQ(output->tags()[1].key(), "2");
	EXPECT_EQ(output->tags()[1].value(), "2");
	EXPECT_EQ(output->tags()[2].key(), "2");
	EXPECT_EQ(output->tags()[2].value(), "3");
	EXPECT_EQ(output->tags()[3].key(), "3");

	delete output;
}

// This test checks that if we create an aggregator to not aggregate metrics,
// that metrics don't get aggregated, but metadata does
TEST(aggregator_base, should_aggregate_metrics)
{
	message_aggregator_builder_impl builder(false);
	host_message_aggregator aggregator(builder);
	auto input = new draiosproto::host();
	input->set_hostname("foo");
	input->add_cpu_loads(1);
	input->add_cpu_loads(2);
	input->set_num_cpus(3);
	auto output = new draiosproto::host();
	aggregator.aggregate(*input, *output, false);
	EXPECT_EQ(output->hostname(), "foo");
	EXPECT_EQ(output->cpu_loads().size(), 0);
	EXPECT_EQ(output->aggr_cpu_loads().weight(), 0);
	EXPECT_EQ(output->num_cpus(), 0);
	EXPECT_EQ(output->aggr_num_cpus().weight(), 0);

	delete input;
	delete output;

	input = new draiosproto::host();
	input->set_hostname("foo");
	input->add_cpu_loads(1);
	input->add_cpu_loads(2);
	input->set_num_cpus(3);

	aggregator.aggregate(*input, *input, true);
	EXPECT_EQ(input->hostname(), "foo");
	EXPECT_EQ(input->cpu_loads().size(), 0);
	EXPECT_EQ(input->aggr_cpu_loads().weight(), 0);
	EXPECT_EQ(input->num_cpus(), 0);
	EXPECT_EQ(input->aggr_num_cpus().weight(), 0);

	delete input;
}
