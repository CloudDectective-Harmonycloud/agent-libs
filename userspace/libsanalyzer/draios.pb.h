// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: draios.proto

#ifndef PROTOBUF_draios_2eproto__INCLUDED
#define PROTOBUF_draios_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace draiosproto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_draios_2eproto();
void protobuf_AssignDesc_draios_2eproto();
void protobuf_ShutdownFile_draios_2eproto();

class counter_time;
class counter_time_bidirectional;
class counter_bytes;
class counter_time_bytes;
class time_categories;
class transaction_breakdown_categories;
class counter_syscall_errors;
class resource_categories;
class connection_categories;
class process_details;
class host;
class thread;
class process;
class program;
class ipv4tuple;
class ipv4_connection;
class ipv4_network_interface;
class metrics;
class dump_request;
class dump_response;
class exec_cmd_request;
class exec_cmd_response;
class ssh_open_channel;
class ssh_data;
class ssh_close_channel;

enum networkrole {
  NONE = 0,
  IS_LOCAL_IPV4_SERVER = 1,
  IS_REMOTE_IPV4_SERVER = 2,
  IS_UNIX_SERVER = 4,
  IS_LOCAL_IPV4_CLIENT = 8,
  IS_REMOTE_IPV4_CLIENT = 16,
  IS_UNIX_CLIENT = 32
};
bool networkrole_IsValid(int value);
const networkrole networkrole_MIN = NONE;
const networkrole networkrole_MAX = IS_UNIX_CLIENT;
const int networkrole_ARRAYSIZE = networkrole_MAX + 1;

const ::google::protobuf::EnumDescriptor* networkrole_descriptor();
inline const ::std::string& networkrole_Name(networkrole value) {
  return ::google::protobuf::internal::NameOfEnum(
    networkrole_descriptor(), value);
}
inline bool networkrole_Parse(
    const ::std::string& name, networkrole* value) {
  return ::google::protobuf::internal::ParseNamedEnum<networkrole>(
    networkrole_descriptor(), name, value);
}
enum message_type {
  METRICS = 1,
  DUMP_REQUEST = 2,
  DUMP_RESPONSE = 3,
  EXEC_COMMAND_REQUEST = 4,
  EXEC_COMMAND_RESPONSE = 5,
  SSH_OPEN_CHANNEL = 6,
  SSH_CLOSE_CHANNEL = 7,
  SSH_DATA = 8
};
bool message_type_IsValid(int value);
const message_type message_type_MIN = METRICS;
const message_type message_type_MAX = SSH_DATA;
const int message_type_ARRAYSIZE = message_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* message_type_descriptor();
inline const ::std::string& message_type_Name(message_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    message_type_descriptor(), value);
}
inline bool message_type_Parse(
    const ::std::string& name, message_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<message_type>(
    message_type_descriptor(), name, value);
}
// ===================================================================

class counter_time : public ::google::protobuf::Message {
 public:
  counter_time();
  virtual ~counter_time();

  counter_time(const counter_time& from);

  inline counter_time& operator=(const counter_time& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const counter_time& default_instance();

  void Swap(counter_time* other);

  // implements Message ----------------------------------------------

  counter_time* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const counter_time& from);
  void MergeFrom(const counter_time& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // required uint64 time_ns = 2;
  inline bool has_time_ns() const;
  inline void clear_time_ns();
  static const int kTimeNsFieldNumber = 2;
  inline ::google::protobuf::uint64 time_ns() const;
  inline void set_time_ns(::google::protobuf::uint64 value);

  // optional uint32 time_percentage = 3;
  inline bool has_time_percentage() const;
  inline void clear_time_percentage();
  static const int kTimePercentageFieldNumber = 3;
  inline ::google::protobuf::uint32 time_percentage() const;
  inline void set_time_percentage(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.counter_time)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_time_ns();
  inline void clear_has_time_ns();
  inline void set_has_time_percentage();
  inline void clear_has_time_percentage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 time_ns_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 time_percentage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static counter_time* default_instance_;
};
// -------------------------------------------------------------------

class counter_time_bidirectional : public ::google::protobuf::Message {
 public:
  counter_time_bidirectional();
  virtual ~counter_time_bidirectional();

  counter_time_bidirectional(const counter_time_bidirectional& from);

  inline counter_time_bidirectional& operator=(const counter_time_bidirectional& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const counter_time_bidirectional& default_instance();

  void Swap(counter_time_bidirectional* other);

  // implements Message ----------------------------------------------

  counter_time_bidirectional* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const counter_time_bidirectional& from);
  void MergeFrom(const counter_time_bidirectional& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 count_in = 1;
  inline bool has_count_in() const;
  inline void clear_count_in();
  static const int kCountInFieldNumber = 1;
  inline ::google::protobuf::uint32 count_in() const;
  inline void set_count_in(::google::protobuf::uint32 value);

  // required uint32 count_out = 2;
  inline bool has_count_out() const;
  inline void clear_count_out();
  static const int kCountOutFieldNumber = 2;
  inline ::google::protobuf::uint32 count_out() const;
  inline void set_count_out(::google::protobuf::uint32 value);

  // required uint64 time_ns_in = 3;
  inline bool has_time_ns_in() const;
  inline void clear_time_ns_in();
  static const int kTimeNsInFieldNumber = 3;
  inline ::google::protobuf::uint64 time_ns_in() const;
  inline void set_time_ns_in(::google::protobuf::uint64 value);

  // required uint64 time_ns_out = 4;
  inline bool has_time_ns_out() const;
  inline void clear_time_ns_out();
  static const int kTimeNsOutFieldNumber = 4;
  inline ::google::protobuf::uint64 time_ns_out() const;
  inline void set_time_ns_out(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:draiosproto.counter_time_bidirectional)
 private:
  inline void set_has_count_in();
  inline void clear_has_count_in();
  inline void set_has_count_out();
  inline void clear_has_count_out();
  inline void set_has_time_ns_in();
  inline void clear_has_time_ns_in();
  inline void set_has_time_ns_out();
  inline void clear_has_time_ns_out();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 count_in_;
  ::google::protobuf::uint32 count_out_;
  ::google::protobuf::uint64 time_ns_in_;
  ::google::protobuf::uint64 time_ns_out_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static counter_time_bidirectional* default_instance_;
};
// -------------------------------------------------------------------

class counter_bytes : public ::google::protobuf::Message {
 public:
  counter_bytes();
  virtual ~counter_bytes();

  counter_bytes(const counter_bytes& from);

  inline counter_bytes& operator=(const counter_bytes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const counter_bytes& default_instance();

  void Swap(counter_bytes* other);

  // implements Message ----------------------------------------------

  counter_bytes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const counter_bytes& from);
  void MergeFrom(const counter_bytes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 count_in = 1;
  inline bool has_count_in() const;
  inline void clear_count_in();
  static const int kCountInFieldNumber = 1;
  inline ::google::protobuf::uint32 count_in() const;
  inline void set_count_in(::google::protobuf::uint32 value);

  // required uint32 count_out = 2;
  inline bool has_count_out() const;
  inline void clear_count_out();
  static const int kCountOutFieldNumber = 2;
  inline ::google::protobuf::uint32 count_out() const;
  inline void set_count_out(::google::protobuf::uint32 value);

  // required uint32 bytes_in = 3;
  inline bool has_bytes_in() const;
  inline void clear_bytes_in();
  static const int kBytesInFieldNumber = 3;
  inline ::google::protobuf::uint32 bytes_in() const;
  inline void set_bytes_in(::google::protobuf::uint32 value);

  // required uint32 bytes_out = 4;
  inline bool has_bytes_out() const;
  inline void clear_bytes_out();
  static const int kBytesOutFieldNumber = 4;
  inline ::google::protobuf::uint32 bytes_out() const;
  inline void set_bytes_out(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.counter_bytes)
 private:
  inline void set_has_count_in();
  inline void clear_has_count_in();
  inline void set_has_count_out();
  inline void clear_has_count_out();
  inline void set_has_bytes_in();
  inline void clear_has_bytes_in();
  inline void set_has_bytes_out();
  inline void clear_has_bytes_out();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 count_in_;
  ::google::protobuf::uint32 count_out_;
  ::google::protobuf::uint32 bytes_in_;
  ::google::protobuf::uint32 bytes_out_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static counter_bytes* default_instance_;
};
// -------------------------------------------------------------------

class counter_time_bytes : public ::google::protobuf::Message {
 public:
  counter_time_bytes();
  virtual ~counter_time_bytes();

  counter_time_bytes(const counter_time_bytes& from);

  inline counter_time_bytes& operator=(const counter_time_bytes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const counter_time_bytes& default_instance();

  void Swap(counter_time_bytes* other);

  // implements Message ----------------------------------------------

  counter_time_bytes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const counter_time_bytes& from);
  void MergeFrom(const counter_time_bytes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 time_ns_in = 1;
  inline bool has_time_ns_in() const;
  inline void clear_time_ns_in();
  static const int kTimeNsInFieldNumber = 1;
  inline ::google::protobuf::uint64 time_ns_in() const;
  inline void set_time_ns_in(::google::protobuf::uint64 value);

  // required uint64 time_ns_out = 2;
  inline bool has_time_ns_out() const;
  inline void clear_time_ns_out();
  static const int kTimeNsOutFieldNumber = 2;
  inline ::google::protobuf::uint64 time_ns_out() const;
  inline void set_time_ns_out(::google::protobuf::uint64 value);

  // required uint64 time_ns_other = 3;
  inline bool has_time_ns_other() const;
  inline void clear_time_ns_other();
  static const int kTimeNsOtherFieldNumber = 3;
  inline ::google::protobuf::uint64 time_ns_other() const;
  inline void set_time_ns_other(::google::protobuf::uint64 value);

  // required uint32 count_in = 4;
  inline bool has_count_in() const;
  inline void clear_count_in();
  static const int kCountInFieldNumber = 4;
  inline ::google::protobuf::uint32 count_in() const;
  inline void set_count_in(::google::protobuf::uint32 value);

  // required uint32 count_out = 5;
  inline bool has_count_out() const;
  inline void clear_count_out();
  static const int kCountOutFieldNumber = 5;
  inline ::google::protobuf::uint32 count_out() const;
  inline void set_count_out(::google::protobuf::uint32 value);

  // required uint32 count_other = 6;
  inline bool has_count_other() const;
  inline void clear_count_other();
  static const int kCountOtherFieldNumber = 6;
  inline ::google::protobuf::uint32 count_other() const;
  inline void set_count_other(::google::protobuf::uint32 value);

  // required uint32 bytes_in = 7;
  inline bool has_bytes_in() const;
  inline void clear_bytes_in();
  static const int kBytesInFieldNumber = 7;
  inline ::google::protobuf::uint32 bytes_in() const;
  inline void set_bytes_in(::google::protobuf::uint32 value);

  // required uint32 bytes_out = 8;
  inline bool has_bytes_out() const;
  inline void clear_bytes_out();
  static const int kBytesOutFieldNumber = 8;
  inline ::google::protobuf::uint32 bytes_out() const;
  inline void set_bytes_out(::google::protobuf::uint32 value);

  // required uint32 bytes_other = 9;
  inline bool has_bytes_other() const;
  inline void clear_bytes_other();
  static const int kBytesOtherFieldNumber = 9;
  inline ::google::protobuf::uint32 bytes_other() const;
  inline void set_bytes_other(::google::protobuf::uint32 value);

  // optional uint32 time_percentage_in = 10;
  inline bool has_time_percentage_in() const;
  inline void clear_time_percentage_in();
  static const int kTimePercentageInFieldNumber = 10;
  inline ::google::protobuf::uint32 time_percentage_in() const;
  inline void set_time_percentage_in(::google::protobuf::uint32 value);

  // optional uint32 time_percentage_out = 11;
  inline bool has_time_percentage_out() const;
  inline void clear_time_percentage_out();
  static const int kTimePercentageOutFieldNumber = 11;
  inline ::google::protobuf::uint32 time_percentage_out() const;
  inline void set_time_percentage_out(::google::protobuf::uint32 value);

  // optional uint32 time_percentage_other = 12;
  inline bool has_time_percentage_other() const;
  inline void clear_time_percentage_other();
  static const int kTimePercentageOtherFieldNumber = 12;
  inline ::google::protobuf::uint32 time_percentage_other() const;
  inline void set_time_percentage_other(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.counter_time_bytes)
 private:
  inline void set_has_time_ns_in();
  inline void clear_has_time_ns_in();
  inline void set_has_time_ns_out();
  inline void clear_has_time_ns_out();
  inline void set_has_time_ns_other();
  inline void clear_has_time_ns_other();
  inline void set_has_count_in();
  inline void clear_has_count_in();
  inline void set_has_count_out();
  inline void clear_has_count_out();
  inline void set_has_count_other();
  inline void clear_has_count_other();
  inline void set_has_bytes_in();
  inline void clear_has_bytes_in();
  inline void set_has_bytes_out();
  inline void clear_has_bytes_out();
  inline void set_has_bytes_other();
  inline void clear_has_bytes_other();
  inline void set_has_time_percentage_in();
  inline void clear_has_time_percentage_in();
  inline void set_has_time_percentage_out();
  inline void clear_has_time_percentage_out();
  inline void set_has_time_percentage_other();
  inline void clear_has_time_percentage_other();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 time_ns_in_;
  ::google::protobuf::uint64 time_ns_out_;
  ::google::protobuf::uint64 time_ns_other_;
  ::google::protobuf::uint32 count_in_;
  ::google::protobuf::uint32 count_out_;
  ::google::protobuf::uint32 count_other_;
  ::google::protobuf::uint32 bytes_in_;
  ::google::protobuf::uint32 bytes_out_;
  ::google::protobuf::uint32 bytes_other_;
  ::google::protobuf::uint32 time_percentage_in_;
  ::google::protobuf::uint32 time_percentage_out_;
  ::google::protobuf::uint32 time_percentage_other_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static counter_time_bytes* default_instance_;
};
// -------------------------------------------------------------------

class time_categories : public ::google::protobuf::Message {
 public:
  time_categories();
  virtual ~time_categories();

  time_categories(const time_categories& from);

  inline time_categories& operator=(const time_categories& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const time_categories& default_instance();

  void Swap(time_categories* other);

  // implements Message ----------------------------------------------

  time_categories* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const time_categories& from);
  void MergeFrom(const time_categories& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .draiosproto.counter_time unknown = 1;
  inline bool has_unknown() const;
  inline void clear_unknown();
  static const int kUnknownFieldNumber = 1;
  inline const ::draiosproto::counter_time& unknown() const;
  inline ::draiosproto::counter_time* mutable_unknown();
  inline ::draiosproto::counter_time* release_unknown();
  inline void set_allocated_unknown(::draiosproto::counter_time* unknown);

  // optional .draiosproto.counter_time other = 2;
  inline bool has_other() const;
  inline void clear_other();
  static const int kOtherFieldNumber = 2;
  inline const ::draiosproto::counter_time& other() const;
  inline ::draiosproto::counter_time* mutable_other();
  inline ::draiosproto::counter_time* release_other();
  inline void set_allocated_other(::draiosproto::counter_time* other);

  // optional .draiosproto.counter_time file = 3;
  inline bool has_file() const;
  inline void clear_file();
  static const int kFileFieldNumber = 3;
  inline const ::draiosproto::counter_time& file() const;
  inline ::draiosproto::counter_time* mutable_file();
  inline ::draiosproto::counter_time* release_file();
  inline void set_allocated_file(::draiosproto::counter_time* file);

  // optional .draiosproto.counter_time net = 4;
  inline bool has_net() const;
  inline void clear_net();
  static const int kNetFieldNumber = 4;
  inline const ::draiosproto::counter_time& net() const;
  inline ::draiosproto::counter_time* mutable_net();
  inline ::draiosproto::counter_time* release_net();
  inline void set_allocated_net(::draiosproto::counter_time* net);

  // optional .draiosproto.counter_time ipc = 5;
  inline bool has_ipc() const;
  inline void clear_ipc();
  static const int kIpcFieldNumber = 5;
  inline const ::draiosproto::counter_time& ipc() const;
  inline ::draiosproto::counter_time* mutable_ipc();
  inline ::draiosproto::counter_time* release_ipc();
  inline void set_allocated_ipc(::draiosproto::counter_time* ipc);

  // optional .draiosproto.counter_time memory = 6;
  inline bool has_memory() const;
  inline void clear_memory();
  static const int kMemoryFieldNumber = 6;
  inline const ::draiosproto::counter_time& memory() const;
  inline ::draiosproto::counter_time* mutable_memory();
  inline ::draiosproto::counter_time* release_memory();
  inline void set_allocated_memory(::draiosproto::counter_time* memory);

  // optional .draiosproto.counter_time process = 7;
  inline bool has_process() const;
  inline void clear_process();
  static const int kProcessFieldNumber = 7;
  inline const ::draiosproto::counter_time& process() const;
  inline ::draiosproto::counter_time* mutable_process();
  inline ::draiosproto::counter_time* release_process();
  inline void set_allocated_process(::draiosproto::counter_time* process);

  // optional .draiosproto.counter_time sleep = 8;
  inline bool has_sleep() const;
  inline void clear_sleep();
  static const int kSleepFieldNumber = 8;
  inline const ::draiosproto::counter_time& sleep() const;
  inline ::draiosproto::counter_time* mutable_sleep();
  inline ::draiosproto::counter_time* release_sleep();
  inline void set_allocated_sleep(::draiosproto::counter_time* sleep);

  // optional .draiosproto.counter_time system = 9;
  inline bool has_system() const;
  inline void clear_system();
  static const int kSystemFieldNumber = 9;
  inline const ::draiosproto::counter_time& system() const;
  inline ::draiosproto::counter_time* mutable_system();
  inline ::draiosproto::counter_time* release_system();
  inline void set_allocated_system(::draiosproto::counter_time* system);

  // optional .draiosproto.counter_time signal = 10;
  inline bool has_signal() const;
  inline void clear_signal();
  static const int kSignalFieldNumber = 10;
  inline const ::draiosproto::counter_time& signal() const;
  inline ::draiosproto::counter_time* mutable_signal();
  inline ::draiosproto::counter_time* release_signal();
  inline void set_allocated_signal(::draiosproto::counter_time* signal);

  // optional .draiosproto.counter_time user = 11;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 11;
  inline const ::draiosproto::counter_time& user() const;
  inline ::draiosproto::counter_time* mutable_user();
  inline ::draiosproto::counter_time* release_user();
  inline void set_allocated_user(::draiosproto::counter_time* user);

  // optional .draiosproto.counter_time time = 12;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 12;
  inline const ::draiosproto::counter_time& time() const;
  inline ::draiosproto::counter_time* mutable_time();
  inline ::draiosproto::counter_time* release_time();
  inline void set_allocated_time(::draiosproto::counter_time* time);

  // optional .draiosproto.counter_time_bytes io_file = 13;
  inline bool has_io_file() const;
  inline void clear_io_file();
  static const int kIoFileFieldNumber = 13;
  inline const ::draiosproto::counter_time_bytes& io_file() const;
  inline ::draiosproto::counter_time_bytes* mutable_io_file();
  inline ::draiosproto::counter_time_bytes* release_io_file();
  inline void set_allocated_io_file(::draiosproto::counter_time_bytes* io_file);

  // optional .draiosproto.counter_time_bytes io_net = 14;
  inline bool has_io_net() const;
  inline void clear_io_net();
  static const int kIoNetFieldNumber = 14;
  inline const ::draiosproto::counter_time_bytes& io_net() const;
  inline ::draiosproto::counter_time_bytes* mutable_io_net();
  inline ::draiosproto::counter_time_bytes* release_io_net();
  inline void set_allocated_io_net(::draiosproto::counter_time_bytes* io_net);

  // optional .draiosproto.counter_time_bytes io_other = 15;
  inline bool has_io_other() const;
  inline void clear_io_other();
  static const int kIoOtherFieldNumber = 15;
  inline const ::draiosproto::counter_time_bytes& io_other() const;
  inline ::draiosproto::counter_time_bytes* mutable_io_other();
  inline ::draiosproto::counter_time_bytes* release_io_other();
  inline void set_allocated_io_other(::draiosproto::counter_time_bytes* io_other);

  // optional .draiosproto.counter_time wait = 16;
  inline bool has_wait() const;
  inline void clear_wait();
  static const int kWaitFieldNumber = 16;
  inline const ::draiosproto::counter_time& wait() const;
  inline ::draiosproto::counter_time* mutable_wait();
  inline ::draiosproto::counter_time* release_wait();
  inline void set_allocated_wait(::draiosproto::counter_time* wait);

  // optional .draiosproto.counter_time processing = 17;
  inline bool has_processing() const;
  inline void clear_processing();
  static const int kProcessingFieldNumber = 17;
  inline const ::draiosproto::counter_time& processing() const;
  inline ::draiosproto::counter_time* mutable_processing();
  inline ::draiosproto::counter_time* release_processing();
  inline void set_allocated_processing(::draiosproto::counter_time* processing);

  // @@protoc_insertion_point(class_scope:draiosproto.time_categories)
 private:
  inline void set_has_unknown();
  inline void clear_has_unknown();
  inline void set_has_other();
  inline void clear_has_other();
  inline void set_has_file();
  inline void clear_has_file();
  inline void set_has_net();
  inline void clear_has_net();
  inline void set_has_ipc();
  inline void clear_has_ipc();
  inline void set_has_memory();
  inline void clear_has_memory();
  inline void set_has_process();
  inline void clear_has_process();
  inline void set_has_sleep();
  inline void clear_has_sleep();
  inline void set_has_system();
  inline void clear_has_system();
  inline void set_has_signal();
  inline void clear_has_signal();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_io_file();
  inline void clear_has_io_file();
  inline void set_has_io_net();
  inline void clear_has_io_net();
  inline void set_has_io_other();
  inline void clear_has_io_other();
  inline void set_has_wait();
  inline void clear_has_wait();
  inline void set_has_processing();
  inline void clear_has_processing();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::draiosproto::counter_time* unknown_;
  ::draiosproto::counter_time* other_;
  ::draiosproto::counter_time* file_;
  ::draiosproto::counter_time* net_;
  ::draiosproto::counter_time* ipc_;
  ::draiosproto::counter_time* memory_;
  ::draiosproto::counter_time* process_;
  ::draiosproto::counter_time* sleep_;
  ::draiosproto::counter_time* system_;
  ::draiosproto::counter_time* signal_;
  ::draiosproto::counter_time* user_;
  ::draiosproto::counter_time* time_;
  ::draiosproto::counter_time_bytes* io_file_;
  ::draiosproto::counter_time_bytes* io_net_;
  ::draiosproto::counter_time_bytes* io_other_;
  ::draiosproto::counter_time* wait_;
  ::draiosproto::counter_time* processing_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static time_categories* default_instance_;
};
// -------------------------------------------------------------------

class transaction_breakdown_categories : public ::google::protobuf::Message {
 public:
  transaction_breakdown_categories();
  virtual ~transaction_breakdown_categories();

  transaction_breakdown_categories(const transaction_breakdown_categories& from);

  inline transaction_breakdown_categories& operator=(const transaction_breakdown_categories& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const transaction_breakdown_categories& default_instance();

  void Swap(transaction_breakdown_categories* other);

  // implements Message ----------------------------------------------

  transaction_breakdown_categories* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const transaction_breakdown_categories& from);
  void MergeFrom(const transaction_breakdown_categories& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .draiosproto.counter_time other = 2;
  inline bool has_other() const;
  inline void clear_other();
  static const int kOtherFieldNumber = 2;
  inline const ::draiosproto::counter_time& other() const;
  inline ::draiosproto::counter_time* mutable_other();
  inline ::draiosproto::counter_time* release_other();
  inline void set_allocated_other(::draiosproto::counter_time* other);

  // optional .draiosproto.counter_time_bytes io_file = 13;
  inline bool has_io_file() const;
  inline void clear_io_file();
  static const int kIoFileFieldNumber = 13;
  inline const ::draiosproto::counter_time_bytes& io_file() const;
  inline ::draiosproto::counter_time_bytes* mutable_io_file();
  inline ::draiosproto::counter_time_bytes* release_io_file();
  inline void set_allocated_io_file(::draiosproto::counter_time_bytes* io_file);

  // optional .draiosproto.counter_time_bytes io_net = 14;
  inline bool has_io_net() const;
  inline void clear_io_net();
  static const int kIoNetFieldNumber = 14;
  inline const ::draiosproto::counter_time_bytes& io_net() const;
  inline ::draiosproto::counter_time_bytes* mutable_io_net();
  inline ::draiosproto::counter_time_bytes* release_io_net();
  inline void set_allocated_io_net(::draiosproto::counter_time_bytes* io_net);

  // optional .draiosproto.counter_time processing = 17;
  inline bool has_processing() const;
  inline void clear_processing();
  static const int kProcessingFieldNumber = 17;
  inline const ::draiosproto::counter_time& processing() const;
  inline ::draiosproto::counter_time* mutable_processing();
  inline ::draiosproto::counter_time* release_processing();
  inline void set_allocated_processing(::draiosproto::counter_time* processing);

  // @@protoc_insertion_point(class_scope:draiosproto.transaction_breakdown_categories)
 private:
  inline void set_has_other();
  inline void clear_has_other();
  inline void set_has_io_file();
  inline void clear_has_io_file();
  inline void set_has_io_net();
  inline void clear_has_io_net();
  inline void set_has_processing();
  inline void clear_has_processing();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::draiosproto::counter_time* other_;
  ::draiosproto::counter_time_bytes* io_file_;
  ::draiosproto::counter_time_bytes* io_net_;
  ::draiosproto::counter_time* processing_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static transaction_breakdown_categories* default_instance_;
};
// -------------------------------------------------------------------

class counter_syscall_errors : public ::google::protobuf::Message {
 public:
  counter_syscall_errors();
  virtual ~counter_syscall_errors();

  counter_syscall_errors(const counter_syscall_errors& from);

  inline counter_syscall_errors& operator=(const counter_syscall_errors& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const counter_syscall_errors& default_instance();

  void Swap(counter_syscall_errors* other);

  // implements Message ----------------------------------------------

  counter_syscall_errors* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const counter_syscall_errors& from);
  void MergeFrom(const counter_syscall_errors& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated uint32 top_error_codes = 2;
  inline int top_error_codes_size() const;
  inline void clear_top_error_codes();
  static const int kTopErrorCodesFieldNumber = 2;
  inline ::google::protobuf::uint32 top_error_codes(int index) const;
  inline void set_top_error_codes(int index, ::google::protobuf::uint32 value);
  inline void add_top_error_codes(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      top_error_codes() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_top_error_codes();

  // @@protoc_insertion_point(class_scope:draiosproto.counter_syscall_errors)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > top_error_codes_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static counter_syscall_errors* default_instance_;
};
// -------------------------------------------------------------------

class resource_categories : public ::google::protobuf::Message {
 public:
  resource_categories();
  virtual ~resource_categories();

  resource_categories(const resource_categories& from);

  inline resource_categories& operator=(const resource_categories& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const resource_categories& default_instance();

  void Swap(resource_categories* other);

  // implements Message ----------------------------------------------

  resource_categories* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const resource_categories& from);
  void MergeFrom(const resource_categories& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 capacity_score = 1;
  inline bool has_capacity_score() const;
  inline void clear_capacity_score();
  static const int kCapacityScoreFieldNumber = 1;
  inline ::google::protobuf::uint32 capacity_score() const;
  inline void set_capacity_score(::google::protobuf::uint32 value);

  // optional uint32 stolen_capacity_score = 6;
  inline bool has_stolen_capacity_score() const;
  inline void clear_stolen_capacity_score();
  static const int kStolenCapacityScoreFieldNumber = 6;
  inline ::google::protobuf::uint32 stolen_capacity_score() const;
  inline void set_stolen_capacity_score(::google::protobuf::uint32 value);

  // optional uint32 connection_queue_usage_pct = 2;
  inline bool has_connection_queue_usage_pct() const;
  inline void clear_connection_queue_usage_pct();
  static const int kConnectionQueueUsagePctFieldNumber = 2;
  inline ::google::protobuf::uint32 connection_queue_usage_pct() const;
  inline void set_connection_queue_usage_pct(::google::protobuf::uint32 value);

  // optional uint32 fd_usage_pct = 3;
  inline bool has_fd_usage_pct() const;
  inline void clear_fd_usage_pct();
  static const int kFdUsagePctFieldNumber = 3;
  inline ::google::protobuf::uint32 fd_usage_pct() const;
  inline void set_fd_usage_pct(::google::protobuf::uint32 value);

  // optional uint32 cpu_pct = 4;
  inline bool has_cpu_pct() const;
  inline void clear_cpu_pct();
  static const int kCpuPctFieldNumber = 4;
  inline ::google::protobuf::uint32 cpu_pct() const;
  inline void set_cpu_pct(::google::protobuf::uint32 value);

  // optional uint64 resident_memory_usage_kb = 5;
  inline bool has_resident_memory_usage_kb() const;
  inline void clear_resident_memory_usage_kb();
  static const int kResidentMemoryUsageKbFieldNumber = 5;
  inline ::google::protobuf::uint64 resident_memory_usage_kb() const;
  inline void set_resident_memory_usage_kb(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:draiosproto.resource_categories)
 private:
  inline void set_has_capacity_score();
  inline void clear_has_capacity_score();
  inline void set_has_stolen_capacity_score();
  inline void clear_has_stolen_capacity_score();
  inline void set_has_connection_queue_usage_pct();
  inline void clear_has_connection_queue_usage_pct();
  inline void set_has_fd_usage_pct();
  inline void clear_has_fd_usage_pct();
  inline void set_has_cpu_pct();
  inline void clear_has_cpu_pct();
  inline void set_has_resident_memory_usage_kb();
  inline void clear_has_resident_memory_usage_kb();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 capacity_score_;
  ::google::protobuf::uint32 stolen_capacity_score_;
  ::google::protobuf::uint32 connection_queue_usage_pct_;
  ::google::protobuf::uint32 fd_usage_pct_;
  ::google::protobuf::uint64 resident_memory_usage_kb_;
  ::google::protobuf::uint32 cpu_pct_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static resource_categories* default_instance_;
};
// -------------------------------------------------------------------

class connection_categories : public ::google::protobuf::Message {
 public:
  connection_categories();
  virtual ~connection_categories();

  connection_categories(const connection_categories& from);

  inline connection_categories& operator=(const connection_categories& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const connection_categories& default_instance();

  void Swap(connection_categories* other);

  // implements Message ----------------------------------------------

  connection_categories* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const connection_categories& from);
  void MergeFrom(const connection_categories& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .draiosproto.counter_bytes server = 1;
  inline bool has_server() const;
  inline void clear_server();
  static const int kServerFieldNumber = 1;
  inline const ::draiosproto::counter_bytes& server() const;
  inline ::draiosproto::counter_bytes* mutable_server();
  inline ::draiosproto::counter_bytes* release_server();
  inline void set_allocated_server(::draiosproto::counter_bytes* server);

  // optional .draiosproto.counter_bytes client = 2;
  inline bool has_client() const;
  inline void clear_client();
  static const int kClientFieldNumber = 2;
  inline const ::draiosproto::counter_bytes& client() const;
  inline ::draiosproto::counter_bytes* mutable_client();
  inline ::draiosproto::counter_bytes* release_client();
  inline void set_allocated_client(::draiosproto::counter_bytes* client);

  // optional .draiosproto.counter_time_bidirectional transaction_counters = 3;
  inline bool has_transaction_counters() const;
  inline void clear_transaction_counters();
  static const int kTransactionCountersFieldNumber = 3;
  inline const ::draiosproto::counter_time_bidirectional& transaction_counters() const;
  inline ::draiosproto::counter_time_bidirectional* mutable_transaction_counters();
  inline ::draiosproto::counter_time_bidirectional* release_transaction_counters();
  inline void set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters);

  // optional uint32 n_aggregated_connections = 4;
  inline bool has_n_aggregated_connections() const;
  inline void clear_n_aggregated_connections();
  static const int kNAggregatedConnectionsFieldNumber = 4;
  inline ::google::protobuf::uint32 n_aggregated_connections() const;
  inline void set_n_aggregated_connections(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.connection_categories)
 private:
  inline void set_has_server();
  inline void clear_has_server();
  inline void set_has_client();
  inline void clear_has_client();
  inline void set_has_transaction_counters();
  inline void clear_has_transaction_counters();
  inline void set_has_n_aggregated_connections();
  inline void clear_has_n_aggregated_connections();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::draiosproto::counter_bytes* server_;
  ::draiosproto::counter_bytes* client_;
  ::draiosproto::counter_time_bidirectional* transaction_counters_;
  ::google::protobuf::uint32 n_aggregated_connections_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static connection_categories* default_instance_;
};
// -------------------------------------------------------------------

class process_details : public ::google::protobuf::Message {
 public:
  process_details();
  virtual ~process_details();

  process_details(const process_details& from);

  inline process_details& operator=(const process_details& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const process_details& default_instance();

  void Swap(process_details* other);

  // implements Message ----------------------------------------------

  process_details* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const process_details& from);
  void MergeFrom(const process_details& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string comm = 1;
  inline bool has_comm() const;
  inline void clear_comm();
  static const int kCommFieldNumber = 1;
  inline const ::std::string& comm() const;
  inline void set_comm(const ::std::string& value);
  inline void set_comm(const char* value);
  inline void set_comm(const char* value, size_t size);
  inline ::std::string* mutable_comm();
  inline ::std::string* release_comm();
  inline void set_allocated_comm(::std::string* comm);

  // required string exe = 2;
  inline bool has_exe() const;
  inline void clear_exe();
  static const int kExeFieldNumber = 2;
  inline const ::std::string& exe() const;
  inline void set_exe(const ::std::string& value);
  inline void set_exe(const char* value);
  inline void set_exe(const char* value, size_t size);
  inline ::std::string* mutable_exe();
  inline ::std::string* release_exe();
  inline void set_allocated_exe(::std::string* exe);

  // repeated string args = 3;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 3;
  inline const ::std::string& args(int index) const;
  inline ::std::string* mutable_args(int index);
  inline void set_args(int index, const ::std::string& value);
  inline void set_args(int index, const char* value);
  inline void set_args(int index, const char* value, size_t size);
  inline ::std::string* add_args();
  inline void add_args(const ::std::string& value);
  inline void add_args(const char* value);
  inline void add_args(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& args() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_args();

  // @@protoc_insertion_point(class_scope:draiosproto.process_details)
 private:
  inline void set_has_comm();
  inline void clear_has_comm();
  inline void set_has_exe();
  inline void clear_has_exe();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* comm_;
  ::std::string* exe_;
  ::google::protobuf::RepeatedPtrField< ::std::string> args_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static process_details* default_instance_;
};
// -------------------------------------------------------------------

class host : public ::google::protobuf::Message {
 public:
  host();
  virtual ~host();

  host(const host& from);

  inline host& operator=(const host& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const host& default_instance();

  void Swap(host* other);

  // implements Message ----------------------------------------------

  host* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const host& from);
  void MergeFrom(const host& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string hostname = 1;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional uint32 num_cpus = 2;
  inline bool has_num_cpus() const;
  inline void clear_num_cpus();
  static const int kNumCpusFieldNumber = 2;
  inline ::google::protobuf::uint32 num_cpus() const;
  inline void set_num_cpus(::google::protobuf::uint32 value);

  // repeated uint32 cpu_loads = 3;
  inline int cpu_loads_size() const;
  inline void clear_cpu_loads();
  static const int kCpuLoadsFieldNumber = 3;
  inline ::google::protobuf::uint32 cpu_loads(int index) const;
  inline void set_cpu_loads(int index, ::google::protobuf::uint32 value);
  inline void add_cpu_loads(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      cpu_loads() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_cpu_loads();

  // repeated uint32 cpu_steal = 11;
  inline int cpu_steal_size() const;
  inline void clear_cpu_steal();
  static const int kCpuStealFieldNumber = 11;
  inline ::google::protobuf::uint32 cpu_steal(int index) const;
  inline void set_cpu_steal(int index, ::google::protobuf::uint32 value);
  inline void add_cpu_steal(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      cpu_steal() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_cpu_steal();

  // required uint64 physical_memory_size_bytes = 4;
  inline bool has_physical_memory_size_bytes() const;
  inline void clear_physical_memory_size_bytes();
  static const int kPhysicalMemorySizeBytesFieldNumber = 4;
  inline ::google::protobuf::uint64 physical_memory_size_bytes() const;
  inline void set_physical_memory_size_bytes(::google::protobuf::uint64 value);

  // optional .draiosproto.time_categories tcounters = 5;
  inline bool has_tcounters() const;
  inline void clear_tcounters();
  static const int kTcountersFieldNumber = 5;
  inline const ::draiosproto::time_categories& tcounters() const;
  inline ::draiosproto::time_categories* mutable_tcounters();
  inline ::draiosproto::time_categories* release_tcounters();
  inline void set_allocated_tcounters(::draiosproto::time_categories* tcounters);

  // optional .draiosproto.transaction_breakdown_categories reqcounters = 12;
  inline bool has_reqcounters() const;
  inline void clear_reqcounters();
  static const int kReqcountersFieldNumber = 12;
  inline const ::draiosproto::transaction_breakdown_categories& reqcounters() const;
  inline ::draiosproto::transaction_breakdown_categories* mutable_reqcounters();
  inline ::draiosproto::transaction_breakdown_categories* release_reqcounters();
  inline void set_allocated_reqcounters(::draiosproto::transaction_breakdown_categories* reqcounters);

  // optional .draiosproto.counter_time_bidirectional transaction_counters = 6;
  inline bool has_transaction_counters() const;
  inline void clear_transaction_counters();
  static const int kTransactionCountersFieldNumber = 6;
  inline const ::draiosproto::counter_time_bidirectional& transaction_counters() const;
  inline ::draiosproto::counter_time_bidirectional* mutable_transaction_counters();
  inline ::draiosproto::counter_time_bidirectional* release_transaction_counters();
  inline void set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters);

  // optional uint64 transaction_processing_delay = 7;
  inline bool has_transaction_processing_delay() const;
  inline void clear_transaction_processing_delay();
  static const int kTransactionProcessingDelayFieldNumber = 7;
  inline ::google::protobuf::uint64 transaction_processing_delay() const;
  inline void set_transaction_processing_delay(::google::protobuf::uint64 value);

  // optional uint64 merged_server_delay = 14;
  inline bool has_merged_server_delay() const;
  inline void clear_merged_server_delay();
  static const int kMergedServerDelayFieldNumber = 14;
  inline ::google::protobuf::uint64 merged_server_delay() const;
  inline void set_merged_server_delay(::google::protobuf::uint64 value);

  // optional uint64 next_tiers_delay = 13;
  inline bool has_next_tiers_delay() const;
  inline void clear_next_tiers_delay();
  static const int kNextTiersDelayFieldNumber = 13;
  inline ::google::protobuf::uint64 next_tiers_delay() const;
  inline void set_next_tiers_delay(::google::protobuf::uint64 value);

  // optional .draiosproto.resource_categories resource_counters = 8;
  inline bool has_resource_counters() const;
  inline void clear_resource_counters();
  static const int kResourceCountersFieldNumber = 8;
  inline const ::draiosproto::resource_categories& resource_counters() const;
  inline ::draiosproto::resource_categories* mutable_resource_counters();
  inline ::draiosproto::resource_categories* release_resource_counters();
  inline void set_allocated_resource_counters(::draiosproto::resource_categories* resource_counters);

  // optional .draiosproto.counter_syscall_errors syscall_errors = 9;
  inline bool has_syscall_errors() const;
  inline void clear_syscall_errors();
  static const int kSyscallErrorsFieldNumber = 9;
  inline const ::draiosproto::counter_syscall_errors& syscall_errors() const;
  inline ::draiosproto::counter_syscall_errors* mutable_syscall_errors();
  inline ::draiosproto::counter_syscall_errors* release_syscall_errors();
  inline void set_allocated_syscall_errors(::draiosproto::counter_syscall_errors* syscall_errors);

  // optional .draiosproto.counter_time_bytes external_io_net = 10;
  inline bool has_external_io_net() const;
  inline void clear_external_io_net();
  static const int kExternalIoNetFieldNumber = 10;
  inline const ::draiosproto::counter_time_bytes& external_io_net() const;
  inline ::draiosproto::counter_time_bytes* mutable_external_io_net();
  inline ::draiosproto::counter_time_bytes* release_external_io_net();
  inline void set_allocated_external_io_net(::draiosproto::counter_time_bytes* external_io_net);

  // @@protoc_insertion_point(class_scope:draiosproto.host)
 private:
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_num_cpus();
  inline void clear_has_num_cpus();
  inline void set_has_physical_memory_size_bytes();
  inline void clear_has_physical_memory_size_bytes();
  inline void set_has_tcounters();
  inline void clear_has_tcounters();
  inline void set_has_reqcounters();
  inline void clear_has_reqcounters();
  inline void set_has_transaction_counters();
  inline void clear_has_transaction_counters();
  inline void set_has_transaction_processing_delay();
  inline void clear_has_transaction_processing_delay();
  inline void set_has_merged_server_delay();
  inline void clear_has_merged_server_delay();
  inline void set_has_next_tiers_delay();
  inline void clear_has_next_tiers_delay();
  inline void set_has_resource_counters();
  inline void clear_has_resource_counters();
  inline void set_has_syscall_errors();
  inline void clear_has_syscall_errors();
  inline void set_has_external_io_net();
  inline void clear_has_external_io_net();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* hostname_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > cpu_loads_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > cpu_steal_;
  ::google::protobuf::uint64 physical_memory_size_bytes_;
  ::draiosproto::time_categories* tcounters_;
  ::draiosproto::transaction_breakdown_categories* reqcounters_;
  ::draiosproto::counter_time_bidirectional* transaction_counters_;
  ::google::protobuf::uint64 transaction_processing_delay_;
  ::google::protobuf::uint64 merged_server_delay_;
  ::google::protobuf::uint64 next_tiers_delay_;
  ::draiosproto::resource_categories* resource_counters_;
  ::draiosproto::counter_syscall_errors* syscall_errors_;
  ::draiosproto::counter_time_bytes* external_io_net_;
  ::google::protobuf::uint32 num_cpus_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static host* default_instance_;
};
// -------------------------------------------------------------------

class thread : public ::google::protobuf::Message {
 public:
  thread();
  virtual ~thread();

  thread(const thread& from);

  inline thread& operator=(const thread& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const thread& default_instance();

  void Swap(thread* other);

  // implements Message ----------------------------------------------

  thread* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const thread& from);
  void MergeFrom(const thread& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 pid = 1;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 1;
  inline ::google::protobuf::uint64 pid() const;
  inline void set_pid(::google::protobuf::uint64 value);

  // required uint64 tid = 2;
  inline bool has_tid() const;
  inline void clear_tid();
  static const int kTidFieldNumber = 2;
  inline ::google::protobuf::uint64 tid() const;
  inline void set_tid(::google::protobuf::uint64 value);

  // optional .draiosproto.time_categories tcounters = 3;
  inline bool has_tcounters() const;
  inline void clear_tcounters();
  static const int kTcountersFieldNumber = 3;
  inline const ::draiosproto::time_categories& tcounters() const;
  inline ::draiosproto::time_categories* mutable_tcounters();
  inline ::draiosproto::time_categories* release_tcounters();
  inline void set_allocated_tcounters(::draiosproto::time_categories* tcounters);

  // optional .draiosproto.counter_time_bidirectional transaction_counters = 5;
  inline bool has_transaction_counters() const;
  inline void clear_transaction_counters();
  static const int kTransactionCountersFieldNumber = 5;
  inline const ::draiosproto::counter_time_bidirectional& transaction_counters() const;
  inline ::draiosproto::counter_time_bidirectional* mutable_transaction_counters();
  inline ::draiosproto::counter_time_bidirectional* release_transaction_counters();
  inline void set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters);

  // @@protoc_insertion_point(class_scope:draiosproto.thread)
 private:
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_tid();
  inline void clear_has_tid();
  inline void set_has_tcounters();
  inline void clear_has_tcounters();
  inline void set_has_transaction_counters();
  inline void clear_has_transaction_counters();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 pid_;
  ::google::protobuf::uint64 tid_;
  ::draiosproto::time_categories* tcounters_;
  ::draiosproto::counter_time_bidirectional* transaction_counters_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static thread* default_instance_;
};
// -------------------------------------------------------------------

class process : public ::google::protobuf::Message {
 public:
  process();
  virtual ~process();

  process(const process& from);

  inline process& operator=(const process& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const process& default_instance();

  void Swap(process* other);

  // implements Message ----------------------------------------------

  process* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const process& from);
  void MergeFrom(const process& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 pid = 1;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 1;
  inline ::google::protobuf::uint64 pid() const;
  inline void set_pid(::google::protobuf::uint64 value);

  // optional .draiosproto.process_details details = 2;
  inline bool has_details() const;
  inline void clear_details();
  static const int kDetailsFieldNumber = 2;
  inline const ::draiosproto::process_details& details() const;
  inline ::draiosproto::process_details* mutable_details();
  inline ::draiosproto::process_details* release_details();
  inline void set_allocated_details(::draiosproto::process_details* details);

  // optional bool is_ipv4_transaction_server = 3;
  inline bool has_is_ipv4_transaction_server() const;
  inline void clear_is_ipv4_transaction_server();
  static const int kIsIpv4TransactionServerFieldNumber = 3;
  inline bool is_ipv4_transaction_server() const;
  inline void set_is_ipv4_transaction_server(bool value);

  // optional bool is_unix_transaction_server = 4;
  inline bool has_is_unix_transaction_server() const;
  inline void clear_is_unix_transaction_server();
  static const int kIsUnixTransactionServerFieldNumber = 4;
  inline bool is_unix_transaction_server() const;
  inline void set_is_unix_transaction_server(bool value);

  // optional bool is_ipv4_transaction_client = 10;
  inline bool has_is_ipv4_transaction_client() const;
  inline void clear_is_ipv4_transaction_client();
  static const int kIsIpv4TransactionClientFieldNumber = 10;
  inline bool is_ipv4_transaction_client() const;
  inline void set_is_ipv4_transaction_client(bool value);

  // optional bool is_unix_transaction_client = 11;
  inline bool has_is_unix_transaction_client() const;
  inline void clear_is_unix_transaction_client();
  static const int kIsUnixTransactionClientFieldNumber = 11;
  inline bool is_unix_transaction_client() const;
  inline void set_is_unix_transaction_client(bool value);

  // optional uint32 netrole = 13;
  inline bool has_netrole() const;
  inline void clear_netrole();
  static const int kNetroleFieldNumber = 13;
  inline ::google::protobuf::uint32 netrole() const;
  inline void set_netrole(::google::protobuf::uint32 value);

  // optional .draiosproto.time_categories tcounters = 5;
  inline bool has_tcounters() const;
  inline void clear_tcounters();
  static const int kTcountersFieldNumber = 5;
  inline const ::draiosproto::time_categories& tcounters() const;
  inline ::draiosproto::time_categories* mutable_tcounters();
  inline ::draiosproto::time_categories* release_tcounters();
  inline void set_allocated_tcounters(::draiosproto::time_categories* tcounters);

  // optional .draiosproto.counter_time_bidirectional transaction_counters = 6;
  inline bool has_transaction_counters() const;
  inline void clear_transaction_counters();
  static const int kTransactionCountersFieldNumber = 6;
  inline const ::draiosproto::counter_time_bidirectional& transaction_counters() const;
  inline ::draiosproto::counter_time_bidirectional* mutable_transaction_counters();
  inline ::draiosproto::counter_time_bidirectional* release_transaction_counters();
  inline void set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters);

  // optional uint64 transaction_processing_delay = 7;
  inline bool has_transaction_processing_delay() const;
  inline void clear_transaction_processing_delay();
  static const int kTransactionProcessingDelayFieldNumber = 7;
  inline ::google::protobuf::uint64 transaction_processing_delay() const;
  inline void set_transaction_processing_delay(::google::protobuf::uint64 value);

  // optional uint64 merged_server_delay = 14;
  inline bool has_merged_server_delay() const;
  inline void clear_merged_server_delay();
  static const int kMergedServerDelayFieldNumber = 14;
  inline ::google::protobuf::uint64 merged_server_delay() const;
  inline void set_merged_server_delay(::google::protobuf::uint64 value);

  // optional uint64 next_tiers_delay = 12;
  inline bool has_next_tiers_delay() const;
  inline void clear_next_tiers_delay();
  static const int kNextTiersDelayFieldNumber = 12;
  inline ::google::protobuf::uint64 next_tiers_delay() const;
  inline void set_next_tiers_delay(::google::protobuf::uint64 value);

  // optional .draiosproto.resource_categories resource_counters = 8;
  inline bool has_resource_counters() const;
  inline void clear_resource_counters();
  static const int kResourceCountersFieldNumber = 8;
  inline const ::draiosproto::resource_categories& resource_counters() const;
  inline ::draiosproto::resource_categories* mutable_resource_counters();
  inline ::draiosproto::resource_categories* release_resource_counters();
  inline void set_allocated_resource_counters(::draiosproto::resource_categories* resource_counters);

  // optional .draiosproto.counter_syscall_errors syscall_errors = 9;
  inline bool has_syscall_errors() const;
  inline void clear_syscall_errors();
  static const int kSyscallErrorsFieldNumber = 9;
  inline const ::draiosproto::counter_syscall_errors& syscall_errors() const;
  inline ::draiosproto::counter_syscall_errors* mutable_syscall_errors();
  inline ::draiosproto::counter_syscall_errors* release_syscall_errors();
  inline void set_allocated_syscall_errors(::draiosproto::counter_syscall_errors* syscall_errors);

  // @@protoc_insertion_point(class_scope:draiosproto.process)
 private:
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_details();
  inline void clear_has_details();
  inline void set_has_is_ipv4_transaction_server();
  inline void clear_has_is_ipv4_transaction_server();
  inline void set_has_is_unix_transaction_server();
  inline void clear_has_is_unix_transaction_server();
  inline void set_has_is_ipv4_transaction_client();
  inline void clear_has_is_ipv4_transaction_client();
  inline void set_has_is_unix_transaction_client();
  inline void clear_has_is_unix_transaction_client();
  inline void set_has_netrole();
  inline void clear_has_netrole();
  inline void set_has_tcounters();
  inline void clear_has_tcounters();
  inline void set_has_transaction_counters();
  inline void clear_has_transaction_counters();
  inline void set_has_transaction_processing_delay();
  inline void clear_has_transaction_processing_delay();
  inline void set_has_merged_server_delay();
  inline void clear_has_merged_server_delay();
  inline void set_has_next_tiers_delay();
  inline void clear_has_next_tiers_delay();
  inline void set_has_resource_counters();
  inline void clear_has_resource_counters();
  inline void set_has_syscall_errors();
  inline void clear_has_syscall_errors();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 pid_;
  ::draiosproto::process_details* details_;
  bool is_ipv4_transaction_server_;
  bool is_unix_transaction_server_;
  bool is_ipv4_transaction_client_;
  bool is_unix_transaction_client_;
  ::google::protobuf::uint32 netrole_;
  ::draiosproto::time_categories* tcounters_;
  ::draiosproto::counter_time_bidirectional* transaction_counters_;
  ::google::protobuf::uint64 transaction_processing_delay_;
  ::google::protobuf::uint64 merged_server_delay_;
  ::google::protobuf::uint64 next_tiers_delay_;
  ::draiosproto::resource_categories* resource_counters_;
  ::draiosproto::counter_syscall_errors* syscall_errors_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static process* default_instance_;
};
// -------------------------------------------------------------------

class program : public ::google::protobuf::Message {
 public:
  program();
  virtual ~program();

  program(const program& from);

  inline program& operator=(const program& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const program& default_instance();

  void Swap(program* other);

  // implements Message ----------------------------------------------

  program* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const program& from);
  void MergeFrom(const program& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.process procinfo = 1;
  inline bool has_procinfo() const;
  inline void clear_procinfo();
  static const int kProcinfoFieldNumber = 1;
  inline const ::draiosproto::process& procinfo() const;
  inline ::draiosproto::process* mutable_procinfo();
  inline ::draiosproto::process* release_procinfo();
  inline void set_allocated_procinfo(::draiosproto::process* procinfo);

  // repeated uint64 pids = 2;
  inline int pids_size() const;
  inline void clear_pids();
  static const int kPidsFieldNumber = 2;
  inline ::google::protobuf::uint64 pids(int index) const;
  inline void set_pids(int index, ::google::protobuf::uint64 value);
  inline void add_pids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      pids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_pids();

  // @@protoc_insertion_point(class_scope:draiosproto.program)
 private:
  inline void set_has_procinfo();
  inline void clear_has_procinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::draiosproto::process* procinfo_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > pids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static program* default_instance_;
};
// -------------------------------------------------------------------

class ipv4tuple : public ::google::protobuf::Message {
 public:
  ipv4tuple();
  virtual ~ipv4tuple();

  ipv4tuple(const ipv4tuple& from);

  inline ipv4tuple& operator=(const ipv4tuple& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ipv4tuple& default_instance();

  void Swap(ipv4tuple* other);

  // implements Message ----------------------------------------------

  ipv4tuple* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ipv4tuple& from);
  void MergeFrom(const ipv4tuple& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 sip = 1;
  inline bool has_sip() const;
  inline void clear_sip();
  static const int kSipFieldNumber = 1;
  inline ::google::protobuf::uint32 sip() const;
  inline void set_sip(::google::protobuf::uint32 value);

  // required uint32 dip = 2;
  inline bool has_dip() const;
  inline void clear_dip();
  static const int kDipFieldNumber = 2;
  inline ::google::protobuf::uint32 dip() const;
  inline void set_dip(::google::protobuf::uint32 value);

  // required uint32 sport = 3;
  inline bool has_sport() const;
  inline void clear_sport();
  static const int kSportFieldNumber = 3;
  inline ::google::protobuf::uint32 sport() const;
  inline void set_sport(::google::protobuf::uint32 value);

  // required uint32 dport = 4;
  inline bool has_dport() const;
  inline void clear_dport();
  static const int kDportFieldNumber = 4;
  inline ::google::protobuf::uint32 dport() const;
  inline void set_dport(::google::protobuf::uint32 value);

  // required uint32 l4proto = 5;
  inline bool has_l4proto() const;
  inline void clear_l4proto();
  static const int kL4ProtoFieldNumber = 5;
  inline ::google::protobuf::uint32 l4proto() const;
  inline void set_l4proto(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.ipv4tuple)
 private:
  inline void set_has_sip();
  inline void clear_has_sip();
  inline void set_has_dip();
  inline void clear_has_dip();
  inline void set_has_sport();
  inline void clear_has_sport();
  inline void set_has_dport();
  inline void clear_has_dport();
  inline void set_has_l4proto();
  inline void clear_has_l4proto();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 sip_;
  ::google::protobuf::uint32 dip_;
  ::google::protobuf::uint32 sport_;
  ::google::protobuf::uint32 dport_;
  ::google::protobuf::uint32 l4proto_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static ipv4tuple* default_instance_;
};
// -------------------------------------------------------------------

class ipv4_connection : public ::google::protobuf::Message {
 public:
  ipv4_connection();
  virtual ~ipv4_connection();

  ipv4_connection(const ipv4_connection& from);

  inline ipv4_connection& operator=(const ipv4_connection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ipv4_connection& default_instance();

  void Swap(ipv4_connection* other);

  // implements Message ----------------------------------------------

  ipv4_connection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ipv4_connection& from);
  void MergeFrom(const ipv4_connection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.ipv4tuple tuple = 1;
  inline bool has_tuple() const;
  inline void clear_tuple();
  static const int kTupleFieldNumber = 1;
  inline const ::draiosproto::ipv4tuple& tuple() const;
  inline ::draiosproto::ipv4tuple* mutable_tuple();
  inline ::draiosproto::ipv4tuple* release_tuple();
  inline void set_allocated_tuple(::draiosproto::ipv4tuple* tuple);

  // optional uint64 spid = 2;
  inline bool has_spid() const;
  inline void clear_spid();
  static const int kSpidFieldNumber = 2;
  inline ::google::protobuf::uint64 spid() const;
  inline void set_spid(::google::protobuf::uint64 value);

  // optional uint64 stid = 3;
  inline bool has_stid() const;
  inline void clear_stid();
  static const int kStidFieldNumber = 3;
  inline ::google::protobuf::uint64 stid() const;
  inline void set_stid(::google::protobuf::uint64 value);

  // optional uint64 dpid = 5;
  inline bool has_dpid() const;
  inline void clear_dpid();
  static const int kDpidFieldNumber = 5;
  inline ::google::protobuf::uint64 dpid() const;
  inline void set_dpid(::google::protobuf::uint64 value);

  // optional uint64 dtid = 6;
  inline bool has_dtid() const;
  inline void clear_dtid();
  static const int kDtidFieldNumber = 6;
  inline ::google::protobuf::uint64 dtid() const;
  inline void set_dtid(::google::protobuf::uint64 value);

  // required .draiosproto.connection_categories counters = 8;
  inline bool has_counters() const;
  inline void clear_counters();
  static const int kCountersFieldNumber = 8;
  inline const ::draiosproto::connection_categories& counters() const;
  inline ::draiosproto::connection_categories* mutable_counters();
  inline ::draiosproto::connection_categories* release_counters();
  inline void set_allocated_counters(::draiosproto::connection_categories* counters);

  // @@protoc_insertion_point(class_scope:draiosproto.ipv4_connection)
 private:
  inline void set_has_tuple();
  inline void clear_has_tuple();
  inline void set_has_spid();
  inline void clear_has_spid();
  inline void set_has_stid();
  inline void clear_has_stid();
  inline void set_has_dpid();
  inline void clear_has_dpid();
  inline void set_has_dtid();
  inline void clear_has_dtid();
  inline void set_has_counters();
  inline void clear_has_counters();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::draiosproto::ipv4tuple* tuple_;
  ::google::protobuf::uint64 spid_;
  ::google::protobuf::uint64 stid_;
  ::google::protobuf::uint64 dpid_;
  ::google::protobuf::uint64 dtid_;
  ::draiosproto::connection_categories* counters_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static ipv4_connection* default_instance_;
};
// -------------------------------------------------------------------

class ipv4_network_interface : public ::google::protobuf::Message {
 public:
  ipv4_network_interface();
  virtual ~ipv4_network_interface();

  ipv4_network_interface(const ipv4_network_interface& from);

  inline ipv4_network_interface& operator=(const ipv4_network_interface& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ipv4_network_interface& default_instance();

  void Swap(ipv4_network_interface* other);

  // implements Message ----------------------------------------------

  ipv4_network_interface* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ipv4_network_interface& from);
  void MergeFrom(const ipv4_network_interface& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 addr = 2;
  inline bool has_addr() const;
  inline void clear_addr();
  static const int kAddrFieldNumber = 2;
  inline ::google::protobuf::uint32 addr() const;
  inline void set_addr(::google::protobuf::uint32 value);

  // required uint32 netmask = 3;
  inline bool has_netmask() const;
  inline void clear_netmask();
  static const int kNetmaskFieldNumber = 3;
  inline ::google::protobuf::uint32 netmask() const;
  inline void set_netmask(::google::protobuf::uint32 value);

  // optional uint32 bcast = 4;
  inline bool has_bcast() const;
  inline void clear_bcast();
  static const int kBcastFieldNumber = 4;
  inline ::google::protobuf::uint32 bcast() const;
  inline void set_bcast(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.ipv4_network_interface)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_addr();
  inline void clear_has_addr();
  inline void set_has_netmask();
  inline void clear_has_netmask();
  inline void set_has_bcast();
  inline void clear_has_bcast();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 addr_;
  ::google::protobuf::uint32 netmask_;
  ::google::protobuf::uint32 bcast_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static ipv4_network_interface* default_instance_;
};
// -------------------------------------------------------------------

class metrics : public ::google::protobuf::Message {
 public:
  metrics();
  virtual ~metrics();

  metrics(const metrics& from);

  inline metrics& operator=(const metrics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const metrics& default_instance();

  void Swap(metrics* other);

  // implements Message ----------------------------------------------

  metrics* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const metrics& from);
  void MergeFrom(const metrics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  inline bool has_timestamp_ns() const;
  inline void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp_ns() const;
  inline void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  inline bool has_machine_id() const;
  inline void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  inline const ::std::string& machine_id() const;
  inline void set_machine_id(const ::std::string& value);
  inline void set_machine_id(const char* value);
  inline void set_machine_id(const char* value, size_t size);
  inline ::std::string* mutable_machine_id();
  inline ::std::string* release_machine_id();
  inline void set_allocated_machine_id(::std::string* machine_id);

  // optional string customer_id = 3;
  inline bool has_customer_id() const;
  inline void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  inline const ::std::string& customer_id() const;
  inline void set_customer_id(const ::std::string& value);
  inline void set_customer_id(const char* value);
  inline void set_customer_id(const char* value, size_t size);
  inline ::std::string* mutable_customer_id();
  inline ::std::string* release_customer_id();
  inline void set_allocated_customer_id(::std::string* customer_id);

  // required .draiosproto.host hostinfo = 4;
  inline bool has_hostinfo() const;
  inline void clear_hostinfo();
  static const int kHostinfoFieldNumber = 4;
  inline const ::draiosproto::host& hostinfo() const;
  inline ::draiosproto::host* mutable_hostinfo();
  inline ::draiosproto::host* release_hostinfo();
  inline void set_allocated_hostinfo(::draiosproto::host* hostinfo);

  // repeated .draiosproto.program programs = 9;
  inline int programs_size() const;
  inline void clear_programs();
  static const int kProgramsFieldNumber = 9;
  inline const ::draiosproto::program& programs(int index) const;
  inline ::draiosproto::program* mutable_programs(int index);
  inline ::draiosproto::program* add_programs();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::program >&
      programs() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::program >*
      mutable_programs();

  // repeated .draiosproto.process processes = 5;
  inline int processes_size() const;
  inline void clear_processes();
  static const int kProcessesFieldNumber = 5;
  inline const ::draiosproto::process& processes(int index) const;
  inline ::draiosproto::process* mutable_processes(int index);
  inline ::draiosproto::process* add_processes();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::process >&
      processes() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::process >*
      mutable_processes();

  // repeated .draiosproto.thread threads = 6;
  inline int threads_size() const;
  inline void clear_threads();
  static const int kThreadsFieldNumber = 6;
  inline const ::draiosproto::thread& threads(int index) const;
  inline ::draiosproto::thread* mutable_threads(int index);
  inline ::draiosproto::thread* add_threads();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::thread >&
      threads() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::thread >*
      mutable_threads();

  // repeated .draiosproto.ipv4_connection ipv4_connections = 7;
  inline int ipv4_connections_size() const;
  inline void clear_ipv4_connections();
  static const int kIpv4ConnectionsFieldNumber = 7;
  inline const ::draiosproto::ipv4_connection& ipv4_connections(int index) const;
  inline ::draiosproto::ipv4_connection* mutable_ipv4_connections(int index);
  inline ::draiosproto::ipv4_connection* add_ipv4_connections();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_connection >&
      ipv4_connections() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_connection >*
      mutable_ipv4_connections();

  // repeated .draiosproto.ipv4_network_interface ipv4_network_interfaces = 8;
  inline int ipv4_network_interfaces_size() const;
  inline void clear_ipv4_network_interfaces();
  static const int kIpv4NetworkInterfacesFieldNumber = 8;
  inline const ::draiosproto::ipv4_network_interface& ipv4_network_interfaces(int index) const;
  inline ::draiosproto::ipv4_network_interface* mutable_ipv4_network_interfaces(int index);
  inline ::draiosproto::ipv4_network_interface* add_ipv4_network_interfaces();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_network_interface >&
      ipv4_network_interfaces() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_network_interface >*
      mutable_ipv4_network_interfaces();

  // optional uint32 sampling_ratio = 10;
  inline bool has_sampling_ratio() const;
  inline void clear_sampling_ratio();
  static const int kSamplingRatioFieldNumber = 10;
  inline ::google::protobuf::uint32 sampling_ratio() const;
  inline void set_sampling_ratio(::google::protobuf::uint32 value);

  // optional string host_custom_name = 11;
  inline bool has_host_custom_name() const;
  inline void clear_host_custom_name();
  static const int kHostCustomNameFieldNumber = 11;
  inline const ::std::string& host_custom_name() const;
  inline void set_host_custom_name(const ::std::string& value);
  inline void set_host_custom_name(const char* value);
  inline void set_host_custom_name(const char* value, size_t size);
  inline ::std::string* mutable_host_custom_name();
  inline ::std::string* release_host_custom_name();
  inline void set_allocated_host_custom_name(::std::string* host_custom_name);

  // optional string host_custom_group = 12;
  inline bool has_host_custom_group() const;
  inline void clear_host_custom_group();
  static const int kHostCustomGroupFieldNumber = 12;
  inline const ::std::string& host_custom_group() const;
  inline void set_host_custom_group(const ::std::string& value);
  inline void set_host_custom_group(const char* value);
  inline void set_host_custom_group(const char* value, size_t size);
  inline ::std::string* mutable_host_custom_group();
  inline ::std::string* release_host_custom_group();
  inline void set_allocated_host_custom_group(::std::string* host_custom_group);

  // optional bool is_host_hidden = 13;
  inline bool has_is_host_hidden() const;
  inline void clear_is_host_hidden();
  static const int kIsHostHiddenFieldNumber = 13;
  inline bool is_host_hidden() const;
  inline void set_is_host_hidden(bool value);

  // optional string hidden_processes = 14;
  inline bool has_hidden_processes() const;
  inline void clear_hidden_processes();
  static const int kHiddenProcessesFieldNumber = 14;
  inline const ::std::string& hidden_processes() const;
  inline void set_hidden_processes(const ::std::string& value);
  inline void set_hidden_processes(const char* value);
  inline void set_hidden_processes(const char* value, size_t size);
  inline ::std::string* mutable_hidden_processes();
  inline ::std::string* release_hidden_processes();
  inline void set_allocated_hidden_processes(::std::string* hidden_processes);

  // @@protoc_insertion_point(class_scope:draiosproto.metrics)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();
  inline void set_has_hostinfo();
  inline void clear_has_hostinfo();
  inline void set_has_sampling_ratio();
  inline void clear_has_sampling_ratio();
  inline void set_has_host_custom_name();
  inline void clear_has_host_custom_name();
  inline void set_has_host_custom_group();
  inline void clear_has_host_custom_group();
  inline void set_has_is_host_hidden();
  inline void clear_has_is_host_hidden();
  inline void set_has_hidden_processes();
  inline void clear_has_hidden_processes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 timestamp_ns_;
  ::std::string* machine_id_;
  ::std::string* customer_id_;
  ::draiosproto::host* hostinfo_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::program > programs_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::process > processes_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::thread > threads_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_connection > ipv4_connections_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_network_interface > ipv4_network_interfaces_;
  ::std::string* host_custom_name_;
  ::google::protobuf::uint32 sampling_ratio_;
  bool is_host_hidden_;
  ::std::string* host_custom_group_;
  ::std::string* hidden_processes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static metrics* default_instance_;
};
// -------------------------------------------------------------------

class dump_request : public ::google::protobuf::Message {
 public:
  dump_request();
  virtual ~dump_request();

  dump_request(const dump_request& from);

  inline dump_request& operator=(const dump_request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dump_request& default_instance();

  void Swap(dump_request* other);

  // implements Message ----------------------------------------------

  dump_request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dump_request& from);
  void MergeFrom(const dump_request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  inline bool has_timestamp_ns() const;
  inline void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp_ns() const;
  inline void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  inline bool has_machine_id() const;
  inline void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  inline const ::std::string& machine_id() const;
  inline void set_machine_id(const ::std::string& value);
  inline void set_machine_id(const char* value);
  inline void set_machine_id(const char* value, size_t size);
  inline ::std::string* mutable_machine_id();
  inline ::std::string* release_machine_id();
  inline void set_allocated_machine_id(::std::string* machine_id);

  // optional string customer_id = 3;
  inline bool has_customer_id() const;
  inline void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  inline const ::std::string& customer_id() const;
  inline void set_customer_id(const ::std::string& value);
  inline void set_customer_id(const char* value);
  inline void set_customer_id(const char* value, size_t size);
  inline ::std::string* mutable_customer_id();
  inline ::std::string* release_customer_id();
  inline void set_allocated_customer_id(::std::string* customer_id);

  // required uint64 duration_ns = 4;
  inline bool has_duration_ns() const;
  inline void clear_duration_ns();
  static const int kDurationNsFieldNumber = 4;
  inline ::google::protobuf::uint64 duration_ns() const;
  inline void set_duration_ns(::google::protobuf::uint64 value);

  // optional string filters = 5;
  inline bool has_filters() const;
  inline void clear_filters();
  static const int kFiltersFieldNumber = 5;
  inline const ::std::string& filters() const;
  inline void set_filters(const ::std::string& value);
  inline void set_filters(const char* value);
  inline void set_filters(const char* value, size_t size);
  inline ::std::string* mutable_filters();
  inline ::std::string* release_filters();
  inline void set_allocated_filters(::std::string* filters);

  // @@protoc_insertion_point(class_scope:draiosproto.dump_request)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();
  inline void set_has_duration_ns();
  inline void clear_has_duration_ns();
  inline void set_has_filters();
  inline void clear_has_filters();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 timestamp_ns_;
  ::std::string* machine_id_;
  ::std::string* customer_id_;
  ::google::protobuf::uint64 duration_ns_;
  ::std::string* filters_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static dump_request* default_instance_;
};
// -------------------------------------------------------------------

class dump_response : public ::google::protobuf::Message {
 public:
  dump_response();
  virtual ~dump_response();

  dump_response(const dump_response& from);

  inline dump_response& operator=(const dump_response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dump_response& default_instance();

  void Swap(dump_response* other);

  // implements Message ----------------------------------------------

  dump_response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dump_response& from);
  void MergeFrom(const dump_response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  inline bool has_timestamp_ns() const;
  inline void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp_ns() const;
  inline void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  inline bool has_machine_id() const;
  inline void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  inline const ::std::string& machine_id() const;
  inline void set_machine_id(const ::std::string& value);
  inline void set_machine_id(const char* value);
  inline void set_machine_id(const char* value, size_t size);
  inline ::std::string* mutable_machine_id();
  inline ::std::string* release_machine_id();
  inline void set_allocated_machine_id(::std::string* machine_id);

  // optional string customer_id = 3;
  inline bool has_customer_id() const;
  inline void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  inline const ::std::string& customer_id() const;
  inline void set_customer_id(const ::std::string& value);
  inline void set_customer_id(const char* value);
  inline void set_customer_id(const char* value, size_t size);
  inline ::std::string* mutable_customer_id();
  inline ::std::string* release_customer_id();
  inline void set_allocated_customer_id(::std::string* customer_id);

  // optional bytes content = 4;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 4;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional string error = 5;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 5;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  inline void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:draiosproto.dump_response)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 timestamp_ns_;
  ::std::string* machine_id_;
  ::std::string* customer_id_;
  ::std::string* content_;
  ::std::string* error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static dump_response* default_instance_;
};
// -------------------------------------------------------------------

class exec_cmd_request : public ::google::protobuf::Message {
 public:
  exec_cmd_request();
  virtual ~exec_cmd_request();

  exec_cmd_request(const exec_cmd_request& from);

  inline exec_cmd_request& operator=(const exec_cmd_request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const exec_cmd_request& default_instance();

  void Swap(exec_cmd_request* other);

  // implements Message ----------------------------------------------

  exec_cmd_request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const exec_cmd_request& from);
  void MergeFrom(const exec_cmd_request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  inline bool has_timestamp_ns() const;
  inline void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp_ns() const;
  inline void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  inline bool has_machine_id() const;
  inline void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  inline const ::std::string& machine_id() const;
  inline void set_machine_id(const ::std::string& value);
  inline void set_machine_id(const char* value);
  inline void set_machine_id(const char* value, size_t size);
  inline ::std::string* mutable_machine_id();
  inline ::std::string* release_machine_id();
  inline void set_allocated_machine_id(::std::string* machine_id);

  // optional string customer_id = 3;
  inline bool has_customer_id() const;
  inline void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  inline const ::std::string& customer_id() const;
  inline void set_customer_id(const ::std::string& value);
  inline void set_customer_id(const char* value);
  inline void set_customer_id(const char* value, size_t size);
  inline ::std::string* mutable_customer_id();
  inline ::std::string* release_customer_id();
  inline void set_allocated_customer_id(::std::string* customer_id);

  // required string token = 4;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 4;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // required string command_line = 5;
  inline bool has_command_line() const;
  inline void clear_command_line();
  static const int kCommandLineFieldNumber = 5;
  inline const ::std::string& command_line() const;
  inline void set_command_line(const ::std::string& value);
  inline void set_command_line(const char* value);
  inline void set_command_line(const char* value, size_t size);
  inline ::std::string* mutable_command_line();
  inline ::std::string* release_command_line();
  inline void set_allocated_command_line(::std::string* command_line);

  // @@protoc_insertion_point(class_scope:draiosproto.exec_cmd_request)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_command_line();
  inline void clear_has_command_line();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 timestamp_ns_;
  ::std::string* machine_id_;
  ::std::string* customer_id_;
  ::std::string* token_;
  ::std::string* command_line_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static exec_cmd_request* default_instance_;
};
// -------------------------------------------------------------------

class exec_cmd_response : public ::google::protobuf::Message {
 public:
  exec_cmd_response();
  virtual ~exec_cmd_response();

  exec_cmd_response(const exec_cmd_response& from);

  inline exec_cmd_response& operator=(const exec_cmd_response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const exec_cmd_response& default_instance();

  void Swap(exec_cmd_response* other);

  // implements Message ----------------------------------------------

  exec_cmd_response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const exec_cmd_response& from);
  void MergeFrom(const exec_cmd_response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  inline bool has_timestamp_ns() const;
  inline void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp_ns() const;
  inline void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  inline bool has_machine_id() const;
  inline void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  inline const ::std::string& machine_id() const;
  inline void set_machine_id(const ::std::string& value);
  inline void set_machine_id(const char* value);
  inline void set_machine_id(const char* value, size_t size);
  inline ::std::string* mutable_machine_id();
  inline ::std::string* release_machine_id();
  inline void set_allocated_machine_id(::std::string* machine_id);

  // optional string customer_id = 3;
  inline bool has_customer_id() const;
  inline void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  inline const ::std::string& customer_id() const;
  inline void set_customer_id(const ::std::string& value);
  inline void set_customer_id(const char* value);
  inline void set_customer_id(const char* value, size_t size);
  inline ::std::string* mutable_customer_id();
  inline ::std::string* release_customer_id();
  inline void set_allocated_customer_id(::std::string* customer_id);

  // required string token = 4;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 4;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional string std_out = 5;
  inline bool has_std_out() const;
  inline void clear_std_out();
  static const int kStdOutFieldNumber = 5;
  inline const ::std::string& std_out() const;
  inline void set_std_out(const ::std::string& value);
  inline void set_std_out(const char* value);
  inline void set_std_out(const char* value, size_t size);
  inline ::std::string* mutable_std_out();
  inline ::std::string* release_std_out();
  inline void set_allocated_std_out(::std::string* std_out);

  // optional string std_err = 6;
  inline bool has_std_err() const;
  inline void clear_std_err();
  static const int kStdErrFieldNumber = 6;
  inline const ::std::string& std_err() const;
  inline void set_std_err(const ::std::string& value);
  inline void set_std_err(const char* value);
  inline void set_std_err(const char* value, size_t size);
  inline ::std::string* mutable_std_err();
  inline ::std::string* release_std_err();
  inline void set_allocated_std_err(::std::string* std_err);

  // optional uint32 exit_val = 7;
  inline bool has_exit_val() const;
  inline void clear_exit_val();
  static const int kExitValFieldNumber = 7;
  inline ::google::protobuf::uint32 exit_val() const;
  inline void set_exit_val(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.exec_cmd_response)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_std_out();
  inline void clear_has_std_out();
  inline void set_has_std_err();
  inline void clear_has_std_err();
  inline void set_has_exit_val();
  inline void clear_has_exit_val();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 timestamp_ns_;
  ::std::string* machine_id_;
  ::std::string* customer_id_;
  ::std::string* token_;
  ::std::string* std_out_;
  ::std::string* std_err_;
  ::google::protobuf::uint32 exit_val_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static exec_cmd_response* default_instance_;
};
// -------------------------------------------------------------------

class ssh_open_channel : public ::google::protobuf::Message {
 public:
  ssh_open_channel();
  virtual ~ssh_open_channel();

  ssh_open_channel(const ssh_open_channel& from);

  inline ssh_open_channel& operator=(const ssh_open_channel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ssh_open_channel& default_instance();

  void Swap(ssh_open_channel* other);

  // implements Message ----------------------------------------------

  ssh_open_channel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ssh_open_channel& from);
  void MergeFrom(const ssh_open_channel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  inline bool has_timestamp_ns() const;
  inline void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp_ns() const;
  inline void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  inline bool has_machine_id() const;
  inline void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  inline const ::std::string& machine_id() const;
  inline void set_machine_id(const ::std::string& value);
  inline void set_machine_id(const char* value);
  inline void set_machine_id(const char* value, size_t size);
  inline ::std::string* mutable_machine_id();
  inline ::std::string* release_machine_id();
  inline void set_allocated_machine_id(::std::string* machine_id);

  // optional string customer_id = 3;
  inline bool has_customer_id() const;
  inline void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  inline const ::std::string& customer_id() const;
  inline void set_customer_id(const ::std::string& value);
  inline void set_customer_id(const char* value);
  inline void set_customer_id(const char* value, size_t size);
  inline ::std::string* mutable_customer_id();
  inline ::std::string* release_customer_id();
  inline void set_allocated_customer_id(::std::string* customer_id);

  // required string token = 4;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 4;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // required string user = 5;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 5;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // optional string password = 6;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 6;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string key = 7;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 7;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string passphrase = 8;
  inline bool has_passphrase() const;
  inline void clear_passphrase();
  static const int kPassphraseFieldNumber = 8;
  inline const ::std::string& passphrase() const;
  inline void set_passphrase(const ::std::string& value);
  inline void set_passphrase(const char* value);
  inline void set_passphrase(const char* value, size_t size);
  inline ::std::string* mutable_passphrase();
  inline ::std::string* release_passphrase();
  inline void set_allocated_passphrase(::std::string* passphrase);

  // optional uint32 port = 9;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 9;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.ssh_open_channel)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_passphrase();
  inline void clear_has_passphrase();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 timestamp_ns_;
  ::std::string* machine_id_;
  ::std::string* customer_id_;
  ::std::string* token_;
  ::std::string* user_;
  ::std::string* password_;
  ::std::string* key_;
  ::std::string* passphrase_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static ssh_open_channel* default_instance_;
};
// -------------------------------------------------------------------

class ssh_data : public ::google::protobuf::Message {
 public:
  ssh_data();
  virtual ~ssh_data();

  ssh_data(const ssh_data& from);

  inline ssh_data& operator=(const ssh_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ssh_data& default_instance();

  void Swap(ssh_data* other);

  // implements Message ----------------------------------------------

  ssh_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ssh_data& from);
  void MergeFrom(const ssh_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  inline bool has_timestamp_ns() const;
  inline void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp_ns() const;
  inline void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  inline bool has_machine_id() const;
  inline void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  inline const ::std::string& machine_id() const;
  inline void set_machine_id(const ::std::string& value);
  inline void set_machine_id(const char* value);
  inline void set_machine_id(const char* value, size_t size);
  inline ::std::string* mutable_machine_id();
  inline ::std::string* release_machine_id();
  inline void set_allocated_machine_id(::std::string* machine_id);

  // optional string customer_id = 3;
  inline bool has_customer_id() const;
  inline void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  inline const ::std::string& customer_id() const;
  inline void set_customer_id(const ::std::string& value);
  inline void set_customer_id(const char* value);
  inline void set_customer_id(const char* value, size_t size);
  inline ::std::string* mutable_customer_id();
  inline ::std::string* release_customer_id();
  inline void set_allocated_customer_id(::std::string* customer_id);

  // required string token = 4;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 4;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional bytes data = 5;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 5;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional string error = 6;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 6;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  inline void set_allocated_error(::std::string* error);

  // optional int32 exit_val = 7;
  inline bool has_exit_val() const;
  inline void clear_exit_val();
  static const int kExitValFieldNumber = 7;
  inline ::google::protobuf::int32 exit_val() const;
  inline void set_exit_val(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.ssh_data)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_exit_val();
  inline void clear_has_exit_val();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 timestamp_ns_;
  ::std::string* machine_id_;
  ::std::string* customer_id_;
  ::std::string* token_;
  ::std::string* data_;
  ::std::string* error_;
  ::google::protobuf::int32 exit_val_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static ssh_data* default_instance_;
};
// -------------------------------------------------------------------

class ssh_close_channel : public ::google::protobuf::Message {
 public:
  ssh_close_channel();
  virtual ~ssh_close_channel();

  ssh_close_channel(const ssh_close_channel& from);

  inline ssh_close_channel& operator=(const ssh_close_channel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ssh_close_channel& default_instance();

  void Swap(ssh_close_channel* other);

  // implements Message ----------------------------------------------

  ssh_close_channel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ssh_close_channel& from);
  void MergeFrom(const ssh_close_channel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  inline bool has_timestamp_ns() const;
  inline void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp_ns() const;
  inline void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  inline bool has_machine_id() const;
  inline void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  inline const ::std::string& machine_id() const;
  inline void set_machine_id(const ::std::string& value);
  inline void set_machine_id(const char* value);
  inline void set_machine_id(const char* value, size_t size);
  inline ::std::string* mutable_machine_id();
  inline ::std::string* release_machine_id();
  inline void set_allocated_machine_id(::std::string* machine_id);

  // optional string customer_id = 3;
  inline bool has_customer_id() const;
  inline void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  inline const ::std::string& customer_id() const;
  inline void set_customer_id(const ::std::string& value);
  inline void set_customer_id(const char* value);
  inline void set_customer_id(const char* value, size_t size);
  inline ::std::string* mutable_customer_id();
  inline ::std::string* release_customer_id();
  inline void set_allocated_customer_id(::std::string* customer_id);

  // required string token = 4;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 4;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:draiosproto.ssh_close_channel)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 timestamp_ns_;
  ::std::string* machine_id_;
  ::std::string* customer_id_;
  ::std::string* token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static ssh_close_channel* default_instance_;
};
// ===================================================================


// ===================================================================

// counter_time

// required uint32 count = 1;
inline bool counter_time::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void counter_time::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void counter_time::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void counter_time::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 counter_time::count() const {
  return count_;
}
inline void counter_time::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// required uint64 time_ns = 2;
inline bool counter_time::has_time_ns() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void counter_time::set_has_time_ns() {
  _has_bits_[0] |= 0x00000002u;
}
inline void counter_time::clear_has_time_ns() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void counter_time::clear_time_ns() {
  time_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_time_ns();
}
inline ::google::protobuf::uint64 counter_time::time_ns() const {
  return time_ns_;
}
inline void counter_time::set_time_ns(::google::protobuf::uint64 value) {
  set_has_time_ns();
  time_ns_ = value;
}

// optional uint32 time_percentage = 3;
inline bool counter_time::has_time_percentage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void counter_time::set_has_time_percentage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void counter_time::clear_has_time_percentage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void counter_time::clear_time_percentage() {
  time_percentage_ = 0u;
  clear_has_time_percentage();
}
inline ::google::protobuf::uint32 counter_time::time_percentage() const {
  return time_percentage_;
}
inline void counter_time::set_time_percentage(::google::protobuf::uint32 value) {
  set_has_time_percentage();
  time_percentage_ = value;
}

// -------------------------------------------------------------------

// counter_time_bidirectional

// required uint32 count_in = 1;
inline bool counter_time_bidirectional::has_count_in() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void counter_time_bidirectional::set_has_count_in() {
  _has_bits_[0] |= 0x00000001u;
}
inline void counter_time_bidirectional::clear_has_count_in() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void counter_time_bidirectional::clear_count_in() {
  count_in_ = 0u;
  clear_has_count_in();
}
inline ::google::protobuf::uint32 counter_time_bidirectional::count_in() const {
  return count_in_;
}
inline void counter_time_bidirectional::set_count_in(::google::protobuf::uint32 value) {
  set_has_count_in();
  count_in_ = value;
}

// required uint32 count_out = 2;
inline bool counter_time_bidirectional::has_count_out() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void counter_time_bidirectional::set_has_count_out() {
  _has_bits_[0] |= 0x00000002u;
}
inline void counter_time_bidirectional::clear_has_count_out() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void counter_time_bidirectional::clear_count_out() {
  count_out_ = 0u;
  clear_has_count_out();
}
inline ::google::protobuf::uint32 counter_time_bidirectional::count_out() const {
  return count_out_;
}
inline void counter_time_bidirectional::set_count_out(::google::protobuf::uint32 value) {
  set_has_count_out();
  count_out_ = value;
}

// required uint64 time_ns_in = 3;
inline bool counter_time_bidirectional::has_time_ns_in() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void counter_time_bidirectional::set_has_time_ns_in() {
  _has_bits_[0] |= 0x00000004u;
}
inline void counter_time_bidirectional::clear_has_time_ns_in() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void counter_time_bidirectional::clear_time_ns_in() {
  time_ns_in_ = GOOGLE_ULONGLONG(0);
  clear_has_time_ns_in();
}
inline ::google::protobuf::uint64 counter_time_bidirectional::time_ns_in() const {
  return time_ns_in_;
}
inline void counter_time_bidirectional::set_time_ns_in(::google::protobuf::uint64 value) {
  set_has_time_ns_in();
  time_ns_in_ = value;
}

// required uint64 time_ns_out = 4;
inline bool counter_time_bidirectional::has_time_ns_out() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void counter_time_bidirectional::set_has_time_ns_out() {
  _has_bits_[0] |= 0x00000008u;
}
inline void counter_time_bidirectional::clear_has_time_ns_out() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void counter_time_bidirectional::clear_time_ns_out() {
  time_ns_out_ = GOOGLE_ULONGLONG(0);
  clear_has_time_ns_out();
}
inline ::google::protobuf::uint64 counter_time_bidirectional::time_ns_out() const {
  return time_ns_out_;
}
inline void counter_time_bidirectional::set_time_ns_out(::google::protobuf::uint64 value) {
  set_has_time_ns_out();
  time_ns_out_ = value;
}

// -------------------------------------------------------------------

// counter_bytes

// required uint32 count_in = 1;
inline bool counter_bytes::has_count_in() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void counter_bytes::set_has_count_in() {
  _has_bits_[0] |= 0x00000001u;
}
inline void counter_bytes::clear_has_count_in() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void counter_bytes::clear_count_in() {
  count_in_ = 0u;
  clear_has_count_in();
}
inline ::google::protobuf::uint32 counter_bytes::count_in() const {
  return count_in_;
}
inline void counter_bytes::set_count_in(::google::protobuf::uint32 value) {
  set_has_count_in();
  count_in_ = value;
}

// required uint32 count_out = 2;
inline bool counter_bytes::has_count_out() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void counter_bytes::set_has_count_out() {
  _has_bits_[0] |= 0x00000002u;
}
inline void counter_bytes::clear_has_count_out() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void counter_bytes::clear_count_out() {
  count_out_ = 0u;
  clear_has_count_out();
}
inline ::google::protobuf::uint32 counter_bytes::count_out() const {
  return count_out_;
}
inline void counter_bytes::set_count_out(::google::protobuf::uint32 value) {
  set_has_count_out();
  count_out_ = value;
}

// required uint32 bytes_in = 3;
inline bool counter_bytes::has_bytes_in() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void counter_bytes::set_has_bytes_in() {
  _has_bits_[0] |= 0x00000004u;
}
inline void counter_bytes::clear_has_bytes_in() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void counter_bytes::clear_bytes_in() {
  bytes_in_ = 0u;
  clear_has_bytes_in();
}
inline ::google::protobuf::uint32 counter_bytes::bytes_in() const {
  return bytes_in_;
}
inline void counter_bytes::set_bytes_in(::google::protobuf::uint32 value) {
  set_has_bytes_in();
  bytes_in_ = value;
}

// required uint32 bytes_out = 4;
inline bool counter_bytes::has_bytes_out() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void counter_bytes::set_has_bytes_out() {
  _has_bits_[0] |= 0x00000008u;
}
inline void counter_bytes::clear_has_bytes_out() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void counter_bytes::clear_bytes_out() {
  bytes_out_ = 0u;
  clear_has_bytes_out();
}
inline ::google::protobuf::uint32 counter_bytes::bytes_out() const {
  return bytes_out_;
}
inline void counter_bytes::set_bytes_out(::google::protobuf::uint32 value) {
  set_has_bytes_out();
  bytes_out_ = value;
}

// -------------------------------------------------------------------

// counter_time_bytes

// required uint64 time_ns_in = 1;
inline bool counter_time_bytes::has_time_ns_in() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void counter_time_bytes::set_has_time_ns_in() {
  _has_bits_[0] |= 0x00000001u;
}
inline void counter_time_bytes::clear_has_time_ns_in() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void counter_time_bytes::clear_time_ns_in() {
  time_ns_in_ = GOOGLE_ULONGLONG(0);
  clear_has_time_ns_in();
}
inline ::google::protobuf::uint64 counter_time_bytes::time_ns_in() const {
  return time_ns_in_;
}
inline void counter_time_bytes::set_time_ns_in(::google::protobuf::uint64 value) {
  set_has_time_ns_in();
  time_ns_in_ = value;
}

// required uint64 time_ns_out = 2;
inline bool counter_time_bytes::has_time_ns_out() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void counter_time_bytes::set_has_time_ns_out() {
  _has_bits_[0] |= 0x00000002u;
}
inline void counter_time_bytes::clear_has_time_ns_out() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void counter_time_bytes::clear_time_ns_out() {
  time_ns_out_ = GOOGLE_ULONGLONG(0);
  clear_has_time_ns_out();
}
inline ::google::protobuf::uint64 counter_time_bytes::time_ns_out() const {
  return time_ns_out_;
}
inline void counter_time_bytes::set_time_ns_out(::google::protobuf::uint64 value) {
  set_has_time_ns_out();
  time_ns_out_ = value;
}

// required uint64 time_ns_other = 3;
inline bool counter_time_bytes::has_time_ns_other() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void counter_time_bytes::set_has_time_ns_other() {
  _has_bits_[0] |= 0x00000004u;
}
inline void counter_time_bytes::clear_has_time_ns_other() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void counter_time_bytes::clear_time_ns_other() {
  time_ns_other_ = GOOGLE_ULONGLONG(0);
  clear_has_time_ns_other();
}
inline ::google::protobuf::uint64 counter_time_bytes::time_ns_other() const {
  return time_ns_other_;
}
inline void counter_time_bytes::set_time_ns_other(::google::protobuf::uint64 value) {
  set_has_time_ns_other();
  time_ns_other_ = value;
}

// required uint32 count_in = 4;
inline bool counter_time_bytes::has_count_in() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void counter_time_bytes::set_has_count_in() {
  _has_bits_[0] |= 0x00000008u;
}
inline void counter_time_bytes::clear_has_count_in() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void counter_time_bytes::clear_count_in() {
  count_in_ = 0u;
  clear_has_count_in();
}
inline ::google::protobuf::uint32 counter_time_bytes::count_in() const {
  return count_in_;
}
inline void counter_time_bytes::set_count_in(::google::protobuf::uint32 value) {
  set_has_count_in();
  count_in_ = value;
}

// required uint32 count_out = 5;
inline bool counter_time_bytes::has_count_out() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void counter_time_bytes::set_has_count_out() {
  _has_bits_[0] |= 0x00000010u;
}
inline void counter_time_bytes::clear_has_count_out() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void counter_time_bytes::clear_count_out() {
  count_out_ = 0u;
  clear_has_count_out();
}
inline ::google::protobuf::uint32 counter_time_bytes::count_out() const {
  return count_out_;
}
inline void counter_time_bytes::set_count_out(::google::protobuf::uint32 value) {
  set_has_count_out();
  count_out_ = value;
}

// required uint32 count_other = 6;
inline bool counter_time_bytes::has_count_other() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void counter_time_bytes::set_has_count_other() {
  _has_bits_[0] |= 0x00000020u;
}
inline void counter_time_bytes::clear_has_count_other() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void counter_time_bytes::clear_count_other() {
  count_other_ = 0u;
  clear_has_count_other();
}
inline ::google::protobuf::uint32 counter_time_bytes::count_other() const {
  return count_other_;
}
inline void counter_time_bytes::set_count_other(::google::protobuf::uint32 value) {
  set_has_count_other();
  count_other_ = value;
}

// required uint32 bytes_in = 7;
inline bool counter_time_bytes::has_bytes_in() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void counter_time_bytes::set_has_bytes_in() {
  _has_bits_[0] |= 0x00000040u;
}
inline void counter_time_bytes::clear_has_bytes_in() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void counter_time_bytes::clear_bytes_in() {
  bytes_in_ = 0u;
  clear_has_bytes_in();
}
inline ::google::protobuf::uint32 counter_time_bytes::bytes_in() const {
  return bytes_in_;
}
inline void counter_time_bytes::set_bytes_in(::google::protobuf::uint32 value) {
  set_has_bytes_in();
  bytes_in_ = value;
}

// required uint32 bytes_out = 8;
inline bool counter_time_bytes::has_bytes_out() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void counter_time_bytes::set_has_bytes_out() {
  _has_bits_[0] |= 0x00000080u;
}
inline void counter_time_bytes::clear_has_bytes_out() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void counter_time_bytes::clear_bytes_out() {
  bytes_out_ = 0u;
  clear_has_bytes_out();
}
inline ::google::protobuf::uint32 counter_time_bytes::bytes_out() const {
  return bytes_out_;
}
inline void counter_time_bytes::set_bytes_out(::google::protobuf::uint32 value) {
  set_has_bytes_out();
  bytes_out_ = value;
}

// required uint32 bytes_other = 9;
inline bool counter_time_bytes::has_bytes_other() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void counter_time_bytes::set_has_bytes_other() {
  _has_bits_[0] |= 0x00000100u;
}
inline void counter_time_bytes::clear_has_bytes_other() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void counter_time_bytes::clear_bytes_other() {
  bytes_other_ = 0u;
  clear_has_bytes_other();
}
inline ::google::protobuf::uint32 counter_time_bytes::bytes_other() const {
  return bytes_other_;
}
inline void counter_time_bytes::set_bytes_other(::google::protobuf::uint32 value) {
  set_has_bytes_other();
  bytes_other_ = value;
}

// optional uint32 time_percentage_in = 10;
inline bool counter_time_bytes::has_time_percentage_in() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void counter_time_bytes::set_has_time_percentage_in() {
  _has_bits_[0] |= 0x00000200u;
}
inline void counter_time_bytes::clear_has_time_percentage_in() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void counter_time_bytes::clear_time_percentage_in() {
  time_percentage_in_ = 0u;
  clear_has_time_percentage_in();
}
inline ::google::protobuf::uint32 counter_time_bytes::time_percentage_in() const {
  return time_percentage_in_;
}
inline void counter_time_bytes::set_time_percentage_in(::google::protobuf::uint32 value) {
  set_has_time_percentage_in();
  time_percentage_in_ = value;
}

// optional uint32 time_percentage_out = 11;
inline bool counter_time_bytes::has_time_percentage_out() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void counter_time_bytes::set_has_time_percentage_out() {
  _has_bits_[0] |= 0x00000400u;
}
inline void counter_time_bytes::clear_has_time_percentage_out() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void counter_time_bytes::clear_time_percentage_out() {
  time_percentage_out_ = 0u;
  clear_has_time_percentage_out();
}
inline ::google::protobuf::uint32 counter_time_bytes::time_percentage_out() const {
  return time_percentage_out_;
}
inline void counter_time_bytes::set_time_percentage_out(::google::protobuf::uint32 value) {
  set_has_time_percentage_out();
  time_percentage_out_ = value;
}

// optional uint32 time_percentage_other = 12;
inline bool counter_time_bytes::has_time_percentage_other() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void counter_time_bytes::set_has_time_percentage_other() {
  _has_bits_[0] |= 0x00000800u;
}
inline void counter_time_bytes::clear_has_time_percentage_other() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void counter_time_bytes::clear_time_percentage_other() {
  time_percentage_other_ = 0u;
  clear_has_time_percentage_other();
}
inline ::google::protobuf::uint32 counter_time_bytes::time_percentage_other() const {
  return time_percentage_other_;
}
inline void counter_time_bytes::set_time_percentage_other(::google::protobuf::uint32 value) {
  set_has_time_percentage_other();
  time_percentage_other_ = value;
}

// -------------------------------------------------------------------

// time_categories

// optional .draiosproto.counter_time unknown = 1;
inline bool time_categories::has_unknown() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void time_categories::set_has_unknown() {
  _has_bits_[0] |= 0x00000001u;
}
inline void time_categories::clear_has_unknown() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void time_categories::clear_unknown() {
  if (unknown_ != NULL) unknown_->::draiosproto::counter_time::Clear();
  clear_has_unknown();
}
inline const ::draiosproto::counter_time& time_categories::unknown() const {
  return unknown_ != NULL ? *unknown_ : *default_instance_->unknown_;
}
inline ::draiosproto::counter_time* time_categories::mutable_unknown() {
  set_has_unknown();
  if (unknown_ == NULL) unknown_ = new ::draiosproto::counter_time;
  return unknown_;
}
inline ::draiosproto::counter_time* time_categories::release_unknown() {
  clear_has_unknown();
  ::draiosproto::counter_time* temp = unknown_;
  unknown_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_unknown(::draiosproto::counter_time* unknown) {
  delete unknown_;
  unknown_ = unknown;
  if (unknown) {
    set_has_unknown();
  } else {
    clear_has_unknown();
  }
}

// optional .draiosproto.counter_time other = 2;
inline bool time_categories::has_other() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void time_categories::set_has_other() {
  _has_bits_[0] |= 0x00000002u;
}
inline void time_categories::clear_has_other() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void time_categories::clear_other() {
  if (other_ != NULL) other_->::draiosproto::counter_time::Clear();
  clear_has_other();
}
inline const ::draiosproto::counter_time& time_categories::other() const {
  return other_ != NULL ? *other_ : *default_instance_->other_;
}
inline ::draiosproto::counter_time* time_categories::mutable_other() {
  set_has_other();
  if (other_ == NULL) other_ = new ::draiosproto::counter_time;
  return other_;
}
inline ::draiosproto::counter_time* time_categories::release_other() {
  clear_has_other();
  ::draiosproto::counter_time* temp = other_;
  other_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_other(::draiosproto::counter_time* other) {
  delete other_;
  other_ = other;
  if (other) {
    set_has_other();
  } else {
    clear_has_other();
  }
}

// optional .draiosproto.counter_time file = 3;
inline bool time_categories::has_file() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void time_categories::set_has_file() {
  _has_bits_[0] |= 0x00000004u;
}
inline void time_categories::clear_has_file() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void time_categories::clear_file() {
  if (file_ != NULL) file_->::draiosproto::counter_time::Clear();
  clear_has_file();
}
inline const ::draiosproto::counter_time& time_categories::file() const {
  return file_ != NULL ? *file_ : *default_instance_->file_;
}
inline ::draiosproto::counter_time* time_categories::mutable_file() {
  set_has_file();
  if (file_ == NULL) file_ = new ::draiosproto::counter_time;
  return file_;
}
inline ::draiosproto::counter_time* time_categories::release_file() {
  clear_has_file();
  ::draiosproto::counter_time* temp = file_;
  file_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_file(::draiosproto::counter_time* file) {
  delete file_;
  file_ = file;
  if (file) {
    set_has_file();
  } else {
    clear_has_file();
  }
}

// optional .draiosproto.counter_time net = 4;
inline bool time_categories::has_net() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void time_categories::set_has_net() {
  _has_bits_[0] |= 0x00000008u;
}
inline void time_categories::clear_has_net() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void time_categories::clear_net() {
  if (net_ != NULL) net_->::draiosproto::counter_time::Clear();
  clear_has_net();
}
inline const ::draiosproto::counter_time& time_categories::net() const {
  return net_ != NULL ? *net_ : *default_instance_->net_;
}
inline ::draiosproto::counter_time* time_categories::mutable_net() {
  set_has_net();
  if (net_ == NULL) net_ = new ::draiosproto::counter_time;
  return net_;
}
inline ::draiosproto::counter_time* time_categories::release_net() {
  clear_has_net();
  ::draiosproto::counter_time* temp = net_;
  net_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_net(::draiosproto::counter_time* net) {
  delete net_;
  net_ = net;
  if (net) {
    set_has_net();
  } else {
    clear_has_net();
  }
}

// optional .draiosproto.counter_time ipc = 5;
inline bool time_categories::has_ipc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void time_categories::set_has_ipc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void time_categories::clear_has_ipc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void time_categories::clear_ipc() {
  if (ipc_ != NULL) ipc_->::draiosproto::counter_time::Clear();
  clear_has_ipc();
}
inline const ::draiosproto::counter_time& time_categories::ipc() const {
  return ipc_ != NULL ? *ipc_ : *default_instance_->ipc_;
}
inline ::draiosproto::counter_time* time_categories::mutable_ipc() {
  set_has_ipc();
  if (ipc_ == NULL) ipc_ = new ::draiosproto::counter_time;
  return ipc_;
}
inline ::draiosproto::counter_time* time_categories::release_ipc() {
  clear_has_ipc();
  ::draiosproto::counter_time* temp = ipc_;
  ipc_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_ipc(::draiosproto::counter_time* ipc) {
  delete ipc_;
  ipc_ = ipc;
  if (ipc) {
    set_has_ipc();
  } else {
    clear_has_ipc();
  }
}

// optional .draiosproto.counter_time memory = 6;
inline bool time_categories::has_memory() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void time_categories::set_has_memory() {
  _has_bits_[0] |= 0x00000020u;
}
inline void time_categories::clear_has_memory() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void time_categories::clear_memory() {
  if (memory_ != NULL) memory_->::draiosproto::counter_time::Clear();
  clear_has_memory();
}
inline const ::draiosproto::counter_time& time_categories::memory() const {
  return memory_ != NULL ? *memory_ : *default_instance_->memory_;
}
inline ::draiosproto::counter_time* time_categories::mutable_memory() {
  set_has_memory();
  if (memory_ == NULL) memory_ = new ::draiosproto::counter_time;
  return memory_;
}
inline ::draiosproto::counter_time* time_categories::release_memory() {
  clear_has_memory();
  ::draiosproto::counter_time* temp = memory_;
  memory_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_memory(::draiosproto::counter_time* memory) {
  delete memory_;
  memory_ = memory;
  if (memory) {
    set_has_memory();
  } else {
    clear_has_memory();
  }
}

// optional .draiosproto.counter_time process = 7;
inline bool time_categories::has_process() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void time_categories::set_has_process() {
  _has_bits_[0] |= 0x00000040u;
}
inline void time_categories::clear_has_process() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void time_categories::clear_process() {
  if (process_ != NULL) process_->::draiosproto::counter_time::Clear();
  clear_has_process();
}
inline const ::draiosproto::counter_time& time_categories::process() const {
  return process_ != NULL ? *process_ : *default_instance_->process_;
}
inline ::draiosproto::counter_time* time_categories::mutable_process() {
  set_has_process();
  if (process_ == NULL) process_ = new ::draiosproto::counter_time;
  return process_;
}
inline ::draiosproto::counter_time* time_categories::release_process() {
  clear_has_process();
  ::draiosproto::counter_time* temp = process_;
  process_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_process(::draiosproto::counter_time* process) {
  delete process_;
  process_ = process;
  if (process) {
    set_has_process();
  } else {
    clear_has_process();
  }
}

// optional .draiosproto.counter_time sleep = 8;
inline bool time_categories::has_sleep() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void time_categories::set_has_sleep() {
  _has_bits_[0] |= 0x00000080u;
}
inline void time_categories::clear_has_sleep() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void time_categories::clear_sleep() {
  if (sleep_ != NULL) sleep_->::draiosproto::counter_time::Clear();
  clear_has_sleep();
}
inline const ::draiosproto::counter_time& time_categories::sleep() const {
  return sleep_ != NULL ? *sleep_ : *default_instance_->sleep_;
}
inline ::draiosproto::counter_time* time_categories::mutable_sleep() {
  set_has_sleep();
  if (sleep_ == NULL) sleep_ = new ::draiosproto::counter_time;
  return sleep_;
}
inline ::draiosproto::counter_time* time_categories::release_sleep() {
  clear_has_sleep();
  ::draiosproto::counter_time* temp = sleep_;
  sleep_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_sleep(::draiosproto::counter_time* sleep) {
  delete sleep_;
  sleep_ = sleep;
  if (sleep) {
    set_has_sleep();
  } else {
    clear_has_sleep();
  }
}

// optional .draiosproto.counter_time system = 9;
inline bool time_categories::has_system() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void time_categories::set_has_system() {
  _has_bits_[0] |= 0x00000100u;
}
inline void time_categories::clear_has_system() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void time_categories::clear_system() {
  if (system_ != NULL) system_->::draiosproto::counter_time::Clear();
  clear_has_system();
}
inline const ::draiosproto::counter_time& time_categories::system() const {
  return system_ != NULL ? *system_ : *default_instance_->system_;
}
inline ::draiosproto::counter_time* time_categories::mutable_system() {
  set_has_system();
  if (system_ == NULL) system_ = new ::draiosproto::counter_time;
  return system_;
}
inline ::draiosproto::counter_time* time_categories::release_system() {
  clear_has_system();
  ::draiosproto::counter_time* temp = system_;
  system_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_system(::draiosproto::counter_time* system) {
  delete system_;
  system_ = system;
  if (system) {
    set_has_system();
  } else {
    clear_has_system();
  }
}

// optional .draiosproto.counter_time signal = 10;
inline bool time_categories::has_signal() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void time_categories::set_has_signal() {
  _has_bits_[0] |= 0x00000200u;
}
inline void time_categories::clear_has_signal() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void time_categories::clear_signal() {
  if (signal_ != NULL) signal_->::draiosproto::counter_time::Clear();
  clear_has_signal();
}
inline const ::draiosproto::counter_time& time_categories::signal() const {
  return signal_ != NULL ? *signal_ : *default_instance_->signal_;
}
inline ::draiosproto::counter_time* time_categories::mutable_signal() {
  set_has_signal();
  if (signal_ == NULL) signal_ = new ::draiosproto::counter_time;
  return signal_;
}
inline ::draiosproto::counter_time* time_categories::release_signal() {
  clear_has_signal();
  ::draiosproto::counter_time* temp = signal_;
  signal_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_signal(::draiosproto::counter_time* signal) {
  delete signal_;
  signal_ = signal;
  if (signal) {
    set_has_signal();
  } else {
    clear_has_signal();
  }
}

// optional .draiosproto.counter_time user = 11;
inline bool time_categories::has_user() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void time_categories::set_has_user() {
  _has_bits_[0] |= 0x00000400u;
}
inline void time_categories::clear_has_user() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void time_categories::clear_user() {
  if (user_ != NULL) user_->::draiosproto::counter_time::Clear();
  clear_has_user();
}
inline const ::draiosproto::counter_time& time_categories::user() const {
  return user_ != NULL ? *user_ : *default_instance_->user_;
}
inline ::draiosproto::counter_time* time_categories::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::draiosproto::counter_time;
  return user_;
}
inline ::draiosproto::counter_time* time_categories::release_user() {
  clear_has_user();
  ::draiosproto::counter_time* temp = user_;
  user_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_user(::draiosproto::counter_time* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
}

// optional .draiosproto.counter_time time = 12;
inline bool time_categories::has_time() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void time_categories::set_has_time() {
  _has_bits_[0] |= 0x00000800u;
}
inline void time_categories::clear_has_time() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void time_categories::clear_time() {
  if (time_ != NULL) time_->::draiosproto::counter_time::Clear();
  clear_has_time();
}
inline const ::draiosproto::counter_time& time_categories::time() const {
  return time_ != NULL ? *time_ : *default_instance_->time_;
}
inline ::draiosproto::counter_time* time_categories::mutable_time() {
  set_has_time();
  if (time_ == NULL) time_ = new ::draiosproto::counter_time;
  return time_;
}
inline ::draiosproto::counter_time* time_categories::release_time() {
  clear_has_time();
  ::draiosproto::counter_time* temp = time_;
  time_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_time(::draiosproto::counter_time* time) {
  delete time_;
  time_ = time;
  if (time) {
    set_has_time();
  } else {
    clear_has_time();
  }
}

// optional .draiosproto.counter_time_bytes io_file = 13;
inline bool time_categories::has_io_file() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void time_categories::set_has_io_file() {
  _has_bits_[0] |= 0x00001000u;
}
inline void time_categories::clear_has_io_file() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void time_categories::clear_io_file() {
  if (io_file_ != NULL) io_file_->::draiosproto::counter_time_bytes::Clear();
  clear_has_io_file();
}
inline const ::draiosproto::counter_time_bytes& time_categories::io_file() const {
  return io_file_ != NULL ? *io_file_ : *default_instance_->io_file_;
}
inline ::draiosproto::counter_time_bytes* time_categories::mutable_io_file() {
  set_has_io_file();
  if (io_file_ == NULL) io_file_ = new ::draiosproto::counter_time_bytes;
  return io_file_;
}
inline ::draiosproto::counter_time_bytes* time_categories::release_io_file() {
  clear_has_io_file();
  ::draiosproto::counter_time_bytes* temp = io_file_;
  io_file_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_io_file(::draiosproto::counter_time_bytes* io_file) {
  delete io_file_;
  io_file_ = io_file;
  if (io_file) {
    set_has_io_file();
  } else {
    clear_has_io_file();
  }
}

// optional .draiosproto.counter_time_bytes io_net = 14;
inline bool time_categories::has_io_net() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void time_categories::set_has_io_net() {
  _has_bits_[0] |= 0x00002000u;
}
inline void time_categories::clear_has_io_net() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void time_categories::clear_io_net() {
  if (io_net_ != NULL) io_net_->::draiosproto::counter_time_bytes::Clear();
  clear_has_io_net();
}
inline const ::draiosproto::counter_time_bytes& time_categories::io_net() const {
  return io_net_ != NULL ? *io_net_ : *default_instance_->io_net_;
}
inline ::draiosproto::counter_time_bytes* time_categories::mutable_io_net() {
  set_has_io_net();
  if (io_net_ == NULL) io_net_ = new ::draiosproto::counter_time_bytes;
  return io_net_;
}
inline ::draiosproto::counter_time_bytes* time_categories::release_io_net() {
  clear_has_io_net();
  ::draiosproto::counter_time_bytes* temp = io_net_;
  io_net_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_io_net(::draiosproto::counter_time_bytes* io_net) {
  delete io_net_;
  io_net_ = io_net;
  if (io_net) {
    set_has_io_net();
  } else {
    clear_has_io_net();
  }
}

// optional .draiosproto.counter_time_bytes io_other = 15;
inline bool time_categories::has_io_other() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void time_categories::set_has_io_other() {
  _has_bits_[0] |= 0x00004000u;
}
inline void time_categories::clear_has_io_other() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void time_categories::clear_io_other() {
  if (io_other_ != NULL) io_other_->::draiosproto::counter_time_bytes::Clear();
  clear_has_io_other();
}
inline const ::draiosproto::counter_time_bytes& time_categories::io_other() const {
  return io_other_ != NULL ? *io_other_ : *default_instance_->io_other_;
}
inline ::draiosproto::counter_time_bytes* time_categories::mutable_io_other() {
  set_has_io_other();
  if (io_other_ == NULL) io_other_ = new ::draiosproto::counter_time_bytes;
  return io_other_;
}
inline ::draiosproto::counter_time_bytes* time_categories::release_io_other() {
  clear_has_io_other();
  ::draiosproto::counter_time_bytes* temp = io_other_;
  io_other_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_io_other(::draiosproto::counter_time_bytes* io_other) {
  delete io_other_;
  io_other_ = io_other;
  if (io_other) {
    set_has_io_other();
  } else {
    clear_has_io_other();
  }
}

// optional .draiosproto.counter_time wait = 16;
inline bool time_categories::has_wait() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void time_categories::set_has_wait() {
  _has_bits_[0] |= 0x00008000u;
}
inline void time_categories::clear_has_wait() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void time_categories::clear_wait() {
  if (wait_ != NULL) wait_->::draiosproto::counter_time::Clear();
  clear_has_wait();
}
inline const ::draiosproto::counter_time& time_categories::wait() const {
  return wait_ != NULL ? *wait_ : *default_instance_->wait_;
}
inline ::draiosproto::counter_time* time_categories::mutable_wait() {
  set_has_wait();
  if (wait_ == NULL) wait_ = new ::draiosproto::counter_time;
  return wait_;
}
inline ::draiosproto::counter_time* time_categories::release_wait() {
  clear_has_wait();
  ::draiosproto::counter_time* temp = wait_;
  wait_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_wait(::draiosproto::counter_time* wait) {
  delete wait_;
  wait_ = wait;
  if (wait) {
    set_has_wait();
  } else {
    clear_has_wait();
  }
}

// optional .draiosproto.counter_time processing = 17;
inline bool time_categories::has_processing() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void time_categories::set_has_processing() {
  _has_bits_[0] |= 0x00010000u;
}
inline void time_categories::clear_has_processing() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void time_categories::clear_processing() {
  if (processing_ != NULL) processing_->::draiosproto::counter_time::Clear();
  clear_has_processing();
}
inline const ::draiosproto::counter_time& time_categories::processing() const {
  return processing_ != NULL ? *processing_ : *default_instance_->processing_;
}
inline ::draiosproto::counter_time* time_categories::mutable_processing() {
  set_has_processing();
  if (processing_ == NULL) processing_ = new ::draiosproto::counter_time;
  return processing_;
}
inline ::draiosproto::counter_time* time_categories::release_processing() {
  clear_has_processing();
  ::draiosproto::counter_time* temp = processing_;
  processing_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_processing(::draiosproto::counter_time* processing) {
  delete processing_;
  processing_ = processing;
  if (processing) {
    set_has_processing();
  } else {
    clear_has_processing();
  }
}

// -------------------------------------------------------------------

// transaction_breakdown_categories

// optional .draiosproto.counter_time other = 2;
inline bool transaction_breakdown_categories::has_other() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void transaction_breakdown_categories::set_has_other() {
  _has_bits_[0] |= 0x00000001u;
}
inline void transaction_breakdown_categories::clear_has_other() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void transaction_breakdown_categories::clear_other() {
  if (other_ != NULL) other_->::draiosproto::counter_time::Clear();
  clear_has_other();
}
inline const ::draiosproto::counter_time& transaction_breakdown_categories::other() const {
  return other_ != NULL ? *other_ : *default_instance_->other_;
}
inline ::draiosproto::counter_time* transaction_breakdown_categories::mutable_other() {
  set_has_other();
  if (other_ == NULL) other_ = new ::draiosproto::counter_time;
  return other_;
}
inline ::draiosproto::counter_time* transaction_breakdown_categories::release_other() {
  clear_has_other();
  ::draiosproto::counter_time* temp = other_;
  other_ = NULL;
  return temp;
}
inline void transaction_breakdown_categories::set_allocated_other(::draiosproto::counter_time* other) {
  delete other_;
  other_ = other;
  if (other) {
    set_has_other();
  } else {
    clear_has_other();
  }
}

// optional .draiosproto.counter_time_bytes io_file = 13;
inline bool transaction_breakdown_categories::has_io_file() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void transaction_breakdown_categories::set_has_io_file() {
  _has_bits_[0] |= 0x00000002u;
}
inline void transaction_breakdown_categories::clear_has_io_file() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void transaction_breakdown_categories::clear_io_file() {
  if (io_file_ != NULL) io_file_->::draiosproto::counter_time_bytes::Clear();
  clear_has_io_file();
}
inline const ::draiosproto::counter_time_bytes& transaction_breakdown_categories::io_file() const {
  return io_file_ != NULL ? *io_file_ : *default_instance_->io_file_;
}
inline ::draiosproto::counter_time_bytes* transaction_breakdown_categories::mutable_io_file() {
  set_has_io_file();
  if (io_file_ == NULL) io_file_ = new ::draiosproto::counter_time_bytes;
  return io_file_;
}
inline ::draiosproto::counter_time_bytes* transaction_breakdown_categories::release_io_file() {
  clear_has_io_file();
  ::draiosproto::counter_time_bytes* temp = io_file_;
  io_file_ = NULL;
  return temp;
}
inline void transaction_breakdown_categories::set_allocated_io_file(::draiosproto::counter_time_bytes* io_file) {
  delete io_file_;
  io_file_ = io_file;
  if (io_file) {
    set_has_io_file();
  } else {
    clear_has_io_file();
  }
}

// optional .draiosproto.counter_time_bytes io_net = 14;
inline bool transaction_breakdown_categories::has_io_net() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void transaction_breakdown_categories::set_has_io_net() {
  _has_bits_[0] |= 0x00000004u;
}
inline void transaction_breakdown_categories::clear_has_io_net() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void transaction_breakdown_categories::clear_io_net() {
  if (io_net_ != NULL) io_net_->::draiosproto::counter_time_bytes::Clear();
  clear_has_io_net();
}
inline const ::draiosproto::counter_time_bytes& transaction_breakdown_categories::io_net() const {
  return io_net_ != NULL ? *io_net_ : *default_instance_->io_net_;
}
inline ::draiosproto::counter_time_bytes* transaction_breakdown_categories::mutable_io_net() {
  set_has_io_net();
  if (io_net_ == NULL) io_net_ = new ::draiosproto::counter_time_bytes;
  return io_net_;
}
inline ::draiosproto::counter_time_bytes* transaction_breakdown_categories::release_io_net() {
  clear_has_io_net();
  ::draiosproto::counter_time_bytes* temp = io_net_;
  io_net_ = NULL;
  return temp;
}
inline void transaction_breakdown_categories::set_allocated_io_net(::draiosproto::counter_time_bytes* io_net) {
  delete io_net_;
  io_net_ = io_net;
  if (io_net) {
    set_has_io_net();
  } else {
    clear_has_io_net();
  }
}

// optional .draiosproto.counter_time processing = 17;
inline bool transaction_breakdown_categories::has_processing() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void transaction_breakdown_categories::set_has_processing() {
  _has_bits_[0] |= 0x00000008u;
}
inline void transaction_breakdown_categories::clear_has_processing() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void transaction_breakdown_categories::clear_processing() {
  if (processing_ != NULL) processing_->::draiosproto::counter_time::Clear();
  clear_has_processing();
}
inline const ::draiosproto::counter_time& transaction_breakdown_categories::processing() const {
  return processing_ != NULL ? *processing_ : *default_instance_->processing_;
}
inline ::draiosproto::counter_time* transaction_breakdown_categories::mutable_processing() {
  set_has_processing();
  if (processing_ == NULL) processing_ = new ::draiosproto::counter_time;
  return processing_;
}
inline ::draiosproto::counter_time* transaction_breakdown_categories::release_processing() {
  clear_has_processing();
  ::draiosproto::counter_time* temp = processing_;
  processing_ = NULL;
  return temp;
}
inline void transaction_breakdown_categories::set_allocated_processing(::draiosproto::counter_time* processing) {
  delete processing_;
  processing_ = processing;
  if (processing) {
    set_has_processing();
  } else {
    clear_has_processing();
  }
}

// -------------------------------------------------------------------

// counter_syscall_errors

// required uint32 count = 1;
inline bool counter_syscall_errors::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void counter_syscall_errors::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void counter_syscall_errors::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void counter_syscall_errors::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 counter_syscall_errors::count() const {
  return count_;
}
inline void counter_syscall_errors::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated uint32 top_error_codes = 2;
inline int counter_syscall_errors::top_error_codes_size() const {
  return top_error_codes_.size();
}
inline void counter_syscall_errors::clear_top_error_codes() {
  top_error_codes_.Clear();
}
inline ::google::protobuf::uint32 counter_syscall_errors::top_error_codes(int index) const {
  return top_error_codes_.Get(index);
}
inline void counter_syscall_errors::set_top_error_codes(int index, ::google::protobuf::uint32 value) {
  top_error_codes_.Set(index, value);
}
inline void counter_syscall_errors::add_top_error_codes(::google::protobuf::uint32 value) {
  top_error_codes_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
counter_syscall_errors::top_error_codes() const {
  return top_error_codes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
counter_syscall_errors::mutable_top_error_codes() {
  return &top_error_codes_;
}

// -------------------------------------------------------------------

// resource_categories

// optional uint32 capacity_score = 1;
inline bool resource_categories::has_capacity_score() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void resource_categories::set_has_capacity_score() {
  _has_bits_[0] |= 0x00000001u;
}
inline void resource_categories::clear_has_capacity_score() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void resource_categories::clear_capacity_score() {
  capacity_score_ = 0u;
  clear_has_capacity_score();
}
inline ::google::protobuf::uint32 resource_categories::capacity_score() const {
  return capacity_score_;
}
inline void resource_categories::set_capacity_score(::google::protobuf::uint32 value) {
  set_has_capacity_score();
  capacity_score_ = value;
}

// optional uint32 stolen_capacity_score = 6;
inline bool resource_categories::has_stolen_capacity_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void resource_categories::set_has_stolen_capacity_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void resource_categories::clear_has_stolen_capacity_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void resource_categories::clear_stolen_capacity_score() {
  stolen_capacity_score_ = 0u;
  clear_has_stolen_capacity_score();
}
inline ::google::protobuf::uint32 resource_categories::stolen_capacity_score() const {
  return stolen_capacity_score_;
}
inline void resource_categories::set_stolen_capacity_score(::google::protobuf::uint32 value) {
  set_has_stolen_capacity_score();
  stolen_capacity_score_ = value;
}

// optional uint32 connection_queue_usage_pct = 2;
inline bool resource_categories::has_connection_queue_usage_pct() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void resource_categories::set_has_connection_queue_usage_pct() {
  _has_bits_[0] |= 0x00000004u;
}
inline void resource_categories::clear_has_connection_queue_usage_pct() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void resource_categories::clear_connection_queue_usage_pct() {
  connection_queue_usage_pct_ = 0u;
  clear_has_connection_queue_usage_pct();
}
inline ::google::protobuf::uint32 resource_categories::connection_queue_usage_pct() const {
  return connection_queue_usage_pct_;
}
inline void resource_categories::set_connection_queue_usage_pct(::google::protobuf::uint32 value) {
  set_has_connection_queue_usage_pct();
  connection_queue_usage_pct_ = value;
}

// optional uint32 fd_usage_pct = 3;
inline bool resource_categories::has_fd_usage_pct() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void resource_categories::set_has_fd_usage_pct() {
  _has_bits_[0] |= 0x00000008u;
}
inline void resource_categories::clear_has_fd_usage_pct() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void resource_categories::clear_fd_usage_pct() {
  fd_usage_pct_ = 0u;
  clear_has_fd_usage_pct();
}
inline ::google::protobuf::uint32 resource_categories::fd_usage_pct() const {
  return fd_usage_pct_;
}
inline void resource_categories::set_fd_usage_pct(::google::protobuf::uint32 value) {
  set_has_fd_usage_pct();
  fd_usage_pct_ = value;
}

// optional uint32 cpu_pct = 4;
inline bool resource_categories::has_cpu_pct() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void resource_categories::set_has_cpu_pct() {
  _has_bits_[0] |= 0x00000010u;
}
inline void resource_categories::clear_has_cpu_pct() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void resource_categories::clear_cpu_pct() {
  cpu_pct_ = 0u;
  clear_has_cpu_pct();
}
inline ::google::protobuf::uint32 resource_categories::cpu_pct() const {
  return cpu_pct_;
}
inline void resource_categories::set_cpu_pct(::google::protobuf::uint32 value) {
  set_has_cpu_pct();
  cpu_pct_ = value;
}

// optional uint64 resident_memory_usage_kb = 5;
inline bool resource_categories::has_resident_memory_usage_kb() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void resource_categories::set_has_resident_memory_usage_kb() {
  _has_bits_[0] |= 0x00000020u;
}
inline void resource_categories::clear_has_resident_memory_usage_kb() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void resource_categories::clear_resident_memory_usage_kb() {
  resident_memory_usage_kb_ = GOOGLE_ULONGLONG(0);
  clear_has_resident_memory_usage_kb();
}
inline ::google::protobuf::uint64 resource_categories::resident_memory_usage_kb() const {
  return resident_memory_usage_kb_;
}
inline void resource_categories::set_resident_memory_usage_kb(::google::protobuf::uint64 value) {
  set_has_resident_memory_usage_kb();
  resident_memory_usage_kb_ = value;
}

// -------------------------------------------------------------------

// connection_categories

// optional .draiosproto.counter_bytes server = 1;
inline bool connection_categories::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void connection_categories::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void connection_categories::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void connection_categories::clear_server() {
  if (server_ != NULL) server_->::draiosproto::counter_bytes::Clear();
  clear_has_server();
}
inline const ::draiosproto::counter_bytes& connection_categories::server() const {
  return server_ != NULL ? *server_ : *default_instance_->server_;
}
inline ::draiosproto::counter_bytes* connection_categories::mutable_server() {
  set_has_server();
  if (server_ == NULL) server_ = new ::draiosproto::counter_bytes;
  return server_;
}
inline ::draiosproto::counter_bytes* connection_categories::release_server() {
  clear_has_server();
  ::draiosproto::counter_bytes* temp = server_;
  server_ = NULL;
  return temp;
}
inline void connection_categories::set_allocated_server(::draiosproto::counter_bytes* server) {
  delete server_;
  server_ = server;
  if (server) {
    set_has_server();
  } else {
    clear_has_server();
  }
}

// optional .draiosproto.counter_bytes client = 2;
inline bool connection_categories::has_client() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void connection_categories::set_has_client() {
  _has_bits_[0] |= 0x00000002u;
}
inline void connection_categories::clear_has_client() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void connection_categories::clear_client() {
  if (client_ != NULL) client_->::draiosproto::counter_bytes::Clear();
  clear_has_client();
}
inline const ::draiosproto::counter_bytes& connection_categories::client() const {
  return client_ != NULL ? *client_ : *default_instance_->client_;
}
inline ::draiosproto::counter_bytes* connection_categories::mutable_client() {
  set_has_client();
  if (client_ == NULL) client_ = new ::draiosproto::counter_bytes;
  return client_;
}
inline ::draiosproto::counter_bytes* connection_categories::release_client() {
  clear_has_client();
  ::draiosproto::counter_bytes* temp = client_;
  client_ = NULL;
  return temp;
}
inline void connection_categories::set_allocated_client(::draiosproto::counter_bytes* client) {
  delete client_;
  client_ = client;
  if (client) {
    set_has_client();
  } else {
    clear_has_client();
  }
}

// optional .draiosproto.counter_time_bidirectional transaction_counters = 3;
inline bool connection_categories::has_transaction_counters() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void connection_categories::set_has_transaction_counters() {
  _has_bits_[0] |= 0x00000004u;
}
inline void connection_categories::clear_has_transaction_counters() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void connection_categories::clear_transaction_counters() {
  if (transaction_counters_ != NULL) transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& connection_categories::transaction_counters() const {
  return transaction_counters_ != NULL ? *transaction_counters_ : *default_instance_->transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* connection_categories::mutable_transaction_counters() {
  set_has_transaction_counters();
  if (transaction_counters_ == NULL) transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  return transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* connection_categories::release_transaction_counters() {
  clear_has_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = transaction_counters_;
  transaction_counters_ = NULL;
  return temp;
}
inline void connection_categories::set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters) {
  delete transaction_counters_;
  transaction_counters_ = transaction_counters;
  if (transaction_counters) {
    set_has_transaction_counters();
  } else {
    clear_has_transaction_counters();
  }
}

// optional uint32 n_aggregated_connections = 4;
inline bool connection_categories::has_n_aggregated_connections() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void connection_categories::set_has_n_aggregated_connections() {
  _has_bits_[0] |= 0x00000008u;
}
inline void connection_categories::clear_has_n_aggregated_connections() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void connection_categories::clear_n_aggregated_connections() {
  n_aggregated_connections_ = 0u;
  clear_has_n_aggregated_connections();
}
inline ::google::protobuf::uint32 connection_categories::n_aggregated_connections() const {
  return n_aggregated_connections_;
}
inline void connection_categories::set_n_aggregated_connections(::google::protobuf::uint32 value) {
  set_has_n_aggregated_connections();
  n_aggregated_connections_ = value;
}

// -------------------------------------------------------------------

// process_details

// required string comm = 1;
inline bool process_details::has_comm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void process_details::set_has_comm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void process_details::clear_has_comm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void process_details::clear_comm() {
  if (comm_ != &::google::protobuf::internal::kEmptyString) {
    comm_->clear();
  }
  clear_has_comm();
}
inline const ::std::string& process_details::comm() const {
  return *comm_;
}
inline void process_details::set_comm(const ::std::string& value) {
  set_has_comm();
  if (comm_ == &::google::protobuf::internal::kEmptyString) {
    comm_ = new ::std::string;
  }
  comm_->assign(value);
}
inline void process_details::set_comm(const char* value) {
  set_has_comm();
  if (comm_ == &::google::protobuf::internal::kEmptyString) {
    comm_ = new ::std::string;
  }
  comm_->assign(value);
}
inline void process_details::set_comm(const char* value, size_t size) {
  set_has_comm();
  if (comm_ == &::google::protobuf::internal::kEmptyString) {
    comm_ = new ::std::string;
  }
  comm_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* process_details::mutable_comm() {
  set_has_comm();
  if (comm_ == &::google::protobuf::internal::kEmptyString) {
    comm_ = new ::std::string;
  }
  return comm_;
}
inline ::std::string* process_details::release_comm() {
  clear_has_comm();
  if (comm_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comm_;
    comm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void process_details::set_allocated_comm(::std::string* comm) {
  if (comm_ != &::google::protobuf::internal::kEmptyString) {
    delete comm_;
  }
  if (comm) {
    set_has_comm();
    comm_ = comm;
  } else {
    clear_has_comm();
    comm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string exe = 2;
inline bool process_details::has_exe() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void process_details::set_has_exe() {
  _has_bits_[0] |= 0x00000002u;
}
inline void process_details::clear_has_exe() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void process_details::clear_exe() {
  if (exe_ != &::google::protobuf::internal::kEmptyString) {
    exe_->clear();
  }
  clear_has_exe();
}
inline const ::std::string& process_details::exe() const {
  return *exe_;
}
inline void process_details::set_exe(const ::std::string& value) {
  set_has_exe();
  if (exe_ == &::google::protobuf::internal::kEmptyString) {
    exe_ = new ::std::string;
  }
  exe_->assign(value);
}
inline void process_details::set_exe(const char* value) {
  set_has_exe();
  if (exe_ == &::google::protobuf::internal::kEmptyString) {
    exe_ = new ::std::string;
  }
  exe_->assign(value);
}
inline void process_details::set_exe(const char* value, size_t size) {
  set_has_exe();
  if (exe_ == &::google::protobuf::internal::kEmptyString) {
    exe_ = new ::std::string;
  }
  exe_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* process_details::mutable_exe() {
  set_has_exe();
  if (exe_ == &::google::protobuf::internal::kEmptyString) {
    exe_ = new ::std::string;
  }
  return exe_;
}
inline ::std::string* process_details::release_exe() {
  clear_has_exe();
  if (exe_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exe_;
    exe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void process_details::set_allocated_exe(::std::string* exe) {
  if (exe_ != &::google::protobuf::internal::kEmptyString) {
    delete exe_;
  }
  if (exe) {
    set_has_exe();
    exe_ = exe;
  } else {
    clear_has_exe();
    exe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string args = 3;
inline int process_details::args_size() const {
  return args_.size();
}
inline void process_details::clear_args() {
  args_.Clear();
}
inline const ::std::string& process_details::args(int index) const {
  return args_.Get(index);
}
inline ::std::string* process_details::mutable_args(int index) {
  return args_.Mutable(index);
}
inline void process_details::set_args(int index, const ::std::string& value) {
  args_.Mutable(index)->assign(value);
}
inline void process_details::set_args(int index, const char* value) {
  args_.Mutable(index)->assign(value);
}
inline void process_details::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* process_details::add_args() {
  return args_.Add();
}
inline void process_details::add_args(const ::std::string& value) {
  args_.Add()->assign(value);
}
inline void process_details::add_args(const char* value) {
  args_.Add()->assign(value);
}
inline void process_details::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
process_details::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
process_details::mutable_args() {
  return &args_;
}

// -------------------------------------------------------------------

// host

// optional string hostname = 1;
inline bool host::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void host::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void host::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void host::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& host::hostname() const {
  return *hostname_;
}
inline void host::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void host::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void host::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* host::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* host::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void host::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 num_cpus = 2;
inline bool host::has_num_cpus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void host::set_has_num_cpus() {
  _has_bits_[0] |= 0x00000002u;
}
inline void host::clear_has_num_cpus() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void host::clear_num_cpus() {
  num_cpus_ = 0u;
  clear_has_num_cpus();
}
inline ::google::protobuf::uint32 host::num_cpus() const {
  return num_cpus_;
}
inline void host::set_num_cpus(::google::protobuf::uint32 value) {
  set_has_num_cpus();
  num_cpus_ = value;
}

// repeated uint32 cpu_loads = 3;
inline int host::cpu_loads_size() const {
  return cpu_loads_.size();
}
inline void host::clear_cpu_loads() {
  cpu_loads_.Clear();
}
inline ::google::protobuf::uint32 host::cpu_loads(int index) const {
  return cpu_loads_.Get(index);
}
inline void host::set_cpu_loads(int index, ::google::protobuf::uint32 value) {
  cpu_loads_.Set(index, value);
}
inline void host::add_cpu_loads(::google::protobuf::uint32 value) {
  cpu_loads_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
host::cpu_loads() const {
  return cpu_loads_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
host::mutable_cpu_loads() {
  return &cpu_loads_;
}

// repeated uint32 cpu_steal = 11;
inline int host::cpu_steal_size() const {
  return cpu_steal_.size();
}
inline void host::clear_cpu_steal() {
  cpu_steal_.Clear();
}
inline ::google::protobuf::uint32 host::cpu_steal(int index) const {
  return cpu_steal_.Get(index);
}
inline void host::set_cpu_steal(int index, ::google::protobuf::uint32 value) {
  cpu_steal_.Set(index, value);
}
inline void host::add_cpu_steal(::google::protobuf::uint32 value) {
  cpu_steal_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
host::cpu_steal() const {
  return cpu_steal_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
host::mutable_cpu_steal() {
  return &cpu_steal_;
}

// required uint64 physical_memory_size_bytes = 4;
inline bool host::has_physical_memory_size_bytes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void host::set_has_physical_memory_size_bytes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void host::clear_has_physical_memory_size_bytes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void host::clear_physical_memory_size_bytes() {
  physical_memory_size_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_physical_memory_size_bytes();
}
inline ::google::protobuf::uint64 host::physical_memory_size_bytes() const {
  return physical_memory_size_bytes_;
}
inline void host::set_physical_memory_size_bytes(::google::protobuf::uint64 value) {
  set_has_physical_memory_size_bytes();
  physical_memory_size_bytes_ = value;
}

// optional .draiosproto.time_categories tcounters = 5;
inline bool host::has_tcounters() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void host::set_has_tcounters() {
  _has_bits_[0] |= 0x00000020u;
}
inline void host::clear_has_tcounters() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void host::clear_tcounters() {
  if (tcounters_ != NULL) tcounters_->::draiosproto::time_categories::Clear();
  clear_has_tcounters();
}
inline const ::draiosproto::time_categories& host::tcounters() const {
  return tcounters_ != NULL ? *tcounters_ : *default_instance_->tcounters_;
}
inline ::draiosproto::time_categories* host::mutable_tcounters() {
  set_has_tcounters();
  if (tcounters_ == NULL) tcounters_ = new ::draiosproto::time_categories;
  return tcounters_;
}
inline ::draiosproto::time_categories* host::release_tcounters() {
  clear_has_tcounters();
  ::draiosproto::time_categories* temp = tcounters_;
  tcounters_ = NULL;
  return temp;
}
inline void host::set_allocated_tcounters(::draiosproto::time_categories* tcounters) {
  delete tcounters_;
  tcounters_ = tcounters;
  if (tcounters) {
    set_has_tcounters();
  } else {
    clear_has_tcounters();
  }
}

// optional .draiosproto.transaction_breakdown_categories reqcounters = 12;
inline bool host::has_reqcounters() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void host::set_has_reqcounters() {
  _has_bits_[0] |= 0x00000040u;
}
inline void host::clear_has_reqcounters() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void host::clear_reqcounters() {
  if (reqcounters_ != NULL) reqcounters_->::draiosproto::transaction_breakdown_categories::Clear();
  clear_has_reqcounters();
}
inline const ::draiosproto::transaction_breakdown_categories& host::reqcounters() const {
  return reqcounters_ != NULL ? *reqcounters_ : *default_instance_->reqcounters_;
}
inline ::draiosproto::transaction_breakdown_categories* host::mutable_reqcounters() {
  set_has_reqcounters();
  if (reqcounters_ == NULL) reqcounters_ = new ::draiosproto::transaction_breakdown_categories;
  return reqcounters_;
}
inline ::draiosproto::transaction_breakdown_categories* host::release_reqcounters() {
  clear_has_reqcounters();
  ::draiosproto::transaction_breakdown_categories* temp = reqcounters_;
  reqcounters_ = NULL;
  return temp;
}
inline void host::set_allocated_reqcounters(::draiosproto::transaction_breakdown_categories* reqcounters) {
  delete reqcounters_;
  reqcounters_ = reqcounters;
  if (reqcounters) {
    set_has_reqcounters();
  } else {
    clear_has_reqcounters();
  }
}

// optional .draiosproto.counter_time_bidirectional transaction_counters = 6;
inline bool host::has_transaction_counters() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void host::set_has_transaction_counters() {
  _has_bits_[0] |= 0x00000080u;
}
inline void host::clear_has_transaction_counters() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void host::clear_transaction_counters() {
  if (transaction_counters_ != NULL) transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& host::transaction_counters() const {
  return transaction_counters_ != NULL ? *transaction_counters_ : *default_instance_->transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* host::mutable_transaction_counters() {
  set_has_transaction_counters();
  if (transaction_counters_ == NULL) transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  return transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* host::release_transaction_counters() {
  clear_has_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = transaction_counters_;
  transaction_counters_ = NULL;
  return temp;
}
inline void host::set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters) {
  delete transaction_counters_;
  transaction_counters_ = transaction_counters;
  if (transaction_counters) {
    set_has_transaction_counters();
  } else {
    clear_has_transaction_counters();
  }
}

// optional uint64 transaction_processing_delay = 7;
inline bool host::has_transaction_processing_delay() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void host::set_has_transaction_processing_delay() {
  _has_bits_[0] |= 0x00000100u;
}
inline void host::clear_has_transaction_processing_delay() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void host::clear_transaction_processing_delay() {
  transaction_processing_delay_ = GOOGLE_ULONGLONG(0);
  clear_has_transaction_processing_delay();
}
inline ::google::protobuf::uint64 host::transaction_processing_delay() const {
  return transaction_processing_delay_;
}
inline void host::set_transaction_processing_delay(::google::protobuf::uint64 value) {
  set_has_transaction_processing_delay();
  transaction_processing_delay_ = value;
}

// optional uint64 merged_server_delay = 14;
inline bool host::has_merged_server_delay() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void host::set_has_merged_server_delay() {
  _has_bits_[0] |= 0x00000200u;
}
inline void host::clear_has_merged_server_delay() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void host::clear_merged_server_delay() {
  merged_server_delay_ = GOOGLE_ULONGLONG(0);
  clear_has_merged_server_delay();
}
inline ::google::protobuf::uint64 host::merged_server_delay() const {
  return merged_server_delay_;
}
inline void host::set_merged_server_delay(::google::protobuf::uint64 value) {
  set_has_merged_server_delay();
  merged_server_delay_ = value;
}

// optional uint64 next_tiers_delay = 13;
inline bool host::has_next_tiers_delay() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void host::set_has_next_tiers_delay() {
  _has_bits_[0] |= 0x00000400u;
}
inline void host::clear_has_next_tiers_delay() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void host::clear_next_tiers_delay() {
  next_tiers_delay_ = GOOGLE_ULONGLONG(0);
  clear_has_next_tiers_delay();
}
inline ::google::protobuf::uint64 host::next_tiers_delay() const {
  return next_tiers_delay_;
}
inline void host::set_next_tiers_delay(::google::protobuf::uint64 value) {
  set_has_next_tiers_delay();
  next_tiers_delay_ = value;
}

// optional .draiosproto.resource_categories resource_counters = 8;
inline bool host::has_resource_counters() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void host::set_has_resource_counters() {
  _has_bits_[0] |= 0x00000800u;
}
inline void host::clear_has_resource_counters() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void host::clear_resource_counters() {
  if (resource_counters_ != NULL) resource_counters_->::draiosproto::resource_categories::Clear();
  clear_has_resource_counters();
}
inline const ::draiosproto::resource_categories& host::resource_counters() const {
  return resource_counters_ != NULL ? *resource_counters_ : *default_instance_->resource_counters_;
}
inline ::draiosproto::resource_categories* host::mutable_resource_counters() {
  set_has_resource_counters();
  if (resource_counters_ == NULL) resource_counters_ = new ::draiosproto::resource_categories;
  return resource_counters_;
}
inline ::draiosproto::resource_categories* host::release_resource_counters() {
  clear_has_resource_counters();
  ::draiosproto::resource_categories* temp = resource_counters_;
  resource_counters_ = NULL;
  return temp;
}
inline void host::set_allocated_resource_counters(::draiosproto::resource_categories* resource_counters) {
  delete resource_counters_;
  resource_counters_ = resource_counters;
  if (resource_counters) {
    set_has_resource_counters();
  } else {
    clear_has_resource_counters();
  }
}

// optional .draiosproto.counter_syscall_errors syscall_errors = 9;
inline bool host::has_syscall_errors() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void host::set_has_syscall_errors() {
  _has_bits_[0] |= 0x00001000u;
}
inline void host::clear_has_syscall_errors() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void host::clear_syscall_errors() {
  if (syscall_errors_ != NULL) syscall_errors_->::draiosproto::counter_syscall_errors::Clear();
  clear_has_syscall_errors();
}
inline const ::draiosproto::counter_syscall_errors& host::syscall_errors() const {
  return syscall_errors_ != NULL ? *syscall_errors_ : *default_instance_->syscall_errors_;
}
inline ::draiosproto::counter_syscall_errors* host::mutable_syscall_errors() {
  set_has_syscall_errors();
  if (syscall_errors_ == NULL) syscall_errors_ = new ::draiosproto::counter_syscall_errors;
  return syscall_errors_;
}
inline ::draiosproto::counter_syscall_errors* host::release_syscall_errors() {
  clear_has_syscall_errors();
  ::draiosproto::counter_syscall_errors* temp = syscall_errors_;
  syscall_errors_ = NULL;
  return temp;
}
inline void host::set_allocated_syscall_errors(::draiosproto::counter_syscall_errors* syscall_errors) {
  delete syscall_errors_;
  syscall_errors_ = syscall_errors;
  if (syscall_errors) {
    set_has_syscall_errors();
  } else {
    clear_has_syscall_errors();
  }
}

// optional .draiosproto.counter_time_bytes external_io_net = 10;
inline bool host::has_external_io_net() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void host::set_has_external_io_net() {
  _has_bits_[0] |= 0x00002000u;
}
inline void host::clear_has_external_io_net() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void host::clear_external_io_net() {
  if (external_io_net_ != NULL) external_io_net_->::draiosproto::counter_time_bytes::Clear();
  clear_has_external_io_net();
}
inline const ::draiosproto::counter_time_bytes& host::external_io_net() const {
  return external_io_net_ != NULL ? *external_io_net_ : *default_instance_->external_io_net_;
}
inline ::draiosproto::counter_time_bytes* host::mutable_external_io_net() {
  set_has_external_io_net();
  if (external_io_net_ == NULL) external_io_net_ = new ::draiosproto::counter_time_bytes;
  return external_io_net_;
}
inline ::draiosproto::counter_time_bytes* host::release_external_io_net() {
  clear_has_external_io_net();
  ::draiosproto::counter_time_bytes* temp = external_io_net_;
  external_io_net_ = NULL;
  return temp;
}
inline void host::set_allocated_external_io_net(::draiosproto::counter_time_bytes* external_io_net) {
  delete external_io_net_;
  external_io_net_ = external_io_net;
  if (external_io_net) {
    set_has_external_io_net();
  } else {
    clear_has_external_io_net();
  }
}

// -------------------------------------------------------------------

// thread

// required uint64 pid = 1;
inline bool thread::has_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void thread::set_has_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void thread::clear_has_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void thread::clear_pid() {
  pid_ = GOOGLE_ULONGLONG(0);
  clear_has_pid();
}
inline ::google::protobuf::uint64 thread::pid() const {
  return pid_;
}
inline void thread::set_pid(::google::protobuf::uint64 value) {
  set_has_pid();
  pid_ = value;
}

// required uint64 tid = 2;
inline bool thread::has_tid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void thread::set_has_tid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void thread::clear_has_tid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void thread::clear_tid() {
  tid_ = GOOGLE_ULONGLONG(0);
  clear_has_tid();
}
inline ::google::protobuf::uint64 thread::tid() const {
  return tid_;
}
inline void thread::set_tid(::google::protobuf::uint64 value) {
  set_has_tid();
  tid_ = value;
}

// optional .draiosproto.time_categories tcounters = 3;
inline bool thread::has_tcounters() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void thread::set_has_tcounters() {
  _has_bits_[0] |= 0x00000004u;
}
inline void thread::clear_has_tcounters() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void thread::clear_tcounters() {
  if (tcounters_ != NULL) tcounters_->::draiosproto::time_categories::Clear();
  clear_has_tcounters();
}
inline const ::draiosproto::time_categories& thread::tcounters() const {
  return tcounters_ != NULL ? *tcounters_ : *default_instance_->tcounters_;
}
inline ::draiosproto::time_categories* thread::mutable_tcounters() {
  set_has_tcounters();
  if (tcounters_ == NULL) tcounters_ = new ::draiosproto::time_categories;
  return tcounters_;
}
inline ::draiosproto::time_categories* thread::release_tcounters() {
  clear_has_tcounters();
  ::draiosproto::time_categories* temp = tcounters_;
  tcounters_ = NULL;
  return temp;
}
inline void thread::set_allocated_tcounters(::draiosproto::time_categories* tcounters) {
  delete tcounters_;
  tcounters_ = tcounters;
  if (tcounters) {
    set_has_tcounters();
  } else {
    clear_has_tcounters();
  }
}

// optional .draiosproto.counter_time_bidirectional transaction_counters = 5;
inline bool thread::has_transaction_counters() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void thread::set_has_transaction_counters() {
  _has_bits_[0] |= 0x00000008u;
}
inline void thread::clear_has_transaction_counters() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void thread::clear_transaction_counters() {
  if (transaction_counters_ != NULL) transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& thread::transaction_counters() const {
  return transaction_counters_ != NULL ? *transaction_counters_ : *default_instance_->transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* thread::mutable_transaction_counters() {
  set_has_transaction_counters();
  if (transaction_counters_ == NULL) transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  return transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* thread::release_transaction_counters() {
  clear_has_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = transaction_counters_;
  transaction_counters_ = NULL;
  return temp;
}
inline void thread::set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters) {
  delete transaction_counters_;
  transaction_counters_ = transaction_counters;
  if (transaction_counters) {
    set_has_transaction_counters();
  } else {
    clear_has_transaction_counters();
  }
}

// -------------------------------------------------------------------

// process

// required uint64 pid = 1;
inline bool process::has_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void process::set_has_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void process::clear_has_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void process::clear_pid() {
  pid_ = GOOGLE_ULONGLONG(0);
  clear_has_pid();
}
inline ::google::protobuf::uint64 process::pid() const {
  return pid_;
}
inline void process::set_pid(::google::protobuf::uint64 value) {
  set_has_pid();
  pid_ = value;
}

// optional .draiosproto.process_details details = 2;
inline bool process::has_details() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void process::set_has_details() {
  _has_bits_[0] |= 0x00000002u;
}
inline void process::clear_has_details() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void process::clear_details() {
  if (details_ != NULL) details_->::draiosproto::process_details::Clear();
  clear_has_details();
}
inline const ::draiosproto::process_details& process::details() const {
  return details_ != NULL ? *details_ : *default_instance_->details_;
}
inline ::draiosproto::process_details* process::mutable_details() {
  set_has_details();
  if (details_ == NULL) details_ = new ::draiosproto::process_details;
  return details_;
}
inline ::draiosproto::process_details* process::release_details() {
  clear_has_details();
  ::draiosproto::process_details* temp = details_;
  details_ = NULL;
  return temp;
}
inline void process::set_allocated_details(::draiosproto::process_details* details) {
  delete details_;
  details_ = details;
  if (details) {
    set_has_details();
  } else {
    clear_has_details();
  }
}

// optional bool is_ipv4_transaction_server = 3;
inline bool process::has_is_ipv4_transaction_server() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void process::set_has_is_ipv4_transaction_server() {
  _has_bits_[0] |= 0x00000004u;
}
inline void process::clear_has_is_ipv4_transaction_server() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void process::clear_is_ipv4_transaction_server() {
  is_ipv4_transaction_server_ = false;
  clear_has_is_ipv4_transaction_server();
}
inline bool process::is_ipv4_transaction_server() const {
  return is_ipv4_transaction_server_;
}
inline void process::set_is_ipv4_transaction_server(bool value) {
  set_has_is_ipv4_transaction_server();
  is_ipv4_transaction_server_ = value;
}

// optional bool is_unix_transaction_server = 4;
inline bool process::has_is_unix_transaction_server() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void process::set_has_is_unix_transaction_server() {
  _has_bits_[0] |= 0x00000008u;
}
inline void process::clear_has_is_unix_transaction_server() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void process::clear_is_unix_transaction_server() {
  is_unix_transaction_server_ = false;
  clear_has_is_unix_transaction_server();
}
inline bool process::is_unix_transaction_server() const {
  return is_unix_transaction_server_;
}
inline void process::set_is_unix_transaction_server(bool value) {
  set_has_is_unix_transaction_server();
  is_unix_transaction_server_ = value;
}

// optional bool is_ipv4_transaction_client = 10;
inline bool process::has_is_ipv4_transaction_client() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void process::set_has_is_ipv4_transaction_client() {
  _has_bits_[0] |= 0x00000010u;
}
inline void process::clear_has_is_ipv4_transaction_client() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void process::clear_is_ipv4_transaction_client() {
  is_ipv4_transaction_client_ = false;
  clear_has_is_ipv4_transaction_client();
}
inline bool process::is_ipv4_transaction_client() const {
  return is_ipv4_transaction_client_;
}
inline void process::set_is_ipv4_transaction_client(bool value) {
  set_has_is_ipv4_transaction_client();
  is_ipv4_transaction_client_ = value;
}

// optional bool is_unix_transaction_client = 11;
inline bool process::has_is_unix_transaction_client() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void process::set_has_is_unix_transaction_client() {
  _has_bits_[0] |= 0x00000020u;
}
inline void process::clear_has_is_unix_transaction_client() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void process::clear_is_unix_transaction_client() {
  is_unix_transaction_client_ = false;
  clear_has_is_unix_transaction_client();
}
inline bool process::is_unix_transaction_client() const {
  return is_unix_transaction_client_;
}
inline void process::set_is_unix_transaction_client(bool value) {
  set_has_is_unix_transaction_client();
  is_unix_transaction_client_ = value;
}

// optional uint32 netrole = 13;
inline bool process::has_netrole() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void process::set_has_netrole() {
  _has_bits_[0] |= 0x00000040u;
}
inline void process::clear_has_netrole() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void process::clear_netrole() {
  netrole_ = 0u;
  clear_has_netrole();
}
inline ::google::protobuf::uint32 process::netrole() const {
  return netrole_;
}
inline void process::set_netrole(::google::protobuf::uint32 value) {
  set_has_netrole();
  netrole_ = value;
}

// optional .draiosproto.time_categories tcounters = 5;
inline bool process::has_tcounters() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void process::set_has_tcounters() {
  _has_bits_[0] |= 0x00000080u;
}
inline void process::clear_has_tcounters() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void process::clear_tcounters() {
  if (tcounters_ != NULL) tcounters_->::draiosproto::time_categories::Clear();
  clear_has_tcounters();
}
inline const ::draiosproto::time_categories& process::tcounters() const {
  return tcounters_ != NULL ? *tcounters_ : *default_instance_->tcounters_;
}
inline ::draiosproto::time_categories* process::mutable_tcounters() {
  set_has_tcounters();
  if (tcounters_ == NULL) tcounters_ = new ::draiosproto::time_categories;
  return tcounters_;
}
inline ::draiosproto::time_categories* process::release_tcounters() {
  clear_has_tcounters();
  ::draiosproto::time_categories* temp = tcounters_;
  tcounters_ = NULL;
  return temp;
}
inline void process::set_allocated_tcounters(::draiosproto::time_categories* tcounters) {
  delete tcounters_;
  tcounters_ = tcounters;
  if (tcounters) {
    set_has_tcounters();
  } else {
    clear_has_tcounters();
  }
}

// optional .draiosproto.counter_time_bidirectional transaction_counters = 6;
inline bool process::has_transaction_counters() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void process::set_has_transaction_counters() {
  _has_bits_[0] |= 0x00000100u;
}
inline void process::clear_has_transaction_counters() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void process::clear_transaction_counters() {
  if (transaction_counters_ != NULL) transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& process::transaction_counters() const {
  return transaction_counters_ != NULL ? *transaction_counters_ : *default_instance_->transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* process::mutable_transaction_counters() {
  set_has_transaction_counters();
  if (transaction_counters_ == NULL) transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  return transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* process::release_transaction_counters() {
  clear_has_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = transaction_counters_;
  transaction_counters_ = NULL;
  return temp;
}
inline void process::set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters) {
  delete transaction_counters_;
  transaction_counters_ = transaction_counters;
  if (transaction_counters) {
    set_has_transaction_counters();
  } else {
    clear_has_transaction_counters();
  }
}

// optional uint64 transaction_processing_delay = 7;
inline bool process::has_transaction_processing_delay() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void process::set_has_transaction_processing_delay() {
  _has_bits_[0] |= 0x00000200u;
}
inline void process::clear_has_transaction_processing_delay() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void process::clear_transaction_processing_delay() {
  transaction_processing_delay_ = GOOGLE_ULONGLONG(0);
  clear_has_transaction_processing_delay();
}
inline ::google::protobuf::uint64 process::transaction_processing_delay() const {
  return transaction_processing_delay_;
}
inline void process::set_transaction_processing_delay(::google::protobuf::uint64 value) {
  set_has_transaction_processing_delay();
  transaction_processing_delay_ = value;
}

// optional uint64 merged_server_delay = 14;
inline bool process::has_merged_server_delay() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void process::set_has_merged_server_delay() {
  _has_bits_[0] |= 0x00000400u;
}
inline void process::clear_has_merged_server_delay() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void process::clear_merged_server_delay() {
  merged_server_delay_ = GOOGLE_ULONGLONG(0);
  clear_has_merged_server_delay();
}
inline ::google::protobuf::uint64 process::merged_server_delay() const {
  return merged_server_delay_;
}
inline void process::set_merged_server_delay(::google::protobuf::uint64 value) {
  set_has_merged_server_delay();
  merged_server_delay_ = value;
}

// optional uint64 next_tiers_delay = 12;
inline bool process::has_next_tiers_delay() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void process::set_has_next_tiers_delay() {
  _has_bits_[0] |= 0x00000800u;
}
inline void process::clear_has_next_tiers_delay() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void process::clear_next_tiers_delay() {
  next_tiers_delay_ = GOOGLE_ULONGLONG(0);
  clear_has_next_tiers_delay();
}
inline ::google::protobuf::uint64 process::next_tiers_delay() const {
  return next_tiers_delay_;
}
inline void process::set_next_tiers_delay(::google::protobuf::uint64 value) {
  set_has_next_tiers_delay();
  next_tiers_delay_ = value;
}

// optional .draiosproto.resource_categories resource_counters = 8;
inline bool process::has_resource_counters() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void process::set_has_resource_counters() {
  _has_bits_[0] |= 0x00001000u;
}
inline void process::clear_has_resource_counters() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void process::clear_resource_counters() {
  if (resource_counters_ != NULL) resource_counters_->::draiosproto::resource_categories::Clear();
  clear_has_resource_counters();
}
inline const ::draiosproto::resource_categories& process::resource_counters() const {
  return resource_counters_ != NULL ? *resource_counters_ : *default_instance_->resource_counters_;
}
inline ::draiosproto::resource_categories* process::mutable_resource_counters() {
  set_has_resource_counters();
  if (resource_counters_ == NULL) resource_counters_ = new ::draiosproto::resource_categories;
  return resource_counters_;
}
inline ::draiosproto::resource_categories* process::release_resource_counters() {
  clear_has_resource_counters();
  ::draiosproto::resource_categories* temp = resource_counters_;
  resource_counters_ = NULL;
  return temp;
}
inline void process::set_allocated_resource_counters(::draiosproto::resource_categories* resource_counters) {
  delete resource_counters_;
  resource_counters_ = resource_counters;
  if (resource_counters) {
    set_has_resource_counters();
  } else {
    clear_has_resource_counters();
  }
}

// optional .draiosproto.counter_syscall_errors syscall_errors = 9;
inline bool process::has_syscall_errors() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void process::set_has_syscall_errors() {
  _has_bits_[0] |= 0x00002000u;
}
inline void process::clear_has_syscall_errors() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void process::clear_syscall_errors() {
  if (syscall_errors_ != NULL) syscall_errors_->::draiosproto::counter_syscall_errors::Clear();
  clear_has_syscall_errors();
}
inline const ::draiosproto::counter_syscall_errors& process::syscall_errors() const {
  return syscall_errors_ != NULL ? *syscall_errors_ : *default_instance_->syscall_errors_;
}
inline ::draiosproto::counter_syscall_errors* process::mutable_syscall_errors() {
  set_has_syscall_errors();
  if (syscall_errors_ == NULL) syscall_errors_ = new ::draiosproto::counter_syscall_errors;
  return syscall_errors_;
}
inline ::draiosproto::counter_syscall_errors* process::release_syscall_errors() {
  clear_has_syscall_errors();
  ::draiosproto::counter_syscall_errors* temp = syscall_errors_;
  syscall_errors_ = NULL;
  return temp;
}
inline void process::set_allocated_syscall_errors(::draiosproto::counter_syscall_errors* syscall_errors) {
  delete syscall_errors_;
  syscall_errors_ = syscall_errors;
  if (syscall_errors) {
    set_has_syscall_errors();
  } else {
    clear_has_syscall_errors();
  }
}

// -------------------------------------------------------------------

// program

// required .draiosproto.process procinfo = 1;
inline bool program::has_procinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void program::set_has_procinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void program::clear_has_procinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void program::clear_procinfo() {
  if (procinfo_ != NULL) procinfo_->::draiosproto::process::Clear();
  clear_has_procinfo();
}
inline const ::draiosproto::process& program::procinfo() const {
  return procinfo_ != NULL ? *procinfo_ : *default_instance_->procinfo_;
}
inline ::draiosproto::process* program::mutable_procinfo() {
  set_has_procinfo();
  if (procinfo_ == NULL) procinfo_ = new ::draiosproto::process;
  return procinfo_;
}
inline ::draiosproto::process* program::release_procinfo() {
  clear_has_procinfo();
  ::draiosproto::process* temp = procinfo_;
  procinfo_ = NULL;
  return temp;
}
inline void program::set_allocated_procinfo(::draiosproto::process* procinfo) {
  delete procinfo_;
  procinfo_ = procinfo;
  if (procinfo) {
    set_has_procinfo();
  } else {
    clear_has_procinfo();
  }
}

// repeated uint64 pids = 2;
inline int program::pids_size() const {
  return pids_.size();
}
inline void program::clear_pids() {
  pids_.Clear();
}
inline ::google::protobuf::uint64 program::pids(int index) const {
  return pids_.Get(index);
}
inline void program::set_pids(int index, ::google::protobuf::uint64 value) {
  pids_.Set(index, value);
}
inline void program::add_pids(::google::protobuf::uint64 value) {
  pids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
program::pids() const {
  return pids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
program::mutable_pids() {
  return &pids_;
}

// -------------------------------------------------------------------

// ipv4tuple

// required uint32 sip = 1;
inline bool ipv4tuple::has_sip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ipv4tuple::set_has_sip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ipv4tuple::clear_has_sip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ipv4tuple::clear_sip() {
  sip_ = 0u;
  clear_has_sip();
}
inline ::google::protobuf::uint32 ipv4tuple::sip() const {
  return sip_;
}
inline void ipv4tuple::set_sip(::google::protobuf::uint32 value) {
  set_has_sip();
  sip_ = value;
}

// required uint32 dip = 2;
inline bool ipv4tuple::has_dip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ipv4tuple::set_has_dip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ipv4tuple::clear_has_dip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ipv4tuple::clear_dip() {
  dip_ = 0u;
  clear_has_dip();
}
inline ::google::protobuf::uint32 ipv4tuple::dip() const {
  return dip_;
}
inline void ipv4tuple::set_dip(::google::protobuf::uint32 value) {
  set_has_dip();
  dip_ = value;
}

// required uint32 sport = 3;
inline bool ipv4tuple::has_sport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ipv4tuple::set_has_sport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ipv4tuple::clear_has_sport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ipv4tuple::clear_sport() {
  sport_ = 0u;
  clear_has_sport();
}
inline ::google::protobuf::uint32 ipv4tuple::sport() const {
  return sport_;
}
inline void ipv4tuple::set_sport(::google::protobuf::uint32 value) {
  set_has_sport();
  sport_ = value;
}

// required uint32 dport = 4;
inline bool ipv4tuple::has_dport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ipv4tuple::set_has_dport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ipv4tuple::clear_has_dport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ipv4tuple::clear_dport() {
  dport_ = 0u;
  clear_has_dport();
}
inline ::google::protobuf::uint32 ipv4tuple::dport() const {
  return dport_;
}
inline void ipv4tuple::set_dport(::google::protobuf::uint32 value) {
  set_has_dport();
  dport_ = value;
}

// required uint32 l4proto = 5;
inline bool ipv4tuple::has_l4proto() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ipv4tuple::set_has_l4proto() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ipv4tuple::clear_has_l4proto() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ipv4tuple::clear_l4proto() {
  l4proto_ = 0u;
  clear_has_l4proto();
}
inline ::google::protobuf::uint32 ipv4tuple::l4proto() const {
  return l4proto_;
}
inline void ipv4tuple::set_l4proto(::google::protobuf::uint32 value) {
  set_has_l4proto();
  l4proto_ = value;
}

// -------------------------------------------------------------------

// ipv4_connection

// required .draiosproto.ipv4tuple tuple = 1;
inline bool ipv4_connection::has_tuple() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ipv4_connection::set_has_tuple() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ipv4_connection::clear_has_tuple() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ipv4_connection::clear_tuple() {
  if (tuple_ != NULL) tuple_->::draiosproto::ipv4tuple::Clear();
  clear_has_tuple();
}
inline const ::draiosproto::ipv4tuple& ipv4_connection::tuple() const {
  return tuple_ != NULL ? *tuple_ : *default_instance_->tuple_;
}
inline ::draiosproto::ipv4tuple* ipv4_connection::mutable_tuple() {
  set_has_tuple();
  if (tuple_ == NULL) tuple_ = new ::draiosproto::ipv4tuple;
  return tuple_;
}
inline ::draiosproto::ipv4tuple* ipv4_connection::release_tuple() {
  clear_has_tuple();
  ::draiosproto::ipv4tuple* temp = tuple_;
  tuple_ = NULL;
  return temp;
}
inline void ipv4_connection::set_allocated_tuple(::draiosproto::ipv4tuple* tuple) {
  delete tuple_;
  tuple_ = tuple;
  if (tuple) {
    set_has_tuple();
  } else {
    clear_has_tuple();
  }
}

// optional uint64 spid = 2;
inline bool ipv4_connection::has_spid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ipv4_connection::set_has_spid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ipv4_connection::clear_has_spid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ipv4_connection::clear_spid() {
  spid_ = GOOGLE_ULONGLONG(0);
  clear_has_spid();
}
inline ::google::protobuf::uint64 ipv4_connection::spid() const {
  return spid_;
}
inline void ipv4_connection::set_spid(::google::protobuf::uint64 value) {
  set_has_spid();
  spid_ = value;
}

// optional uint64 stid = 3;
inline bool ipv4_connection::has_stid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ipv4_connection::set_has_stid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ipv4_connection::clear_has_stid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ipv4_connection::clear_stid() {
  stid_ = GOOGLE_ULONGLONG(0);
  clear_has_stid();
}
inline ::google::protobuf::uint64 ipv4_connection::stid() const {
  return stid_;
}
inline void ipv4_connection::set_stid(::google::protobuf::uint64 value) {
  set_has_stid();
  stid_ = value;
}

// optional uint64 dpid = 5;
inline bool ipv4_connection::has_dpid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ipv4_connection::set_has_dpid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ipv4_connection::clear_has_dpid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ipv4_connection::clear_dpid() {
  dpid_ = GOOGLE_ULONGLONG(0);
  clear_has_dpid();
}
inline ::google::protobuf::uint64 ipv4_connection::dpid() const {
  return dpid_;
}
inline void ipv4_connection::set_dpid(::google::protobuf::uint64 value) {
  set_has_dpid();
  dpid_ = value;
}

// optional uint64 dtid = 6;
inline bool ipv4_connection::has_dtid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ipv4_connection::set_has_dtid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ipv4_connection::clear_has_dtid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ipv4_connection::clear_dtid() {
  dtid_ = GOOGLE_ULONGLONG(0);
  clear_has_dtid();
}
inline ::google::protobuf::uint64 ipv4_connection::dtid() const {
  return dtid_;
}
inline void ipv4_connection::set_dtid(::google::protobuf::uint64 value) {
  set_has_dtid();
  dtid_ = value;
}

// required .draiosproto.connection_categories counters = 8;
inline bool ipv4_connection::has_counters() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ipv4_connection::set_has_counters() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ipv4_connection::clear_has_counters() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ipv4_connection::clear_counters() {
  if (counters_ != NULL) counters_->::draiosproto::connection_categories::Clear();
  clear_has_counters();
}
inline const ::draiosproto::connection_categories& ipv4_connection::counters() const {
  return counters_ != NULL ? *counters_ : *default_instance_->counters_;
}
inline ::draiosproto::connection_categories* ipv4_connection::mutable_counters() {
  set_has_counters();
  if (counters_ == NULL) counters_ = new ::draiosproto::connection_categories;
  return counters_;
}
inline ::draiosproto::connection_categories* ipv4_connection::release_counters() {
  clear_has_counters();
  ::draiosproto::connection_categories* temp = counters_;
  counters_ = NULL;
  return temp;
}
inline void ipv4_connection::set_allocated_counters(::draiosproto::connection_categories* counters) {
  delete counters_;
  counters_ = counters;
  if (counters) {
    set_has_counters();
  } else {
    clear_has_counters();
  }
}

// -------------------------------------------------------------------

// ipv4_network_interface

// required string name = 1;
inline bool ipv4_network_interface::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ipv4_network_interface::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ipv4_network_interface::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ipv4_network_interface::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ipv4_network_interface::name() const {
  return *name_;
}
inline void ipv4_network_interface::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ipv4_network_interface::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ipv4_network_interface::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ipv4_network_interface::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ipv4_network_interface::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ipv4_network_interface::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 addr = 2;
inline bool ipv4_network_interface::has_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ipv4_network_interface::set_has_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ipv4_network_interface::clear_has_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ipv4_network_interface::clear_addr() {
  addr_ = 0u;
  clear_has_addr();
}
inline ::google::protobuf::uint32 ipv4_network_interface::addr() const {
  return addr_;
}
inline void ipv4_network_interface::set_addr(::google::protobuf::uint32 value) {
  set_has_addr();
  addr_ = value;
}

// required uint32 netmask = 3;
inline bool ipv4_network_interface::has_netmask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ipv4_network_interface::set_has_netmask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ipv4_network_interface::clear_has_netmask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ipv4_network_interface::clear_netmask() {
  netmask_ = 0u;
  clear_has_netmask();
}
inline ::google::protobuf::uint32 ipv4_network_interface::netmask() const {
  return netmask_;
}
inline void ipv4_network_interface::set_netmask(::google::protobuf::uint32 value) {
  set_has_netmask();
  netmask_ = value;
}

// optional uint32 bcast = 4;
inline bool ipv4_network_interface::has_bcast() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ipv4_network_interface::set_has_bcast() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ipv4_network_interface::clear_has_bcast() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ipv4_network_interface::clear_bcast() {
  bcast_ = 0u;
  clear_has_bcast();
}
inline ::google::protobuf::uint32 ipv4_network_interface::bcast() const {
  return bcast_;
}
inline void ipv4_network_interface::set_bcast(::google::protobuf::uint32 value) {
  set_has_bcast();
  bcast_ = value;
}

// -------------------------------------------------------------------

// metrics

// required uint64 timestamp_ns = 1;
inline bool metrics::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void metrics::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void metrics::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void metrics::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 metrics::timestamp_ns() const {
  return timestamp_ns_;
}
inline void metrics::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
}

// required string machine_id = 2;
inline bool metrics::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void metrics::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void metrics::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void metrics::clear_machine_id() {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    machine_id_->clear();
  }
  clear_has_machine_id();
}
inline const ::std::string& metrics::machine_id() const {
  return *machine_id_;
}
inline void metrics::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void metrics::set_machine_id(const char* value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void metrics::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* metrics::mutable_machine_id() {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  return machine_id_;
}
inline ::std::string* metrics::release_machine_id() {
  clear_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_id_;
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void metrics::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_id_;
  }
  if (machine_id) {
    set_has_machine_id();
    machine_id_ = machine_id;
  } else {
    clear_has_machine_id();
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string customer_id = 3;
inline bool metrics::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void metrics::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void metrics::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void metrics::clear_customer_id() {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    customer_id_->clear();
  }
  clear_has_customer_id();
}
inline const ::std::string& metrics::customer_id() const {
  return *customer_id_;
}
inline void metrics::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void metrics::set_customer_id(const char* value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void metrics::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* metrics::mutable_customer_id() {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  return customer_id_;
}
inline ::std::string* metrics::release_customer_id() {
  clear_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customer_id_;
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void metrics::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete customer_id_;
  }
  if (customer_id) {
    set_has_customer_id();
    customer_id_ = customer_id;
  } else {
    clear_has_customer_id();
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .draiosproto.host hostinfo = 4;
inline bool metrics::has_hostinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void metrics::set_has_hostinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void metrics::clear_has_hostinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void metrics::clear_hostinfo() {
  if (hostinfo_ != NULL) hostinfo_->::draiosproto::host::Clear();
  clear_has_hostinfo();
}
inline const ::draiosproto::host& metrics::hostinfo() const {
  return hostinfo_ != NULL ? *hostinfo_ : *default_instance_->hostinfo_;
}
inline ::draiosproto::host* metrics::mutable_hostinfo() {
  set_has_hostinfo();
  if (hostinfo_ == NULL) hostinfo_ = new ::draiosproto::host;
  return hostinfo_;
}
inline ::draiosproto::host* metrics::release_hostinfo() {
  clear_has_hostinfo();
  ::draiosproto::host* temp = hostinfo_;
  hostinfo_ = NULL;
  return temp;
}
inline void metrics::set_allocated_hostinfo(::draiosproto::host* hostinfo) {
  delete hostinfo_;
  hostinfo_ = hostinfo;
  if (hostinfo) {
    set_has_hostinfo();
  } else {
    clear_has_hostinfo();
  }
}

// repeated .draiosproto.program programs = 9;
inline int metrics::programs_size() const {
  return programs_.size();
}
inline void metrics::clear_programs() {
  programs_.Clear();
}
inline const ::draiosproto::program& metrics::programs(int index) const {
  return programs_.Get(index);
}
inline ::draiosproto::program* metrics::mutable_programs(int index) {
  return programs_.Mutable(index);
}
inline ::draiosproto::program* metrics::add_programs() {
  return programs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::program >&
metrics::programs() const {
  return programs_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::program >*
metrics::mutable_programs() {
  return &programs_;
}

// repeated .draiosproto.process processes = 5;
inline int metrics::processes_size() const {
  return processes_.size();
}
inline void metrics::clear_processes() {
  processes_.Clear();
}
inline const ::draiosproto::process& metrics::processes(int index) const {
  return processes_.Get(index);
}
inline ::draiosproto::process* metrics::mutable_processes(int index) {
  return processes_.Mutable(index);
}
inline ::draiosproto::process* metrics::add_processes() {
  return processes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::process >&
metrics::processes() const {
  return processes_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::process >*
metrics::mutable_processes() {
  return &processes_;
}

// repeated .draiosproto.thread threads = 6;
inline int metrics::threads_size() const {
  return threads_.size();
}
inline void metrics::clear_threads() {
  threads_.Clear();
}
inline const ::draiosproto::thread& metrics::threads(int index) const {
  return threads_.Get(index);
}
inline ::draiosproto::thread* metrics::mutable_threads(int index) {
  return threads_.Mutable(index);
}
inline ::draiosproto::thread* metrics::add_threads() {
  return threads_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::thread >&
metrics::threads() const {
  return threads_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::thread >*
metrics::mutable_threads() {
  return &threads_;
}

// repeated .draiosproto.ipv4_connection ipv4_connections = 7;
inline int metrics::ipv4_connections_size() const {
  return ipv4_connections_.size();
}
inline void metrics::clear_ipv4_connections() {
  ipv4_connections_.Clear();
}
inline const ::draiosproto::ipv4_connection& metrics::ipv4_connections(int index) const {
  return ipv4_connections_.Get(index);
}
inline ::draiosproto::ipv4_connection* metrics::mutable_ipv4_connections(int index) {
  return ipv4_connections_.Mutable(index);
}
inline ::draiosproto::ipv4_connection* metrics::add_ipv4_connections() {
  return ipv4_connections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_connection >&
metrics::ipv4_connections() const {
  return ipv4_connections_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_connection >*
metrics::mutable_ipv4_connections() {
  return &ipv4_connections_;
}

// repeated .draiosproto.ipv4_network_interface ipv4_network_interfaces = 8;
inline int metrics::ipv4_network_interfaces_size() const {
  return ipv4_network_interfaces_.size();
}
inline void metrics::clear_ipv4_network_interfaces() {
  ipv4_network_interfaces_.Clear();
}
inline const ::draiosproto::ipv4_network_interface& metrics::ipv4_network_interfaces(int index) const {
  return ipv4_network_interfaces_.Get(index);
}
inline ::draiosproto::ipv4_network_interface* metrics::mutable_ipv4_network_interfaces(int index) {
  return ipv4_network_interfaces_.Mutable(index);
}
inline ::draiosproto::ipv4_network_interface* metrics::add_ipv4_network_interfaces() {
  return ipv4_network_interfaces_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_network_interface >&
metrics::ipv4_network_interfaces() const {
  return ipv4_network_interfaces_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_network_interface >*
metrics::mutable_ipv4_network_interfaces() {
  return &ipv4_network_interfaces_;
}

// optional uint32 sampling_ratio = 10;
inline bool metrics::has_sampling_ratio() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void metrics::set_has_sampling_ratio() {
  _has_bits_[0] |= 0x00000200u;
}
inline void metrics::clear_has_sampling_ratio() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void metrics::clear_sampling_ratio() {
  sampling_ratio_ = 0u;
  clear_has_sampling_ratio();
}
inline ::google::protobuf::uint32 metrics::sampling_ratio() const {
  return sampling_ratio_;
}
inline void metrics::set_sampling_ratio(::google::protobuf::uint32 value) {
  set_has_sampling_ratio();
  sampling_ratio_ = value;
}

// optional string host_custom_name = 11;
inline bool metrics::has_host_custom_name() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void metrics::set_has_host_custom_name() {
  _has_bits_[0] |= 0x00000400u;
}
inline void metrics::clear_has_host_custom_name() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void metrics::clear_host_custom_name() {
  if (host_custom_name_ != &::google::protobuf::internal::kEmptyString) {
    host_custom_name_->clear();
  }
  clear_has_host_custom_name();
}
inline const ::std::string& metrics::host_custom_name() const {
  return *host_custom_name_;
}
inline void metrics::set_host_custom_name(const ::std::string& value) {
  set_has_host_custom_name();
  if (host_custom_name_ == &::google::protobuf::internal::kEmptyString) {
    host_custom_name_ = new ::std::string;
  }
  host_custom_name_->assign(value);
}
inline void metrics::set_host_custom_name(const char* value) {
  set_has_host_custom_name();
  if (host_custom_name_ == &::google::protobuf::internal::kEmptyString) {
    host_custom_name_ = new ::std::string;
  }
  host_custom_name_->assign(value);
}
inline void metrics::set_host_custom_name(const char* value, size_t size) {
  set_has_host_custom_name();
  if (host_custom_name_ == &::google::protobuf::internal::kEmptyString) {
    host_custom_name_ = new ::std::string;
  }
  host_custom_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* metrics::mutable_host_custom_name() {
  set_has_host_custom_name();
  if (host_custom_name_ == &::google::protobuf::internal::kEmptyString) {
    host_custom_name_ = new ::std::string;
  }
  return host_custom_name_;
}
inline ::std::string* metrics::release_host_custom_name() {
  clear_has_host_custom_name();
  if (host_custom_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_custom_name_;
    host_custom_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void metrics::set_allocated_host_custom_name(::std::string* host_custom_name) {
  if (host_custom_name_ != &::google::protobuf::internal::kEmptyString) {
    delete host_custom_name_;
  }
  if (host_custom_name) {
    set_has_host_custom_name();
    host_custom_name_ = host_custom_name;
  } else {
    clear_has_host_custom_name();
    host_custom_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string host_custom_group = 12;
inline bool metrics::has_host_custom_group() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void metrics::set_has_host_custom_group() {
  _has_bits_[0] |= 0x00000800u;
}
inline void metrics::clear_has_host_custom_group() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void metrics::clear_host_custom_group() {
  if (host_custom_group_ != &::google::protobuf::internal::kEmptyString) {
    host_custom_group_->clear();
  }
  clear_has_host_custom_group();
}
inline const ::std::string& metrics::host_custom_group() const {
  return *host_custom_group_;
}
inline void metrics::set_host_custom_group(const ::std::string& value) {
  set_has_host_custom_group();
  if (host_custom_group_ == &::google::protobuf::internal::kEmptyString) {
    host_custom_group_ = new ::std::string;
  }
  host_custom_group_->assign(value);
}
inline void metrics::set_host_custom_group(const char* value) {
  set_has_host_custom_group();
  if (host_custom_group_ == &::google::protobuf::internal::kEmptyString) {
    host_custom_group_ = new ::std::string;
  }
  host_custom_group_->assign(value);
}
inline void metrics::set_host_custom_group(const char* value, size_t size) {
  set_has_host_custom_group();
  if (host_custom_group_ == &::google::protobuf::internal::kEmptyString) {
    host_custom_group_ = new ::std::string;
  }
  host_custom_group_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* metrics::mutable_host_custom_group() {
  set_has_host_custom_group();
  if (host_custom_group_ == &::google::protobuf::internal::kEmptyString) {
    host_custom_group_ = new ::std::string;
  }
  return host_custom_group_;
}
inline ::std::string* metrics::release_host_custom_group() {
  clear_has_host_custom_group();
  if (host_custom_group_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_custom_group_;
    host_custom_group_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void metrics::set_allocated_host_custom_group(::std::string* host_custom_group) {
  if (host_custom_group_ != &::google::protobuf::internal::kEmptyString) {
    delete host_custom_group_;
  }
  if (host_custom_group) {
    set_has_host_custom_group();
    host_custom_group_ = host_custom_group;
  } else {
    clear_has_host_custom_group();
    host_custom_group_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_host_hidden = 13;
inline bool metrics::has_is_host_hidden() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void metrics::set_has_is_host_hidden() {
  _has_bits_[0] |= 0x00001000u;
}
inline void metrics::clear_has_is_host_hidden() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void metrics::clear_is_host_hidden() {
  is_host_hidden_ = false;
  clear_has_is_host_hidden();
}
inline bool metrics::is_host_hidden() const {
  return is_host_hidden_;
}
inline void metrics::set_is_host_hidden(bool value) {
  set_has_is_host_hidden();
  is_host_hidden_ = value;
}

// optional string hidden_processes = 14;
inline bool metrics::has_hidden_processes() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void metrics::set_has_hidden_processes() {
  _has_bits_[0] |= 0x00002000u;
}
inline void metrics::clear_has_hidden_processes() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void metrics::clear_hidden_processes() {
  if (hidden_processes_ != &::google::protobuf::internal::kEmptyString) {
    hidden_processes_->clear();
  }
  clear_has_hidden_processes();
}
inline const ::std::string& metrics::hidden_processes() const {
  return *hidden_processes_;
}
inline void metrics::set_hidden_processes(const ::std::string& value) {
  set_has_hidden_processes();
  if (hidden_processes_ == &::google::protobuf::internal::kEmptyString) {
    hidden_processes_ = new ::std::string;
  }
  hidden_processes_->assign(value);
}
inline void metrics::set_hidden_processes(const char* value) {
  set_has_hidden_processes();
  if (hidden_processes_ == &::google::protobuf::internal::kEmptyString) {
    hidden_processes_ = new ::std::string;
  }
  hidden_processes_->assign(value);
}
inline void metrics::set_hidden_processes(const char* value, size_t size) {
  set_has_hidden_processes();
  if (hidden_processes_ == &::google::protobuf::internal::kEmptyString) {
    hidden_processes_ = new ::std::string;
  }
  hidden_processes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* metrics::mutable_hidden_processes() {
  set_has_hidden_processes();
  if (hidden_processes_ == &::google::protobuf::internal::kEmptyString) {
    hidden_processes_ = new ::std::string;
  }
  return hidden_processes_;
}
inline ::std::string* metrics::release_hidden_processes() {
  clear_has_hidden_processes();
  if (hidden_processes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hidden_processes_;
    hidden_processes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void metrics::set_allocated_hidden_processes(::std::string* hidden_processes) {
  if (hidden_processes_ != &::google::protobuf::internal::kEmptyString) {
    delete hidden_processes_;
  }
  if (hidden_processes) {
    set_has_hidden_processes();
    hidden_processes_ = hidden_processes;
  } else {
    clear_has_hidden_processes();
    hidden_processes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// dump_request

// required uint64 timestamp_ns = 1;
inline bool dump_request::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dump_request::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dump_request::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dump_request::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 dump_request::timestamp_ns() const {
  return timestamp_ns_;
}
inline void dump_request::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
}

// required string machine_id = 2;
inline bool dump_request::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dump_request::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dump_request::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dump_request::clear_machine_id() {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    machine_id_->clear();
  }
  clear_has_machine_id();
}
inline const ::std::string& dump_request::machine_id() const {
  return *machine_id_;
}
inline void dump_request::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void dump_request::set_machine_id(const char* value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void dump_request::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dump_request::mutable_machine_id() {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  return machine_id_;
}
inline ::std::string* dump_request::release_machine_id() {
  clear_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_id_;
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dump_request::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_id_;
  }
  if (machine_id) {
    set_has_machine_id();
    machine_id_ = machine_id;
  } else {
    clear_has_machine_id();
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string customer_id = 3;
inline bool dump_request::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dump_request::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dump_request::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dump_request::clear_customer_id() {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    customer_id_->clear();
  }
  clear_has_customer_id();
}
inline const ::std::string& dump_request::customer_id() const {
  return *customer_id_;
}
inline void dump_request::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void dump_request::set_customer_id(const char* value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void dump_request::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dump_request::mutable_customer_id() {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  return customer_id_;
}
inline ::std::string* dump_request::release_customer_id() {
  clear_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customer_id_;
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dump_request::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete customer_id_;
  }
  if (customer_id) {
    set_has_customer_id();
    customer_id_ = customer_id;
  } else {
    clear_has_customer_id();
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 duration_ns = 4;
inline bool dump_request::has_duration_ns() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dump_request::set_has_duration_ns() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dump_request::clear_has_duration_ns() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dump_request::clear_duration_ns() {
  duration_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_duration_ns();
}
inline ::google::protobuf::uint64 dump_request::duration_ns() const {
  return duration_ns_;
}
inline void dump_request::set_duration_ns(::google::protobuf::uint64 value) {
  set_has_duration_ns();
  duration_ns_ = value;
}

// optional string filters = 5;
inline bool dump_request::has_filters() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void dump_request::set_has_filters() {
  _has_bits_[0] |= 0x00000010u;
}
inline void dump_request::clear_has_filters() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void dump_request::clear_filters() {
  if (filters_ != &::google::protobuf::internal::kEmptyString) {
    filters_->clear();
  }
  clear_has_filters();
}
inline const ::std::string& dump_request::filters() const {
  return *filters_;
}
inline void dump_request::set_filters(const ::std::string& value) {
  set_has_filters();
  if (filters_ == &::google::protobuf::internal::kEmptyString) {
    filters_ = new ::std::string;
  }
  filters_->assign(value);
}
inline void dump_request::set_filters(const char* value) {
  set_has_filters();
  if (filters_ == &::google::protobuf::internal::kEmptyString) {
    filters_ = new ::std::string;
  }
  filters_->assign(value);
}
inline void dump_request::set_filters(const char* value, size_t size) {
  set_has_filters();
  if (filters_ == &::google::protobuf::internal::kEmptyString) {
    filters_ = new ::std::string;
  }
  filters_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dump_request::mutable_filters() {
  set_has_filters();
  if (filters_ == &::google::protobuf::internal::kEmptyString) {
    filters_ = new ::std::string;
  }
  return filters_;
}
inline ::std::string* dump_request::release_filters() {
  clear_has_filters();
  if (filters_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filters_;
    filters_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dump_request::set_allocated_filters(::std::string* filters) {
  if (filters_ != &::google::protobuf::internal::kEmptyString) {
    delete filters_;
  }
  if (filters) {
    set_has_filters();
    filters_ = filters;
  } else {
    clear_has_filters();
    filters_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// dump_response

// required uint64 timestamp_ns = 1;
inline bool dump_response::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dump_response::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dump_response::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dump_response::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 dump_response::timestamp_ns() const {
  return timestamp_ns_;
}
inline void dump_response::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
}

// required string machine_id = 2;
inline bool dump_response::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dump_response::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dump_response::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dump_response::clear_machine_id() {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    machine_id_->clear();
  }
  clear_has_machine_id();
}
inline const ::std::string& dump_response::machine_id() const {
  return *machine_id_;
}
inline void dump_response::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void dump_response::set_machine_id(const char* value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void dump_response::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dump_response::mutable_machine_id() {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  return machine_id_;
}
inline ::std::string* dump_response::release_machine_id() {
  clear_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_id_;
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dump_response::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_id_;
  }
  if (machine_id) {
    set_has_machine_id();
    machine_id_ = machine_id;
  } else {
    clear_has_machine_id();
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string customer_id = 3;
inline bool dump_response::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dump_response::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dump_response::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dump_response::clear_customer_id() {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    customer_id_->clear();
  }
  clear_has_customer_id();
}
inline const ::std::string& dump_response::customer_id() const {
  return *customer_id_;
}
inline void dump_response::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void dump_response::set_customer_id(const char* value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void dump_response::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dump_response::mutable_customer_id() {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  return customer_id_;
}
inline ::std::string* dump_response::release_customer_id() {
  clear_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customer_id_;
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dump_response::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete customer_id_;
  }
  if (customer_id) {
    set_has_customer_id();
    customer_id_ = customer_id;
  } else {
    clear_has_customer_id();
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes content = 4;
inline bool dump_response::has_content() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dump_response::set_has_content() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dump_response::clear_has_content() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dump_response::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& dump_response::content() const {
  return *content_;
}
inline void dump_response::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void dump_response::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void dump_response::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dump_response::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* dump_response::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dump_response::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string error = 5;
inline bool dump_response::has_error() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void dump_response::set_has_error() {
  _has_bits_[0] |= 0x00000010u;
}
inline void dump_response::clear_has_error() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void dump_response::clear_error() {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& dump_response::error() const {
  return *error_;
}
inline void dump_response::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void dump_response::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void dump_response::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dump_response::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  return error_;
}
inline ::std::string* dump_response::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dump_response::set_allocated_error(::std::string* error) {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    delete error_;
  }
  if (error) {
    set_has_error();
    error_ = error;
  } else {
    clear_has_error();
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// exec_cmd_request

// required uint64 timestamp_ns = 1;
inline bool exec_cmd_request::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void exec_cmd_request::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void exec_cmd_request::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void exec_cmd_request::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 exec_cmd_request::timestamp_ns() const {
  return timestamp_ns_;
}
inline void exec_cmd_request::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
}

// required string machine_id = 2;
inline bool exec_cmd_request::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void exec_cmd_request::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void exec_cmd_request::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void exec_cmd_request::clear_machine_id() {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    machine_id_->clear();
  }
  clear_has_machine_id();
}
inline const ::std::string& exec_cmd_request::machine_id() const {
  return *machine_id_;
}
inline void exec_cmd_request::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void exec_cmd_request::set_machine_id(const char* value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void exec_cmd_request::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* exec_cmd_request::mutable_machine_id() {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  return machine_id_;
}
inline ::std::string* exec_cmd_request::release_machine_id() {
  clear_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_id_;
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void exec_cmd_request::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_id_;
  }
  if (machine_id) {
    set_has_machine_id();
    machine_id_ = machine_id;
  } else {
    clear_has_machine_id();
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string customer_id = 3;
inline bool exec_cmd_request::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void exec_cmd_request::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void exec_cmd_request::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void exec_cmd_request::clear_customer_id() {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    customer_id_->clear();
  }
  clear_has_customer_id();
}
inline const ::std::string& exec_cmd_request::customer_id() const {
  return *customer_id_;
}
inline void exec_cmd_request::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void exec_cmd_request::set_customer_id(const char* value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void exec_cmd_request::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* exec_cmd_request::mutable_customer_id() {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  return customer_id_;
}
inline ::std::string* exec_cmd_request::release_customer_id() {
  clear_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customer_id_;
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void exec_cmd_request::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete customer_id_;
  }
  if (customer_id) {
    set_has_customer_id();
    customer_id_ = customer_id;
  } else {
    clear_has_customer_id();
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string token = 4;
inline bool exec_cmd_request::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void exec_cmd_request::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void exec_cmd_request::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void exec_cmd_request::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& exec_cmd_request::token() const {
  return *token_;
}
inline void exec_cmd_request::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void exec_cmd_request::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void exec_cmd_request::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* exec_cmd_request::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* exec_cmd_request::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void exec_cmd_request::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string command_line = 5;
inline bool exec_cmd_request::has_command_line() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void exec_cmd_request::set_has_command_line() {
  _has_bits_[0] |= 0x00000010u;
}
inline void exec_cmd_request::clear_has_command_line() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void exec_cmd_request::clear_command_line() {
  if (command_line_ != &::google::protobuf::internal::kEmptyString) {
    command_line_->clear();
  }
  clear_has_command_line();
}
inline const ::std::string& exec_cmd_request::command_line() const {
  return *command_line_;
}
inline void exec_cmd_request::set_command_line(const ::std::string& value) {
  set_has_command_line();
  if (command_line_ == &::google::protobuf::internal::kEmptyString) {
    command_line_ = new ::std::string;
  }
  command_line_->assign(value);
}
inline void exec_cmd_request::set_command_line(const char* value) {
  set_has_command_line();
  if (command_line_ == &::google::protobuf::internal::kEmptyString) {
    command_line_ = new ::std::string;
  }
  command_line_->assign(value);
}
inline void exec_cmd_request::set_command_line(const char* value, size_t size) {
  set_has_command_line();
  if (command_line_ == &::google::protobuf::internal::kEmptyString) {
    command_line_ = new ::std::string;
  }
  command_line_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* exec_cmd_request::mutable_command_line() {
  set_has_command_line();
  if (command_line_ == &::google::protobuf::internal::kEmptyString) {
    command_line_ = new ::std::string;
  }
  return command_line_;
}
inline ::std::string* exec_cmd_request::release_command_line() {
  clear_has_command_line();
  if (command_line_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = command_line_;
    command_line_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void exec_cmd_request::set_allocated_command_line(::std::string* command_line) {
  if (command_line_ != &::google::protobuf::internal::kEmptyString) {
    delete command_line_;
  }
  if (command_line) {
    set_has_command_line();
    command_line_ = command_line;
  } else {
    clear_has_command_line();
    command_line_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// exec_cmd_response

// required uint64 timestamp_ns = 1;
inline bool exec_cmd_response::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void exec_cmd_response::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void exec_cmd_response::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void exec_cmd_response::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 exec_cmd_response::timestamp_ns() const {
  return timestamp_ns_;
}
inline void exec_cmd_response::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
}

// required string machine_id = 2;
inline bool exec_cmd_response::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void exec_cmd_response::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void exec_cmd_response::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void exec_cmd_response::clear_machine_id() {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    machine_id_->clear();
  }
  clear_has_machine_id();
}
inline const ::std::string& exec_cmd_response::machine_id() const {
  return *machine_id_;
}
inline void exec_cmd_response::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void exec_cmd_response::set_machine_id(const char* value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void exec_cmd_response::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* exec_cmd_response::mutable_machine_id() {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  return machine_id_;
}
inline ::std::string* exec_cmd_response::release_machine_id() {
  clear_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_id_;
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void exec_cmd_response::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_id_;
  }
  if (machine_id) {
    set_has_machine_id();
    machine_id_ = machine_id;
  } else {
    clear_has_machine_id();
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string customer_id = 3;
inline bool exec_cmd_response::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void exec_cmd_response::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void exec_cmd_response::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void exec_cmd_response::clear_customer_id() {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    customer_id_->clear();
  }
  clear_has_customer_id();
}
inline const ::std::string& exec_cmd_response::customer_id() const {
  return *customer_id_;
}
inline void exec_cmd_response::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void exec_cmd_response::set_customer_id(const char* value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void exec_cmd_response::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* exec_cmd_response::mutable_customer_id() {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  return customer_id_;
}
inline ::std::string* exec_cmd_response::release_customer_id() {
  clear_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customer_id_;
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void exec_cmd_response::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete customer_id_;
  }
  if (customer_id) {
    set_has_customer_id();
    customer_id_ = customer_id;
  } else {
    clear_has_customer_id();
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string token = 4;
inline bool exec_cmd_response::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void exec_cmd_response::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void exec_cmd_response::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void exec_cmd_response::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& exec_cmd_response::token() const {
  return *token_;
}
inline void exec_cmd_response::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void exec_cmd_response::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void exec_cmd_response::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* exec_cmd_response::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* exec_cmd_response::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void exec_cmd_response::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string std_out = 5;
inline bool exec_cmd_response::has_std_out() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void exec_cmd_response::set_has_std_out() {
  _has_bits_[0] |= 0x00000010u;
}
inline void exec_cmd_response::clear_has_std_out() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void exec_cmd_response::clear_std_out() {
  if (std_out_ != &::google::protobuf::internal::kEmptyString) {
    std_out_->clear();
  }
  clear_has_std_out();
}
inline const ::std::string& exec_cmd_response::std_out() const {
  return *std_out_;
}
inline void exec_cmd_response::set_std_out(const ::std::string& value) {
  set_has_std_out();
  if (std_out_ == &::google::protobuf::internal::kEmptyString) {
    std_out_ = new ::std::string;
  }
  std_out_->assign(value);
}
inline void exec_cmd_response::set_std_out(const char* value) {
  set_has_std_out();
  if (std_out_ == &::google::protobuf::internal::kEmptyString) {
    std_out_ = new ::std::string;
  }
  std_out_->assign(value);
}
inline void exec_cmd_response::set_std_out(const char* value, size_t size) {
  set_has_std_out();
  if (std_out_ == &::google::protobuf::internal::kEmptyString) {
    std_out_ = new ::std::string;
  }
  std_out_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* exec_cmd_response::mutable_std_out() {
  set_has_std_out();
  if (std_out_ == &::google::protobuf::internal::kEmptyString) {
    std_out_ = new ::std::string;
  }
  return std_out_;
}
inline ::std::string* exec_cmd_response::release_std_out() {
  clear_has_std_out();
  if (std_out_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = std_out_;
    std_out_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void exec_cmd_response::set_allocated_std_out(::std::string* std_out) {
  if (std_out_ != &::google::protobuf::internal::kEmptyString) {
    delete std_out_;
  }
  if (std_out) {
    set_has_std_out();
    std_out_ = std_out;
  } else {
    clear_has_std_out();
    std_out_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string std_err = 6;
inline bool exec_cmd_response::has_std_err() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void exec_cmd_response::set_has_std_err() {
  _has_bits_[0] |= 0x00000020u;
}
inline void exec_cmd_response::clear_has_std_err() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void exec_cmd_response::clear_std_err() {
  if (std_err_ != &::google::protobuf::internal::kEmptyString) {
    std_err_->clear();
  }
  clear_has_std_err();
}
inline const ::std::string& exec_cmd_response::std_err() const {
  return *std_err_;
}
inline void exec_cmd_response::set_std_err(const ::std::string& value) {
  set_has_std_err();
  if (std_err_ == &::google::protobuf::internal::kEmptyString) {
    std_err_ = new ::std::string;
  }
  std_err_->assign(value);
}
inline void exec_cmd_response::set_std_err(const char* value) {
  set_has_std_err();
  if (std_err_ == &::google::protobuf::internal::kEmptyString) {
    std_err_ = new ::std::string;
  }
  std_err_->assign(value);
}
inline void exec_cmd_response::set_std_err(const char* value, size_t size) {
  set_has_std_err();
  if (std_err_ == &::google::protobuf::internal::kEmptyString) {
    std_err_ = new ::std::string;
  }
  std_err_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* exec_cmd_response::mutable_std_err() {
  set_has_std_err();
  if (std_err_ == &::google::protobuf::internal::kEmptyString) {
    std_err_ = new ::std::string;
  }
  return std_err_;
}
inline ::std::string* exec_cmd_response::release_std_err() {
  clear_has_std_err();
  if (std_err_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = std_err_;
    std_err_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void exec_cmd_response::set_allocated_std_err(::std::string* std_err) {
  if (std_err_ != &::google::protobuf::internal::kEmptyString) {
    delete std_err_;
  }
  if (std_err) {
    set_has_std_err();
    std_err_ = std_err;
  } else {
    clear_has_std_err();
    std_err_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 exit_val = 7;
inline bool exec_cmd_response::has_exit_val() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void exec_cmd_response::set_has_exit_val() {
  _has_bits_[0] |= 0x00000040u;
}
inline void exec_cmd_response::clear_has_exit_val() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void exec_cmd_response::clear_exit_val() {
  exit_val_ = 0u;
  clear_has_exit_val();
}
inline ::google::protobuf::uint32 exec_cmd_response::exit_val() const {
  return exit_val_;
}
inline void exec_cmd_response::set_exit_val(::google::protobuf::uint32 value) {
  set_has_exit_val();
  exit_val_ = value;
}

// -------------------------------------------------------------------

// ssh_open_channel

// required uint64 timestamp_ns = 1;
inline bool ssh_open_channel::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ssh_open_channel::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ssh_open_channel::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ssh_open_channel::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 ssh_open_channel::timestamp_ns() const {
  return timestamp_ns_;
}
inline void ssh_open_channel::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
}

// required string machine_id = 2;
inline bool ssh_open_channel::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ssh_open_channel::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ssh_open_channel::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ssh_open_channel::clear_machine_id() {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    machine_id_->clear();
  }
  clear_has_machine_id();
}
inline const ::std::string& ssh_open_channel::machine_id() const {
  return *machine_id_;
}
inline void ssh_open_channel::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void ssh_open_channel::set_machine_id(const char* value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void ssh_open_channel::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_open_channel::mutable_machine_id() {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  return machine_id_;
}
inline ::std::string* ssh_open_channel::release_machine_id() {
  clear_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_id_;
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_open_channel::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_id_;
  }
  if (machine_id) {
    set_has_machine_id();
    machine_id_ = machine_id;
  } else {
    clear_has_machine_id();
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string customer_id = 3;
inline bool ssh_open_channel::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ssh_open_channel::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ssh_open_channel::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ssh_open_channel::clear_customer_id() {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    customer_id_->clear();
  }
  clear_has_customer_id();
}
inline const ::std::string& ssh_open_channel::customer_id() const {
  return *customer_id_;
}
inline void ssh_open_channel::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void ssh_open_channel::set_customer_id(const char* value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void ssh_open_channel::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_open_channel::mutable_customer_id() {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  return customer_id_;
}
inline ::std::string* ssh_open_channel::release_customer_id() {
  clear_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customer_id_;
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_open_channel::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete customer_id_;
  }
  if (customer_id) {
    set_has_customer_id();
    customer_id_ = customer_id;
  } else {
    clear_has_customer_id();
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string token = 4;
inline bool ssh_open_channel::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ssh_open_channel::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ssh_open_channel::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ssh_open_channel::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& ssh_open_channel::token() const {
  return *token_;
}
inline void ssh_open_channel::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ssh_open_channel::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ssh_open_channel::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_open_channel::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* ssh_open_channel::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_open_channel::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string user = 5;
inline bool ssh_open_channel::has_user() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ssh_open_channel::set_has_user() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ssh_open_channel::clear_has_user() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ssh_open_channel::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& ssh_open_channel::user() const {
  return *user_;
}
inline void ssh_open_channel::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void ssh_open_channel::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void ssh_open_channel::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_open_channel::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* ssh_open_channel::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_open_channel::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 6;
inline bool ssh_open_channel::has_password() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ssh_open_channel::set_has_password() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ssh_open_channel::clear_has_password() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ssh_open_channel::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& ssh_open_channel::password() const {
  return *password_;
}
inline void ssh_open_channel::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ssh_open_channel::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ssh_open_channel::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_open_channel::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* ssh_open_channel::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_open_channel::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string key = 7;
inline bool ssh_open_channel::has_key() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ssh_open_channel::set_has_key() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ssh_open_channel::clear_has_key() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ssh_open_channel::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& ssh_open_channel::key() const {
  return *key_;
}
inline void ssh_open_channel::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void ssh_open_channel::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void ssh_open_channel::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_open_channel::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* ssh_open_channel::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_open_channel::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string passphrase = 8;
inline bool ssh_open_channel::has_passphrase() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ssh_open_channel::set_has_passphrase() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ssh_open_channel::clear_has_passphrase() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ssh_open_channel::clear_passphrase() {
  if (passphrase_ != &::google::protobuf::internal::kEmptyString) {
    passphrase_->clear();
  }
  clear_has_passphrase();
}
inline const ::std::string& ssh_open_channel::passphrase() const {
  return *passphrase_;
}
inline void ssh_open_channel::set_passphrase(const ::std::string& value) {
  set_has_passphrase();
  if (passphrase_ == &::google::protobuf::internal::kEmptyString) {
    passphrase_ = new ::std::string;
  }
  passphrase_->assign(value);
}
inline void ssh_open_channel::set_passphrase(const char* value) {
  set_has_passphrase();
  if (passphrase_ == &::google::protobuf::internal::kEmptyString) {
    passphrase_ = new ::std::string;
  }
  passphrase_->assign(value);
}
inline void ssh_open_channel::set_passphrase(const char* value, size_t size) {
  set_has_passphrase();
  if (passphrase_ == &::google::protobuf::internal::kEmptyString) {
    passphrase_ = new ::std::string;
  }
  passphrase_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_open_channel::mutable_passphrase() {
  set_has_passphrase();
  if (passphrase_ == &::google::protobuf::internal::kEmptyString) {
    passphrase_ = new ::std::string;
  }
  return passphrase_;
}
inline ::std::string* ssh_open_channel::release_passphrase() {
  clear_has_passphrase();
  if (passphrase_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passphrase_;
    passphrase_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_open_channel::set_allocated_passphrase(::std::string* passphrase) {
  if (passphrase_ != &::google::protobuf::internal::kEmptyString) {
    delete passphrase_;
  }
  if (passphrase) {
    set_has_passphrase();
    passphrase_ = passphrase;
  } else {
    clear_has_passphrase();
    passphrase_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 port = 9;
inline bool ssh_open_channel::has_port() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ssh_open_channel::set_has_port() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ssh_open_channel::clear_has_port() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ssh_open_channel::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 ssh_open_channel::port() const {
  return port_;
}
inline void ssh_open_channel::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// ssh_data

// required uint64 timestamp_ns = 1;
inline bool ssh_data::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ssh_data::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ssh_data::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ssh_data::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 ssh_data::timestamp_ns() const {
  return timestamp_ns_;
}
inline void ssh_data::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
}

// required string machine_id = 2;
inline bool ssh_data::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ssh_data::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ssh_data::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ssh_data::clear_machine_id() {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    machine_id_->clear();
  }
  clear_has_machine_id();
}
inline const ::std::string& ssh_data::machine_id() const {
  return *machine_id_;
}
inline void ssh_data::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void ssh_data::set_machine_id(const char* value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void ssh_data::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_data::mutable_machine_id() {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  return machine_id_;
}
inline ::std::string* ssh_data::release_machine_id() {
  clear_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_id_;
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_data::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_id_;
  }
  if (machine_id) {
    set_has_machine_id();
    machine_id_ = machine_id;
  } else {
    clear_has_machine_id();
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string customer_id = 3;
inline bool ssh_data::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ssh_data::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ssh_data::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ssh_data::clear_customer_id() {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    customer_id_->clear();
  }
  clear_has_customer_id();
}
inline const ::std::string& ssh_data::customer_id() const {
  return *customer_id_;
}
inline void ssh_data::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void ssh_data::set_customer_id(const char* value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void ssh_data::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_data::mutable_customer_id() {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  return customer_id_;
}
inline ::std::string* ssh_data::release_customer_id() {
  clear_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customer_id_;
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_data::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete customer_id_;
  }
  if (customer_id) {
    set_has_customer_id();
    customer_id_ = customer_id;
  } else {
    clear_has_customer_id();
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string token = 4;
inline bool ssh_data::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ssh_data::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ssh_data::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ssh_data::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& ssh_data::token() const {
  return *token_;
}
inline void ssh_data::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ssh_data::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ssh_data::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_data::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* ssh_data::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_data::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes data = 5;
inline bool ssh_data::has_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ssh_data::set_has_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ssh_data::clear_has_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ssh_data::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ssh_data::data() const {
  return *data_;
}
inline void ssh_data::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ssh_data::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ssh_data::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_data::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* ssh_data::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_data::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string error = 6;
inline bool ssh_data::has_error() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ssh_data::set_has_error() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ssh_data::clear_has_error() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ssh_data::clear_error() {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& ssh_data::error() const {
  return *error_;
}
inline void ssh_data::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void ssh_data::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void ssh_data::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_data::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  return error_;
}
inline ::std::string* ssh_data::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_data::set_allocated_error(::std::string* error) {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    delete error_;
  }
  if (error) {
    set_has_error();
    error_ = error;
  } else {
    clear_has_error();
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 exit_val = 7;
inline bool ssh_data::has_exit_val() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ssh_data::set_has_exit_val() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ssh_data::clear_has_exit_val() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ssh_data::clear_exit_val() {
  exit_val_ = 0;
  clear_has_exit_val();
}
inline ::google::protobuf::int32 ssh_data::exit_val() const {
  return exit_val_;
}
inline void ssh_data::set_exit_val(::google::protobuf::int32 value) {
  set_has_exit_val();
  exit_val_ = value;
}

// -------------------------------------------------------------------

// ssh_close_channel

// required uint64 timestamp_ns = 1;
inline bool ssh_close_channel::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ssh_close_channel::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ssh_close_channel::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ssh_close_channel::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 ssh_close_channel::timestamp_ns() const {
  return timestamp_ns_;
}
inline void ssh_close_channel::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
}

// required string machine_id = 2;
inline bool ssh_close_channel::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ssh_close_channel::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ssh_close_channel::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ssh_close_channel::clear_machine_id() {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    machine_id_->clear();
  }
  clear_has_machine_id();
}
inline const ::std::string& ssh_close_channel::machine_id() const {
  return *machine_id_;
}
inline void ssh_close_channel::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void ssh_close_channel::set_machine_id(const char* value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void ssh_close_channel::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_close_channel::mutable_machine_id() {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  return machine_id_;
}
inline ::std::string* ssh_close_channel::release_machine_id() {
  clear_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_id_;
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_close_channel::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_id_;
  }
  if (machine_id) {
    set_has_machine_id();
    machine_id_ = machine_id;
  } else {
    clear_has_machine_id();
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string customer_id = 3;
inline bool ssh_close_channel::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ssh_close_channel::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ssh_close_channel::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ssh_close_channel::clear_customer_id() {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    customer_id_->clear();
  }
  clear_has_customer_id();
}
inline const ::std::string& ssh_close_channel::customer_id() const {
  return *customer_id_;
}
inline void ssh_close_channel::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void ssh_close_channel::set_customer_id(const char* value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void ssh_close_channel::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_close_channel::mutable_customer_id() {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  return customer_id_;
}
inline ::std::string* ssh_close_channel::release_customer_id() {
  clear_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customer_id_;
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_close_channel::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete customer_id_;
  }
  if (customer_id) {
    set_has_customer_id();
    customer_id_ = customer_id;
  } else {
    clear_has_customer_id();
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string token = 4;
inline bool ssh_close_channel::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ssh_close_channel::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ssh_close_channel::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ssh_close_channel::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& ssh_close_channel::token() const {
  return *token_;
}
inline void ssh_close_channel::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ssh_close_channel::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ssh_close_channel::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_close_channel::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* ssh_close_channel::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_close_channel::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace draiosproto

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::draiosproto::networkrole>() {
  return ::draiosproto::networkrole_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::draiosproto::message_type>() {
  return ::draiosproto::message_type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_draios_2eproto__INCLUDED
