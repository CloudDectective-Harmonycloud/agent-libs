// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: draios.proto

#ifndef PROTOBUF_draios_2eproto__INCLUDED
#define PROTOBUF_draios_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace draiosproto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_draios_2eproto();
void protobuf_AssignDesc_draios_2eproto();
void protobuf_ShutdownFile_draios_2eproto();

class counter_time;
class counter_time_bidirectional;
class counter_bytes;
class counter_time_bytes;
class time_categories;
class transaction_breakdown_categories;
class counter_syscall_errors;
class resource_categories;
class connection_categories;
class process_details;
class command_details;
class counter_proto_entry;
class url_details;
class status_code_details;
class http_info;
class sql_entry_details;
class sql_query_type_details;
class sql_info;
class mongodb_collection_details;
class mongodb_op_type_details;
class mongodb_info;
class jmx_attribute;
class jmx_bean;
class java_info;
class statsd_tag;
class statsd_metric;
class statsd_info;
class app_tag;
class app_metric;
class app_check;
class app_info;
class proto_info;
class network_by_port;
class host;
class process;
class program;
class ipv4tuple;
class ipv4_connection;
class ipv4_network_interface;
class mounted_fs;
class file_stat;
class container_port_mapping;
class container_label;
class container;
class k8s_pair;
class k8s_common;
class k8s_namespace;
class k8s_node;
class k8s_pod;
class k8s_replication_controller;
class k8s_service;
class k8s_service_net_port;
class k8s_state;
class mesos_pair;
class mesos_common;
class mesos_task;
class marathon_app;
class marathon_group;
class mesos_framework;
class mesos_slave;
class mesos_state;
class metrics;
class dump_request_start;
class dump_request_stop;
class dump_response;
class ssh_open_channel;
class ssh_data;
class ssh_close_channel;
class auto_update_request;
class dirty_shutdown_report;

enum sql_statement_type {
  SOP_NONE = 0,
  SOP_SELECT = 1,
  SOP_INSERT = 2,
  SOP_SET = 3,
  SOP_CREATE = 4,
  SOP_DELETE = 5,
  SOP_DROP = 6,
  SOP_REPLACE = 7,
  SOP_UPDATE = 8,
  SOP_USE = 9,
  SOP_SHOW = 10,
  SOP_LOCK = 11,
  SOP_UNLOCK = 12,
  SOP_ALTER = 13
};
bool sql_statement_type_IsValid(int value);
const sql_statement_type sql_statement_type_MIN = SOP_NONE;
const sql_statement_type sql_statement_type_MAX = SOP_ALTER;
const int sql_statement_type_ARRAYSIZE = sql_statement_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* sql_statement_type_descriptor();
inline const ::std::string& sql_statement_type_Name(sql_statement_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    sql_statement_type_descriptor(), value);
}
inline bool sql_statement_type_Parse(
    const ::std::string& name, sql_statement_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<sql_statement_type>(
    sql_statement_type_descriptor(), name, value);
}
enum mongodb_op_type {
  MONGODB_OP_NONE = 0,
  MONGODB_OP_INSERT = 1,
  MONGODB_OP_UPDATE = 2,
  MONGODB_OP_DELETE = 3,
  MONGODB_OP_GET_MORE = 4,
  MONGODB_OP_KILL_CURSORS = 5,
  MONGODB_OP_FIND = 6,
  MONGODB_OP_AGGREGATE = 7,
  MONGODB_OP_COMMAND = 8,
  MONGODB_OP_COUNT = 9,
  MONGODB_OP_DISTINCT = 10,
  MONGODB_OP_MAP_REDUCE = 11,
  MONGODB_OP_GEO_NEAR = 12,
  MONGODB_OP_GEO_SEARCH = 13,
  MONGODB_OP_FIND_AND_MODIFY = 14
};
bool mongodb_op_type_IsValid(int value);
const mongodb_op_type mongodb_op_type_MIN = MONGODB_OP_NONE;
const mongodb_op_type mongodb_op_type_MAX = MONGODB_OP_FIND_AND_MODIFY;
const int mongodb_op_type_ARRAYSIZE = mongodb_op_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* mongodb_op_type_descriptor();
inline const ::std::string& mongodb_op_type_Name(mongodb_op_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    mongodb_op_type_descriptor(), value);
}
inline bool mongodb_op_type_Parse(
    const ::std::string& name, mongodb_op_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<mongodb_op_type>(
    mongodb_op_type_descriptor(), name, value);
}
enum unit {
  UNIT_NONE = 0,
  UNIT_SECOND = 1,
  UNIT_BYTE = 2,
  UNIT_PERCENT = 3
};
bool unit_IsValid(int value);
const unit unit_MIN = UNIT_NONE;
const unit unit_MAX = UNIT_PERCENT;
const int unit_ARRAYSIZE = unit_MAX + 1;

const ::google::protobuf::EnumDescriptor* unit_descriptor();
inline const ::std::string& unit_Name(unit value) {
  return ::google::protobuf::internal::NameOfEnum(
    unit_descriptor(), value);
}
inline bool unit_Parse(
    const ::std::string& name, unit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<unit>(
    unit_descriptor(), name, value);
}
enum scale {
  SCALE_NONE = 0,
  SCALE_MILLI = 1,
  SCALE_MICRO = 2,
  SCALE_NANO = 3,
  SCALE_MINUTE = 4,
  SCALE_HOUR = 5,
  SCALE_DAY = 6,
  SCALE_KILO = 7,
  SCALE_MEGA = 8,
  SCALE_GIGA = 9,
  SCALE_TERA = 10,
  SCALE_KIBI = 11,
  SCALE_MEBI = 12,
  SCALE_GIBI = 13,
  SCALE_TEBI = 14,
  SCALE_PERCENT_0_1 = 15
};
bool scale_IsValid(int value);
const scale scale_MIN = SCALE_NONE;
const scale scale_MAX = SCALE_PERCENT_0_1;
const int scale_ARRAYSIZE = scale_MAX + 1;

const ::google::protobuf::EnumDescriptor* scale_descriptor();
inline const ::std::string& scale_Name(scale value) {
  return ::google::protobuf::internal::NameOfEnum(
    scale_descriptor(), value);
}
inline bool scale_Parse(
    const ::std::string& name, scale* value) {
  return ::google::protobuf::internal::ParseNamedEnum<scale>(
    scale_descriptor(), name, value);
}
enum jmx_metric_type {
  JMX_METRIC_TYPE_COUNTER = 1,
  JMX_METRIC_TYPE_GAUGE = 2
};
bool jmx_metric_type_IsValid(int value);
const jmx_metric_type jmx_metric_type_MIN = JMX_METRIC_TYPE_COUNTER;
const jmx_metric_type jmx_metric_type_MAX = JMX_METRIC_TYPE_GAUGE;
const int jmx_metric_type_ARRAYSIZE = jmx_metric_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* jmx_metric_type_descriptor();
inline const ::std::string& jmx_metric_type_Name(jmx_metric_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    jmx_metric_type_descriptor(), value);
}
inline bool jmx_metric_type_Parse(
    const ::std::string& name, jmx_metric_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<jmx_metric_type>(
    jmx_metric_type_descriptor(), name, value);
}
enum statsd_metric_type {
  STATSD_COUNT = 1,
  STATSD_HISTOGRAM = 2,
  STATSD_GAUGE = 3,
  STATSD_SET = 4
};
bool statsd_metric_type_IsValid(int value);
const statsd_metric_type statsd_metric_type_MIN = STATSD_COUNT;
const statsd_metric_type statsd_metric_type_MAX = STATSD_SET;
const int statsd_metric_type_ARRAYSIZE = statsd_metric_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* statsd_metric_type_descriptor();
inline const ::std::string& statsd_metric_type_Name(statsd_metric_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    statsd_metric_type_descriptor(), value);
}
inline bool statsd_metric_type_Parse(
    const ::std::string& name, statsd_metric_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<statsd_metric_type>(
    statsd_metric_type_descriptor(), name, value);
}
enum app_metric_type {
  APP_METRIC_TYPE_GAUGE = 1,
  APP_METRIC_TYPE_RATE = 2
};
bool app_metric_type_IsValid(int value);
const app_metric_type app_metric_type_MIN = APP_METRIC_TYPE_GAUGE;
const app_metric_type app_metric_type_MAX = APP_METRIC_TYPE_RATE;
const int app_metric_type_ARRAYSIZE = app_metric_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* app_metric_type_descriptor();
inline const ::std::string& app_metric_type_Name(app_metric_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    app_metric_type_descriptor(), value);
}
inline bool app_metric_type_Parse(
    const ::std::string& name, app_metric_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<app_metric_type>(
    app_metric_type_descriptor(), name, value);
}
enum app_check_value {
  APP_CHECK_VALUE_OK = 0,
  APP_CHECK_VALUE_WARNING = 1,
  APP_CHECK_VALUE_CRITICAL = 2,
  APP_CHECK_VALUE_UNKNOWN = 3
};
bool app_check_value_IsValid(int value);
const app_check_value app_check_value_MIN = APP_CHECK_VALUE_OK;
const app_check_value app_check_value_MAX = APP_CHECK_VALUE_UNKNOWN;
const int app_check_value_ARRAYSIZE = app_check_value_MAX + 1;

const ::google::protobuf::EnumDescriptor* app_check_value_descriptor();
inline const ::std::string& app_check_value_Name(app_check_value value) {
  return ::google::protobuf::internal::NameOfEnum(
    app_check_value_descriptor(), value);
}
inline bool app_check_value_Parse(
    const ::std::string& name, app_check_value* value) {
  return ::google::protobuf::internal::ParseNamedEnum<app_check_value>(
    app_check_value_descriptor(), name, value);
}
enum networkrole {
  NONE = 0,
  IS_LOCAL_IPV4_SERVER = 1,
  IS_REMOTE_IPV4_SERVER = 2,
  IS_UNIX_SERVER = 4,
  IS_LOCAL_IPV4_CLIENT = 8,
  IS_REMOTE_IPV4_CLIENT = 16,
  IS_UNIX_CLIENT = 32
};
bool networkrole_IsValid(int value);
const networkrole networkrole_MIN = NONE;
const networkrole networkrole_MAX = IS_UNIX_CLIENT;
const int networkrole_ARRAYSIZE = networkrole_MAX + 1;

const ::google::protobuf::EnumDescriptor* networkrole_descriptor();
inline const ::std::string& networkrole_Name(networkrole value) {
  return ::google::protobuf::internal::NameOfEnum(
    networkrole_descriptor(), value);
}
inline bool networkrole_Parse(
    const ::std::string& name, networkrole* value) {
  return ::google::protobuf::internal::ParseNamedEnum<networkrole>(
    networkrole_descriptor(), name, value);
}
enum message_type {
  METRICS = 1,
  DUMP_REQUEST_START = 2,
  DUMP_REQUEST_STOP = 4,
  DUMP_RESPONSE = 3,
  SSH_OPEN_CHANNEL = 6,
  SSH_CLOSE_CHANNEL = 7,
  SSH_DATA = 8,
  AUTO_UPDATE_REQUEST = 9,
  DIRTY_SHUTDOWN_REPORT = 10
};
bool message_type_IsValid(int value);
const message_type message_type_MIN = METRICS;
const message_type message_type_MAX = DIRTY_SHUTDOWN_REPORT;
const int message_type_ARRAYSIZE = message_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* message_type_descriptor();
inline const ::std::string& message_type_Name(message_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    message_type_descriptor(), value);
}
inline bool message_type_Parse(
    const ::std::string& name, message_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<message_type>(
    message_type_descriptor(), name, value);
}
enum container_type {
  DOCKER = 1,
  LXC = 2,
  LIBVIRT_LXC = 3,
  MESOS = 4,
  RKT = 5
};
bool container_type_IsValid(int value);
const container_type container_type_MIN = DOCKER;
const container_type container_type_MAX = RKT;
const int container_type_ARRAYSIZE = container_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* container_type_descriptor();
inline const ::std::string& container_type_Name(container_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    container_type_descriptor(), value);
}
inline bool container_type_Parse(
    const ::std::string& name, container_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<container_type>(
    container_type_descriptor(), name, value);
}
// ===================================================================

class counter_time : public ::google::protobuf::Message {
 public:
  counter_time();
  virtual ~counter_time();

  counter_time(const counter_time& from);

  inline counter_time& operator=(const counter_time& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const counter_time& default_instance();

  void Swap(counter_time* other);

  // implements Message ----------------------------------------------

  counter_time* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const counter_time& from);
  void MergeFrom(const counter_time& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // required uint64 time_ns = 2;
  inline bool has_time_ns() const;
  inline void clear_time_ns();
  static const int kTimeNsFieldNumber = 2;
  inline ::google::protobuf::uint64 time_ns() const;
  inline void set_time_ns(::google::protobuf::uint64 value);

  // optional uint32 time_percentage = 3;
  inline bool has_time_percentage() const;
  inline void clear_time_percentage();
  static const int kTimePercentageFieldNumber = 3;
  inline ::google::protobuf::uint32 time_percentage() const;
  inline void set_time_percentage(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.counter_time)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_time_ns();
  inline void clear_has_time_ns();
  inline void set_has_time_percentage();
  inline void clear_has_time_percentage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 time_ns_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 time_percentage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static counter_time* default_instance_;
};
// -------------------------------------------------------------------

class counter_time_bidirectional : public ::google::protobuf::Message {
 public:
  counter_time_bidirectional();
  virtual ~counter_time_bidirectional();

  counter_time_bidirectional(const counter_time_bidirectional& from);

  inline counter_time_bidirectional& operator=(const counter_time_bidirectional& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const counter_time_bidirectional& default_instance();

  void Swap(counter_time_bidirectional* other);

  // implements Message ----------------------------------------------

  counter_time_bidirectional* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const counter_time_bidirectional& from);
  void MergeFrom(const counter_time_bidirectional& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 count_in = 1;
  inline bool has_count_in() const;
  inline void clear_count_in();
  static const int kCountInFieldNumber = 1;
  inline ::google::protobuf::uint32 count_in() const;
  inline void set_count_in(::google::protobuf::uint32 value);

  // required uint32 count_out = 2;
  inline bool has_count_out() const;
  inline void clear_count_out();
  static const int kCountOutFieldNumber = 2;
  inline ::google::protobuf::uint32 count_out() const;
  inline void set_count_out(::google::protobuf::uint32 value);

  // required uint64 time_ns_in = 3;
  inline bool has_time_ns_in() const;
  inline void clear_time_ns_in();
  static const int kTimeNsInFieldNumber = 3;
  inline ::google::protobuf::uint64 time_ns_in() const;
  inline void set_time_ns_in(::google::protobuf::uint64 value);

  // required uint64 time_ns_out = 4;
  inline bool has_time_ns_out() const;
  inline void clear_time_ns_out();
  static const int kTimeNsOutFieldNumber = 4;
  inline ::google::protobuf::uint64 time_ns_out() const;
  inline void set_time_ns_out(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:draiosproto.counter_time_bidirectional)
 private:
  inline void set_has_count_in();
  inline void clear_has_count_in();
  inline void set_has_count_out();
  inline void clear_has_count_out();
  inline void set_has_time_ns_in();
  inline void clear_has_time_ns_in();
  inline void set_has_time_ns_out();
  inline void clear_has_time_ns_out();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 count_in_;
  ::google::protobuf::uint32 count_out_;
  ::google::protobuf::uint64 time_ns_in_;
  ::google::protobuf::uint64 time_ns_out_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static counter_time_bidirectional* default_instance_;
};
// -------------------------------------------------------------------

class counter_bytes : public ::google::protobuf::Message {
 public:
  counter_bytes();
  virtual ~counter_bytes();

  counter_bytes(const counter_bytes& from);

  inline counter_bytes& operator=(const counter_bytes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const counter_bytes& default_instance();

  void Swap(counter_bytes* other);

  // implements Message ----------------------------------------------

  counter_bytes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const counter_bytes& from);
  void MergeFrom(const counter_bytes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 count_in = 1;
  inline bool has_count_in() const;
  inline void clear_count_in();
  static const int kCountInFieldNumber = 1;
  inline ::google::protobuf::uint32 count_in() const;
  inline void set_count_in(::google::protobuf::uint32 value);

  // required uint32 count_out = 2;
  inline bool has_count_out() const;
  inline void clear_count_out();
  static const int kCountOutFieldNumber = 2;
  inline ::google::protobuf::uint32 count_out() const;
  inline void set_count_out(::google::protobuf::uint32 value);

  // required uint32 bytes_in = 3;
  inline bool has_bytes_in() const;
  inline void clear_bytes_in();
  static const int kBytesInFieldNumber = 3;
  inline ::google::protobuf::uint32 bytes_in() const;
  inline void set_bytes_in(::google::protobuf::uint32 value);

  // required uint32 bytes_out = 4;
  inline bool has_bytes_out() const;
  inline void clear_bytes_out();
  static const int kBytesOutFieldNumber = 4;
  inline ::google::protobuf::uint32 bytes_out() const;
  inline void set_bytes_out(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.counter_bytes)
 private:
  inline void set_has_count_in();
  inline void clear_has_count_in();
  inline void set_has_count_out();
  inline void clear_has_count_out();
  inline void set_has_bytes_in();
  inline void clear_has_bytes_in();
  inline void set_has_bytes_out();
  inline void clear_has_bytes_out();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 count_in_;
  ::google::protobuf::uint32 count_out_;
  ::google::protobuf::uint32 bytes_in_;
  ::google::protobuf::uint32 bytes_out_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static counter_bytes* default_instance_;
};
// -------------------------------------------------------------------

class counter_time_bytes : public ::google::protobuf::Message {
 public:
  counter_time_bytes();
  virtual ~counter_time_bytes();

  counter_time_bytes(const counter_time_bytes& from);

  inline counter_time_bytes& operator=(const counter_time_bytes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const counter_time_bytes& default_instance();

  void Swap(counter_time_bytes* other);

  // implements Message ----------------------------------------------

  counter_time_bytes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const counter_time_bytes& from);
  void MergeFrom(const counter_time_bytes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 time_ns_in = 1;
  inline bool has_time_ns_in() const;
  inline void clear_time_ns_in();
  static const int kTimeNsInFieldNumber = 1;
  inline ::google::protobuf::uint64 time_ns_in() const;
  inline void set_time_ns_in(::google::protobuf::uint64 value);

  // required uint64 time_ns_out = 2;
  inline bool has_time_ns_out() const;
  inline void clear_time_ns_out();
  static const int kTimeNsOutFieldNumber = 2;
  inline ::google::protobuf::uint64 time_ns_out() const;
  inline void set_time_ns_out(::google::protobuf::uint64 value);

  // required uint64 time_ns_other = 3;
  inline bool has_time_ns_other() const;
  inline void clear_time_ns_other();
  static const int kTimeNsOtherFieldNumber = 3;
  inline ::google::protobuf::uint64 time_ns_other() const;
  inline void set_time_ns_other(::google::protobuf::uint64 value);

  // required uint32 count_in = 4;
  inline bool has_count_in() const;
  inline void clear_count_in();
  static const int kCountInFieldNumber = 4;
  inline ::google::protobuf::uint32 count_in() const;
  inline void set_count_in(::google::protobuf::uint32 value);

  // required uint32 count_out = 5;
  inline bool has_count_out() const;
  inline void clear_count_out();
  static const int kCountOutFieldNumber = 5;
  inline ::google::protobuf::uint32 count_out() const;
  inline void set_count_out(::google::protobuf::uint32 value);

  // required uint32 count_other = 6;
  inline bool has_count_other() const;
  inline void clear_count_other();
  static const int kCountOtherFieldNumber = 6;
  inline ::google::protobuf::uint32 count_other() const;
  inline void set_count_other(::google::protobuf::uint32 value);

  // required uint32 bytes_in = 7;
  inline bool has_bytes_in() const;
  inline void clear_bytes_in();
  static const int kBytesInFieldNumber = 7;
  inline ::google::protobuf::uint32 bytes_in() const;
  inline void set_bytes_in(::google::protobuf::uint32 value);

  // required uint32 bytes_out = 8;
  inline bool has_bytes_out() const;
  inline void clear_bytes_out();
  static const int kBytesOutFieldNumber = 8;
  inline ::google::protobuf::uint32 bytes_out() const;
  inline void set_bytes_out(::google::protobuf::uint32 value);

  // required uint32 bytes_other = 9;
  inline bool has_bytes_other() const;
  inline void clear_bytes_other();
  static const int kBytesOtherFieldNumber = 9;
  inline ::google::protobuf::uint32 bytes_other() const;
  inline void set_bytes_other(::google::protobuf::uint32 value);

  // optional uint32 time_percentage_in = 10;
  inline bool has_time_percentage_in() const;
  inline void clear_time_percentage_in();
  static const int kTimePercentageInFieldNumber = 10;
  inline ::google::protobuf::uint32 time_percentage_in() const;
  inline void set_time_percentage_in(::google::protobuf::uint32 value);

  // optional uint32 time_percentage_out = 11;
  inline bool has_time_percentage_out() const;
  inline void clear_time_percentage_out();
  static const int kTimePercentageOutFieldNumber = 11;
  inline ::google::protobuf::uint32 time_percentage_out() const;
  inline void set_time_percentage_out(::google::protobuf::uint32 value);

  // optional uint32 time_percentage_other = 12;
  inline bool has_time_percentage_other() const;
  inline void clear_time_percentage_other();
  static const int kTimePercentageOtherFieldNumber = 12;
  inline ::google::protobuf::uint32 time_percentage_other() const;
  inline void set_time_percentage_other(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.counter_time_bytes)
 private:
  inline void set_has_time_ns_in();
  inline void clear_has_time_ns_in();
  inline void set_has_time_ns_out();
  inline void clear_has_time_ns_out();
  inline void set_has_time_ns_other();
  inline void clear_has_time_ns_other();
  inline void set_has_count_in();
  inline void clear_has_count_in();
  inline void set_has_count_out();
  inline void clear_has_count_out();
  inline void set_has_count_other();
  inline void clear_has_count_other();
  inline void set_has_bytes_in();
  inline void clear_has_bytes_in();
  inline void set_has_bytes_out();
  inline void clear_has_bytes_out();
  inline void set_has_bytes_other();
  inline void clear_has_bytes_other();
  inline void set_has_time_percentage_in();
  inline void clear_has_time_percentage_in();
  inline void set_has_time_percentage_out();
  inline void clear_has_time_percentage_out();
  inline void set_has_time_percentage_other();
  inline void clear_has_time_percentage_other();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 time_ns_in_;
  ::google::protobuf::uint64 time_ns_out_;
  ::google::protobuf::uint64 time_ns_other_;
  ::google::protobuf::uint32 count_in_;
  ::google::protobuf::uint32 count_out_;
  ::google::protobuf::uint32 count_other_;
  ::google::protobuf::uint32 bytes_in_;
  ::google::protobuf::uint32 bytes_out_;
  ::google::protobuf::uint32 bytes_other_;
  ::google::protobuf::uint32 time_percentage_in_;
  ::google::protobuf::uint32 time_percentage_out_;
  ::google::protobuf::uint32 time_percentage_other_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static counter_time_bytes* default_instance_;
};
// -------------------------------------------------------------------

class time_categories : public ::google::protobuf::Message {
 public:
  time_categories();
  virtual ~time_categories();

  time_categories(const time_categories& from);

  inline time_categories& operator=(const time_categories& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const time_categories& default_instance();

  void Swap(time_categories* other);

  // implements Message ----------------------------------------------

  time_categories* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const time_categories& from);
  void MergeFrom(const time_categories& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .draiosproto.counter_time unknown = 1;
  inline bool has_unknown() const;
  inline void clear_unknown();
  static const int kUnknownFieldNumber = 1;
  inline const ::draiosproto::counter_time& unknown() const;
  inline ::draiosproto::counter_time* mutable_unknown();
  inline ::draiosproto::counter_time* release_unknown();
  inline void set_allocated_unknown(::draiosproto::counter_time* unknown);

  // optional .draiosproto.counter_time other = 2;
  inline bool has_other() const;
  inline void clear_other();
  static const int kOtherFieldNumber = 2;
  inline const ::draiosproto::counter_time& other() const;
  inline ::draiosproto::counter_time* mutable_other();
  inline ::draiosproto::counter_time* release_other();
  inline void set_allocated_other(::draiosproto::counter_time* other);

  // optional .draiosproto.counter_time file = 3;
  inline bool has_file() const;
  inline void clear_file();
  static const int kFileFieldNumber = 3;
  inline const ::draiosproto::counter_time& file() const;
  inline ::draiosproto::counter_time* mutable_file();
  inline ::draiosproto::counter_time* release_file();
  inline void set_allocated_file(::draiosproto::counter_time* file);

  // optional .draiosproto.counter_time net = 4;
  inline bool has_net() const;
  inline void clear_net();
  static const int kNetFieldNumber = 4;
  inline const ::draiosproto::counter_time& net() const;
  inline ::draiosproto::counter_time* mutable_net();
  inline ::draiosproto::counter_time* release_net();
  inline void set_allocated_net(::draiosproto::counter_time* net);

  // optional .draiosproto.counter_time ipc = 5;
  inline bool has_ipc() const;
  inline void clear_ipc();
  static const int kIpcFieldNumber = 5;
  inline const ::draiosproto::counter_time& ipc() const;
  inline ::draiosproto::counter_time* mutable_ipc();
  inline ::draiosproto::counter_time* release_ipc();
  inline void set_allocated_ipc(::draiosproto::counter_time* ipc);

  // optional .draiosproto.counter_time memory = 6;
  inline bool has_memory() const;
  inline void clear_memory();
  static const int kMemoryFieldNumber = 6;
  inline const ::draiosproto::counter_time& memory() const;
  inline ::draiosproto::counter_time* mutable_memory();
  inline ::draiosproto::counter_time* release_memory();
  inline void set_allocated_memory(::draiosproto::counter_time* memory);

  // optional .draiosproto.counter_time process = 7;
  inline bool has_process() const;
  inline void clear_process();
  static const int kProcessFieldNumber = 7;
  inline const ::draiosproto::counter_time& process() const;
  inline ::draiosproto::counter_time* mutable_process();
  inline ::draiosproto::counter_time* release_process();
  inline void set_allocated_process(::draiosproto::counter_time* process);

  // optional .draiosproto.counter_time sleep = 8;
  inline bool has_sleep() const;
  inline void clear_sleep();
  static const int kSleepFieldNumber = 8;
  inline const ::draiosproto::counter_time& sleep() const;
  inline ::draiosproto::counter_time* mutable_sleep();
  inline ::draiosproto::counter_time* release_sleep();
  inline void set_allocated_sleep(::draiosproto::counter_time* sleep);

  // optional .draiosproto.counter_time system = 9;
  inline bool has_system() const;
  inline void clear_system();
  static const int kSystemFieldNumber = 9;
  inline const ::draiosproto::counter_time& system() const;
  inline ::draiosproto::counter_time* mutable_system();
  inline ::draiosproto::counter_time* release_system();
  inline void set_allocated_system(::draiosproto::counter_time* system);

  // optional .draiosproto.counter_time signal = 10;
  inline bool has_signal() const;
  inline void clear_signal();
  static const int kSignalFieldNumber = 10;
  inline const ::draiosproto::counter_time& signal() const;
  inline ::draiosproto::counter_time* mutable_signal();
  inline ::draiosproto::counter_time* release_signal();
  inline void set_allocated_signal(::draiosproto::counter_time* signal);

  // optional .draiosproto.counter_time user = 11;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 11;
  inline const ::draiosproto::counter_time& user() const;
  inline ::draiosproto::counter_time* mutable_user();
  inline ::draiosproto::counter_time* release_user();
  inline void set_allocated_user(::draiosproto::counter_time* user);

  // optional .draiosproto.counter_time time = 12;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 12;
  inline const ::draiosproto::counter_time& time() const;
  inline ::draiosproto::counter_time* mutable_time();
  inline ::draiosproto::counter_time* release_time();
  inline void set_allocated_time(::draiosproto::counter_time* time);

  // optional .draiosproto.counter_time_bytes io_file = 13;
  inline bool has_io_file() const;
  inline void clear_io_file();
  static const int kIoFileFieldNumber = 13;
  inline const ::draiosproto::counter_time_bytes& io_file() const;
  inline ::draiosproto::counter_time_bytes* mutable_io_file();
  inline ::draiosproto::counter_time_bytes* release_io_file();
  inline void set_allocated_io_file(::draiosproto::counter_time_bytes* io_file);

  // optional .draiosproto.counter_time_bytes io_net = 14;
  inline bool has_io_net() const;
  inline void clear_io_net();
  static const int kIoNetFieldNumber = 14;
  inline const ::draiosproto::counter_time_bytes& io_net() const;
  inline ::draiosproto::counter_time_bytes* mutable_io_net();
  inline ::draiosproto::counter_time_bytes* release_io_net();
  inline void set_allocated_io_net(::draiosproto::counter_time_bytes* io_net);

  // optional .draiosproto.counter_time_bytes io_other = 15;
  inline bool has_io_other() const;
  inline void clear_io_other();
  static const int kIoOtherFieldNumber = 15;
  inline const ::draiosproto::counter_time_bytes& io_other() const;
  inline ::draiosproto::counter_time_bytes* mutable_io_other();
  inline ::draiosproto::counter_time_bytes* release_io_other();
  inline void set_allocated_io_other(::draiosproto::counter_time_bytes* io_other);

  // optional .draiosproto.counter_time wait = 16;
  inline bool has_wait() const;
  inline void clear_wait();
  static const int kWaitFieldNumber = 16;
  inline const ::draiosproto::counter_time& wait() const;
  inline ::draiosproto::counter_time* mutable_wait();
  inline ::draiosproto::counter_time* release_wait();
  inline void set_allocated_wait(::draiosproto::counter_time* wait);

  // optional .draiosproto.counter_time processing = 17;
  inline bool has_processing() const;
  inline void clear_processing();
  static const int kProcessingFieldNumber = 17;
  inline const ::draiosproto::counter_time& processing() const;
  inline ::draiosproto::counter_time* mutable_processing();
  inline ::draiosproto::counter_time* release_processing();
  inline void set_allocated_processing(::draiosproto::counter_time* processing);

  // @@protoc_insertion_point(class_scope:draiosproto.time_categories)
 private:
  inline void set_has_unknown();
  inline void clear_has_unknown();
  inline void set_has_other();
  inline void clear_has_other();
  inline void set_has_file();
  inline void clear_has_file();
  inline void set_has_net();
  inline void clear_has_net();
  inline void set_has_ipc();
  inline void clear_has_ipc();
  inline void set_has_memory();
  inline void clear_has_memory();
  inline void set_has_process();
  inline void clear_has_process();
  inline void set_has_sleep();
  inline void clear_has_sleep();
  inline void set_has_system();
  inline void clear_has_system();
  inline void set_has_signal();
  inline void clear_has_signal();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_io_file();
  inline void clear_has_io_file();
  inline void set_has_io_net();
  inline void clear_has_io_net();
  inline void set_has_io_other();
  inline void clear_has_io_other();
  inline void set_has_wait();
  inline void clear_has_wait();
  inline void set_has_processing();
  inline void clear_has_processing();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::draiosproto::counter_time* unknown_;
  ::draiosproto::counter_time* other_;
  ::draiosproto::counter_time* file_;
  ::draiosproto::counter_time* net_;
  ::draiosproto::counter_time* ipc_;
  ::draiosproto::counter_time* memory_;
  ::draiosproto::counter_time* process_;
  ::draiosproto::counter_time* sleep_;
  ::draiosproto::counter_time* system_;
  ::draiosproto::counter_time* signal_;
  ::draiosproto::counter_time* user_;
  ::draiosproto::counter_time* time_;
  ::draiosproto::counter_time_bytes* io_file_;
  ::draiosproto::counter_time_bytes* io_net_;
  ::draiosproto::counter_time_bytes* io_other_;
  ::draiosproto::counter_time* wait_;
  ::draiosproto::counter_time* processing_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static time_categories* default_instance_;
};
// -------------------------------------------------------------------

class transaction_breakdown_categories : public ::google::protobuf::Message {
 public:
  transaction_breakdown_categories();
  virtual ~transaction_breakdown_categories();

  transaction_breakdown_categories(const transaction_breakdown_categories& from);

  inline transaction_breakdown_categories& operator=(const transaction_breakdown_categories& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const transaction_breakdown_categories& default_instance();

  void Swap(transaction_breakdown_categories* other);

  // implements Message ----------------------------------------------

  transaction_breakdown_categories* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const transaction_breakdown_categories& from);
  void MergeFrom(const transaction_breakdown_categories& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .draiosproto.counter_time other = 2;
  inline bool has_other() const;
  inline void clear_other();
  static const int kOtherFieldNumber = 2;
  inline const ::draiosproto::counter_time& other() const;
  inline ::draiosproto::counter_time* mutable_other();
  inline ::draiosproto::counter_time* release_other();
  inline void set_allocated_other(::draiosproto::counter_time* other);

  // optional .draiosproto.counter_time_bytes io_file = 13;
  inline bool has_io_file() const;
  inline void clear_io_file();
  static const int kIoFileFieldNumber = 13;
  inline const ::draiosproto::counter_time_bytes& io_file() const;
  inline ::draiosproto::counter_time_bytes* mutable_io_file();
  inline ::draiosproto::counter_time_bytes* release_io_file();
  inline void set_allocated_io_file(::draiosproto::counter_time_bytes* io_file);

  // optional .draiosproto.counter_time_bytes io_net = 14;
  inline bool has_io_net() const;
  inline void clear_io_net();
  static const int kIoNetFieldNumber = 14;
  inline const ::draiosproto::counter_time_bytes& io_net() const;
  inline ::draiosproto::counter_time_bytes* mutable_io_net();
  inline ::draiosproto::counter_time_bytes* release_io_net();
  inline void set_allocated_io_net(::draiosproto::counter_time_bytes* io_net);

  // optional .draiosproto.counter_time processing = 17;
  inline bool has_processing() const;
  inline void clear_processing();
  static const int kProcessingFieldNumber = 17;
  inline const ::draiosproto::counter_time& processing() const;
  inline ::draiosproto::counter_time* mutable_processing();
  inline ::draiosproto::counter_time* release_processing();
  inline void set_allocated_processing(::draiosproto::counter_time* processing);

  // @@protoc_insertion_point(class_scope:draiosproto.transaction_breakdown_categories)
 private:
  inline void set_has_other();
  inline void clear_has_other();
  inline void set_has_io_file();
  inline void clear_has_io_file();
  inline void set_has_io_net();
  inline void clear_has_io_net();
  inline void set_has_processing();
  inline void clear_has_processing();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::draiosproto::counter_time* other_;
  ::draiosproto::counter_time_bytes* io_file_;
  ::draiosproto::counter_time_bytes* io_net_;
  ::draiosproto::counter_time* processing_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static transaction_breakdown_categories* default_instance_;
};
// -------------------------------------------------------------------

class counter_syscall_errors : public ::google::protobuf::Message {
 public:
  counter_syscall_errors();
  virtual ~counter_syscall_errors();

  counter_syscall_errors(const counter_syscall_errors& from);

  inline counter_syscall_errors& operator=(const counter_syscall_errors& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const counter_syscall_errors& default_instance();

  void Swap(counter_syscall_errors* other);

  // implements Message ----------------------------------------------

  counter_syscall_errors* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const counter_syscall_errors& from);
  void MergeFrom(const counter_syscall_errors& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated uint32 top_error_codes = 2;
  inline int top_error_codes_size() const;
  inline void clear_top_error_codes();
  static const int kTopErrorCodesFieldNumber = 2;
  inline ::google::protobuf::uint32 top_error_codes(int index) const;
  inline void set_top_error_codes(int index, ::google::protobuf::uint32 value);
  inline void add_top_error_codes(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      top_error_codes() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_top_error_codes();

  // optional uint32 count_file = 4;
  inline bool has_count_file() const;
  inline void clear_count_file();
  static const int kCountFileFieldNumber = 4;
  inline ::google::protobuf::uint32 count_file() const;
  inline void set_count_file(::google::protobuf::uint32 value);

  // optional uint32 count_file_open = 5;
  inline bool has_count_file_open() const;
  inline void clear_count_file_open();
  static const int kCountFileOpenFieldNumber = 5;
  inline ::google::protobuf::uint32 count_file_open() const;
  inline void set_count_file_open(::google::protobuf::uint32 value);

  // optional uint32 count_net = 6;
  inline bool has_count_net() const;
  inline void clear_count_net();
  static const int kCountNetFieldNumber = 6;
  inline ::google::protobuf::uint32 count_net() const;
  inline void set_count_net(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.counter_syscall_errors)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_count_file();
  inline void clear_has_count_file();
  inline void set_has_count_file_open();
  inline void clear_has_count_file_open();
  inline void set_has_count_net();
  inline void clear_has_count_net();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > top_error_codes_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 count_file_;
  ::google::protobuf::uint32 count_file_open_;
  ::google::protobuf::uint32 count_net_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static counter_syscall_errors* default_instance_;
};
// -------------------------------------------------------------------

class resource_categories : public ::google::protobuf::Message {
 public:
  resource_categories();
  virtual ~resource_categories();

  resource_categories(const resource_categories& from);

  inline resource_categories& operator=(const resource_categories& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const resource_categories& default_instance();

  void Swap(resource_categories* other);

  // implements Message ----------------------------------------------

  resource_categories* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const resource_categories& from);
  void MergeFrom(const resource_categories& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 capacity_score = 1;
  inline bool has_capacity_score() const;
  inline void clear_capacity_score();
  static const int kCapacityScoreFieldNumber = 1;
  inline ::google::protobuf::uint32 capacity_score() const;
  inline void set_capacity_score(::google::protobuf::uint32 value);

  // optional uint32 stolen_capacity_score = 6;
  inline bool has_stolen_capacity_score() const;
  inline void clear_stolen_capacity_score();
  static const int kStolenCapacityScoreFieldNumber = 6;
  inline ::google::protobuf::uint32 stolen_capacity_score() const;
  inline void set_stolen_capacity_score(::google::protobuf::uint32 value);

  // optional uint32 connection_queue_usage_pct = 2;
  inline bool has_connection_queue_usage_pct() const;
  inline void clear_connection_queue_usage_pct();
  static const int kConnectionQueueUsagePctFieldNumber = 2;
  inline ::google::protobuf::uint32 connection_queue_usage_pct() const;
  inline void set_connection_queue_usage_pct(::google::protobuf::uint32 value);

  // optional uint32 fd_usage_pct = 3;
  inline bool has_fd_usage_pct() const;
  inline void clear_fd_usage_pct();
  static const int kFdUsagePctFieldNumber = 3;
  inline ::google::protobuf::uint32 fd_usage_pct() const;
  inline void set_fd_usage_pct(::google::protobuf::uint32 value);

  // optional uint32 cpu_pct = 4;
  inline bool has_cpu_pct() const;
  inline void clear_cpu_pct();
  static const int kCpuPctFieldNumber = 4;
  inline ::google::protobuf::uint32 cpu_pct() const;
  inline void set_cpu_pct(::google::protobuf::uint32 value);

  // optional uint32 resident_memory_usage_kb = 5;
  inline bool has_resident_memory_usage_kb() const;
  inline void clear_resident_memory_usage_kb();
  static const int kResidentMemoryUsageKbFieldNumber = 5;
  inline ::google::protobuf::uint32 resident_memory_usage_kb() const;
  inline void set_resident_memory_usage_kb(::google::protobuf::uint32 value);

  // optional uint32 virtual_memory_usage_kb = 13;
  inline bool has_virtual_memory_usage_kb() const;
  inline void clear_virtual_memory_usage_kb();
  static const int kVirtualMemoryUsageKbFieldNumber = 13;
  inline ::google::protobuf::uint32 virtual_memory_usage_kb() const;
  inline void set_virtual_memory_usage_kb(::google::protobuf::uint32 value);

  // optional uint32 swap_memory_usage_kb = 14;
  inline bool has_swap_memory_usage_kb() const;
  inline void clear_swap_memory_usage_kb();
  static const int kSwapMemoryUsageKbFieldNumber = 14;
  inline ::google::protobuf::uint32 swap_memory_usage_kb() const;
  inline void set_swap_memory_usage_kb(::google::protobuf::uint32 value);

  // optional uint64 major_pagefaults = 15;
  inline bool has_major_pagefaults() const;
  inline void clear_major_pagefaults();
  static const int kMajorPagefaultsFieldNumber = 15;
  inline ::google::protobuf::uint64 major_pagefaults() const;
  inline void set_major_pagefaults(::google::protobuf::uint64 value);

  // optional uint64 minor_pagefaults = 16;
  inline bool has_minor_pagefaults() const;
  inline void clear_minor_pagefaults();
  static const int kMinorPagefaultsFieldNumber = 16;
  inline ::google::protobuf::uint64 minor_pagefaults() const;
  inline void set_minor_pagefaults(::google::protobuf::uint64 value);

  // optional uint32 fd_count = 21;
  inline bool has_fd_count() const;
  inline void clear_fd_count();
  static const int kFdCountFieldNumber = 21;
  inline ::google::protobuf::uint32 fd_count() const;
  inline void set_fd_count(::google::protobuf::uint32 value);

  // optional uint32 cpu_limit_pct = 23;
  inline bool has_cpu_limit_pct() const;
  inline void clear_cpu_limit_pct();
  static const int kCpuLimitPctFieldNumber = 23;
  inline ::google::protobuf::uint32 cpu_limit_pct() const;
  inline void set_cpu_limit_pct(::google::protobuf::uint32 value);

  // optional uint32 memory_limit_kb = 24;
  inline bool has_memory_limit_kb() const;
  inline void clear_memory_limit_kb();
  static const int kMemoryLimitKbFieldNumber = 24;
  inline ::google::protobuf::uint32 memory_limit_kb() const;
  inline void set_memory_limit_kb(::google::protobuf::uint32 value);

  // optional uint32 swap_limit_kb = 25;
  inline bool has_swap_limit_kb() const;
  inline void clear_swap_limit_kb();
  static const int kSwapLimitKbFieldNumber = 25;
  inline ::google::protobuf::uint32 swap_limit_kb() const;
  inline void set_swap_limit_kb(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.resource_categories)
 private:
  inline void set_has_capacity_score();
  inline void clear_has_capacity_score();
  inline void set_has_stolen_capacity_score();
  inline void clear_has_stolen_capacity_score();
  inline void set_has_connection_queue_usage_pct();
  inline void clear_has_connection_queue_usage_pct();
  inline void set_has_fd_usage_pct();
  inline void clear_has_fd_usage_pct();
  inline void set_has_cpu_pct();
  inline void clear_has_cpu_pct();
  inline void set_has_resident_memory_usage_kb();
  inline void clear_has_resident_memory_usage_kb();
  inline void set_has_virtual_memory_usage_kb();
  inline void clear_has_virtual_memory_usage_kb();
  inline void set_has_swap_memory_usage_kb();
  inline void clear_has_swap_memory_usage_kb();
  inline void set_has_major_pagefaults();
  inline void clear_has_major_pagefaults();
  inline void set_has_minor_pagefaults();
  inline void clear_has_minor_pagefaults();
  inline void set_has_fd_count();
  inline void clear_has_fd_count();
  inline void set_has_cpu_limit_pct();
  inline void clear_has_cpu_limit_pct();
  inline void set_has_memory_limit_kb();
  inline void clear_has_memory_limit_kb();
  inline void set_has_swap_limit_kb();
  inline void clear_has_swap_limit_kb();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 capacity_score_;
  ::google::protobuf::uint32 stolen_capacity_score_;
  ::google::protobuf::uint32 connection_queue_usage_pct_;
  ::google::protobuf::uint32 fd_usage_pct_;
  ::google::protobuf::uint32 cpu_pct_;
  ::google::protobuf::uint32 resident_memory_usage_kb_;
  ::google::protobuf::uint32 virtual_memory_usage_kb_;
  ::google::protobuf::uint32 swap_memory_usage_kb_;
  ::google::protobuf::uint64 major_pagefaults_;
  ::google::protobuf::uint64 minor_pagefaults_;
  ::google::protobuf::uint32 fd_count_;
  ::google::protobuf::uint32 cpu_limit_pct_;
  ::google::protobuf::uint32 memory_limit_kb_;
  ::google::protobuf::uint32 swap_limit_kb_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static resource_categories* default_instance_;
};
// -------------------------------------------------------------------

class connection_categories : public ::google::protobuf::Message {
 public:
  connection_categories();
  virtual ~connection_categories();

  connection_categories(const connection_categories& from);

  inline connection_categories& operator=(const connection_categories& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const connection_categories& default_instance();

  void Swap(connection_categories* other);

  // implements Message ----------------------------------------------

  connection_categories* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const connection_categories& from);
  void MergeFrom(const connection_categories& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .draiosproto.counter_bytes server = 1;
  inline bool has_server() const;
  inline void clear_server();
  static const int kServerFieldNumber = 1;
  inline const ::draiosproto::counter_bytes& server() const;
  inline ::draiosproto::counter_bytes* mutable_server();
  inline ::draiosproto::counter_bytes* release_server();
  inline void set_allocated_server(::draiosproto::counter_bytes* server);

  // optional .draiosproto.counter_bytes client = 2;
  inline bool has_client() const;
  inline void clear_client();
  static const int kClientFieldNumber = 2;
  inline const ::draiosproto::counter_bytes& client() const;
  inline ::draiosproto::counter_bytes* mutable_client();
  inline ::draiosproto::counter_bytes* release_client();
  inline void set_allocated_client(::draiosproto::counter_bytes* client);

  // optional .draiosproto.counter_time_bidirectional transaction_counters = 3;
  inline bool has_transaction_counters() const;
  inline void clear_transaction_counters();
  static const int kTransactionCountersFieldNumber = 3;
  inline const ::draiosproto::counter_time_bidirectional& transaction_counters() const;
  inline ::draiosproto::counter_time_bidirectional* mutable_transaction_counters();
  inline ::draiosproto::counter_time_bidirectional* release_transaction_counters();
  inline void set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters);

  // optional .draiosproto.counter_time_bidirectional min_transaction_counters = 18;
  inline bool has_min_transaction_counters() const;
  inline void clear_min_transaction_counters();
  static const int kMinTransactionCountersFieldNumber = 18;
  inline const ::draiosproto::counter_time_bidirectional& min_transaction_counters() const;
  inline ::draiosproto::counter_time_bidirectional* mutable_min_transaction_counters();
  inline ::draiosproto::counter_time_bidirectional* release_min_transaction_counters();
  inline void set_allocated_min_transaction_counters(::draiosproto::counter_time_bidirectional* min_transaction_counters);

  // optional .draiosproto.counter_time_bidirectional max_transaction_counters = 19;
  inline bool has_max_transaction_counters() const;
  inline void clear_max_transaction_counters();
  static const int kMaxTransactionCountersFieldNumber = 19;
  inline const ::draiosproto::counter_time_bidirectional& max_transaction_counters() const;
  inline ::draiosproto::counter_time_bidirectional* mutable_max_transaction_counters();
  inline ::draiosproto::counter_time_bidirectional* release_max_transaction_counters();
  inline void set_allocated_max_transaction_counters(::draiosproto::counter_time_bidirectional* max_transaction_counters);

  // optional uint32 n_aggregated_connections = 4;
  inline bool has_n_aggregated_connections() const;
  inline void clear_n_aggregated_connections();
  static const int kNAggregatedConnectionsFieldNumber = 4;
  inline ::google::protobuf::uint32 n_aggregated_connections() const;
  inline void set_n_aggregated_connections(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.connection_categories)
 private:
  inline void set_has_server();
  inline void clear_has_server();
  inline void set_has_client();
  inline void clear_has_client();
  inline void set_has_transaction_counters();
  inline void clear_has_transaction_counters();
  inline void set_has_min_transaction_counters();
  inline void clear_has_min_transaction_counters();
  inline void set_has_max_transaction_counters();
  inline void clear_has_max_transaction_counters();
  inline void set_has_n_aggregated_connections();
  inline void clear_has_n_aggregated_connections();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::draiosproto::counter_bytes* server_;
  ::draiosproto::counter_bytes* client_;
  ::draiosproto::counter_time_bidirectional* transaction_counters_;
  ::draiosproto::counter_time_bidirectional* min_transaction_counters_;
  ::draiosproto::counter_time_bidirectional* max_transaction_counters_;
  ::google::protobuf::uint32 n_aggregated_connections_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static connection_categories* default_instance_;
};
// -------------------------------------------------------------------

class process_details : public ::google::protobuf::Message {
 public:
  process_details();
  virtual ~process_details();

  process_details(const process_details& from);

  inline process_details& operator=(const process_details& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const process_details& default_instance();

  void Swap(process_details* other);

  // implements Message ----------------------------------------------

  process_details* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const process_details& from);
  void MergeFrom(const process_details& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string comm = 1;
  inline bool has_comm() const;
  inline void clear_comm();
  static const int kCommFieldNumber = 1;
  inline const ::std::string& comm() const;
  inline void set_comm(const ::std::string& value);
  inline void set_comm(const char* value);
  inline void set_comm(const char* value, size_t size);
  inline ::std::string* mutable_comm();
  inline ::std::string* release_comm();
  inline void set_allocated_comm(::std::string* comm);

  // required string exe = 2;
  inline bool has_exe() const;
  inline void clear_exe();
  static const int kExeFieldNumber = 2;
  inline const ::std::string& exe() const;
  inline void set_exe(const ::std::string& value);
  inline void set_exe(const char* value);
  inline void set_exe(const char* value, size_t size);
  inline ::std::string* mutable_exe();
  inline ::std::string* release_exe();
  inline void set_allocated_exe(::std::string* exe);

  // repeated string args = 3;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 3;
  inline const ::std::string& args(int index) const;
  inline ::std::string* mutable_args(int index);
  inline void set_args(int index, const ::std::string& value);
  inline void set_args(int index, const char* value);
  inline void set_args(int index, const char* value, size_t size);
  inline ::std::string* add_args();
  inline void add_args(const ::std::string& value);
  inline void add_args(const char* value);
  inline void add_args(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& args() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_args();

  // optional string container_id = 4;
  inline bool has_container_id() const;
  inline void clear_container_id();
  static const int kContainerIdFieldNumber = 4;
  inline const ::std::string& container_id() const;
  inline void set_container_id(const ::std::string& value);
  inline void set_container_id(const char* value);
  inline void set_container_id(const char* value, size_t size);
  inline ::std::string* mutable_container_id();
  inline ::std::string* release_container_id();
  inline void set_allocated_container_id(::std::string* container_id);

  // @@protoc_insertion_point(class_scope:draiosproto.process_details)
 private:
  inline void set_has_comm();
  inline void clear_has_comm();
  inline void set_has_exe();
  inline void clear_has_exe();
  inline void set_has_container_id();
  inline void clear_has_container_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* comm_;
  ::std::string* exe_;
  ::google::protobuf::RepeatedPtrField< ::std::string> args_;
  ::std::string* container_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static process_details* default_instance_;
};
// -------------------------------------------------------------------

class command_details : public ::google::protobuf::Message {
 public:
  command_details();
  virtual ~command_details();

  command_details(const command_details& from);

  inline command_details& operator=(const command_details& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const command_details& default_instance();

  void Swap(command_details* other);

  // implements Message ----------------------------------------------

  command_details* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const command_details& from);
  void MergeFrom(const command_details& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // required uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // required string cmdline = 3;
  inline bool has_cmdline() const;
  inline void clear_cmdline();
  static const int kCmdlineFieldNumber = 3;
  inline const ::std::string& cmdline() const;
  inline void set_cmdline(const ::std::string& value);
  inline void set_cmdline(const char* value);
  inline void set_cmdline(const char* value, size_t size);
  inline ::std::string* mutable_cmdline();
  inline ::std::string* release_cmdline();
  inline void set_allocated_cmdline(::std::string* cmdline);

  // required string exe = 4;
  inline bool has_exe() const;
  inline void clear_exe();
  static const int kExeFieldNumber = 4;
  inline const ::std::string& exe() const;
  inline void set_exe(const ::std::string& value);
  inline void set_exe(const char* value);
  inline void set_exe(const char* value, size_t size);
  inline ::std::string* mutable_exe();
  inline ::std::string* release_exe();
  inline void set_allocated_exe(::std::string* exe);

  // optional string parentcomm = 5;
  inline bool has_parentcomm() const;
  inline void clear_parentcomm();
  static const int kParentcommFieldNumber = 5;
  inline const ::std::string& parentcomm() const;
  inline void set_parentcomm(const ::std::string& value);
  inline void set_parentcomm(const char* value);
  inline void set_parentcomm(const char* value, size_t size);
  inline ::std::string* mutable_parentcomm();
  inline ::std::string* release_parentcomm();
  inline void set_allocated_parentcomm(::std::string* parentcomm);

  // @@protoc_insertion_point(class_scope:draiosproto.command_details)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_cmdline();
  inline void clear_has_cmdline();
  inline void set_has_exe();
  inline void clear_has_exe();
  inline void set_has_parentcomm();
  inline void clear_has_parentcomm();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 timestamp_;
  ::std::string* cmdline_;
  ::std::string* exe_;
  ::std::string* parentcomm_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static command_details* default_instance_;
};
// -------------------------------------------------------------------

class counter_proto_entry : public ::google::protobuf::Message {
 public:
  counter_proto_entry();
  virtual ~counter_proto_entry();

  counter_proto_entry(const counter_proto_entry& from);

  inline counter_proto_entry& operator=(const counter_proto_entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const counter_proto_entry& default_instance();

  void Swap(counter_proto_entry* other);

  // implements Message ----------------------------------------------

  counter_proto_entry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const counter_proto_entry& from);
  void MergeFrom(const counter_proto_entry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ncalls = 1;
  inline bool has_ncalls() const;
  inline void clear_ncalls();
  static const int kNcallsFieldNumber = 1;
  inline ::google::protobuf::uint32 ncalls() const;
  inline void set_ncalls(::google::protobuf::uint32 value);

  // required uint64 time_tot = 2;
  inline bool has_time_tot() const;
  inline void clear_time_tot();
  static const int kTimeTotFieldNumber = 2;
  inline ::google::protobuf::uint64 time_tot() const;
  inline void set_time_tot(::google::protobuf::uint64 value);

  // required uint64 time_max = 3;
  inline bool has_time_max() const;
  inline void clear_time_max();
  static const int kTimeMaxFieldNumber = 3;
  inline ::google::protobuf::uint64 time_max() const;
  inline void set_time_max(::google::protobuf::uint64 value);

  // required uint64 bytes_in = 4;
  inline bool has_bytes_in() const;
  inline void clear_bytes_in();
  static const int kBytesInFieldNumber = 4;
  inline ::google::protobuf::uint64 bytes_in() const;
  inline void set_bytes_in(::google::protobuf::uint64 value);

  // required uint64 bytes_out = 5;
  inline bool has_bytes_out() const;
  inline void clear_bytes_out();
  static const int kBytesOutFieldNumber = 5;
  inline ::google::protobuf::uint64 bytes_out() const;
  inline void set_bytes_out(::google::protobuf::uint64 value);

  // required uint32 nerrors = 6;
  inline bool has_nerrors() const;
  inline void clear_nerrors();
  static const int kNerrorsFieldNumber = 6;
  inline ::google::protobuf::uint32 nerrors() const;
  inline void set_nerrors(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.counter_proto_entry)
 private:
  inline void set_has_ncalls();
  inline void clear_has_ncalls();
  inline void set_has_time_tot();
  inline void clear_has_time_tot();
  inline void set_has_time_max();
  inline void clear_has_time_max();
  inline void set_has_bytes_in();
  inline void clear_has_bytes_in();
  inline void set_has_bytes_out();
  inline void clear_has_bytes_out();
  inline void set_has_nerrors();
  inline void clear_has_nerrors();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 time_tot_;
  ::google::protobuf::uint64 time_max_;
  ::google::protobuf::uint32 ncalls_;
  ::google::protobuf::uint32 nerrors_;
  ::google::protobuf::uint64 bytes_in_;
  ::google::protobuf::uint64 bytes_out_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static counter_proto_entry* default_instance_;
};
// -------------------------------------------------------------------

class url_details : public ::google::protobuf::Message {
 public:
  url_details();
  virtual ~url_details();

  url_details(const url_details& from);

  inline url_details& operator=(const url_details& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const url_details& default_instance();

  void Swap(url_details* other);

  // implements Message ----------------------------------------------

  url_details* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const url_details& from);
  void MergeFrom(const url_details& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string url = 1;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 1;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // required .draiosproto.counter_proto_entry counters = 2;
  inline bool has_counters() const;
  inline void clear_counters();
  static const int kCountersFieldNumber = 2;
  inline const ::draiosproto::counter_proto_entry& counters() const;
  inline ::draiosproto::counter_proto_entry* mutable_counters();
  inline ::draiosproto::counter_proto_entry* release_counters();
  inline void set_allocated_counters(::draiosproto::counter_proto_entry* counters);

  // @@protoc_insertion_point(class_scope:draiosproto.url_details)
 private:
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_counters();
  inline void clear_has_counters();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* url_;
  ::draiosproto::counter_proto_entry* counters_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static url_details* default_instance_;
};
// -------------------------------------------------------------------

class status_code_details : public ::google::protobuf::Message {
 public:
  status_code_details();
  virtual ~status_code_details();

  status_code_details(const status_code_details& from);

  inline status_code_details& operator=(const status_code_details& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const status_code_details& default_instance();

  void Swap(status_code_details* other);

  // implements Message ----------------------------------------------

  status_code_details* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const status_code_details& from);
  void MergeFrom(const status_code_details& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 status_code = 1;
  inline bool has_status_code() const;
  inline void clear_status_code();
  static const int kStatusCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 status_code() const;
  inline void set_status_code(::google::protobuf::uint32 value);

  // required uint32 ncalls = 2;
  inline bool has_ncalls() const;
  inline void clear_ncalls();
  static const int kNcallsFieldNumber = 2;
  inline ::google::protobuf::uint32 ncalls() const;
  inline void set_ncalls(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.status_code_details)
 private:
  inline void set_has_status_code();
  inline void clear_has_status_code();
  inline void set_has_ncalls();
  inline void clear_has_ncalls();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 status_code_;
  ::google::protobuf::uint32 ncalls_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static status_code_details* default_instance_;
};
// -------------------------------------------------------------------

class http_info : public ::google::protobuf::Message {
 public:
  http_info();
  virtual ~http_info();

  http_info(const http_info& from);

  inline http_info& operator=(const http_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const http_info& default_instance();

  void Swap(http_info* other);

  // implements Message ----------------------------------------------

  http_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const http_info& from);
  void MergeFrom(const http_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .draiosproto.url_details server_urls = 1;
  inline int server_urls_size() const;
  inline void clear_server_urls();
  static const int kServerUrlsFieldNumber = 1;
  inline const ::draiosproto::url_details& server_urls(int index) const;
  inline ::draiosproto::url_details* mutable_server_urls(int index);
  inline ::draiosproto::url_details* add_server_urls();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::url_details >&
      server_urls() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::url_details >*
      mutable_server_urls();

  // repeated .draiosproto.url_details client_urls = 2;
  inline int client_urls_size() const;
  inline void clear_client_urls();
  static const int kClientUrlsFieldNumber = 2;
  inline const ::draiosproto::url_details& client_urls(int index) const;
  inline ::draiosproto::url_details* mutable_client_urls(int index);
  inline ::draiosproto::url_details* add_client_urls();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::url_details >&
      client_urls() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::url_details >*
      mutable_client_urls();

  // repeated .draiosproto.status_code_details client_status_codes = 3;
  inline int client_status_codes_size() const;
  inline void clear_client_status_codes();
  static const int kClientStatusCodesFieldNumber = 3;
  inline const ::draiosproto::status_code_details& client_status_codes(int index) const;
  inline ::draiosproto::status_code_details* mutable_client_status_codes(int index);
  inline ::draiosproto::status_code_details* add_client_status_codes();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::status_code_details >&
      client_status_codes() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::status_code_details >*
      mutable_client_status_codes();

  // repeated .draiosproto.status_code_details server_status_codes = 4;
  inline int server_status_codes_size() const;
  inline void clear_server_status_codes();
  static const int kServerStatusCodesFieldNumber = 4;
  inline const ::draiosproto::status_code_details& server_status_codes(int index) const;
  inline ::draiosproto::status_code_details* mutable_server_status_codes(int index);
  inline ::draiosproto::status_code_details* add_server_status_codes();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::status_code_details >&
      server_status_codes() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::status_code_details >*
      mutable_server_status_codes();

  // @@protoc_insertion_point(class_scope:draiosproto.http_info)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::draiosproto::url_details > server_urls_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::url_details > client_urls_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::status_code_details > client_status_codes_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::status_code_details > server_status_codes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static http_info* default_instance_;
};
// -------------------------------------------------------------------

class sql_entry_details : public ::google::protobuf::Message {
 public:
  sql_entry_details();
  virtual ~sql_entry_details();

  sql_entry_details(const sql_entry_details& from);

  inline sql_entry_details& operator=(const sql_entry_details& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sql_entry_details& default_instance();

  void Swap(sql_entry_details* other);

  // implements Message ----------------------------------------------

  sql_entry_details* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sql_entry_details& from);
  void MergeFrom(const sql_entry_details& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .draiosproto.counter_proto_entry counters = 2;
  inline bool has_counters() const;
  inline void clear_counters();
  static const int kCountersFieldNumber = 2;
  inline const ::draiosproto::counter_proto_entry& counters() const;
  inline ::draiosproto::counter_proto_entry* mutable_counters();
  inline ::draiosproto::counter_proto_entry* release_counters();
  inline void set_allocated_counters(::draiosproto::counter_proto_entry* counters);

  // @@protoc_insertion_point(class_scope:draiosproto.sql_entry_details)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_counters();
  inline void clear_has_counters();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::draiosproto::counter_proto_entry* counters_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static sql_entry_details* default_instance_;
};
// -------------------------------------------------------------------

class sql_query_type_details : public ::google::protobuf::Message {
 public:
  sql_query_type_details();
  virtual ~sql_query_type_details();

  sql_query_type_details(const sql_query_type_details& from);

  inline sql_query_type_details& operator=(const sql_query_type_details& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sql_query_type_details& default_instance();

  void Swap(sql_query_type_details* other);

  // implements Message ----------------------------------------------

  sql_query_type_details* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sql_query_type_details& from);
  void MergeFrom(const sql_query_type_details& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.sql_statement_type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::draiosproto::sql_statement_type type() const;
  inline void set_type(::draiosproto::sql_statement_type value);

  // required .draiosproto.counter_proto_entry counters = 2;
  inline bool has_counters() const;
  inline void clear_counters();
  static const int kCountersFieldNumber = 2;
  inline const ::draiosproto::counter_proto_entry& counters() const;
  inline ::draiosproto::counter_proto_entry* mutable_counters();
  inline ::draiosproto::counter_proto_entry* release_counters();
  inline void set_allocated_counters(::draiosproto::counter_proto_entry* counters);

  // @@protoc_insertion_point(class_scope:draiosproto.sql_query_type_details)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_counters();
  inline void clear_has_counters();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::draiosproto::counter_proto_entry* counters_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static sql_query_type_details* default_instance_;
};
// -------------------------------------------------------------------

class sql_info : public ::google::protobuf::Message {
 public:
  sql_info();
  virtual ~sql_info();

  sql_info(const sql_info& from);

  inline sql_info& operator=(const sql_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sql_info& default_instance();

  void Swap(sql_info* other);

  // implements Message ----------------------------------------------

  sql_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sql_info& from);
  void MergeFrom(const sql_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .draiosproto.sql_entry_details server_queries = 1;
  inline int server_queries_size() const;
  inline void clear_server_queries();
  static const int kServerQueriesFieldNumber = 1;
  inline const ::draiosproto::sql_entry_details& server_queries(int index) const;
  inline ::draiosproto::sql_entry_details* mutable_server_queries(int index);
  inline ::draiosproto::sql_entry_details* add_server_queries();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >&
      server_queries() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >*
      mutable_server_queries();

  // repeated .draiosproto.sql_entry_details client_queries = 2;
  inline int client_queries_size() const;
  inline void clear_client_queries();
  static const int kClientQueriesFieldNumber = 2;
  inline const ::draiosproto::sql_entry_details& client_queries(int index) const;
  inline ::draiosproto::sql_entry_details* mutable_client_queries(int index);
  inline ::draiosproto::sql_entry_details* add_client_queries();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >&
      client_queries() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >*
      mutable_client_queries();

  // repeated .draiosproto.sql_query_type_details server_query_types = 3;
  inline int server_query_types_size() const;
  inline void clear_server_query_types();
  static const int kServerQueryTypesFieldNumber = 3;
  inline const ::draiosproto::sql_query_type_details& server_query_types(int index) const;
  inline ::draiosproto::sql_query_type_details* mutable_server_query_types(int index);
  inline ::draiosproto::sql_query_type_details* add_server_query_types();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_query_type_details >&
      server_query_types() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_query_type_details >*
      mutable_server_query_types();

  // repeated .draiosproto.sql_query_type_details client_query_types = 4;
  inline int client_query_types_size() const;
  inline void clear_client_query_types();
  static const int kClientQueryTypesFieldNumber = 4;
  inline const ::draiosproto::sql_query_type_details& client_query_types(int index) const;
  inline ::draiosproto::sql_query_type_details* mutable_client_query_types(int index);
  inline ::draiosproto::sql_query_type_details* add_client_query_types();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_query_type_details >&
      client_query_types() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_query_type_details >*
      mutable_client_query_types();

  // repeated .draiosproto.sql_entry_details server_tables = 5;
  inline int server_tables_size() const;
  inline void clear_server_tables();
  static const int kServerTablesFieldNumber = 5;
  inline const ::draiosproto::sql_entry_details& server_tables(int index) const;
  inline ::draiosproto::sql_entry_details* mutable_server_tables(int index);
  inline ::draiosproto::sql_entry_details* add_server_tables();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >&
      server_tables() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >*
      mutable_server_tables();

  // repeated .draiosproto.sql_entry_details client_tables = 6;
  inline int client_tables_size() const;
  inline void clear_client_tables();
  static const int kClientTablesFieldNumber = 6;
  inline const ::draiosproto::sql_entry_details& client_tables(int index) const;
  inline ::draiosproto::sql_entry_details* mutable_client_tables(int index);
  inline ::draiosproto::sql_entry_details* add_client_tables();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >&
      client_tables() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >*
      mutable_client_tables();

  // @@protoc_insertion_point(class_scope:draiosproto.sql_info)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details > server_queries_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details > client_queries_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_query_type_details > server_query_types_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_query_type_details > client_query_types_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details > server_tables_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details > client_tables_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static sql_info* default_instance_;
};
// -------------------------------------------------------------------

class mongodb_collection_details : public ::google::protobuf::Message {
 public:
  mongodb_collection_details();
  virtual ~mongodb_collection_details();

  mongodb_collection_details(const mongodb_collection_details& from);

  inline mongodb_collection_details& operator=(const mongodb_collection_details& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mongodb_collection_details& default_instance();

  void Swap(mongodb_collection_details* other);

  // implements Message ----------------------------------------------

  mongodb_collection_details* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mongodb_collection_details& from);
  void MergeFrom(const mongodb_collection_details& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .draiosproto.counter_proto_entry counters = 2;
  inline bool has_counters() const;
  inline void clear_counters();
  static const int kCountersFieldNumber = 2;
  inline const ::draiosproto::counter_proto_entry& counters() const;
  inline ::draiosproto::counter_proto_entry* mutable_counters();
  inline ::draiosproto::counter_proto_entry* release_counters();
  inline void set_allocated_counters(::draiosproto::counter_proto_entry* counters);

  // @@protoc_insertion_point(class_scope:draiosproto.mongodb_collection_details)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_counters();
  inline void clear_has_counters();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::draiosproto::counter_proto_entry* counters_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static mongodb_collection_details* default_instance_;
};
// -------------------------------------------------------------------

class mongodb_op_type_details : public ::google::protobuf::Message {
 public:
  mongodb_op_type_details();
  virtual ~mongodb_op_type_details();

  mongodb_op_type_details(const mongodb_op_type_details& from);

  inline mongodb_op_type_details& operator=(const mongodb_op_type_details& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mongodb_op_type_details& default_instance();

  void Swap(mongodb_op_type_details* other);

  // implements Message ----------------------------------------------

  mongodb_op_type_details* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mongodb_op_type_details& from);
  void MergeFrom(const mongodb_op_type_details& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.mongodb_op_type op = 1;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 1;
  inline ::draiosproto::mongodb_op_type op() const;
  inline void set_op(::draiosproto::mongodb_op_type value);

  // required .draiosproto.counter_proto_entry counters = 2;
  inline bool has_counters() const;
  inline void clear_counters();
  static const int kCountersFieldNumber = 2;
  inline const ::draiosproto::counter_proto_entry& counters() const;
  inline ::draiosproto::counter_proto_entry* mutable_counters();
  inline ::draiosproto::counter_proto_entry* release_counters();
  inline void set_allocated_counters(::draiosproto::counter_proto_entry* counters);

  // @@protoc_insertion_point(class_scope:draiosproto.mongodb_op_type_details)
 private:
  inline void set_has_op();
  inline void clear_has_op();
  inline void set_has_counters();
  inline void clear_has_counters();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::draiosproto::counter_proto_entry* counters_;
  int op_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static mongodb_op_type_details* default_instance_;
};
// -------------------------------------------------------------------

class mongodb_info : public ::google::protobuf::Message {
 public:
  mongodb_info();
  virtual ~mongodb_info();

  mongodb_info(const mongodb_info& from);

  inline mongodb_info& operator=(const mongodb_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mongodb_info& default_instance();

  void Swap(mongodb_info* other);

  // implements Message ----------------------------------------------

  mongodb_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mongodb_info& from);
  void MergeFrom(const mongodb_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .draiosproto.mongodb_op_type_details servers_ops = 1;
  inline int servers_ops_size() const;
  inline void clear_servers_ops();
  static const int kServersOpsFieldNumber = 1;
  inline const ::draiosproto::mongodb_op_type_details& servers_ops(int index) const;
  inline ::draiosproto::mongodb_op_type_details* mutable_servers_ops(int index);
  inline ::draiosproto::mongodb_op_type_details* add_servers_ops();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_op_type_details >&
      servers_ops() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_op_type_details >*
      mutable_servers_ops();

  // repeated .draiosproto.mongodb_op_type_details client_ops = 2;
  inline int client_ops_size() const;
  inline void clear_client_ops();
  static const int kClientOpsFieldNumber = 2;
  inline const ::draiosproto::mongodb_op_type_details& client_ops(int index) const;
  inline ::draiosproto::mongodb_op_type_details* mutable_client_ops(int index);
  inline ::draiosproto::mongodb_op_type_details* add_client_ops();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_op_type_details >&
      client_ops() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_op_type_details >*
      mutable_client_ops();

  // repeated .draiosproto.mongodb_collection_details server_collections = 3;
  inline int server_collections_size() const;
  inline void clear_server_collections();
  static const int kServerCollectionsFieldNumber = 3;
  inline const ::draiosproto::mongodb_collection_details& server_collections(int index) const;
  inline ::draiosproto::mongodb_collection_details* mutable_server_collections(int index);
  inline ::draiosproto::mongodb_collection_details* add_server_collections();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_collection_details >&
      server_collections() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_collection_details >*
      mutable_server_collections();

  // repeated .draiosproto.mongodb_collection_details client_collections = 4;
  inline int client_collections_size() const;
  inline void clear_client_collections();
  static const int kClientCollectionsFieldNumber = 4;
  inline const ::draiosproto::mongodb_collection_details& client_collections(int index) const;
  inline ::draiosproto::mongodb_collection_details* mutable_client_collections(int index);
  inline ::draiosproto::mongodb_collection_details* add_client_collections();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_collection_details >&
      client_collections() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_collection_details >*
      mutable_client_collections();

  // @@protoc_insertion_point(class_scope:draiosproto.mongodb_info)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_op_type_details > servers_ops_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_op_type_details > client_ops_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_collection_details > server_collections_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_collection_details > client_collections_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static mongodb_info* default_instance_;
};
// -------------------------------------------------------------------

class jmx_attribute : public ::google::protobuf::Message {
 public:
  jmx_attribute();
  virtual ~jmx_attribute();

  jmx_attribute(const jmx_attribute& from);

  inline jmx_attribute& operator=(const jmx_attribute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const jmx_attribute& default_instance();

  void Swap(jmx_attribute* other);

  // implements Message ----------------------------------------------

  jmx_attribute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const jmx_attribute& from);
  void MergeFrom(const jmx_attribute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional double value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline double value() const;
  inline void set_value(double value);

  // optional string alias = 5;
  inline bool has_alias() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 5;
  inline const ::std::string& alias() const;
  inline void set_alias(const ::std::string& value);
  inline void set_alias(const char* value);
  inline void set_alias(const char* value, size_t size);
  inline ::std::string* mutable_alias();
  inline ::std::string* release_alias();
  inline void set_allocated_alias(::std::string* alias);

  // optional .draiosproto.jmx_metric_type type = 7;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 7;
  inline ::draiosproto::jmx_metric_type type() const;
  inline void set_type(::draiosproto::jmx_metric_type value);

  // optional .draiosproto.unit unit = 8;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 8;
  inline ::draiosproto::unit unit() const;
  inline void set_unit(::draiosproto::unit value);

  // optional .draiosproto.scale scale = 9;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 9;
  inline ::draiosproto::scale scale() const;
  inline void set_scale(::draiosproto::scale value);

  // repeated .draiosproto.jmx_attribute subattributes = 3;
  inline int subattributes_size() const;
  inline void clear_subattributes();
  static const int kSubattributesFieldNumber = 3;
  inline const ::draiosproto::jmx_attribute& subattributes(int index) const;
  inline ::draiosproto::jmx_attribute* mutable_subattributes(int index);
  inline ::draiosproto::jmx_attribute* add_subattributes();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_attribute >&
      subattributes() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_attribute >*
      mutable_subattributes();

  // @@protoc_insertion_point(class_scope:draiosproto.jmx_attribute)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_alias();
  inline void clear_has_alias();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_unit();
  inline void clear_has_unit();
  inline void set_has_scale();
  inline void clear_has_scale();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  double value_;
  ::std::string* alias_;
  int type_;
  int unit_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_attribute > subattributes_;
  int scale_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static jmx_attribute* default_instance_;
};
// -------------------------------------------------------------------

class jmx_bean : public ::google::protobuf::Message {
 public:
  jmx_bean();
  virtual ~jmx_bean();

  jmx_bean(const jmx_bean& from);

  inline jmx_bean& operator=(const jmx_bean& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const jmx_bean& default_instance();

  void Swap(jmx_bean* other);

  // implements Message ----------------------------------------------

  jmx_bean* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const jmx_bean& from);
  void MergeFrom(const jmx_bean& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .draiosproto.jmx_attribute attributes = 2;
  inline int attributes_size() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 2;
  inline const ::draiosproto::jmx_attribute& attributes(int index) const;
  inline ::draiosproto::jmx_attribute* mutable_attributes(int index);
  inline ::draiosproto::jmx_attribute* add_attributes();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_attribute >&
      attributes() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_attribute >*
      mutable_attributes();

  // @@protoc_insertion_point(class_scope:draiosproto.jmx_bean)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_attribute > attributes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static jmx_bean* default_instance_;
};
// -------------------------------------------------------------------

class java_info : public ::google::protobuf::Message {
 public:
  java_info();
  virtual ~java_info();

  java_info(const java_info& from);

  inline java_info& operator=(const java_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const java_info& default_instance();

  void Swap(java_info* other);

  // implements Message ----------------------------------------------

  java_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const java_info& from);
  void MergeFrom(const java_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string process_name = 1;
  inline bool has_process_name() const;
  inline void clear_process_name();
  static const int kProcessNameFieldNumber = 1;
  inline const ::std::string& process_name() const;
  inline void set_process_name(const ::std::string& value);
  inline void set_process_name(const char* value);
  inline void set_process_name(const char* value, size_t size);
  inline ::std::string* mutable_process_name();
  inline ::std::string* release_process_name();
  inline void set_allocated_process_name(::std::string* process_name);

  // repeated .draiosproto.jmx_bean beans = 2;
  inline int beans_size() const;
  inline void clear_beans();
  static const int kBeansFieldNumber = 2;
  inline const ::draiosproto::jmx_bean& beans(int index) const;
  inline ::draiosproto::jmx_bean* mutable_beans(int index);
  inline ::draiosproto::jmx_bean* add_beans();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_bean >&
      beans() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_bean >*
      mutable_beans();

  // @@protoc_insertion_point(class_scope:draiosproto.java_info)
 private:
  inline void set_has_process_name();
  inline void clear_has_process_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* process_name_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_bean > beans_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static java_info* default_instance_;
};
// -------------------------------------------------------------------

class statsd_tag : public ::google::protobuf::Message {
 public:
  statsd_tag();
  virtual ~statsd_tag();

  statsd_tag(const statsd_tag& from);

  inline statsd_tag& operator=(const statsd_tag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const statsd_tag& default_instance();

  void Swap(statsd_tag* other);

  // implements Message ----------------------------------------------

  statsd_tag* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const statsd_tag& from);
  void MergeFrom(const statsd_tag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:draiosproto.statsd_tag)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static statsd_tag* default_instance_;
};
// -------------------------------------------------------------------

class statsd_metric : public ::google::protobuf::Message {
 public:
  statsd_metric();
  virtual ~statsd_metric();

  statsd_metric(const statsd_metric& from);

  inline statsd_metric& operator=(const statsd_metric& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const statsd_metric& default_instance();

  void Swap(statsd_metric* other);

  // implements Message ----------------------------------------------

  statsd_metric* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const statsd_metric& from);
  void MergeFrom(const statsd_metric& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .draiosproto.statsd_tag tags = 2;
  inline int tags_size() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 2;
  inline const ::draiosproto::statsd_tag& tags(int index) const;
  inline ::draiosproto::statsd_tag* mutable_tags(int index);
  inline ::draiosproto::statsd_tag* add_tags();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::statsd_tag >&
      tags() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::statsd_tag >*
      mutable_tags();

  // optional .draiosproto.statsd_metric_type type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::draiosproto::statsd_metric_type type() const;
  inline void set_type(::draiosproto::statsd_metric_type value);

  // optional double value = 4;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 4;
  inline double value() const;
  inline void set_value(double value);

  // optional double sum = 5;
  inline bool has_sum() const;
  inline void clear_sum();
  static const int kSumFieldNumber = 5;
  inline double sum() const;
  inline void set_sum(double value);

  // optional double min = 6;
  inline bool has_min() const;
  inline void clear_min();
  static const int kMinFieldNumber = 6;
  inline double min() const;
  inline void set_min(double value);

  // optional double max = 7;
  inline bool has_max() const;
  inline void clear_max();
  static const int kMaxFieldNumber = 7;
  inline double max() const;
  inline void set_max(double value);

  // optional double count = 8;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 8;
  inline double count() const;
  inline void set_count(double value);

  // optional double median = 9;
  inline bool has_median() const;
  inline void clear_median();
  static const int kMedianFieldNumber = 9;
  inline double median() const;
  inline void set_median(double value);

  // optional double percentile_95 = 10;
  inline bool has_percentile_95() const;
  inline void clear_percentile_95();
  static const int kPercentile95FieldNumber = 10;
  inline double percentile_95() const;
  inline void set_percentile_95(double value);

  // optional double percentile_99 = 11;
  inline bool has_percentile_99() const;
  inline void clear_percentile_99();
  static const int kPercentile99FieldNumber = 11;
  inline double percentile_99() const;
  inline void set_percentile_99(double value);

  // @@protoc_insertion_point(class_scope:draiosproto.statsd_metric)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_sum();
  inline void clear_has_sum();
  inline void set_has_min();
  inline void clear_has_min();
  inline void set_has_max();
  inline void clear_has_max();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_median();
  inline void clear_has_median();
  inline void set_has_percentile_95();
  inline void clear_has_percentile_95();
  inline void set_has_percentile_99();
  inline void clear_has_percentile_99();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::statsd_tag > tags_;
  double value_;
  double sum_;
  double min_;
  double max_;
  double count_;
  double median_;
  double percentile_95_;
  double percentile_99_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static statsd_metric* default_instance_;
};
// -------------------------------------------------------------------

class statsd_info : public ::google::protobuf::Message {
 public:
  statsd_info();
  virtual ~statsd_info();

  statsd_info(const statsd_info& from);

  inline statsd_info& operator=(const statsd_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const statsd_info& default_instance();

  void Swap(statsd_info* other);

  // implements Message ----------------------------------------------

  statsd_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const statsd_info& from);
  void MergeFrom(const statsd_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .draiosproto.statsd_metric statsd_metrics = 1;
  inline int statsd_metrics_size() const;
  inline void clear_statsd_metrics();
  static const int kStatsdMetricsFieldNumber = 1;
  inline const ::draiosproto::statsd_metric& statsd_metrics(int index) const;
  inline ::draiosproto::statsd_metric* mutable_statsd_metrics(int index);
  inline ::draiosproto::statsd_metric* add_statsd_metrics();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::statsd_metric >&
      statsd_metrics() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::statsd_metric >*
      mutable_statsd_metrics();

  // @@protoc_insertion_point(class_scope:draiosproto.statsd_info)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::draiosproto::statsd_metric > statsd_metrics_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static statsd_info* default_instance_;
};
// -------------------------------------------------------------------

class app_tag : public ::google::protobuf::Message {
 public:
  app_tag();
  virtual ~app_tag();

  app_tag(const app_tag& from);

  inline app_tag& operator=(const app_tag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const app_tag& default_instance();

  void Swap(app_tag* other);

  // implements Message ----------------------------------------------

  app_tag* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const app_tag& from);
  void MergeFrom(const app_tag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:draiosproto.app_tag)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static app_tag* default_instance_;
};
// -------------------------------------------------------------------

class app_metric : public ::google::protobuf::Message {
 public:
  app_metric();
  virtual ~app_metric();

  app_metric(const app_metric& from);

  inline app_metric& operator=(const app_metric& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const app_metric& default_instance();

  void Swap(app_metric* other);

  // implements Message ----------------------------------------------

  app_metric* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const app_metric& from);
  void MergeFrom(const app_metric& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .draiosproto.app_metric_type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::draiosproto::app_metric_type type() const;
  inline void set_type(::draiosproto::app_metric_type value);

  // optional double value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline double value() const;
  inline void set_value(double value);

  // repeated .draiosproto.app_tag tags = 4;
  inline int tags_size() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 4;
  inline const ::draiosproto::app_tag& tags(int index) const;
  inline ::draiosproto::app_tag* mutable_tags(int index);
  inline ::draiosproto::app_tag* add_tags();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::app_tag >&
      tags() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::app_tag >*
      mutable_tags();

  // @@protoc_insertion_point(class_scope:draiosproto.app_metric)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  double value_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::app_tag > tags_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static app_metric* default_instance_;
};
// -------------------------------------------------------------------

class app_check : public ::google::protobuf::Message {
 public:
  app_check();
  virtual ~app_check();

  app_check(const app_check& from);

  inline app_check& operator=(const app_check& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const app_check& default_instance();

  void Swap(app_check* other);

  // implements Message ----------------------------------------------

  app_check* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const app_check& from);
  void MergeFrom(const app_check& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .draiosproto.app_check_value value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::draiosproto::app_check_value value() const;
  inline void set_value(::draiosproto::app_check_value value);

  // repeated .draiosproto.app_tag tags = 3;
  inline int tags_size() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 3;
  inline const ::draiosproto::app_tag& tags(int index) const;
  inline ::draiosproto::app_tag* mutable_tags(int index);
  inline ::draiosproto::app_tag* add_tags();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::app_tag >&
      tags() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::app_tag >*
      mutable_tags();

  // @@protoc_insertion_point(class_scope:draiosproto.app_check)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::app_tag > tags_;
  int value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static app_check* default_instance_;
};
// -------------------------------------------------------------------

class app_info : public ::google::protobuf::Message {
 public:
  app_info();
  virtual ~app_info();

  app_info(const app_info& from);

  inline app_info& operator=(const app_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const app_info& default_instance();

  void Swap(app_info* other);

  // implements Message ----------------------------------------------

  app_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const app_info& from);
  void MergeFrom(const app_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string process_name = 1;
  inline bool has_process_name() const;
  inline void clear_process_name();
  static const int kProcessNameFieldNumber = 1;
  inline const ::std::string& process_name() const;
  inline void set_process_name(const ::std::string& value);
  inline void set_process_name(const char* value);
  inline void set_process_name(const char* value, size_t size);
  inline ::std::string* mutable_process_name();
  inline ::std::string* release_process_name();
  inline void set_allocated_process_name(::std::string* process_name);

  // repeated .draiosproto.app_metric metrics = 2;
  inline int metrics_size() const;
  inline void clear_metrics();
  static const int kMetricsFieldNumber = 2;
  inline const ::draiosproto::app_metric& metrics(int index) const;
  inline ::draiosproto::app_metric* mutable_metrics(int index);
  inline ::draiosproto::app_metric* add_metrics();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::app_metric >&
      metrics() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::app_metric >*
      mutable_metrics();

  // repeated .draiosproto.app_check checks = 3;
  inline int checks_size() const;
  inline void clear_checks();
  static const int kChecksFieldNumber = 3;
  inline const ::draiosproto::app_check& checks(int index) const;
  inline ::draiosproto::app_check* mutable_checks(int index);
  inline ::draiosproto::app_check* add_checks();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::app_check >&
      checks() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::app_check >*
      mutable_checks();

  // @@protoc_insertion_point(class_scope:draiosproto.app_info)
 private:
  inline void set_has_process_name();
  inline void clear_has_process_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* process_name_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::app_metric > metrics_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::app_check > checks_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static app_info* default_instance_;
};
// -------------------------------------------------------------------

class proto_info : public ::google::protobuf::Message {
 public:
  proto_info();
  virtual ~proto_info();

  proto_info(const proto_info& from);

  inline proto_info& operator=(const proto_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const proto_info& default_instance();

  void Swap(proto_info* other);

  // implements Message ----------------------------------------------

  proto_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const proto_info& from);
  void MergeFrom(const proto_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .draiosproto.http_info http = 1;
  inline bool has_http() const;
  inline void clear_http();
  static const int kHttpFieldNumber = 1;
  inline const ::draiosproto::http_info& http() const;
  inline ::draiosproto::http_info* mutable_http();
  inline ::draiosproto::http_info* release_http();
  inline void set_allocated_http(::draiosproto::http_info* http);

  // optional .draiosproto.sql_info mysql = 2;
  inline bool has_mysql() const;
  inline void clear_mysql();
  static const int kMysqlFieldNumber = 2;
  inline const ::draiosproto::sql_info& mysql() const;
  inline ::draiosproto::sql_info* mutable_mysql();
  inline ::draiosproto::sql_info* release_mysql();
  inline void set_allocated_mysql(::draiosproto::sql_info* mysql);

  // optional .draiosproto.sql_info postgres = 3;
  inline bool has_postgres() const;
  inline void clear_postgres();
  static const int kPostgresFieldNumber = 3;
  inline const ::draiosproto::sql_info& postgres() const;
  inline ::draiosproto::sql_info* mutable_postgres();
  inline ::draiosproto::sql_info* release_postgres();
  inline void set_allocated_postgres(::draiosproto::sql_info* postgres);

  // optional .draiosproto.mongodb_info mongodb = 4;
  inline bool has_mongodb() const;
  inline void clear_mongodb();
  static const int kMongodbFieldNumber = 4;
  inline const ::draiosproto::mongodb_info& mongodb() const;
  inline ::draiosproto::mongodb_info* mutable_mongodb();
  inline ::draiosproto::mongodb_info* release_mongodb();
  inline void set_allocated_mongodb(::draiosproto::mongodb_info* mongodb);

  // optional .draiosproto.java_info java = 5;
  inline bool has_java() const;
  inline void clear_java();
  static const int kJavaFieldNumber = 5;
  inline const ::draiosproto::java_info& java() const;
  inline ::draiosproto::java_info* mutable_java();
  inline ::draiosproto::java_info* release_java();
  inline void set_allocated_java(::draiosproto::java_info* java);

  // optional .draiosproto.statsd_info statsd = 6;
  inline bool has_statsd() const;
  inline void clear_statsd();
  static const int kStatsdFieldNumber = 6;
  inline const ::draiosproto::statsd_info& statsd() const;
  inline ::draiosproto::statsd_info* mutable_statsd();
  inline ::draiosproto::statsd_info* release_statsd();
  inline void set_allocated_statsd(::draiosproto::statsd_info* statsd);

  // optional .draiosproto.app_info app = 7;
  inline bool has_app() const;
  inline void clear_app();
  static const int kAppFieldNumber = 7;
  inline const ::draiosproto::app_info& app() const;
  inline ::draiosproto::app_info* mutable_app();
  inline ::draiosproto::app_info* release_app();
  inline void set_allocated_app(::draiosproto::app_info* app);

  // @@protoc_insertion_point(class_scope:draiosproto.proto_info)
 private:
  inline void set_has_http();
  inline void clear_has_http();
  inline void set_has_mysql();
  inline void clear_has_mysql();
  inline void set_has_postgres();
  inline void clear_has_postgres();
  inline void set_has_mongodb();
  inline void clear_has_mongodb();
  inline void set_has_java();
  inline void clear_has_java();
  inline void set_has_statsd();
  inline void clear_has_statsd();
  inline void set_has_app();
  inline void clear_has_app();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::draiosproto::http_info* http_;
  ::draiosproto::sql_info* mysql_;
  ::draiosproto::sql_info* postgres_;
  ::draiosproto::mongodb_info* mongodb_;
  ::draiosproto::java_info* java_;
  ::draiosproto::statsd_info* statsd_;
  ::draiosproto::app_info* app_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static proto_info* default_instance_;
};
// -------------------------------------------------------------------

class network_by_port : public ::google::protobuf::Message {
 public:
  network_by_port();
  virtual ~network_by_port();

  network_by_port(const network_by_port& from);

  inline network_by_port& operator=(const network_by_port& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const network_by_port& default_instance();

  void Swap(network_by_port* other);

  // implements Message ----------------------------------------------

  network_by_port* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const network_by_port& from);
  void MergeFrom(const network_by_port& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 port = 1;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 1;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // required .draiosproto.connection_categories counters = 2;
  inline bool has_counters() const;
  inline void clear_counters();
  static const int kCountersFieldNumber = 2;
  inline const ::draiosproto::connection_categories& counters() const;
  inline ::draiosproto::connection_categories* mutable_counters();
  inline ::draiosproto::connection_categories* release_counters();
  inline void set_allocated_counters(::draiosproto::connection_categories* counters);

  // @@protoc_insertion_point(class_scope:draiosproto.network_by_port)
 private:
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_counters();
  inline void clear_has_counters();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::draiosproto::connection_categories* counters_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static network_by_port* default_instance_;
};
// -------------------------------------------------------------------

class host : public ::google::protobuf::Message {
 public:
  host();
  virtual ~host();

  host(const host& from);

  inline host& operator=(const host& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const host& default_instance();

  void Swap(host* other);

  // implements Message ----------------------------------------------

  host* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const host& from);
  void MergeFrom(const host& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string hostname = 1;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional uint32 num_cpus = 2;
  inline bool has_num_cpus() const;
  inline void clear_num_cpus();
  static const int kNumCpusFieldNumber = 2;
  inline ::google::protobuf::uint32 num_cpus() const;
  inline void set_num_cpus(::google::protobuf::uint32 value);

  // repeated uint32 cpu_loads = 3;
  inline int cpu_loads_size() const;
  inline void clear_cpu_loads();
  static const int kCpuLoadsFieldNumber = 3;
  inline ::google::protobuf::uint32 cpu_loads(int index) const;
  inline void set_cpu_loads(int index, ::google::protobuf::uint32 value);
  inline void add_cpu_loads(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      cpu_loads() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_cpu_loads();

  // repeated uint32 cpu_steal = 11;
  inline int cpu_steal_size() const;
  inline void clear_cpu_steal();
  static const int kCpuStealFieldNumber = 11;
  inline ::google::protobuf::uint32 cpu_steal(int index) const;
  inline void set_cpu_steal(int index, ::google::protobuf::uint32 value);
  inline void add_cpu_steal(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      cpu_steal() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_cpu_steal();

  // required uint64 physical_memory_size_bytes = 4;
  inline bool has_physical_memory_size_bytes() const;
  inline void clear_physical_memory_size_bytes();
  static const int kPhysicalMemorySizeBytesFieldNumber = 4;
  inline ::google::protobuf::uint64 physical_memory_size_bytes() const;
  inline void set_physical_memory_size_bytes(::google::protobuf::uint64 value);

  // optional .draiosproto.time_categories tcounters = 5;
  inline bool has_tcounters() const;
  inline void clear_tcounters();
  static const int kTcountersFieldNumber = 5;
  inline const ::draiosproto::time_categories& tcounters() const;
  inline ::draiosproto::time_categories* mutable_tcounters();
  inline ::draiosproto::time_categories* release_tcounters();
  inline void set_allocated_tcounters(::draiosproto::time_categories* tcounters);

  // optional .draiosproto.transaction_breakdown_categories reqcounters = 12;
  inline bool has_reqcounters() const;
  inline void clear_reqcounters();
  static const int kReqcountersFieldNumber = 12;
  inline const ::draiosproto::transaction_breakdown_categories& reqcounters() const;
  inline ::draiosproto::transaction_breakdown_categories* mutable_reqcounters();
  inline ::draiosproto::transaction_breakdown_categories* release_reqcounters();
  inline void set_allocated_reqcounters(::draiosproto::transaction_breakdown_categories* reqcounters);

  // optional .draiosproto.counter_time_bidirectional transaction_counters = 6;
  inline bool has_transaction_counters() const;
  inline void clear_transaction_counters();
  static const int kTransactionCountersFieldNumber = 6;
  inline const ::draiosproto::counter_time_bidirectional& transaction_counters() const;
  inline ::draiosproto::counter_time_bidirectional* mutable_transaction_counters();
  inline ::draiosproto::counter_time_bidirectional* release_transaction_counters();
  inline void set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters);

  // optional .draiosproto.counter_time_bidirectional min_transaction_counters = 22;
  inline bool has_min_transaction_counters() const;
  inline void clear_min_transaction_counters();
  static const int kMinTransactionCountersFieldNumber = 22;
  inline const ::draiosproto::counter_time_bidirectional& min_transaction_counters() const;
  inline ::draiosproto::counter_time_bidirectional* mutable_min_transaction_counters();
  inline ::draiosproto::counter_time_bidirectional* release_min_transaction_counters();
  inline void set_allocated_min_transaction_counters(::draiosproto::counter_time_bidirectional* min_transaction_counters);

  // optional .draiosproto.counter_time_bidirectional max_transaction_counters = 23;
  inline bool has_max_transaction_counters() const;
  inline void clear_max_transaction_counters();
  static const int kMaxTransactionCountersFieldNumber = 23;
  inline const ::draiosproto::counter_time_bidirectional& max_transaction_counters() const;
  inline ::draiosproto::counter_time_bidirectional* mutable_max_transaction_counters();
  inline ::draiosproto::counter_time_bidirectional* release_max_transaction_counters();
  inline void set_allocated_max_transaction_counters(::draiosproto::counter_time_bidirectional* max_transaction_counters);

  // optional uint64 transaction_processing_delay = 7;
  inline bool has_transaction_processing_delay() const;
  inline void clear_transaction_processing_delay();
  static const int kTransactionProcessingDelayFieldNumber = 7;
  inline ::google::protobuf::uint64 transaction_processing_delay() const;
  inline void set_transaction_processing_delay(::google::protobuf::uint64 value);

  // optional uint64 next_tiers_delay = 13;
  inline bool has_next_tiers_delay() const;
  inline void clear_next_tiers_delay();
  static const int kNextTiersDelayFieldNumber = 13;
  inline ::google::protobuf::uint64 next_tiers_delay() const;
  inline void set_next_tiers_delay(::google::protobuf::uint64 value);

  // optional .draiosproto.resource_categories resource_counters = 8;
  inline bool has_resource_counters() const;
  inline void clear_resource_counters();
  static const int kResourceCountersFieldNumber = 8;
  inline const ::draiosproto::resource_categories& resource_counters() const;
  inline ::draiosproto::resource_categories* mutable_resource_counters();
  inline ::draiosproto::resource_categories* release_resource_counters();
  inline void set_allocated_resource_counters(::draiosproto::resource_categories* resource_counters);

  // optional .draiosproto.counter_syscall_errors syscall_errors = 9;
  inline bool has_syscall_errors() const;
  inline void clear_syscall_errors();
  static const int kSyscallErrorsFieldNumber = 9;
  inline const ::draiosproto::counter_syscall_errors& syscall_errors() const;
  inline ::draiosproto::counter_syscall_errors* mutable_syscall_errors();
  inline ::draiosproto::counter_syscall_errors* release_syscall_errors();
  inline void set_allocated_syscall_errors(::draiosproto::counter_syscall_errors* syscall_errors);

  // optional .draiosproto.counter_time_bytes external_io_net = 10;
  inline bool has_external_io_net() const;
  inline void clear_external_io_net();
  static const int kExternalIoNetFieldNumber = 10;
  inline const ::draiosproto::counter_time_bytes& external_io_net() const;
  inline ::draiosproto::counter_time_bytes* mutable_external_io_net();
  inline ::draiosproto::counter_time_bytes* release_external_io_net();
  inline void set_allocated_external_io_net(::draiosproto::counter_time_bytes* external_io_net);

  // repeated .draiosproto.network_by_port network_by_serverports = 24;
  inline int network_by_serverports_size() const;
  inline void clear_network_by_serverports();
  static const int kNetworkByServerportsFieldNumber = 24;
  inline const ::draiosproto::network_by_port& network_by_serverports(int index) const;
  inline ::draiosproto::network_by_port* mutable_network_by_serverports(int index);
  inline ::draiosproto::network_by_port* add_network_by_serverports();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::network_by_port >&
      network_by_serverports() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::network_by_port >*
      mutable_network_by_serverports();

  // @@protoc_insertion_point(class_scope:draiosproto.host)
 private:
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_num_cpus();
  inline void clear_has_num_cpus();
  inline void set_has_physical_memory_size_bytes();
  inline void clear_has_physical_memory_size_bytes();
  inline void set_has_tcounters();
  inline void clear_has_tcounters();
  inline void set_has_reqcounters();
  inline void clear_has_reqcounters();
  inline void set_has_transaction_counters();
  inline void clear_has_transaction_counters();
  inline void set_has_min_transaction_counters();
  inline void clear_has_min_transaction_counters();
  inline void set_has_max_transaction_counters();
  inline void clear_has_max_transaction_counters();
  inline void set_has_transaction_processing_delay();
  inline void clear_has_transaction_processing_delay();
  inline void set_has_next_tiers_delay();
  inline void clear_has_next_tiers_delay();
  inline void set_has_resource_counters();
  inline void clear_has_resource_counters();
  inline void set_has_syscall_errors();
  inline void clear_has_syscall_errors();
  inline void set_has_external_io_net();
  inline void clear_has_external_io_net();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* hostname_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > cpu_loads_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > cpu_steal_;
  ::google::protobuf::uint64 physical_memory_size_bytes_;
  ::draiosproto::time_categories* tcounters_;
  ::draiosproto::transaction_breakdown_categories* reqcounters_;
  ::draiosproto::counter_time_bidirectional* transaction_counters_;
  ::draiosproto::counter_time_bidirectional* min_transaction_counters_;
  ::draiosproto::counter_time_bidirectional* max_transaction_counters_;
  ::google::protobuf::uint64 transaction_processing_delay_;
  ::google::protobuf::uint64 next_tiers_delay_;
  ::draiosproto::resource_categories* resource_counters_;
  ::draiosproto::counter_syscall_errors* syscall_errors_;
  ::draiosproto::counter_time_bytes* external_io_net_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::network_by_port > network_by_serverports_;
  ::google::protobuf::uint32 num_cpus_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static host* default_instance_;
};
// -------------------------------------------------------------------

class process : public ::google::protobuf::Message {
 public:
  process();
  virtual ~process();

  process(const process& from);

  inline process& operator=(const process& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const process& default_instance();

  void Swap(process* other);

  // implements Message ----------------------------------------------

  process* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const process& from);
  void MergeFrom(const process& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .draiosproto.process_details details = 2;
  inline bool has_details() const;
  inline void clear_details();
  static const int kDetailsFieldNumber = 2;
  inline const ::draiosproto::process_details& details() const;
  inline ::draiosproto::process_details* mutable_details();
  inline ::draiosproto::process_details* release_details();
  inline void set_allocated_details(::draiosproto::process_details* details);

  // optional bool is_ipv4_transaction_server = 3;
  inline bool has_is_ipv4_transaction_server() const;
  inline void clear_is_ipv4_transaction_server();
  static const int kIsIpv4TransactionServerFieldNumber = 3;
  inline bool is_ipv4_transaction_server() const;
  inline void set_is_ipv4_transaction_server(bool value);

  // optional bool is_unix_transaction_server = 4;
  inline bool has_is_unix_transaction_server() const;
  inline void clear_is_unix_transaction_server();
  static const int kIsUnixTransactionServerFieldNumber = 4;
  inline bool is_unix_transaction_server() const;
  inline void set_is_unix_transaction_server(bool value);

  // optional bool is_ipv4_transaction_client = 10;
  inline bool has_is_ipv4_transaction_client() const;
  inline void clear_is_ipv4_transaction_client();
  static const int kIsIpv4TransactionClientFieldNumber = 10;
  inline bool is_ipv4_transaction_client() const;
  inline void set_is_ipv4_transaction_client(bool value);

  // optional bool is_unix_transaction_client = 11;
  inline bool has_is_unix_transaction_client() const;
  inline void clear_is_unix_transaction_client();
  static const int kIsUnixTransactionClientFieldNumber = 11;
  inline bool is_unix_transaction_client() const;
  inline void set_is_unix_transaction_client(bool value);

  // optional uint32 netrole = 13;
  inline bool has_netrole() const;
  inline void clear_netrole();
  static const int kNetroleFieldNumber = 13;
  inline ::google::protobuf::uint32 netrole() const;
  inline void set_netrole(::google::protobuf::uint32 value);

  // optional .draiosproto.time_categories tcounters = 5;
  inline bool has_tcounters() const;
  inline void clear_tcounters();
  static const int kTcountersFieldNumber = 5;
  inline const ::draiosproto::time_categories& tcounters() const;
  inline ::draiosproto::time_categories* mutable_tcounters();
  inline ::draiosproto::time_categories* release_tcounters();
  inline void set_allocated_tcounters(::draiosproto::time_categories* tcounters);

  // optional .draiosproto.counter_time_bidirectional transaction_counters = 6;
  inline bool has_transaction_counters() const;
  inline void clear_transaction_counters();
  static const int kTransactionCountersFieldNumber = 6;
  inline const ::draiosproto::counter_time_bidirectional& transaction_counters() const;
  inline ::draiosproto::counter_time_bidirectional* mutable_transaction_counters();
  inline ::draiosproto::counter_time_bidirectional* release_transaction_counters();
  inline void set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters);

  // optional .draiosproto.counter_time_bidirectional min_transaction_counters = 18;
  inline bool has_min_transaction_counters() const;
  inline void clear_min_transaction_counters();
  static const int kMinTransactionCountersFieldNumber = 18;
  inline const ::draiosproto::counter_time_bidirectional& min_transaction_counters() const;
  inline ::draiosproto::counter_time_bidirectional* mutable_min_transaction_counters();
  inline ::draiosproto::counter_time_bidirectional* release_min_transaction_counters();
  inline void set_allocated_min_transaction_counters(::draiosproto::counter_time_bidirectional* min_transaction_counters);

  // optional .draiosproto.counter_time_bidirectional max_transaction_counters = 19;
  inline bool has_max_transaction_counters() const;
  inline void clear_max_transaction_counters();
  static const int kMaxTransactionCountersFieldNumber = 19;
  inline const ::draiosproto::counter_time_bidirectional& max_transaction_counters() const;
  inline ::draiosproto::counter_time_bidirectional* mutable_max_transaction_counters();
  inline ::draiosproto::counter_time_bidirectional* release_max_transaction_counters();
  inline void set_allocated_max_transaction_counters(::draiosproto::counter_time_bidirectional* max_transaction_counters);

  // optional uint64 transaction_processing_delay = 7;
  inline bool has_transaction_processing_delay() const;
  inline void clear_transaction_processing_delay();
  static const int kTransactionProcessingDelayFieldNumber = 7;
  inline ::google::protobuf::uint64 transaction_processing_delay() const;
  inline void set_transaction_processing_delay(::google::protobuf::uint64 value);

  // optional uint64 next_tiers_delay = 12;
  inline bool has_next_tiers_delay() const;
  inline void clear_next_tiers_delay();
  static const int kNextTiersDelayFieldNumber = 12;
  inline ::google::protobuf::uint64 next_tiers_delay() const;
  inline void set_next_tiers_delay(::google::protobuf::uint64 value);

  // optional .draiosproto.resource_categories resource_counters = 8;
  inline bool has_resource_counters() const;
  inline void clear_resource_counters();
  static const int kResourceCountersFieldNumber = 8;
  inline const ::draiosproto::resource_categories& resource_counters() const;
  inline ::draiosproto::resource_categories* mutable_resource_counters();
  inline ::draiosproto::resource_categories* release_resource_counters();
  inline void set_allocated_resource_counters(::draiosproto::resource_categories* resource_counters);

  // optional .draiosproto.counter_syscall_errors syscall_errors = 9;
  inline bool has_syscall_errors() const;
  inline void clear_syscall_errors();
  static const int kSyscallErrorsFieldNumber = 9;
  inline const ::draiosproto::counter_syscall_errors& syscall_errors() const;
  inline ::draiosproto::counter_syscall_errors* mutable_syscall_errors();
  inline ::draiosproto::counter_syscall_errors* release_syscall_errors();
  inline void set_allocated_syscall_errors(::draiosproto::counter_syscall_errors* syscall_errors);

  // optional .draiosproto.proto_info protos = 20;
  inline bool has_protos() const;
  inline void clear_protos();
  static const int kProtosFieldNumber = 20;
  inline const ::draiosproto::proto_info& protos() const;
  inline ::draiosproto::proto_info* mutable_protos();
  inline ::draiosproto::proto_info* release_protos();
  inline void set_allocated_protos(::draiosproto::proto_info* protos);

  // optional uint64 start_count = 21;
  inline bool has_start_count() const;
  inline void clear_start_count();
  static const int kStartCountFieldNumber = 21;
  inline ::google::protobuf::uint64 start_count() const;
  inline void set_start_count(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:draiosproto.process)
 private:
  inline void set_has_details();
  inline void clear_has_details();
  inline void set_has_is_ipv4_transaction_server();
  inline void clear_has_is_ipv4_transaction_server();
  inline void set_has_is_unix_transaction_server();
  inline void clear_has_is_unix_transaction_server();
  inline void set_has_is_ipv4_transaction_client();
  inline void clear_has_is_ipv4_transaction_client();
  inline void set_has_is_unix_transaction_client();
  inline void clear_has_is_unix_transaction_client();
  inline void set_has_netrole();
  inline void clear_has_netrole();
  inline void set_has_tcounters();
  inline void clear_has_tcounters();
  inline void set_has_transaction_counters();
  inline void clear_has_transaction_counters();
  inline void set_has_min_transaction_counters();
  inline void clear_has_min_transaction_counters();
  inline void set_has_max_transaction_counters();
  inline void clear_has_max_transaction_counters();
  inline void set_has_transaction_processing_delay();
  inline void clear_has_transaction_processing_delay();
  inline void set_has_next_tiers_delay();
  inline void clear_has_next_tiers_delay();
  inline void set_has_resource_counters();
  inline void clear_has_resource_counters();
  inline void set_has_syscall_errors();
  inline void clear_has_syscall_errors();
  inline void set_has_protos();
  inline void clear_has_protos();
  inline void set_has_start_count();
  inline void clear_has_start_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::draiosproto::process_details* details_;
  bool is_ipv4_transaction_server_;
  bool is_unix_transaction_server_;
  bool is_ipv4_transaction_client_;
  bool is_unix_transaction_client_;
  ::google::protobuf::uint32 netrole_;
  ::draiosproto::time_categories* tcounters_;
  ::draiosproto::counter_time_bidirectional* transaction_counters_;
  ::draiosproto::counter_time_bidirectional* min_transaction_counters_;
  ::draiosproto::counter_time_bidirectional* max_transaction_counters_;
  ::google::protobuf::uint64 transaction_processing_delay_;
  ::google::protobuf::uint64 next_tiers_delay_;
  ::draiosproto::resource_categories* resource_counters_;
  ::draiosproto::counter_syscall_errors* syscall_errors_;
  ::draiosproto::proto_info* protos_;
  ::google::protobuf::uint64 start_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static process* default_instance_;
};
// -------------------------------------------------------------------

class program : public ::google::protobuf::Message {
 public:
  program();
  virtual ~program();

  program(const program& from);

  inline program& operator=(const program& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const program& default_instance();

  void Swap(program* other);

  // implements Message ----------------------------------------------

  program* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const program& from);
  void MergeFrom(const program& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.process procinfo = 1;
  inline bool has_procinfo() const;
  inline void clear_procinfo();
  static const int kProcinfoFieldNumber = 1;
  inline const ::draiosproto::process& procinfo() const;
  inline ::draiosproto::process* mutable_procinfo();
  inline ::draiosproto::process* release_procinfo();
  inline void set_allocated_procinfo(::draiosproto::process* procinfo);

  // repeated uint64 pids = 2;
  inline int pids_size() const;
  inline void clear_pids();
  static const int kPidsFieldNumber = 2;
  inline ::google::protobuf::uint64 pids(int index) const;
  inline void set_pids(int index, ::google::protobuf::uint64 value);
  inline void add_pids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      pids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_pids();

  // @@protoc_insertion_point(class_scope:draiosproto.program)
 private:
  inline void set_has_procinfo();
  inline void clear_has_procinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::draiosproto::process* procinfo_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > pids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static program* default_instance_;
};
// -------------------------------------------------------------------

class ipv4tuple : public ::google::protobuf::Message {
 public:
  ipv4tuple();
  virtual ~ipv4tuple();

  ipv4tuple(const ipv4tuple& from);

  inline ipv4tuple& operator=(const ipv4tuple& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ipv4tuple& default_instance();

  void Swap(ipv4tuple* other);

  // implements Message ----------------------------------------------

  ipv4tuple* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ipv4tuple& from);
  void MergeFrom(const ipv4tuple& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 sip = 1;
  inline bool has_sip() const;
  inline void clear_sip();
  static const int kSipFieldNumber = 1;
  inline ::google::protobuf::uint32 sip() const;
  inline void set_sip(::google::protobuf::uint32 value);

  // required uint32 dip = 2;
  inline bool has_dip() const;
  inline void clear_dip();
  static const int kDipFieldNumber = 2;
  inline ::google::protobuf::uint32 dip() const;
  inline void set_dip(::google::protobuf::uint32 value);

  // required uint32 sport = 3;
  inline bool has_sport() const;
  inline void clear_sport();
  static const int kSportFieldNumber = 3;
  inline ::google::protobuf::uint32 sport() const;
  inline void set_sport(::google::protobuf::uint32 value);

  // required uint32 dport = 4;
  inline bool has_dport() const;
  inline void clear_dport();
  static const int kDportFieldNumber = 4;
  inline ::google::protobuf::uint32 dport() const;
  inline void set_dport(::google::protobuf::uint32 value);

  // required uint32 l4proto = 5;
  inline bool has_l4proto() const;
  inline void clear_l4proto();
  static const int kL4ProtoFieldNumber = 5;
  inline ::google::protobuf::uint32 l4proto() const;
  inline void set_l4proto(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.ipv4tuple)
 private:
  inline void set_has_sip();
  inline void clear_has_sip();
  inline void set_has_dip();
  inline void clear_has_dip();
  inline void set_has_sport();
  inline void clear_has_sport();
  inline void set_has_dport();
  inline void clear_has_dport();
  inline void set_has_l4proto();
  inline void clear_has_l4proto();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 sip_;
  ::google::protobuf::uint32 dip_;
  ::google::protobuf::uint32 sport_;
  ::google::protobuf::uint32 dport_;
  ::google::protobuf::uint32 l4proto_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static ipv4tuple* default_instance_;
};
// -------------------------------------------------------------------

class ipv4_connection : public ::google::protobuf::Message {
 public:
  ipv4_connection();
  virtual ~ipv4_connection();

  ipv4_connection(const ipv4_connection& from);

  inline ipv4_connection& operator=(const ipv4_connection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ipv4_connection& default_instance();

  void Swap(ipv4_connection* other);

  // implements Message ----------------------------------------------

  ipv4_connection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ipv4_connection& from);
  void MergeFrom(const ipv4_connection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.ipv4tuple tuple = 1;
  inline bool has_tuple() const;
  inline void clear_tuple();
  static const int kTupleFieldNumber = 1;
  inline const ::draiosproto::ipv4tuple& tuple() const;
  inline ::draiosproto::ipv4tuple* mutable_tuple();
  inline ::draiosproto::ipv4tuple* release_tuple();
  inline void set_allocated_tuple(::draiosproto::ipv4tuple* tuple);

  // optional uint64 spid = 2;
  inline bool has_spid() const;
  inline void clear_spid();
  static const int kSpidFieldNumber = 2;
  inline ::google::protobuf::uint64 spid() const;
  inline void set_spid(::google::protobuf::uint64 value);

  // optional uint64 dpid = 5;
  inline bool has_dpid() const;
  inline void clear_dpid();
  static const int kDpidFieldNumber = 5;
  inline ::google::protobuf::uint64 dpid() const;
  inline void set_dpid(::google::protobuf::uint64 value);

  // required .draiosproto.connection_categories counters = 8;
  inline bool has_counters() const;
  inline void clear_counters();
  static const int kCountersFieldNumber = 8;
  inline const ::draiosproto::connection_categories& counters() const;
  inline ::draiosproto::connection_categories* mutable_counters();
  inline ::draiosproto::connection_categories* release_counters();
  inline void set_allocated_counters(::draiosproto::connection_categories* counters);

  // @@protoc_insertion_point(class_scope:draiosproto.ipv4_connection)
 private:
  inline void set_has_tuple();
  inline void clear_has_tuple();
  inline void set_has_spid();
  inline void clear_has_spid();
  inline void set_has_dpid();
  inline void clear_has_dpid();
  inline void set_has_counters();
  inline void clear_has_counters();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::draiosproto::ipv4tuple* tuple_;
  ::google::protobuf::uint64 spid_;
  ::google::protobuf::uint64 dpid_;
  ::draiosproto::connection_categories* counters_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static ipv4_connection* default_instance_;
};
// -------------------------------------------------------------------

class ipv4_network_interface : public ::google::protobuf::Message {
 public:
  ipv4_network_interface();
  virtual ~ipv4_network_interface();

  ipv4_network_interface(const ipv4_network_interface& from);

  inline ipv4_network_interface& operator=(const ipv4_network_interface& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ipv4_network_interface& default_instance();

  void Swap(ipv4_network_interface* other);

  // implements Message ----------------------------------------------

  ipv4_network_interface* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ipv4_network_interface& from);
  void MergeFrom(const ipv4_network_interface& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 addr = 2;
  inline bool has_addr() const;
  inline void clear_addr();
  static const int kAddrFieldNumber = 2;
  inline ::google::protobuf::uint32 addr() const;
  inline void set_addr(::google::protobuf::uint32 value);

  // required uint32 netmask = 3;
  inline bool has_netmask() const;
  inline void clear_netmask();
  static const int kNetmaskFieldNumber = 3;
  inline ::google::protobuf::uint32 netmask() const;
  inline void set_netmask(::google::protobuf::uint32 value);

  // optional uint32 bcast = 4;
  inline bool has_bcast() const;
  inline void clear_bcast();
  static const int kBcastFieldNumber = 4;
  inline ::google::protobuf::uint32 bcast() const;
  inline void set_bcast(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.ipv4_network_interface)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_addr();
  inline void clear_has_addr();
  inline void set_has_netmask();
  inline void clear_has_netmask();
  inline void set_has_bcast();
  inline void clear_has_bcast();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 addr_;
  ::google::protobuf::uint32 netmask_;
  ::google::protobuf::uint32 bcast_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static ipv4_network_interface* default_instance_;
};
// -------------------------------------------------------------------

class mounted_fs : public ::google::protobuf::Message {
 public:
  mounted_fs();
  virtual ~mounted_fs();

  mounted_fs(const mounted_fs& from);

  inline mounted_fs& operator=(const mounted_fs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mounted_fs& default_instance();

  void Swap(mounted_fs* other);

  // implements Message ----------------------------------------------

  mounted_fs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mounted_fs& from);
  void MergeFrom(const mounted_fs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string device = 1;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 1;
  inline const ::std::string& device() const;
  inline void set_device(const ::std::string& value);
  inline void set_device(const char* value);
  inline void set_device(const char* value, size_t size);
  inline ::std::string* mutable_device();
  inline ::std::string* release_device();
  inline void set_allocated_device(::std::string* device);

  // required string mount_dir = 2;
  inline bool has_mount_dir() const;
  inline void clear_mount_dir();
  static const int kMountDirFieldNumber = 2;
  inline const ::std::string& mount_dir() const;
  inline void set_mount_dir(const ::std::string& value);
  inline void set_mount_dir(const char* value);
  inline void set_mount_dir(const char* value, size_t size);
  inline ::std::string* mutable_mount_dir();
  inline ::std::string* release_mount_dir();
  inline void set_allocated_mount_dir(::std::string* mount_dir);

  // required string type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required uint64 size_bytes = 4;
  inline bool has_size_bytes() const;
  inline void clear_size_bytes();
  static const int kSizeBytesFieldNumber = 4;
  inline ::google::protobuf::uint64 size_bytes() const;
  inline void set_size_bytes(::google::protobuf::uint64 value);

  // required uint64 used_bytes = 5;
  inline bool has_used_bytes() const;
  inline void clear_used_bytes();
  static const int kUsedBytesFieldNumber = 5;
  inline ::google::protobuf::uint64 used_bytes() const;
  inline void set_used_bytes(::google::protobuf::uint64 value);

  // required uint64 available_bytes = 6;
  inline bool has_available_bytes() const;
  inline void clear_available_bytes();
  static const int kAvailableBytesFieldNumber = 6;
  inline ::google::protobuf::uint64 available_bytes() const;
  inline void set_available_bytes(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:draiosproto.mounted_fs)
 private:
  inline void set_has_device();
  inline void clear_has_device();
  inline void set_has_mount_dir();
  inline void clear_has_mount_dir();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_size_bytes();
  inline void clear_has_size_bytes();
  inline void set_has_used_bytes();
  inline void clear_has_used_bytes();
  inline void set_has_available_bytes();
  inline void clear_has_available_bytes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_;
  ::std::string* mount_dir_;
  ::std::string* type_;
  ::google::protobuf::uint64 size_bytes_;
  ::google::protobuf::uint64 used_bytes_;
  ::google::protobuf::uint64 available_bytes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static mounted_fs* default_instance_;
};
// -------------------------------------------------------------------

class file_stat : public ::google::protobuf::Message {
 public:
  file_stat();
  virtual ~file_stat();

  file_stat(const file_stat& from);

  inline file_stat& operator=(const file_stat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const file_stat& default_instance();

  void Swap(file_stat* other);

  // implements Message ----------------------------------------------

  file_stat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const file_stat& from);
  void MergeFrom(const file_stat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 bytes = 2;
  inline bool has_bytes() const;
  inline void clear_bytes();
  static const int kBytesFieldNumber = 2;
  inline ::google::protobuf::uint32 bytes() const;
  inline void set_bytes(::google::protobuf::uint32 value);

  // required uint64 time_ns = 3;
  inline bool has_time_ns() const;
  inline void clear_time_ns();
  static const int kTimeNsFieldNumber = 3;
  inline ::google::protobuf::uint64 time_ns() const;
  inline void set_time_ns(::google::protobuf::uint64 value);

  // required uint32 open_count = 4;
  inline bool has_open_count() const;
  inline void clear_open_count();
  static const int kOpenCountFieldNumber = 4;
  inline ::google::protobuf::uint32 open_count() const;
  inline void set_open_count(::google::protobuf::uint32 value);

  // required uint32 errors = 5;
  inline bool has_errors() const;
  inline void clear_errors();
  static const int kErrorsFieldNumber = 5;
  inline ::google::protobuf::uint32 errors() const;
  inline void set_errors(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.file_stat)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_bytes();
  inline void clear_has_bytes();
  inline void set_has_time_ns();
  inline void clear_has_time_ns();
  inline void set_has_open_count();
  inline void clear_has_open_count();
  inline void set_has_errors();
  inline void clear_has_errors();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint64 time_ns_;
  ::google::protobuf::uint32 bytes_;
  ::google::protobuf::uint32 open_count_;
  ::google::protobuf::uint32 errors_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static file_stat* default_instance_;
};
// -------------------------------------------------------------------

class container_port_mapping : public ::google::protobuf::Message {
 public:
  container_port_mapping();
  virtual ~container_port_mapping();

  container_port_mapping(const container_port_mapping& from);

  inline container_port_mapping& operator=(const container_port_mapping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const container_port_mapping& default_instance();

  void Swap(container_port_mapping* other);

  // implements Message ----------------------------------------------

  container_port_mapping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const container_port_mapping& from);
  void MergeFrom(const container_port_mapping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 host_ip = 1;
  inline bool has_host_ip() const;
  inline void clear_host_ip();
  static const int kHostIpFieldNumber = 1;
  inline ::google::protobuf::uint32 host_ip() const;
  inline void set_host_ip(::google::protobuf::uint32 value);

  // optional uint32 host_port = 2;
  inline bool has_host_port() const;
  inline void clear_host_port();
  static const int kHostPortFieldNumber = 2;
  inline ::google::protobuf::uint32 host_port() const;
  inline void set_host_port(::google::protobuf::uint32 value);

  // optional uint32 container_ip = 3;
  inline bool has_container_ip() const;
  inline void clear_container_ip();
  static const int kContainerIpFieldNumber = 3;
  inline ::google::protobuf::uint32 container_ip() const;
  inline void set_container_ip(::google::protobuf::uint32 value);

  // optional uint32 container_port = 4;
  inline bool has_container_port() const;
  inline void clear_container_port();
  static const int kContainerPortFieldNumber = 4;
  inline ::google::protobuf::uint32 container_port() const;
  inline void set_container_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.container_port_mapping)
 private:
  inline void set_has_host_ip();
  inline void clear_has_host_ip();
  inline void set_has_host_port();
  inline void clear_has_host_port();
  inline void set_has_container_ip();
  inline void clear_has_container_ip();
  inline void set_has_container_port();
  inline void clear_has_container_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 host_ip_;
  ::google::protobuf::uint32 host_port_;
  ::google::protobuf::uint32 container_ip_;
  ::google::protobuf::uint32 container_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static container_port_mapping* default_instance_;
};
// -------------------------------------------------------------------

class container_label : public ::google::protobuf::Message {
 public:
  container_label();
  virtual ~container_label();

  container_label(const container_label& from);

  inline container_label& operator=(const container_label& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const container_label& default_instance();

  void Swap(container_label* other);

  // implements Message ----------------------------------------------

  container_label* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const container_label& from);
  void MergeFrom(const container_label& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:draiosproto.container_label)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static container_label* default_instance_;
};
// -------------------------------------------------------------------

class container : public ::google::protobuf::Message {
 public:
  container();
  virtual ~container();

  container(const container& from);

  inline container& operator=(const container& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const container& default_instance();

  void Swap(container* other);

  // implements Message ----------------------------------------------

  container* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const container& from);
  void MergeFrom(const container& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional .draiosproto.container_type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::draiosproto::container_type type() const;
  inline void set_type(::draiosproto::container_type value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string image = 4;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 4;
  inline const ::std::string& image() const;
  inline void set_image(const ::std::string& value);
  inline void set_image(const char* value);
  inline void set_image(const char* value, size_t size);
  inline ::std::string* mutable_image();
  inline ::std::string* release_image();
  inline void set_allocated_image(::std::string* image);

  // optional .draiosproto.time_categories tcounters = 5;
  inline bool has_tcounters() const;
  inline void clear_tcounters();
  static const int kTcountersFieldNumber = 5;
  inline const ::draiosproto::time_categories& tcounters() const;
  inline ::draiosproto::time_categories* mutable_tcounters();
  inline ::draiosproto::time_categories* release_tcounters();
  inline void set_allocated_tcounters(::draiosproto::time_categories* tcounters);

  // optional .draiosproto.transaction_breakdown_categories reqcounters = 6;
  inline bool has_reqcounters() const;
  inline void clear_reqcounters();
  static const int kReqcountersFieldNumber = 6;
  inline const ::draiosproto::transaction_breakdown_categories& reqcounters() const;
  inline ::draiosproto::transaction_breakdown_categories* mutable_reqcounters();
  inline ::draiosproto::transaction_breakdown_categories* release_reqcounters();
  inline void set_allocated_reqcounters(::draiosproto::transaction_breakdown_categories* reqcounters);

  // optional .draiosproto.counter_time_bidirectional transaction_counters = 7;
  inline bool has_transaction_counters() const;
  inline void clear_transaction_counters();
  static const int kTransactionCountersFieldNumber = 7;
  inline const ::draiosproto::counter_time_bidirectional& transaction_counters() const;
  inline ::draiosproto::counter_time_bidirectional* mutable_transaction_counters();
  inline ::draiosproto::counter_time_bidirectional* release_transaction_counters();
  inline void set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters);

  // optional .draiosproto.counter_time_bidirectional min_transaction_counters = 8;
  inline bool has_min_transaction_counters() const;
  inline void clear_min_transaction_counters();
  static const int kMinTransactionCountersFieldNumber = 8;
  inline const ::draiosproto::counter_time_bidirectional& min_transaction_counters() const;
  inline ::draiosproto::counter_time_bidirectional* mutable_min_transaction_counters();
  inline ::draiosproto::counter_time_bidirectional* release_min_transaction_counters();
  inline void set_allocated_min_transaction_counters(::draiosproto::counter_time_bidirectional* min_transaction_counters);

  // optional .draiosproto.counter_time_bidirectional max_transaction_counters = 9;
  inline bool has_max_transaction_counters() const;
  inline void clear_max_transaction_counters();
  static const int kMaxTransactionCountersFieldNumber = 9;
  inline const ::draiosproto::counter_time_bidirectional& max_transaction_counters() const;
  inline ::draiosproto::counter_time_bidirectional* mutable_max_transaction_counters();
  inline ::draiosproto::counter_time_bidirectional* release_max_transaction_counters();
  inline void set_allocated_max_transaction_counters(::draiosproto::counter_time_bidirectional* max_transaction_counters);

  // optional uint64 transaction_processing_delay = 10;
  inline bool has_transaction_processing_delay() const;
  inline void clear_transaction_processing_delay();
  static const int kTransactionProcessingDelayFieldNumber = 10;
  inline ::google::protobuf::uint64 transaction_processing_delay() const;
  inline void set_transaction_processing_delay(::google::protobuf::uint64 value);

  // optional uint64 next_tiers_delay = 12;
  inline bool has_next_tiers_delay() const;
  inline void clear_next_tiers_delay();
  static const int kNextTiersDelayFieldNumber = 12;
  inline ::google::protobuf::uint64 next_tiers_delay() const;
  inline void set_next_tiers_delay(::google::protobuf::uint64 value);

  // optional .draiosproto.resource_categories resource_counters = 13;
  inline bool has_resource_counters() const;
  inline void clear_resource_counters();
  static const int kResourceCountersFieldNumber = 13;
  inline const ::draiosproto::resource_categories& resource_counters() const;
  inline ::draiosproto::resource_categories* mutable_resource_counters();
  inline ::draiosproto::resource_categories* release_resource_counters();
  inline void set_allocated_resource_counters(::draiosproto::resource_categories* resource_counters);

  // optional .draiosproto.counter_syscall_errors syscall_errors = 14;
  inline bool has_syscall_errors() const;
  inline void clear_syscall_errors();
  static const int kSyscallErrorsFieldNumber = 14;
  inline const ::draiosproto::counter_syscall_errors& syscall_errors() const;
  inline ::draiosproto::counter_syscall_errors* mutable_syscall_errors();
  inline ::draiosproto::counter_syscall_errors* release_syscall_errors();
  inline void set_allocated_syscall_errors(::draiosproto::counter_syscall_errors* syscall_errors);

  // repeated .draiosproto.container_port_mapping port_mappings = 18;
  inline int port_mappings_size() const;
  inline void clear_port_mappings();
  static const int kPortMappingsFieldNumber = 18;
  inline const ::draiosproto::container_port_mapping& port_mappings(int index) const;
  inline ::draiosproto::container_port_mapping* mutable_port_mappings(int index);
  inline ::draiosproto::container_port_mapping* add_port_mappings();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::container_port_mapping >&
      port_mappings() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::container_port_mapping >*
      mutable_port_mappings();

  // optional .draiosproto.proto_info protos = 19;
  inline bool has_protos() const;
  inline void clear_protos();
  static const int kProtosFieldNumber = 19;
  inline const ::draiosproto::proto_info& protos() const;
  inline ::draiosproto::proto_info* mutable_protos();
  inline ::draiosproto::proto_info* release_protos();
  inline void set_allocated_protos(::draiosproto::proto_info* protos);

  // repeated .draiosproto.container_label labels = 20;
  inline int labels_size() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 20;
  inline const ::draiosproto::container_label& labels(int index) const;
  inline ::draiosproto::container_label* mutable_labels(int index);
  inline ::draiosproto::container_label* add_labels();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::container_label >&
      labels() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::container_label >*
      mutable_labels();

  // repeated .draiosproto.mounted_fs mounts = 21;
  inline int mounts_size() const;
  inline void clear_mounts();
  static const int kMountsFieldNumber = 21;
  inline const ::draiosproto::mounted_fs& mounts(int index) const;
  inline ::draiosproto::mounted_fs* mutable_mounts(int index);
  inline ::draiosproto::mounted_fs* add_mounts();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mounted_fs >&
      mounts() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mounted_fs >*
      mutable_mounts();

  // repeated .draiosproto.network_by_port network_by_serverports = 22;
  inline int network_by_serverports_size() const;
  inline void clear_network_by_serverports();
  static const int kNetworkByServerportsFieldNumber = 22;
  inline const ::draiosproto::network_by_port& network_by_serverports(int index) const;
  inline ::draiosproto::network_by_port* mutable_network_by_serverports(int index);
  inline ::draiosproto::network_by_port* add_network_by_serverports();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::network_by_port >&
      network_by_serverports() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::network_by_port >*
      mutable_network_by_serverports();

  // optional string mesos_task_id = 23;
  inline bool has_mesos_task_id() const;
  inline void clear_mesos_task_id();
  static const int kMesosTaskIdFieldNumber = 23;
  inline const ::std::string& mesos_task_id() const;
  inline void set_mesos_task_id(const ::std::string& value);
  inline void set_mesos_task_id(const char* value);
  inline void set_mesos_task_id(const char* value, size_t size);
  inline ::std::string* mutable_mesos_task_id();
  inline ::std::string* release_mesos_task_id();
  inline void set_allocated_mesos_task_id(::std::string* mesos_task_id);

  // @@protoc_insertion_point(class_scope:draiosproto.container)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_tcounters();
  inline void clear_has_tcounters();
  inline void set_has_reqcounters();
  inline void clear_has_reqcounters();
  inline void set_has_transaction_counters();
  inline void clear_has_transaction_counters();
  inline void set_has_min_transaction_counters();
  inline void clear_has_min_transaction_counters();
  inline void set_has_max_transaction_counters();
  inline void clear_has_max_transaction_counters();
  inline void set_has_transaction_processing_delay();
  inline void clear_has_transaction_processing_delay();
  inline void set_has_next_tiers_delay();
  inline void clear_has_next_tiers_delay();
  inline void set_has_resource_counters();
  inline void clear_has_resource_counters();
  inline void set_has_syscall_errors();
  inline void clear_has_syscall_errors();
  inline void set_has_protos();
  inline void clear_has_protos();
  inline void set_has_mesos_task_id();
  inline void clear_has_mesos_task_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* name_;
  ::std::string* image_;
  ::draiosproto::time_categories* tcounters_;
  ::draiosproto::transaction_breakdown_categories* reqcounters_;
  ::draiosproto::counter_time_bidirectional* transaction_counters_;
  ::draiosproto::counter_time_bidirectional* min_transaction_counters_;
  ::draiosproto::counter_time_bidirectional* max_transaction_counters_;
  ::google::protobuf::uint64 transaction_processing_delay_;
  ::google::protobuf::uint64 next_tiers_delay_;
  ::draiosproto::resource_categories* resource_counters_;
  ::draiosproto::counter_syscall_errors* syscall_errors_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::container_port_mapping > port_mappings_;
  ::draiosproto::proto_info* protos_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::container_label > labels_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mounted_fs > mounts_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::network_by_port > network_by_serverports_;
  ::std::string* mesos_task_id_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static container* default_instance_;
};
// -------------------------------------------------------------------

class k8s_pair : public ::google::protobuf::Message {
 public:
  k8s_pair();
  virtual ~k8s_pair();

  k8s_pair(const k8s_pair& from);

  inline k8s_pair& operator=(const k8s_pair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const k8s_pair& default_instance();

  void Swap(k8s_pair* other);

  // implements Message ----------------------------------------------

  k8s_pair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const k8s_pair& from);
  void MergeFrom(const k8s_pair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:draiosproto.k8s_pair)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static k8s_pair* default_instance_;
};
// -------------------------------------------------------------------

class k8s_common : public ::google::protobuf::Message {
 public:
  k8s_common();
  virtual ~k8s_common();

  k8s_common(const k8s_common& from);

  inline k8s_common& operator=(const k8s_common& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const k8s_common& default_instance();

  void Swap(k8s_common* other);

  // implements Message ----------------------------------------------

  k8s_common* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const k8s_common& from);
  void MergeFrom(const k8s_common& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional string namespace = 3;
  inline bool has_namespace_() const;
  inline void clear_namespace_();
  static const int kNamespaceFieldNumber = 3;
  inline const ::std::string& namespace_() const;
  inline void set_namespace_(const ::std::string& value);
  inline void set_namespace_(const char* value);
  inline void set_namespace_(const char* value, size_t size);
  inline ::std::string* mutable_namespace_();
  inline ::std::string* release_namespace_();
  inline void set_allocated_namespace_(::std::string* namespace_);

  // repeated .draiosproto.k8s_pair labels = 4;
  inline int labels_size() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 4;
  inline const ::draiosproto::k8s_pair& labels(int index) const;
  inline ::draiosproto::k8s_pair* mutable_labels(int index);
  inline ::draiosproto::k8s_pair* add_labels();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pair >&
      labels() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pair >*
      mutable_labels();

  // repeated .draiosproto.k8s_pair selectors = 5;
  inline int selectors_size() const;
  inline void clear_selectors();
  static const int kSelectorsFieldNumber = 5;
  inline const ::draiosproto::k8s_pair& selectors(int index) const;
  inline ::draiosproto::k8s_pair* mutable_selectors(int index);
  inline ::draiosproto::k8s_pair* add_selectors();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pair >&
      selectors() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pair >*
      mutable_selectors();

  // @@protoc_insertion_point(class_scope:draiosproto.k8s_common)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_namespace_();
  inline void clear_has_namespace_();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* uid_;
  ::std::string* namespace__;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pair > labels_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pair > selectors_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static k8s_common* default_instance_;
};
// -------------------------------------------------------------------

class k8s_namespace : public ::google::protobuf::Message {
 public:
  k8s_namespace();
  virtual ~k8s_namespace();

  k8s_namespace(const k8s_namespace& from);

  inline k8s_namespace& operator=(const k8s_namespace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const k8s_namespace& default_instance();

  void Swap(k8s_namespace* other);

  // implements Message ----------------------------------------------

  k8s_namespace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const k8s_namespace& from);
  void MergeFrom(const k8s_namespace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.k8s_common common = 1;
  inline bool has_common() const;
  inline void clear_common();
  static const int kCommonFieldNumber = 1;
  inline const ::draiosproto::k8s_common& common() const;
  inline ::draiosproto::k8s_common* mutable_common();
  inline ::draiosproto::k8s_common* release_common();
  inline void set_allocated_common(::draiosproto::k8s_common* common);

  // @@protoc_insertion_point(class_scope:draiosproto.k8s_namespace)
 private:
  inline void set_has_common();
  inline void clear_has_common();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::draiosproto::k8s_common* common_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static k8s_namespace* default_instance_;
};
// -------------------------------------------------------------------

class k8s_node : public ::google::protobuf::Message {
 public:
  k8s_node();
  virtual ~k8s_node();

  k8s_node(const k8s_node& from);

  inline k8s_node& operator=(const k8s_node& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const k8s_node& default_instance();

  void Swap(k8s_node* other);

  // implements Message ----------------------------------------------

  k8s_node* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const k8s_node& from);
  void MergeFrom(const k8s_node& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.k8s_common common = 1;
  inline bool has_common() const;
  inline void clear_common();
  static const int kCommonFieldNumber = 1;
  inline const ::draiosproto::k8s_common& common() const;
  inline ::draiosproto::k8s_common* mutable_common();
  inline ::draiosproto::k8s_common* release_common();
  inline void set_allocated_common(::draiosproto::k8s_common* common);

  // repeated string host_ips = 2;
  inline int host_ips_size() const;
  inline void clear_host_ips();
  static const int kHostIpsFieldNumber = 2;
  inline const ::std::string& host_ips(int index) const;
  inline ::std::string* mutable_host_ips(int index);
  inline void set_host_ips(int index, const ::std::string& value);
  inline void set_host_ips(int index, const char* value);
  inline void set_host_ips(int index, const char* value, size_t size);
  inline ::std::string* add_host_ips();
  inline void add_host_ips(const ::std::string& value);
  inline void add_host_ips(const char* value);
  inline void add_host_ips(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& host_ips() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_host_ips();

  // @@protoc_insertion_point(class_scope:draiosproto.k8s_node)
 private:
  inline void set_has_common();
  inline void clear_has_common();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::draiosproto::k8s_common* common_;
  ::google::protobuf::RepeatedPtrField< ::std::string> host_ips_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static k8s_node* default_instance_;
};
// -------------------------------------------------------------------

class k8s_pod : public ::google::protobuf::Message {
 public:
  k8s_pod();
  virtual ~k8s_pod();

  k8s_pod(const k8s_pod& from);

  inline k8s_pod& operator=(const k8s_pod& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const k8s_pod& default_instance();

  void Swap(k8s_pod* other);

  // implements Message ----------------------------------------------

  k8s_pod* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const k8s_pod& from);
  void MergeFrom(const k8s_pod& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.k8s_common common = 1;
  inline bool has_common() const;
  inline void clear_common();
  static const int kCommonFieldNumber = 1;
  inline const ::draiosproto::k8s_common& common() const;
  inline ::draiosproto::k8s_common* mutable_common();
  inline ::draiosproto::k8s_common* release_common();
  inline void set_allocated_common(::draiosproto::k8s_common* common);

  // repeated string container_ids = 2;
  inline int container_ids_size() const;
  inline void clear_container_ids();
  static const int kContainerIdsFieldNumber = 2;
  inline const ::std::string& container_ids(int index) const;
  inline ::std::string* mutable_container_ids(int index);
  inline void set_container_ids(int index, const ::std::string& value);
  inline void set_container_ids(int index, const char* value);
  inline void set_container_ids(int index, const char* value, size_t size);
  inline ::std::string* add_container_ids();
  inline void add_container_ids(const ::std::string& value);
  inline void add_container_ids(const char* value);
  inline void add_container_ids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& container_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_container_ids();

  // optional string node_name = 3;
  inline bool has_node_name() const;
  inline void clear_node_name();
  static const int kNodeNameFieldNumber = 3;
  inline const ::std::string& node_name() const;
  inline void set_node_name(const ::std::string& value);
  inline void set_node_name(const char* value);
  inline void set_node_name(const char* value, size_t size);
  inline ::std::string* mutable_node_name();
  inline ::std::string* release_node_name();
  inline void set_allocated_node_name(::std::string* node_name);

  // optional string host_ip = 4;
  inline bool has_host_ip() const;
  inline void clear_host_ip();
  static const int kHostIpFieldNumber = 4;
  inline const ::std::string& host_ip() const;
  inline void set_host_ip(const ::std::string& value);
  inline void set_host_ip(const char* value);
  inline void set_host_ip(const char* value, size_t size);
  inline ::std::string* mutable_host_ip();
  inline ::std::string* release_host_ip();
  inline void set_allocated_host_ip(::std::string* host_ip);

  // optional string internal_ip = 5;
  inline bool has_internal_ip() const;
  inline void clear_internal_ip();
  static const int kInternalIpFieldNumber = 5;
  inline const ::std::string& internal_ip() const;
  inline void set_internal_ip(const ::std::string& value);
  inline void set_internal_ip(const char* value);
  inline void set_internal_ip(const char* value, size_t size);
  inline ::std::string* mutable_internal_ip();
  inline ::std::string* release_internal_ip();
  inline void set_allocated_internal_ip(::std::string* internal_ip);

  // @@protoc_insertion_point(class_scope:draiosproto.k8s_pod)
 private:
  inline void set_has_common();
  inline void clear_has_common();
  inline void set_has_node_name();
  inline void clear_has_node_name();
  inline void set_has_host_ip();
  inline void clear_has_host_ip();
  inline void set_has_internal_ip();
  inline void clear_has_internal_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::draiosproto::k8s_common* common_;
  ::google::protobuf::RepeatedPtrField< ::std::string> container_ids_;
  ::std::string* node_name_;
  ::std::string* host_ip_;
  ::std::string* internal_ip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static k8s_pod* default_instance_;
};
// -------------------------------------------------------------------

class k8s_replication_controller : public ::google::protobuf::Message {
 public:
  k8s_replication_controller();
  virtual ~k8s_replication_controller();

  k8s_replication_controller(const k8s_replication_controller& from);

  inline k8s_replication_controller& operator=(const k8s_replication_controller& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const k8s_replication_controller& default_instance();

  void Swap(k8s_replication_controller* other);

  // implements Message ----------------------------------------------

  k8s_replication_controller* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const k8s_replication_controller& from);
  void MergeFrom(const k8s_replication_controller& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.k8s_common common = 1;
  inline bool has_common() const;
  inline void clear_common();
  static const int kCommonFieldNumber = 1;
  inline const ::draiosproto::k8s_common& common() const;
  inline ::draiosproto::k8s_common* mutable_common();
  inline ::draiosproto::k8s_common* release_common();
  inline void set_allocated_common(::draiosproto::k8s_common* common);

  // @@protoc_insertion_point(class_scope:draiosproto.k8s_replication_controller)
 private:
  inline void set_has_common();
  inline void clear_has_common();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::draiosproto::k8s_common* common_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static k8s_replication_controller* default_instance_;
};
// -------------------------------------------------------------------

class k8s_service_net_port : public ::google::protobuf::Message {
 public:
  k8s_service_net_port();
  virtual ~k8s_service_net_port();

  k8s_service_net_port(const k8s_service_net_port& from);

  inline k8s_service_net_port& operator=(const k8s_service_net_port& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const k8s_service_net_port& default_instance();

  void Swap(k8s_service_net_port* other);

  // implements Message ----------------------------------------------

  k8s_service_net_port* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const k8s_service_net_port& from);
  void MergeFrom(const k8s_service_net_port& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 port = 1;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 1;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // required uint32 target_port = 2;
  inline bool has_target_port() const;
  inline void clear_target_port();
  static const int kTargetPortFieldNumber = 2;
  inline ::google::protobuf::uint32 target_port() const;
  inline void set_target_port(::google::protobuf::uint32 value);

  // optional string protocol = 3;
  inline bool has_protocol() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 3;
  inline const ::std::string& protocol() const;
  inline void set_protocol(const ::std::string& value);
  inline void set_protocol(const char* value);
  inline void set_protocol(const char* value, size_t size);
  inline ::std::string* mutable_protocol();
  inline ::std::string* release_protocol();
  inline void set_allocated_protocol(::std::string* protocol);

  // optional uint32 node_port = 4;
  inline bool has_node_port() const;
  inline void clear_node_port();
  static const int kNodePortFieldNumber = 4;
  inline ::google::protobuf::uint32 node_port() const;
  inline void set_node_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.k8s_service.net_port)
 private:
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_target_port();
  inline void clear_has_target_port();
  inline void set_has_protocol();
  inline void clear_has_protocol();
  inline void set_has_node_port();
  inline void clear_has_node_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint32 target_port_;
  ::std::string* protocol_;
  ::google::protobuf::uint32 node_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static k8s_service_net_port* default_instance_;
};
// -------------------------------------------------------------------

class k8s_service : public ::google::protobuf::Message {
 public:
  k8s_service();
  virtual ~k8s_service();

  k8s_service(const k8s_service& from);

  inline k8s_service& operator=(const k8s_service& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const k8s_service& default_instance();

  void Swap(k8s_service* other);

  // implements Message ----------------------------------------------

  k8s_service* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const k8s_service& from);
  void MergeFrom(const k8s_service& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef k8s_service_net_port net_port;

  // accessors -------------------------------------------------------

  // required .draiosproto.k8s_common common = 1;
  inline bool has_common() const;
  inline void clear_common();
  static const int kCommonFieldNumber = 1;
  inline const ::draiosproto::k8s_common& common() const;
  inline ::draiosproto::k8s_common* mutable_common();
  inline ::draiosproto::k8s_common* release_common();
  inline void set_allocated_common(::draiosproto::k8s_common* common);

  // optional string cluster_ip = 2;
  inline bool has_cluster_ip() const;
  inline void clear_cluster_ip();
  static const int kClusterIpFieldNumber = 2;
  inline const ::std::string& cluster_ip() const;
  inline void set_cluster_ip(const ::std::string& value);
  inline void set_cluster_ip(const char* value);
  inline void set_cluster_ip(const char* value, size_t size);
  inline ::std::string* mutable_cluster_ip();
  inline ::std::string* release_cluster_ip();
  inline void set_allocated_cluster_ip(::std::string* cluster_ip);

  // repeated .draiosproto.k8s_service.net_port ports = 3;
  inline int ports_size() const;
  inline void clear_ports();
  static const int kPortsFieldNumber = 3;
  inline const ::draiosproto::k8s_service_net_port& ports(int index) const;
  inline ::draiosproto::k8s_service_net_port* mutable_ports(int index);
  inline ::draiosproto::k8s_service_net_port* add_ports();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_service_net_port >&
      ports() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_service_net_port >*
      mutable_ports();

  // @@protoc_insertion_point(class_scope:draiosproto.k8s_service)
 private:
  inline void set_has_common();
  inline void clear_has_common();
  inline void set_has_cluster_ip();
  inline void clear_has_cluster_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::draiosproto::k8s_common* common_;
  ::std::string* cluster_ip_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_service_net_port > ports_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static k8s_service* default_instance_;
};
// -------------------------------------------------------------------

class k8s_state : public ::google::protobuf::Message {
 public:
  k8s_state();
  virtual ~k8s_state();

  k8s_state(const k8s_state& from);

  inline k8s_state& operator=(const k8s_state& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const k8s_state& default_instance();

  void Swap(k8s_state* other);

  // implements Message ----------------------------------------------

  k8s_state* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const k8s_state& from);
  void MergeFrom(const k8s_state& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .draiosproto.k8s_namespace namespaces = 1;
  inline int namespaces_size() const;
  inline void clear_namespaces();
  static const int kNamespacesFieldNumber = 1;
  inline const ::draiosproto::k8s_namespace& namespaces(int index) const;
  inline ::draiosproto::k8s_namespace* mutable_namespaces(int index);
  inline ::draiosproto::k8s_namespace* add_namespaces();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_namespace >&
      namespaces() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_namespace >*
      mutable_namespaces();

  // repeated .draiosproto.k8s_node nodes = 2;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 2;
  inline const ::draiosproto::k8s_node& nodes(int index) const;
  inline ::draiosproto::k8s_node* mutable_nodes(int index);
  inline ::draiosproto::k8s_node* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_node >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_node >*
      mutable_nodes();

  // repeated .draiosproto.k8s_pod pods = 3;
  inline int pods_size() const;
  inline void clear_pods();
  static const int kPodsFieldNumber = 3;
  inline const ::draiosproto::k8s_pod& pods(int index) const;
  inline ::draiosproto::k8s_pod* mutable_pods(int index);
  inline ::draiosproto::k8s_pod* add_pods();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pod >&
      pods() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pod >*
      mutable_pods();

  // repeated .draiosproto.k8s_replication_controller controllers = 4;
  inline int controllers_size() const;
  inline void clear_controllers();
  static const int kControllersFieldNumber = 4;
  inline const ::draiosproto::k8s_replication_controller& controllers(int index) const;
  inline ::draiosproto::k8s_replication_controller* mutable_controllers(int index);
  inline ::draiosproto::k8s_replication_controller* add_controllers();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_replication_controller >&
      controllers() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_replication_controller >*
      mutable_controllers();

  // repeated .draiosproto.k8s_service services = 5;
  inline int services_size() const;
  inline void clear_services();
  static const int kServicesFieldNumber = 5;
  inline const ::draiosproto::k8s_service& services(int index) const;
  inline ::draiosproto::k8s_service* mutable_services(int index);
  inline ::draiosproto::k8s_service* add_services();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_service >&
      services() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_service >*
      mutable_services();

  // @@protoc_insertion_point(class_scope:draiosproto.k8s_state)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_namespace > namespaces_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_node > nodes_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pod > pods_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_replication_controller > controllers_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_service > services_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static k8s_state* default_instance_;
};
// -------------------------------------------------------------------

class mesos_pair : public ::google::protobuf::Message {
 public:
  mesos_pair();
  virtual ~mesos_pair();

  mesos_pair(const mesos_pair& from);

  inline mesos_pair& operator=(const mesos_pair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mesos_pair& default_instance();

  void Swap(mesos_pair* other);

  // implements Message ----------------------------------------------

  mesos_pair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mesos_pair& from);
  void MergeFrom(const mesos_pair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:draiosproto.mesos_pair)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static mesos_pair* default_instance_;
};
// -------------------------------------------------------------------

class mesos_common : public ::google::protobuf::Message {
 public:
  mesos_common();
  virtual ~mesos_common();

  mesos_common(const mesos_common& from);

  inline mesos_common& operator=(const mesos_common& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mesos_common& default_instance();

  void Swap(mesos_common* other);

  // implements Message ----------------------------------------------

  mesos_common* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mesos_common& from);
  void MergeFrom(const mesos_common& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .draiosproto.mesos_pair labels = 3;
  inline int labels_size() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 3;
  inline const ::draiosproto::mesos_pair& labels(int index) const;
  inline ::draiosproto::mesos_pair* mutable_labels(int index);
  inline ::draiosproto::mesos_pair* add_labels();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_pair >&
      labels() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_pair >*
      mutable_labels();

  // @@protoc_insertion_point(class_scope:draiosproto.mesos_common)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_pair > labels_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static mesos_common* default_instance_;
};
// -------------------------------------------------------------------

class mesos_task : public ::google::protobuf::Message {
 public:
  mesos_task();
  virtual ~mesos_task();

  mesos_task(const mesos_task& from);

  inline mesos_task& operator=(const mesos_task& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mesos_task& default_instance();

  void Swap(mesos_task* other);

  // implements Message ----------------------------------------------

  mesos_task* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mesos_task& from);
  void MergeFrom(const mesos_task& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.mesos_common common = 1;
  inline bool has_common() const;
  inline void clear_common();
  static const int kCommonFieldNumber = 1;
  inline const ::draiosproto::mesos_common& common() const;
  inline ::draiosproto::mesos_common* mutable_common();
  inline ::draiosproto::mesos_common* release_common();
  inline void set_allocated_common(::draiosproto::mesos_common* common);

  // required string slave_id = 2;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 2;
  inline const ::std::string& slave_id() const;
  inline void set_slave_id(const ::std::string& value);
  inline void set_slave_id(const char* value);
  inline void set_slave_id(const char* value, size_t size);
  inline ::std::string* mutable_slave_id();
  inline ::std::string* release_slave_id();
  inline void set_allocated_slave_id(::std::string* slave_id);

  // @@protoc_insertion_point(class_scope:draiosproto.mesos_task)
 private:
  inline void set_has_common();
  inline void clear_has_common();
  inline void set_has_slave_id();
  inline void clear_has_slave_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::draiosproto::mesos_common* common_;
  ::std::string* slave_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static mesos_task* default_instance_;
};
// -------------------------------------------------------------------

class marathon_app : public ::google::protobuf::Message {
 public:
  marathon_app();
  virtual ~marathon_app();

  marathon_app(const marathon_app& from);

  inline marathon_app& operator=(const marathon_app& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const marathon_app& default_instance();

  void Swap(marathon_app* other);

  // implements Message ----------------------------------------------

  marathon_app* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const marathon_app& from);
  void MergeFrom(const marathon_app& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // repeated string task_ids = 2;
  inline int task_ids_size() const;
  inline void clear_task_ids();
  static const int kTaskIdsFieldNumber = 2;
  inline const ::std::string& task_ids(int index) const;
  inline ::std::string* mutable_task_ids(int index);
  inline void set_task_ids(int index, const ::std::string& value);
  inline void set_task_ids(int index, const char* value);
  inline void set_task_ids(int index, const char* value, size_t size);
  inline ::std::string* add_task_ids();
  inline void add_task_ids(const ::std::string& value);
  inline void add_task_ids(const char* value);
  inline void add_task_ids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& task_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_task_ids();

  // @@protoc_insertion_point(class_scope:draiosproto.marathon_app)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> task_ids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static marathon_app* default_instance_;
};
// -------------------------------------------------------------------

class marathon_group : public ::google::protobuf::Message {
 public:
  marathon_group();
  virtual ~marathon_group();

  marathon_group(const marathon_group& from);

  inline marathon_group& operator=(const marathon_group& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const marathon_group& default_instance();

  void Swap(marathon_group* other);

  // implements Message ----------------------------------------------

  marathon_group* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const marathon_group& from);
  void MergeFrom(const marathon_group& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // repeated .draiosproto.marathon_app apps = 2;
  inline int apps_size() const;
  inline void clear_apps();
  static const int kAppsFieldNumber = 2;
  inline const ::draiosproto::marathon_app& apps(int index) const;
  inline ::draiosproto::marathon_app* mutable_apps(int index);
  inline ::draiosproto::marathon_app* add_apps();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_app >&
      apps() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_app >*
      mutable_apps();

  // repeated .draiosproto.marathon_group groups = 3;
  inline int groups_size() const;
  inline void clear_groups();
  static const int kGroupsFieldNumber = 3;
  inline const ::draiosproto::marathon_group& groups(int index) const;
  inline ::draiosproto::marathon_group* mutable_groups(int index);
  inline ::draiosproto::marathon_group* add_groups();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_group >&
      groups() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_group >*
      mutable_groups();

  // @@protoc_insertion_point(class_scope:draiosproto.marathon_group)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_app > apps_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_group > groups_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static marathon_group* default_instance_;
};
// -------------------------------------------------------------------

class mesos_framework : public ::google::protobuf::Message {
 public:
  mesos_framework();
  virtual ~mesos_framework();

  mesos_framework(const mesos_framework& from);

  inline mesos_framework& operator=(const mesos_framework& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mesos_framework& default_instance();

  void Swap(mesos_framework* other);

  // implements Message ----------------------------------------------

  mesos_framework* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mesos_framework& from);
  void MergeFrom(const mesos_framework& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.mesos_common common = 1;
  inline bool has_common() const;
  inline void clear_common();
  static const int kCommonFieldNumber = 1;
  inline const ::draiosproto::mesos_common& common() const;
  inline ::draiosproto::mesos_common* mutable_common();
  inline ::draiosproto::mesos_common* release_common();
  inline void set_allocated_common(::draiosproto::mesos_common* common);

  // repeated .draiosproto.mesos_task tasks = 2;
  inline int tasks_size() const;
  inline void clear_tasks();
  static const int kTasksFieldNumber = 2;
  inline const ::draiosproto::mesos_task& tasks(int index) const;
  inline ::draiosproto::mesos_task* mutable_tasks(int index);
  inline ::draiosproto::mesos_task* add_tasks();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_task >&
      tasks() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_task >*
      mutable_tasks();

  // @@protoc_insertion_point(class_scope:draiosproto.mesos_framework)
 private:
  inline void set_has_common();
  inline void clear_has_common();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::draiosproto::mesos_common* common_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_task > tasks_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static mesos_framework* default_instance_;
};
// -------------------------------------------------------------------

class mesos_slave : public ::google::protobuf::Message {
 public:
  mesos_slave();
  virtual ~mesos_slave();

  mesos_slave(const mesos_slave& from);

  inline mesos_slave& operator=(const mesos_slave& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mesos_slave& default_instance();

  void Swap(mesos_slave* other);

  // implements Message ----------------------------------------------

  mesos_slave* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mesos_slave& from);
  void MergeFrom(const mesos_slave& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.mesos_common common = 1;
  inline bool has_common() const;
  inline void clear_common();
  static const int kCommonFieldNumber = 1;
  inline const ::draiosproto::mesos_common& common() const;
  inline ::draiosproto::mesos_common* mutable_common();
  inline ::draiosproto::mesos_common* release_common();
  inline void set_allocated_common(::draiosproto::mesos_common* common);

  // @@protoc_insertion_point(class_scope:draiosproto.mesos_slave)
 private:
  inline void set_has_common();
  inline void clear_has_common();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::draiosproto::mesos_common* common_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static mesos_slave* default_instance_;
};
// -------------------------------------------------------------------

class mesos_state : public ::google::protobuf::Message {
 public:
  mesos_state();
  virtual ~mesos_state();

  mesos_state(const mesos_state& from);

  inline mesos_state& operator=(const mesos_state& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mesos_state& default_instance();

  void Swap(mesos_state* other);

  // implements Message ----------------------------------------------

  mesos_state* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mesos_state& from);
  void MergeFrom(const mesos_state& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .draiosproto.mesos_framework frameworks = 1;
  inline int frameworks_size() const;
  inline void clear_frameworks();
  static const int kFrameworksFieldNumber = 1;
  inline const ::draiosproto::mesos_framework& frameworks(int index) const;
  inline ::draiosproto::mesos_framework* mutable_frameworks(int index);
  inline ::draiosproto::mesos_framework* add_frameworks();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_framework >&
      frameworks() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_framework >*
      mutable_frameworks();

  // repeated .draiosproto.marathon_group groups = 2;
  inline int groups_size() const;
  inline void clear_groups();
  static const int kGroupsFieldNumber = 2;
  inline const ::draiosproto::marathon_group& groups(int index) const;
  inline ::draiosproto::marathon_group* mutable_groups(int index);
  inline ::draiosproto::marathon_group* add_groups();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_group >&
      groups() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_group >*
      mutable_groups();

  // repeated .draiosproto.mesos_slave slaves = 3;
  inline int slaves_size() const;
  inline void clear_slaves();
  static const int kSlavesFieldNumber = 3;
  inline const ::draiosproto::mesos_slave& slaves(int index) const;
  inline ::draiosproto::mesos_slave* mutable_slaves(int index);
  inline ::draiosproto::mesos_slave* add_slaves();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_slave >&
      slaves() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_slave >*
      mutable_slaves();

  // @@protoc_insertion_point(class_scope:draiosproto.mesos_state)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_framework > frameworks_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_group > groups_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_slave > slaves_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static mesos_state* default_instance_;
};
// -------------------------------------------------------------------

class metrics : public ::google::protobuf::Message {
 public:
  metrics();
  virtual ~metrics();

  metrics(const metrics& from);

  inline metrics& operator=(const metrics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const metrics& default_instance();

  void Swap(metrics* other);

  // implements Message ----------------------------------------------

  metrics* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const metrics& from);
  void MergeFrom(const metrics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  inline bool has_timestamp_ns() const;
  inline void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp_ns() const;
  inline void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  inline bool has_machine_id() const;
  inline void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  inline const ::std::string& machine_id() const;
  inline void set_machine_id(const ::std::string& value);
  inline void set_machine_id(const char* value);
  inline void set_machine_id(const char* value, size_t size);
  inline ::std::string* mutable_machine_id();
  inline ::std::string* release_machine_id();
  inline void set_allocated_machine_id(::std::string* machine_id);

  // optional string customer_id = 3;
  inline bool has_customer_id() const;
  inline void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  inline const ::std::string& customer_id() const;
  inline void set_customer_id(const ::std::string& value);
  inline void set_customer_id(const char* value);
  inline void set_customer_id(const char* value, size_t size);
  inline ::std::string* mutable_customer_id();
  inline ::std::string* release_customer_id();
  inline void set_allocated_customer_id(::std::string* customer_id);

  // optional uint32 sampling_ratio = 10;
  inline bool has_sampling_ratio() const;
  inline void clear_sampling_ratio();
  static const int kSamplingRatioFieldNumber = 10;
  inline ::google::protobuf::uint32 sampling_ratio() const;
  inline void set_sampling_ratio(::google::protobuf::uint32 value);

  // optional string host_custom_name = 11;
  inline bool has_host_custom_name() const;
  inline void clear_host_custom_name();
  static const int kHostCustomNameFieldNumber = 11;
  inline const ::std::string& host_custom_name() const;
  inline void set_host_custom_name(const ::std::string& value);
  inline void set_host_custom_name(const char* value);
  inline void set_host_custom_name(const char* value, size_t size);
  inline ::std::string* mutable_host_custom_name();
  inline ::std::string* release_host_custom_name();
  inline void set_allocated_host_custom_name(::std::string* host_custom_name);

  // optional string host_tags = 12;
  inline bool has_host_tags() const;
  inline void clear_host_tags();
  static const int kHostTagsFieldNumber = 12;
  inline const ::std::string& host_tags() const;
  inline void set_host_tags(const ::std::string& value);
  inline void set_host_tags(const char* value);
  inline void set_host_tags(const char* value, size_t size);
  inline ::std::string* mutable_host_tags();
  inline ::std::string* release_host_tags();
  inline void set_allocated_host_tags(::std::string* host_tags);

  // optional bool is_host_hidden = 14;
  inline bool has_is_host_hidden() const;
  inline void clear_is_host_hidden();
  static const int kIsHostHiddenFieldNumber = 14;
  inline bool is_host_hidden() const;
  inline void set_is_host_hidden(bool value);

  // optional string hidden_processes = 15;
  inline bool has_hidden_processes() const;
  inline void clear_hidden_processes();
  static const int kHiddenProcessesFieldNumber = 15;
  inline const ::std::string& hidden_processes() const;
  inline void set_hidden_processes(const ::std::string& value);
  inline void set_hidden_processes(const char* value);
  inline void set_hidden_processes(const char* value, size_t size);
  inline ::std::string* mutable_hidden_processes();
  inline ::std::string* release_hidden_processes();
  inline void set_allocated_hidden_processes(::std::string* hidden_processes);

  // optional string version = 16;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 16;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional string instance_id = 21;
  inline bool has_instance_id() const;
  inline void clear_instance_id();
  static const int kInstanceIdFieldNumber = 21;
  inline const ::std::string& instance_id() const;
  inline void set_instance_id(const ::std::string& value);
  inline void set_instance_id(const char* value);
  inline void set_instance_id(const char* value, size_t size);
  inline ::std::string* mutable_instance_id();
  inline ::std::string* release_instance_id();
  inline void set_allocated_instance_id(::std::string* instance_id);

  // optional .draiosproto.host hostinfo = 4;
  inline bool has_hostinfo() const;
  inline void clear_hostinfo();
  static const int kHostinfoFieldNumber = 4;
  inline const ::draiosproto::host& hostinfo() const;
  inline ::draiosproto::host* mutable_hostinfo();
  inline ::draiosproto::host* release_hostinfo();
  inline void set_allocated_hostinfo(::draiosproto::host* hostinfo);

  // repeated .draiosproto.program programs = 9;
  inline int programs_size() const;
  inline void clear_programs();
  static const int kProgramsFieldNumber = 9;
  inline const ::draiosproto::program& programs(int index) const;
  inline ::draiosproto::program* mutable_programs(int index);
  inline ::draiosproto::program* add_programs();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::program >&
      programs() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::program >*
      mutable_programs();

  // repeated .draiosproto.ipv4_connection ipv4_connections = 7;
  inline int ipv4_connections_size() const;
  inline void clear_ipv4_connections();
  static const int kIpv4ConnectionsFieldNumber = 7;
  inline const ::draiosproto::ipv4_connection& ipv4_connections(int index) const;
  inline ::draiosproto::ipv4_connection* mutable_ipv4_connections(int index);
  inline ::draiosproto::ipv4_connection* add_ipv4_connections();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_connection >&
      ipv4_connections() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_connection >*
      mutable_ipv4_connections();

  // repeated .draiosproto.ipv4_network_interface ipv4_network_interfaces = 8;
  inline int ipv4_network_interfaces_size() const;
  inline void clear_ipv4_network_interfaces();
  static const int kIpv4NetworkInterfacesFieldNumber = 8;
  inline const ::draiosproto::ipv4_network_interface& ipv4_network_interfaces(int index) const;
  inline ::draiosproto::ipv4_network_interface* mutable_ipv4_network_interfaces(int index);
  inline ::draiosproto::ipv4_network_interface* add_ipv4_network_interfaces();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_network_interface >&
      ipv4_network_interfaces() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_network_interface >*
      mutable_ipv4_network_interfaces();

  // repeated .draiosproto.command_details commands = 17;
  inline int commands_size() const;
  inline void clear_commands();
  static const int kCommandsFieldNumber = 17;
  inline const ::draiosproto::command_details& commands(int index) const;
  inline ::draiosproto::command_details* mutable_commands(int index);
  inline ::draiosproto::command_details* add_commands();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::command_details >&
      commands() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::command_details >*
      mutable_commands();

  // repeated .draiosproto.mounted_fs mounts = 18;
  inline int mounts_size() const;
  inline void clear_mounts();
  static const int kMountsFieldNumber = 18;
  inline const ::draiosproto::mounted_fs& mounts(int index) const;
  inline ::draiosproto::mounted_fs* mutable_mounts(int index);
  inline ::draiosproto::mounted_fs* add_mounts();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mounted_fs >&
      mounts() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mounted_fs >*
      mutable_mounts();

  // repeated .draiosproto.file_stat top_files = 19;
  inline int top_files_size() const;
  inline void clear_top_files();
  static const int kTopFilesFieldNumber = 19;
  inline const ::draiosproto::file_stat& top_files(int index) const;
  inline ::draiosproto::file_stat* mutable_top_files(int index);
  inline ::draiosproto::file_stat* add_top_files();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::file_stat >&
      top_files() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::file_stat >*
      mutable_top_files();

  // optional .draiosproto.proto_info protos = 20;
  inline bool has_protos() const;
  inline void clear_protos();
  static const int kProtosFieldNumber = 20;
  inline const ::draiosproto::proto_info& protos() const;
  inline ::draiosproto::proto_info* mutable_protos();
  inline ::draiosproto::proto_info* release_protos();
  inline void set_allocated_protos(::draiosproto::proto_info* protos);

  // repeated .draiosproto.container containers = 22;
  inline int containers_size() const;
  inline void clear_containers();
  static const int kContainersFieldNumber = 22;
  inline const ::draiosproto::container& containers(int index) const;
  inline ::draiosproto::container* mutable_containers(int index);
  inline ::draiosproto::container* add_containers();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::container >&
      containers() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::container >*
      mutable_containers();

  // optional .draiosproto.k8s_state kubernetes = 24;
  inline bool has_kubernetes() const;
  inline void clear_kubernetes();
  static const int kKubernetesFieldNumber = 24;
  inline const ::draiosproto::k8s_state& kubernetes() const;
  inline ::draiosproto::k8s_state* mutable_kubernetes();
  inline ::draiosproto::k8s_state* release_kubernetes();
  inline void set_allocated_kubernetes(::draiosproto::k8s_state* kubernetes);

  // optional .draiosproto.mesos_state mesos = 25;
  inline bool has_mesos() const;
  inline void clear_mesos();
  static const int kMesosFieldNumber = 25;
  inline const ::draiosproto::mesos_state& mesos() const;
  inline ::draiosproto::mesos_state* mutable_mesos();
  inline ::draiosproto::mesos_state* release_mesos();
  inline void set_allocated_mesos(::draiosproto::mesos_state* mesos);

  // @@protoc_insertion_point(class_scope:draiosproto.metrics)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();
  inline void set_has_sampling_ratio();
  inline void clear_has_sampling_ratio();
  inline void set_has_host_custom_name();
  inline void clear_has_host_custom_name();
  inline void set_has_host_tags();
  inline void clear_has_host_tags();
  inline void set_has_is_host_hidden();
  inline void clear_has_is_host_hidden();
  inline void set_has_hidden_processes();
  inline void clear_has_hidden_processes();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_instance_id();
  inline void clear_has_instance_id();
  inline void set_has_hostinfo();
  inline void clear_has_hostinfo();
  inline void set_has_protos();
  inline void clear_has_protos();
  inline void set_has_kubernetes();
  inline void clear_has_kubernetes();
  inline void set_has_mesos();
  inline void clear_has_mesos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 timestamp_ns_;
  ::std::string* machine_id_;
  ::std::string* customer_id_;
  ::std::string* host_custom_name_;
  ::google::protobuf::uint32 sampling_ratio_;
  bool is_host_hidden_;
  ::std::string* host_tags_;
  ::std::string* hidden_processes_;
  ::std::string* version_;
  ::std::string* instance_id_;
  ::draiosproto::host* hostinfo_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::program > programs_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_connection > ipv4_connections_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_network_interface > ipv4_network_interfaces_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::command_details > commands_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::mounted_fs > mounts_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::file_stat > top_files_;
  ::draiosproto::proto_info* protos_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::container > containers_;
  ::draiosproto::k8s_state* kubernetes_;
  ::draiosproto::mesos_state* mesos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static metrics* default_instance_;
};
// -------------------------------------------------------------------

class dump_request_start : public ::google::protobuf::Message {
 public:
  dump_request_start();
  virtual ~dump_request_start();

  dump_request_start(const dump_request_start& from);

  inline dump_request_start& operator=(const dump_request_start& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dump_request_start& default_instance();

  void Swap(dump_request_start* other);

  // implements Message ----------------------------------------------

  dump_request_start* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dump_request_start& from);
  void MergeFrom(const dump_request_start& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  inline bool has_timestamp_ns() const;
  inline void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp_ns() const;
  inline void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  inline bool has_machine_id() const;
  inline void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  inline const ::std::string& machine_id() const;
  inline void set_machine_id(const ::std::string& value);
  inline void set_machine_id(const char* value);
  inline void set_machine_id(const char* value, size_t size);
  inline ::std::string* mutable_machine_id();
  inline ::std::string* release_machine_id();
  inline void set_allocated_machine_id(::std::string* machine_id);

  // optional string customer_id = 3;
  inline bool has_customer_id() const;
  inline void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  inline const ::std::string& customer_id() const;
  inline void set_customer_id(const ::std::string& value);
  inline void set_customer_id(const char* value);
  inline void set_customer_id(const char* value, size_t size);
  inline ::std::string* mutable_customer_id();
  inline ::std::string* release_customer_id();
  inline void set_allocated_customer_id(::std::string* customer_id);

  // optional uint64 duration_ns = 4;
  inline bool has_duration_ns() const;
  inline void clear_duration_ns();
  static const int kDurationNsFieldNumber = 4;
  inline ::google::protobuf::uint64 duration_ns() const;
  inline void set_duration_ns(::google::protobuf::uint64 value);

  // optional string filters = 5;
  inline bool has_filters() const;
  inline void clear_filters();
  static const int kFiltersFieldNumber = 5;
  inline const ::std::string& filters() const;
  inline void set_filters(const ::std::string& value);
  inline void set_filters(const char* value);
  inline void set_filters(const char* value, size_t size);
  inline ::std::string* mutable_filters();
  inline ::std::string* release_filters();
  inline void set_allocated_filters(::std::string* filters);

  // optional uint64 max_size = 7;
  inline bool has_max_size() const;
  inline void clear_max_size();
  static const int kMaxSizeFieldNumber = 7;
  inline ::google::protobuf::uint64 max_size() const;
  inline void set_max_size(::google::protobuf::uint64 value);

  // required string token = 6;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 6;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:draiosproto.dump_request_start)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();
  inline void set_has_duration_ns();
  inline void clear_has_duration_ns();
  inline void set_has_filters();
  inline void clear_has_filters();
  inline void set_has_max_size();
  inline void clear_has_max_size();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 timestamp_ns_;
  ::std::string* machine_id_;
  ::std::string* customer_id_;
  ::google::protobuf::uint64 duration_ns_;
  ::std::string* filters_;
  ::google::protobuf::uint64 max_size_;
  ::std::string* token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static dump_request_start* default_instance_;
};
// -------------------------------------------------------------------

class dump_request_stop : public ::google::protobuf::Message {
 public:
  dump_request_stop();
  virtual ~dump_request_stop();

  dump_request_stop(const dump_request_stop& from);

  inline dump_request_stop& operator=(const dump_request_stop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dump_request_stop& default_instance();

  void Swap(dump_request_stop* other);

  // implements Message ----------------------------------------------

  dump_request_stop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dump_request_stop& from);
  void MergeFrom(const dump_request_stop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  inline bool has_timestamp_ns() const;
  inline void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp_ns() const;
  inline void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  inline bool has_machine_id() const;
  inline void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  inline const ::std::string& machine_id() const;
  inline void set_machine_id(const ::std::string& value);
  inline void set_machine_id(const char* value);
  inline void set_machine_id(const char* value, size_t size);
  inline ::std::string* mutable_machine_id();
  inline ::std::string* release_machine_id();
  inline void set_allocated_machine_id(::std::string* machine_id);

  // optional string customer_id = 3;
  inline bool has_customer_id() const;
  inline void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  inline const ::std::string& customer_id() const;
  inline void set_customer_id(const ::std::string& value);
  inline void set_customer_id(const char* value);
  inline void set_customer_id(const char* value, size_t size);
  inline ::std::string* mutable_customer_id();
  inline ::std::string* release_customer_id();
  inline void set_allocated_customer_id(::std::string* customer_id);

  // required string token = 4;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 4;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:draiosproto.dump_request_stop)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 timestamp_ns_;
  ::std::string* machine_id_;
  ::std::string* customer_id_;
  ::std::string* token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static dump_request_stop* default_instance_;
};
// -------------------------------------------------------------------

class dump_response : public ::google::protobuf::Message {
 public:
  dump_response();
  virtual ~dump_response();

  dump_response(const dump_response& from);

  inline dump_response& operator=(const dump_response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dump_response& default_instance();

  void Swap(dump_response* other);

  // implements Message ----------------------------------------------

  dump_response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dump_response& from);
  void MergeFrom(const dump_response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  inline bool has_timestamp_ns() const;
  inline void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp_ns() const;
  inline void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  inline bool has_machine_id() const;
  inline void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  inline const ::std::string& machine_id() const;
  inline void set_machine_id(const ::std::string& value);
  inline void set_machine_id(const char* value);
  inline void set_machine_id(const char* value, size_t size);
  inline ::std::string* mutable_machine_id();
  inline ::std::string* release_machine_id();
  inline void set_allocated_machine_id(::std::string* machine_id);

  // optional string customer_id = 3;
  inline bool has_customer_id() const;
  inline void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  inline const ::std::string& customer_id() const;
  inline void set_customer_id(const ::std::string& value);
  inline void set_customer_id(const char* value);
  inline void set_customer_id(const char* value, size_t size);
  inline ::std::string* mutable_customer_id();
  inline ::std::string* release_customer_id();
  inline void set_allocated_customer_id(::std::string* customer_id);

  // optional uint32 chunk_no = 7;
  inline bool has_chunk_no() const;
  inline void clear_chunk_no();
  static const int kChunkNoFieldNumber = 7;
  inline ::google::protobuf::uint32 chunk_no() const;
  inline void set_chunk_no(::google::protobuf::uint32 value);

  // optional bool final_chunk = 8;
  inline bool has_final_chunk() const;
  inline void clear_final_chunk();
  static const int kFinalChunkFieldNumber = 8;
  inline bool final_chunk() const;
  inline void set_final_chunk(bool value);

  // optional bool keep_alive = 9;
  inline bool has_keep_alive() const;
  inline void clear_keep_alive();
  static const int kKeepAliveFieldNumber = 9;
  inline bool keep_alive() const;
  inline void set_keep_alive(bool value);

  // optional bytes content = 4;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 4;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional uint64 final_size_bytes = 10;
  inline bool has_final_size_bytes() const;
  inline void clear_final_size_bytes();
  static const int kFinalSizeBytesFieldNumber = 10;
  inline ::google::protobuf::uint64 final_size_bytes() const;
  inline void set_final_size_bytes(::google::protobuf::uint64 value);

  // optional string error = 5;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 5;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  inline void set_allocated_error(::std::string* error);

  // required string token = 6;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 6;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:draiosproto.dump_response)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();
  inline void set_has_chunk_no();
  inline void clear_has_chunk_no();
  inline void set_has_final_chunk();
  inline void clear_has_final_chunk();
  inline void set_has_keep_alive();
  inline void clear_has_keep_alive();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_final_size_bytes();
  inline void clear_has_final_size_bytes();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 timestamp_ns_;
  ::std::string* machine_id_;
  ::std::string* customer_id_;
  ::google::protobuf::uint32 chunk_no_;
  bool final_chunk_;
  bool keep_alive_;
  ::std::string* content_;
  ::google::protobuf::uint64 final_size_bytes_;
  ::std::string* error_;
  ::std::string* token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static dump_response* default_instance_;
};
// -------------------------------------------------------------------

class ssh_open_channel : public ::google::protobuf::Message {
 public:
  ssh_open_channel();
  virtual ~ssh_open_channel();

  ssh_open_channel(const ssh_open_channel& from);

  inline ssh_open_channel& operator=(const ssh_open_channel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ssh_open_channel& default_instance();

  void Swap(ssh_open_channel* other);

  // implements Message ----------------------------------------------

  ssh_open_channel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ssh_open_channel& from);
  void MergeFrom(const ssh_open_channel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  inline bool has_timestamp_ns() const;
  inline void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp_ns() const;
  inline void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  inline bool has_machine_id() const;
  inline void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  inline const ::std::string& machine_id() const;
  inline void set_machine_id(const ::std::string& value);
  inline void set_machine_id(const char* value);
  inline void set_machine_id(const char* value, size_t size);
  inline ::std::string* mutable_machine_id();
  inline ::std::string* release_machine_id();
  inline void set_allocated_machine_id(::std::string* machine_id);

  // optional string customer_id = 3;
  inline bool has_customer_id() const;
  inline void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  inline const ::std::string& customer_id() const;
  inline void set_customer_id(const ::std::string& value);
  inline void set_customer_id(const char* value);
  inline void set_customer_id(const char* value, size_t size);
  inline ::std::string* mutable_customer_id();
  inline ::std::string* release_customer_id();
  inline void set_allocated_customer_id(::std::string* customer_id);

  // required string token = 4;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 4;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // required string user = 5;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 5;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // optional string password = 6;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 6;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string key = 7;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 7;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string passphrase = 8;
  inline bool has_passphrase() const;
  inline void clear_passphrase();
  static const int kPassphraseFieldNumber = 8;
  inline const ::std::string& passphrase() const;
  inline void set_passphrase(const ::std::string& value);
  inline void set_passphrase(const char* value);
  inline void set_passphrase(const char* value, size_t size);
  inline ::std::string* mutable_passphrase();
  inline ::std::string* release_passphrase();
  inline void set_allocated_passphrase(::std::string* passphrase);

  // optional uint32 port = 9;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 9;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.ssh_open_channel)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_passphrase();
  inline void clear_has_passphrase();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 timestamp_ns_;
  ::std::string* machine_id_;
  ::std::string* customer_id_;
  ::std::string* token_;
  ::std::string* user_;
  ::std::string* password_;
  ::std::string* key_;
  ::std::string* passphrase_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static ssh_open_channel* default_instance_;
};
// -------------------------------------------------------------------

class ssh_data : public ::google::protobuf::Message {
 public:
  ssh_data();
  virtual ~ssh_data();

  ssh_data(const ssh_data& from);

  inline ssh_data& operator=(const ssh_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ssh_data& default_instance();

  void Swap(ssh_data* other);

  // implements Message ----------------------------------------------

  ssh_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ssh_data& from);
  void MergeFrom(const ssh_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  inline bool has_timestamp_ns() const;
  inline void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp_ns() const;
  inline void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  inline bool has_machine_id() const;
  inline void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  inline const ::std::string& machine_id() const;
  inline void set_machine_id(const ::std::string& value);
  inline void set_machine_id(const char* value);
  inline void set_machine_id(const char* value, size_t size);
  inline ::std::string* mutable_machine_id();
  inline ::std::string* release_machine_id();
  inline void set_allocated_machine_id(::std::string* machine_id);

  // optional string customer_id = 3;
  inline bool has_customer_id() const;
  inline void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  inline const ::std::string& customer_id() const;
  inline void set_customer_id(const ::std::string& value);
  inline void set_customer_id(const char* value);
  inline void set_customer_id(const char* value, size_t size);
  inline ::std::string* mutable_customer_id();
  inline ::std::string* release_customer_id();
  inline void set_allocated_customer_id(::std::string* customer_id);

  // required string token = 4;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 4;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional bytes data = 5;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 5;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional string error = 6;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 6;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  inline void set_allocated_error(::std::string* error);

  // optional int32 exit_status = 7;
  inline bool has_exit_status() const;
  inline void clear_exit_status();
  static const int kExitStatusFieldNumber = 7;
  inline ::google::protobuf::int32 exit_status() const;
  inline void set_exit_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.ssh_data)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_exit_status();
  inline void clear_has_exit_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 timestamp_ns_;
  ::std::string* machine_id_;
  ::std::string* customer_id_;
  ::std::string* token_;
  ::std::string* data_;
  ::std::string* error_;
  ::google::protobuf::int32 exit_status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static ssh_data* default_instance_;
};
// -------------------------------------------------------------------

class ssh_close_channel : public ::google::protobuf::Message {
 public:
  ssh_close_channel();
  virtual ~ssh_close_channel();

  ssh_close_channel(const ssh_close_channel& from);

  inline ssh_close_channel& operator=(const ssh_close_channel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ssh_close_channel& default_instance();

  void Swap(ssh_close_channel* other);

  // implements Message ----------------------------------------------

  ssh_close_channel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ssh_close_channel& from);
  void MergeFrom(const ssh_close_channel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  inline bool has_timestamp_ns() const;
  inline void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp_ns() const;
  inline void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  inline bool has_machine_id() const;
  inline void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  inline const ::std::string& machine_id() const;
  inline void set_machine_id(const ::std::string& value);
  inline void set_machine_id(const char* value);
  inline void set_machine_id(const char* value, size_t size);
  inline ::std::string* mutable_machine_id();
  inline ::std::string* release_machine_id();
  inline void set_allocated_machine_id(::std::string* machine_id);

  // optional string customer_id = 3;
  inline bool has_customer_id() const;
  inline void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  inline const ::std::string& customer_id() const;
  inline void set_customer_id(const ::std::string& value);
  inline void set_customer_id(const char* value);
  inline void set_customer_id(const char* value, size_t size);
  inline ::std::string* mutable_customer_id();
  inline ::std::string* release_customer_id();
  inline void set_allocated_customer_id(::std::string* customer_id);

  // required string token = 4;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 4;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:draiosproto.ssh_close_channel)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 timestamp_ns_;
  ::std::string* machine_id_;
  ::std::string* customer_id_;
  ::std::string* token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static ssh_close_channel* default_instance_;
};
// -------------------------------------------------------------------

class auto_update_request : public ::google::protobuf::Message {
 public:
  auto_update_request();
  virtual ~auto_update_request();

  auto_update_request(const auto_update_request& from);

  inline auto_update_request& operator=(const auto_update_request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const auto_update_request& default_instance();

  void Swap(auto_update_request* other);

  // implements Message ----------------------------------------------

  auto_update_request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const auto_update_request& from);
  void MergeFrom(const auto_update_request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  inline bool has_timestamp_ns() const;
  inline void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp_ns() const;
  inline void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  inline bool has_machine_id() const;
  inline void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  inline const ::std::string& machine_id() const;
  inline void set_machine_id(const ::std::string& value);
  inline void set_machine_id(const char* value);
  inline void set_machine_id(const char* value, size_t size);
  inline ::std::string* mutable_machine_id();
  inline ::std::string* release_machine_id();
  inline void set_allocated_machine_id(::std::string* machine_id);

  // optional string customer_id = 3;
  inline bool has_customer_id() const;
  inline void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  inline const ::std::string& customer_id() const;
  inline void set_customer_id(const ::std::string& value);
  inline void set_customer_id(const char* value);
  inline void set_customer_id(const char* value, size_t size);
  inline ::std::string* mutable_customer_id();
  inline ::std::string* release_customer_id();
  inline void set_allocated_customer_id(::std::string* customer_id);

  // @@protoc_insertion_point(class_scope:draiosproto.auto_update_request)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 timestamp_ns_;
  ::std::string* machine_id_;
  ::std::string* customer_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static auto_update_request* default_instance_;
};
// -------------------------------------------------------------------

class dirty_shutdown_report : public ::google::protobuf::Message {
 public:
  dirty_shutdown_report();
  virtual ~dirty_shutdown_report();

  dirty_shutdown_report(const dirty_shutdown_report& from);

  inline dirty_shutdown_report& operator=(const dirty_shutdown_report& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dirty_shutdown_report& default_instance();

  void Swap(dirty_shutdown_report* other);

  // implements Message ----------------------------------------------

  dirty_shutdown_report* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dirty_shutdown_report& from);
  void MergeFrom(const dirty_shutdown_report& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  inline bool has_timestamp_ns() const;
  inline void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp_ns() const;
  inline void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  inline bool has_machine_id() const;
  inline void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  inline const ::std::string& machine_id() const;
  inline void set_machine_id(const ::std::string& value);
  inline void set_machine_id(const char* value);
  inline void set_machine_id(const char* value, size_t size);
  inline ::std::string* mutable_machine_id();
  inline ::std::string* release_machine_id();
  inline void set_allocated_machine_id(::std::string* machine_id);

  // optional string customer_id = 3;
  inline bool has_customer_id() const;
  inline void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  inline const ::std::string& customer_id() const;
  inline void set_customer_id(const ::std::string& value);
  inline void set_customer_id(const char* value);
  inline void set_customer_id(const char* value, size_t size);
  inline ::std::string* mutable_customer_id();
  inline ::std::string* release_customer_id();
  inline void set_allocated_customer_id(::std::string* customer_id);

  // required string log = 4;
  inline bool has_log() const;
  inline void clear_log();
  static const int kLogFieldNumber = 4;
  inline const ::std::string& log() const;
  inline void set_log(const ::std::string& value);
  inline void set_log(const char* value);
  inline void set_log(const char* value, size_t size);
  inline ::std::string* mutable_log();
  inline ::std::string* release_log();
  inline void set_allocated_log(::std::string* log);

  // @@protoc_insertion_point(class_scope:draiosproto.dirty_shutdown_report)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();
  inline void set_has_log();
  inline void clear_has_log();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 timestamp_ns_;
  ::std::string* machine_id_;
  ::std::string* customer_id_;
  ::std::string* log_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_draios_2eproto();
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static dirty_shutdown_report* default_instance_;
};
// ===================================================================


// ===================================================================

// counter_time

// required uint32 count = 1;
inline bool counter_time::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void counter_time::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void counter_time::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void counter_time::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 counter_time::count() const {
  return count_;
}
inline void counter_time::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// required uint64 time_ns = 2;
inline bool counter_time::has_time_ns() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void counter_time::set_has_time_ns() {
  _has_bits_[0] |= 0x00000002u;
}
inline void counter_time::clear_has_time_ns() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void counter_time::clear_time_ns() {
  time_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_time_ns();
}
inline ::google::protobuf::uint64 counter_time::time_ns() const {
  return time_ns_;
}
inline void counter_time::set_time_ns(::google::protobuf::uint64 value) {
  set_has_time_ns();
  time_ns_ = value;
}

// optional uint32 time_percentage = 3;
inline bool counter_time::has_time_percentage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void counter_time::set_has_time_percentage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void counter_time::clear_has_time_percentage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void counter_time::clear_time_percentage() {
  time_percentage_ = 0u;
  clear_has_time_percentage();
}
inline ::google::protobuf::uint32 counter_time::time_percentage() const {
  return time_percentage_;
}
inline void counter_time::set_time_percentage(::google::protobuf::uint32 value) {
  set_has_time_percentage();
  time_percentage_ = value;
}

// -------------------------------------------------------------------

// counter_time_bidirectional

// required uint32 count_in = 1;
inline bool counter_time_bidirectional::has_count_in() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void counter_time_bidirectional::set_has_count_in() {
  _has_bits_[0] |= 0x00000001u;
}
inline void counter_time_bidirectional::clear_has_count_in() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void counter_time_bidirectional::clear_count_in() {
  count_in_ = 0u;
  clear_has_count_in();
}
inline ::google::protobuf::uint32 counter_time_bidirectional::count_in() const {
  return count_in_;
}
inline void counter_time_bidirectional::set_count_in(::google::protobuf::uint32 value) {
  set_has_count_in();
  count_in_ = value;
}

// required uint32 count_out = 2;
inline bool counter_time_bidirectional::has_count_out() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void counter_time_bidirectional::set_has_count_out() {
  _has_bits_[0] |= 0x00000002u;
}
inline void counter_time_bidirectional::clear_has_count_out() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void counter_time_bidirectional::clear_count_out() {
  count_out_ = 0u;
  clear_has_count_out();
}
inline ::google::protobuf::uint32 counter_time_bidirectional::count_out() const {
  return count_out_;
}
inline void counter_time_bidirectional::set_count_out(::google::protobuf::uint32 value) {
  set_has_count_out();
  count_out_ = value;
}

// required uint64 time_ns_in = 3;
inline bool counter_time_bidirectional::has_time_ns_in() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void counter_time_bidirectional::set_has_time_ns_in() {
  _has_bits_[0] |= 0x00000004u;
}
inline void counter_time_bidirectional::clear_has_time_ns_in() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void counter_time_bidirectional::clear_time_ns_in() {
  time_ns_in_ = GOOGLE_ULONGLONG(0);
  clear_has_time_ns_in();
}
inline ::google::protobuf::uint64 counter_time_bidirectional::time_ns_in() const {
  return time_ns_in_;
}
inline void counter_time_bidirectional::set_time_ns_in(::google::protobuf::uint64 value) {
  set_has_time_ns_in();
  time_ns_in_ = value;
}

// required uint64 time_ns_out = 4;
inline bool counter_time_bidirectional::has_time_ns_out() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void counter_time_bidirectional::set_has_time_ns_out() {
  _has_bits_[0] |= 0x00000008u;
}
inline void counter_time_bidirectional::clear_has_time_ns_out() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void counter_time_bidirectional::clear_time_ns_out() {
  time_ns_out_ = GOOGLE_ULONGLONG(0);
  clear_has_time_ns_out();
}
inline ::google::protobuf::uint64 counter_time_bidirectional::time_ns_out() const {
  return time_ns_out_;
}
inline void counter_time_bidirectional::set_time_ns_out(::google::protobuf::uint64 value) {
  set_has_time_ns_out();
  time_ns_out_ = value;
}

// -------------------------------------------------------------------

// counter_bytes

// required uint32 count_in = 1;
inline bool counter_bytes::has_count_in() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void counter_bytes::set_has_count_in() {
  _has_bits_[0] |= 0x00000001u;
}
inline void counter_bytes::clear_has_count_in() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void counter_bytes::clear_count_in() {
  count_in_ = 0u;
  clear_has_count_in();
}
inline ::google::protobuf::uint32 counter_bytes::count_in() const {
  return count_in_;
}
inline void counter_bytes::set_count_in(::google::protobuf::uint32 value) {
  set_has_count_in();
  count_in_ = value;
}

// required uint32 count_out = 2;
inline bool counter_bytes::has_count_out() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void counter_bytes::set_has_count_out() {
  _has_bits_[0] |= 0x00000002u;
}
inline void counter_bytes::clear_has_count_out() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void counter_bytes::clear_count_out() {
  count_out_ = 0u;
  clear_has_count_out();
}
inline ::google::protobuf::uint32 counter_bytes::count_out() const {
  return count_out_;
}
inline void counter_bytes::set_count_out(::google::protobuf::uint32 value) {
  set_has_count_out();
  count_out_ = value;
}

// required uint32 bytes_in = 3;
inline bool counter_bytes::has_bytes_in() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void counter_bytes::set_has_bytes_in() {
  _has_bits_[0] |= 0x00000004u;
}
inline void counter_bytes::clear_has_bytes_in() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void counter_bytes::clear_bytes_in() {
  bytes_in_ = 0u;
  clear_has_bytes_in();
}
inline ::google::protobuf::uint32 counter_bytes::bytes_in() const {
  return bytes_in_;
}
inline void counter_bytes::set_bytes_in(::google::protobuf::uint32 value) {
  set_has_bytes_in();
  bytes_in_ = value;
}

// required uint32 bytes_out = 4;
inline bool counter_bytes::has_bytes_out() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void counter_bytes::set_has_bytes_out() {
  _has_bits_[0] |= 0x00000008u;
}
inline void counter_bytes::clear_has_bytes_out() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void counter_bytes::clear_bytes_out() {
  bytes_out_ = 0u;
  clear_has_bytes_out();
}
inline ::google::protobuf::uint32 counter_bytes::bytes_out() const {
  return bytes_out_;
}
inline void counter_bytes::set_bytes_out(::google::protobuf::uint32 value) {
  set_has_bytes_out();
  bytes_out_ = value;
}

// -------------------------------------------------------------------

// counter_time_bytes

// required uint64 time_ns_in = 1;
inline bool counter_time_bytes::has_time_ns_in() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void counter_time_bytes::set_has_time_ns_in() {
  _has_bits_[0] |= 0x00000001u;
}
inline void counter_time_bytes::clear_has_time_ns_in() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void counter_time_bytes::clear_time_ns_in() {
  time_ns_in_ = GOOGLE_ULONGLONG(0);
  clear_has_time_ns_in();
}
inline ::google::protobuf::uint64 counter_time_bytes::time_ns_in() const {
  return time_ns_in_;
}
inline void counter_time_bytes::set_time_ns_in(::google::protobuf::uint64 value) {
  set_has_time_ns_in();
  time_ns_in_ = value;
}

// required uint64 time_ns_out = 2;
inline bool counter_time_bytes::has_time_ns_out() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void counter_time_bytes::set_has_time_ns_out() {
  _has_bits_[0] |= 0x00000002u;
}
inline void counter_time_bytes::clear_has_time_ns_out() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void counter_time_bytes::clear_time_ns_out() {
  time_ns_out_ = GOOGLE_ULONGLONG(0);
  clear_has_time_ns_out();
}
inline ::google::protobuf::uint64 counter_time_bytes::time_ns_out() const {
  return time_ns_out_;
}
inline void counter_time_bytes::set_time_ns_out(::google::protobuf::uint64 value) {
  set_has_time_ns_out();
  time_ns_out_ = value;
}

// required uint64 time_ns_other = 3;
inline bool counter_time_bytes::has_time_ns_other() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void counter_time_bytes::set_has_time_ns_other() {
  _has_bits_[0] |= 0x00000004u;
}
inline void counter_time_bytes::clear_has_time_ns_other() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void counter_time_bytes::clear_time_ns_other() {
  time_ns_other_ = GOOGLE_ULONGLONG(0);
  clear_has_time_ns_other();
}
inline ::google::protobuf::uint64 counter_time_bytes::time_ns_other() const {
  return time_ns_other_;
}
inline void counter_time_bytes::set_time_ns_other(::google::protobuf::uint64 value) {
  set_has_time_ns_other();
  time_ns_other_ = value;
}

// required uint32 count_in = 4;
inline bool counter_time_bytes::has_count_in() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void counter_time_bytes::set_has_count_in() {
  _has_bits_[0] |= 0x00000008u;
}
inline void counter_time_bytes::clear_has_count_in() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void counter_time_bytes::clear_count_in() {
  count_in_ = 0u;
  clear_has_count_in();
}
inline ::google::protobuf::uint32 counter_time_bytes::count_in() const {
  return count_in_;
}
inline void counter_time_bytes::set_count_in(::google::protobuf::uint32 value) {
  set_has_count_in();
  count_in_ = value;
}

// required uint32 count_out = 5;
inline bool counter_time_bytes::has_count_out() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void counter_time_bytes::set_has_count_out() {
  _has_bits_[0] |= 0x00000010u;
}
inline void counter_time_bytes::clear_has_count_out() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void counter_time_bytes::clear_count_out() {
  count_out_ = 0u;
  clear_has_count_out();
}
inline ::google::protobuf::uint32 counter_time_bytes::count_out() const {
  return count_out_;
}
inline void counter_time_bytes::set_count_out(::google::protobuf::uint32 value) {
  set_has_count_out();
  count_out_ = value;
}

// required uint32 count_other = 6;
inline bool counter_time_bytes::has_count_other() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void counter_time_bytes::set_has_count_other() {
  _has_bits_[0] |= 0x00000020u;
}
inline void counter_time_bytes::clear_has_count_other() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void counter_time_bytes::clear_count_other() {
  count_other_ = 0u;
  clear_has_count_other();
}
inline ::google::protobuf::uint32 counter_time_bytes::count_other() const {
  return count_other_;
}
inline void counter_time_bytes::set_count_other(::google::protobuf::uint32 value) {
  set_has_count_other();
  count_other_ = value;
}

// required uint32 bytes_in = 7;
inline bool counter_time_bytes::has_bytes_in() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void counter_time_bytes::set_has_bytes_in() {
  _has_bits_[0] |= 0x00000040u;
}
inline void counter_time_bytes::clear_has_bytes_in() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void counter_time_bytes::clear_bytes_in() {
  bytes_in_ = 0u;
  clear_has_bytes_in();
}
inline ::google::protobuf::uint32 counter_time_bytes::bytes_in() const {
  return bytes_in_;
}
inline void counter_time_bytes::set_bytes_in(::google::protobuf::uint32 value) {
  set_has_bytes_in();
  bytes_in_ = value;
}

// required uint32 bytes_out = 8;
inline bool counter_time_bytes::has_bytes_out() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void counter_time_bytes::set_has_bytes_out() {
  _has_bits_[0] |= 0x00000080u;
}
inline void counter_time_bytes::clear_has_bytes_out() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void counter_time_bytes::clear_bytes_out() {
  bytes_out_ = 0u;
  clear_has_bytes_out();
}
inline ::google::protobuf::uint32 counter_time_bytes::bytes_out() const {
  return bytes_out_;
}
inline void counter_time_bytes::set_bytes_out(::google::protobuf::uint32 value) {
  set_has_bytes_out();
  bytes_out_ = value;
}

// required uint32 bytes_other = 9;
inline bool counter_time_bytes::has_bytes_other() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void counter_time_bytes::set_has_bytes_other() {
  _has_bits_[0] |= 0x00000100u;
}
inline void counter_time_bytes::clear_has_bytes_other() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void counter_time_bytes::clear_bytes_other() {
  bytes_other_ = 0u;
  clear_has_bytes_other();
}
inline ::google::protobuf::uint32 counter_time_bytes::bytes_other() const {
  return bytes_other_;
}
inline void counter_time_bytes::set_bytes_other(::google::protobuf::uint32 value) {
  set_has_bytes_other();
  bytes_other_ = value;
}

// optional uint32 time_percentage_in = 10;
inline bool counter_time_bytes::has_time_percentage_in() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void counter_time_bytes::set_has_time_percentage_in() {
  _has_bits_[0] |= 0x00000200u;
}
inline void counter_time_bytes::clear_has_time_percentage_in() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void counter_time_bytes::clear_time_percentage_in() {
  time_percentage_in_ = 0u;
  clear_has_time_percentage_in();
}
inline ::google::protobuf::uint32 counter_time_bytes::time_percentage_in() const {
  return time_percentage_in_;
}
inline void counter_time_bytes::set_time_percentage_in(::google::protobuf::uint32 value) {
  set_has_time_percentage_in();
  time_percentage_in_ = value;
}

// optional uint32 time_percentage_out = 11;
inline bool counter_time_bytes::has_time_percentage_out() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void counter_time_bytes::set_has_time_percentage_out() {
  _has_bits_[0] |= 0x00000400u;
}
inline void counter_time_bytes::clear_has_time_percentage_out() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void counter_time_bytes::clear_time_percentage_out() {
  time_percentage_out_ = 0u;
  clear_has_time_percentage_out();
}
inline ::google::protobuf::uint32 counter_time_bytes::time_percentage_out() const {
  return time_percentage_out_;
}
inline void counter_time_bytes::set_time_percentage_out(::google::protobuf::uint32 value) {
  set_has_time_percentage_out();
  time_percentage_out_ = value;
}

// optional uint32 time_percentage_other = 12;
inline bool counter_time_bytes::has_time_percentage_other() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void counter_time_bytes::set_has_time_percentage_other() {
  _has_bits_[0] |= 0x00000800u;
}
inline void counter_time_bytes::clear_has_time_percentage_other() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void counter_time_bytes::clear_time_percentage_other() {
  time_percentage_other_ = 0u;
  clear_has_time_percentage_other();
}
inline ::google::protobuf::uint32 counter_time_bytes::time_percentage_other() const {
  return time_percentage_other_;
}
inline void counter_time_bytes::set_time_percentage_other(::google::protobuf::uint32 value) {
  set_has_time_percentage_other();
  time_percentage_other_ = value;
}

// -------------------------------------------------------------------

// time_categories

// optional .draiosproto.counter_time unknown = 1;
inline bool time_categories::has_unknown() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void time_categories::set_has_unknown() {
  _has_bits_[0] |= 0x00000001u;
}
inline void time_categories::clear_has_unknown() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void time_categories::clear_unknown() {
  if (unknown_ != NULL) unknown_->::draiosproto::counter_time::Clear();
  clear_has_unknown();
}
inline const ::draiosproto::counter_time& time_categories::unknown() const {
  return unknown_ != NULL ? *unknown_ : *default_instance_->unknown_;
}
inline ::draiosproto::counter_time* time_categories::mutable_unknown() {
  set_has_unknown();
  if (unknown_ == NULL) unknown_ = new ::draiosproto::counter_time;
  return unknown_;
}
inline ::draiosproto::counter_time* time_categories::release_unknown() {
  clear_has_unknown();
  ::draiosproto::counter_time* temp = unknown_;
  unknown_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_unknown(::draiosproto::counter_time* unknown) {
  delete unknown_;
  unknown_ = unknown;
  if (unknown) {
    set_has_unknown();
  } else {
    clear_has_unknown();
  }
}

// optional .draiosproto.counter_time other = 2;
inline bool time_categories::has_other() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void time_categories::set_has_other() {
  _has_bits_[0] |= 0x00000002u;
}
inline void time_categories::clear_has_other() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void time_categories::clear_other() {
  if (other_ != NULL) other_->::draiosproto::counter_time::Clear();
  clear_has_other();
}
inline const ::draiosproto::counter_time& time_categories::other() const {
  return other_ != NULL ? *other_ : *default_instance_->other_;
}
inline ::draiosproto::counter_time* time_categories::mutable_other() {
  set_has_other();
  if (other_ == NULL) other_ = new ::draiosproto::counter_time;
  return other_;
}
inline ::draiosproto::counter_time* time_categories::release_other() {
  clear_has_other();
  ::draiosproto::counter_time* temp = other_;
  other_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_other(::draiosproto::counter_time* other) {
  delete other_;
  other_ = other;
  if (other) {
    set_has_other();
  } else {
    clear_has_other();
  }
}

// optional .draiosproto.counter_time file = 3;
inline bool time_categories::has_file() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void time_categories::set_has_file() {
  _has_bits_[0] |= 0x00000004u;
}
inline void time_categories::clear_has_file() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void time_categories::clear_file() {
  if (file_ != NULL) file_->::draiosproto::counter_time::Clear();
  clear_has_file();
}
inline const ::draiosproto::counter_time& time_categories::file() const {
  return file_ != NULL ? *file_ : *default_instance_->file_;
}
inline ::draiosproto::counter_time* time_categories::mutable_file() {
  set_has_file();
  if (file_ == NULL) file_ = new ::draiosproto::counter_time;
  return file_;
}
inline ::draiosproto::counter_time* time_categories::release_file() {
  clear_has_file();
  ::draiosproto::counter_time* temp = file_;
  file_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_file(::draiosproto::counter_time* file) {
  delete file_;
  file_ = file;
  if (file) {
    set_has_file();
  } else {
    clear_has_file();
  }
}

// optional .draiosproto.counter_time net = 4;
inline bool time_categories::has_net() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void time_categories::set_has_net() {
  _has_bits_[0] |= 0x00000008u;
}
inline void time_categories::clear_has_net() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void time_categories::clear_net() {
  if (net_ != NULL) net_->::draiosproto::counter_time::Clear();
  clear_has_net();
}
inline const ::draiosproto::counter_time& time_categories::net() const {
  return net_ != NULL ? *net_ : *default_instance_->net_;
}
inline ::draiosproto::counter_time* time_categories::mutable_net() {
  set_has_net();
  if (net_ == NULL) net_ = new ::draiosproto::counter_time;
  return net_;
}
inline ::draiosproto::counter_time* time_categories::release_net() {
  clear_has_net();
  ::draiosproto::counter_time* temp = net_;
  net_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_net(::draiosproto::counter_time* net) {
  delete net_;
  net_ = net;
  if (net) {
    set_has_net();
  } else {
    clear_has_net();
  }
}

// optional .draiosproto.counter_time ipc = 5;
inline bool time_categories::has_ipc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void time_categories::set_has_ipc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void time_categories::clear_has_ipc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void time_categories::clear_ipc() {
  if (ipc_ != NULL) ipc_->::draiosproto::counter_time::Clear();
  clear_has_ipc();
}
inline const ::draiosproto::counter_time& time_categories::ipc() const {
  return ipc_ != NULL ? *ipc_ : *default_instance_->ipc_;
}
inline ::draiosproto::counter_time* time_categories::mutable_ipc() {
  set_has_ipc();
  if (ipc_ == NULL) ipc_ = new ::draiosproto::counter_time;
  return ipc_;
}
inline ::draiosproto::counter_time* time_categories::release_ipc() {
  clear_has_ipc();
  ::draiosproto::counter_time* temp = ipc_;
  ipc_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_ipc(::draiosproto::counter_time* ipc) {
  delete ipc_;
  ipc_ = ipc;
  if (ipc) {
    set_has_ipc();
  } else {
    clear_has_ipc();
  }
}

// optional .draiosproto.counter_time memory = 6;
inline bool time_categories::has_memory() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void time_categories::set_has_memory() {
  _has_bits_[0] |= 0x00000020u;
}
inline void time_categories::clear_has_memory() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void time_categories::clear_memory() {
  if (memory_ != NULL) memory_->::draiosproto::counter_time::Clear();
  clear_has_memory();
}
inline const ::draiosproto::counter_time& time_categories::memory() const {
  return memory_ != NULL ? *memory_ : *default_instance_->memory_;
}
inline ::draiosproto::counter_time* time_categories::mutable_memory() {
  set_has_memory();
  if (memory_ == NULL) memory_ = new ::draiosproto::counter_time;
  return memory_;
}
inline ::draiosproto::counter_time* time_categories::release_memory() {
  clear_has_memory();
  ::draiosproto::counter_time* temp = memory_;
  memory_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_memory(::draiosproto::counter_time* memory) {
  delete memory_;
  memory_ = memory;
  if (memory) {
    set_has_memory();
  } else {
    clear_has_memory();
  }
}

// optional .draiosproto.counter_time process = 7;
inline bool time_categories::has_process() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void time_categories::set_has_process() {
  _has_bits_[0] |= 0x00000040u;
}
inline void time_categories::clear_has_process() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void time_categories::clear_process() {
  if (process_ != NULL) process_->::draiosproto::counter_time::Clear();
  clear_has_process();
}
inline const ::draiosproto::counter_time& time_categories::process() const {
  return process_ != NULL ? *process_ : *default_instance_->process_;
}
inline ::draiosproto::counter_time* time_categories::mutable_process() {
  set_has_process();
  if (process_ == NULL) process_ = new ::draiosproto::counter_time;
  return process_;
}
inline ::draiosproto::counter_time* time_categories::release_process() {
  clear_has_process();
  ::draiosproto::counter_time* temp = process_;
  process_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_process(::draiosproto::counter_time* process) {
  delete process_;
  process_ = process;
  if (process) {
    set_has_process();
  } else {
    clear_has_process();
  }
}

// optional .draiosproto.counter_time sleep = 8;
inline bool time_categories::has_sleep() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void time_categories::set_has_sleep() {
  _has_bits_[0] |= 0x00000080u;
}
inline void time_categories::clear_has_sleep() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void time_categories::clear_sleep() {
  if (sleep_ != NULL) sleep_->::draiosproto::counter_time::Clear();
  clear_has_sleep();
}
inline const ::draiosproto::counter_time& time_categories::sleep() const {
  return sleep_ != NULL ? *sleep_ : *default_instance_->sleep_;
}
inline ::draiosproto::counter_time* time_categories::mutable_sleep() {
  set_has_sleep();
  if (sleep_ == NULL) sleep_ = new ::draiosproto::counter_time;
  return sleep_;
}
inline ::draiosproto::counter_time* time_categories::release_sleep() {
  clear_has_sleep();
  ::draiosproto::counter_time* temp = sleep_;
  sleep_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_sleep(::draiosproto::counter_time* sleep) {
  delete sleep_;
  sleep_ = sleep;
  if (sleep) {
    set_has_sleep();
  } else {
    clear_has_sleep();
  }
}

// optional .draiosproto.counter_time system = 9;
inline bool time_categories::has_system() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void time_categories::set_has_system() {
  _has_bits_[0] |= 0x00000100u;
}
inline void time_categories::clear_has_system() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void time_categories::clear_system() {
  if (system_ != NULL) system_->::draiosproto::counter_time::Clear();
  clear_has_system();
}
inline const ::draiosproto::counter_time& time_categories::system() const {
  return system_ != NULL ? *system_ : *default_instance_->system_;
}
inline ::draiosproto::counter_time* time_categories::mutable_system() {
  set_has_system();
  if (system_ == NULL) system_ = new ::draiosproto::counter_time;
  return system_;
}
inline ::draiosproto::counter_time* time_categories::release_system() {
  clear_has_system();
  ::draiosproto::counter_time* temp = system_;
  system_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_system(::draiosproto::counter_time* system) {
  delete system_;
  system_ = system;
  if (system) {
    set_has_system();
  } else {
    clear_has_system();
  }
}

// optional .draiosproto.counter_time signal = 10;
inline bool time_categories::has_signal() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void time_categories::set_has_signal() {
  _has_bits_[0] |= 0x00000200u;
}
inline void time_categories::clear_has_signal() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void time_categories::clear_signal() {
  if (signal_ != NULL) signal_->::draiosproto::counter_time::Clear();
  clear_has_signal();
}
inline const ::draiosproto::counter_time& time_categories::signal() const {
  return signal_ != NULL ? *signal_ : *default_instance_->signal_;
}
inline ::draiosproto::counter_time* time_categories::mutable_signal() {
  set_has_signal();
  if (signal_ == NULL) signal_ = new ::draiosproto::counter_time;
  return signal_;
}
inline ::draiosproto::counter_time* time_categories::release_signal() {
  clear_has_signal();
  ::draiosproto::counter_time* temp = signal_;
  signal_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_signal(::draiosproto::counter_time* signal) {
  delete signal_;
  signal_ = signal;
  if (signal) {
    set_has_signal();
  } else {
    clear_has_signal();
  }
}

// optional .draiosproto.counter_time user = 11;
inline bool time_categories::has_user() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void time_categories::set_has_user() {
  _has_bits_[0] |= 0x00000400u;
}
inline void time_categories::clear_has_user() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void time_categories::clear_user() {
  if (user_ != NULL) user_->::draiosproto::counter_time::Clear();
  clear_has_user();
}
inline const ::draiosproto::counter_time& time_categories::user() const {
  return user_ != NULL ? *user_ : *default_instance_->user_;
}
inline ::draiosproto::counter_time* time_categories::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::draiosproto::counter_time;
  return user_;
}
inline ::draiosproto::counter_time* time_categories::release_user() {
  clear_has_user();
  ::draiosproto::counter_time* temp = user_;
  user_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_user(::draiosproto::counter_time* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
}

// optional .draiosproto.counter_time time = 12;
inline bool time_categories::has_time() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void time_categories::set_has_time() {
  _has_bits_[0] |= 0x00000800u;
}
inline void time_categories::clear_has_time() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void time_categories::clear_time() {
  if (time_ != NULL) time_->::draiosproto::counter_time::Clear();
  clear_has_time();
}
inline const ::draiosproto::counter_time& time_categories::time() const {
  return time_ != NULL ? *time_ : *default_instance_->time_;
}
inline ::draiosproto::counter_time* time_categories::mutable_time() {
  set_has_time();
  if (time_ == NULL) time_ = new ::draiosproto::counter_time;
  return time_;
}
inline ::draiosproto::counter_time* time_categories::release_time() {
  clear_has_time();
  ::draiosproto::counter_time* temp = time_;
  time_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_time(::draiosproto::counter_time* time) {
  delete time_;
  time_ = time;
  if (time) {
    set_has_time();
  } else {
    clear_has_time();
  }
}

// optional .draiosproto.counter_time_bytes io_file = 13;
inline bool time_categories::has_io_file() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void time_categories::set_has_io_file() {
  _has_bits_[0] |= 0x00001000u;
}
inline void time_categories::clear_has_io_file() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void time_categories::clear_io_file() {
  if (io_file_ != NULL) io_file_->::draiosproto::counter_time_bytes::Clear();
  clear_has_io_file();
}
inline const ::draiosproto::counter_time_bytes& time_categories::io_file() const {
  return io_file_ != NULL ? *io_file_ : *default_instance_->io_file_;
}
inline ::draiosproto::counter_time_bytes* time_categories::mutable_io_file() {
  set_has_io_file();
  if (io_file_ == NULL) io_file_ = new ::draiosproto::counter_time_bytes;
  return io_file_;
}
inline ::draiosproto::counter_time_bytes* time_categories::release_io_file() {
  clear_has_io_file();
  ::draiosproto::counter_time_bytes* temp = io_file_;
  io_file_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_io_file(::draiosproto::counter_time_bytes* io_file) {
  delete io_file_;
  io_file_ = io_file;
  if (io_file) {
    set_has_io_file();
  } else {
    clear_has_io_file();
  }
}

// optional .draiosproto.counter_time_bytes io_net = 14;
inline bool time_categories::has_io_net() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void time_categories::set_has_io_net() {
  _has_bits_[0] |= 0x00002000u;
}
inline void time_categories::clear_has_io_net() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void time_categories::clear_io_net() {
  if (io_net_ != NULL) io_net_->::draiosproto::counter_time_bytes::Clear();
  clear_has_io_net();
}
inline const ::draiosproto::counter_time_bytes& time_categories::io_net() const {
  return io_net_ != NULL ? *io_net_ : *default_instance_->io_net_;
}
inline ::draiosproto::counter_time_bytes* time_categories::mutable_io_net() {
  set_has_io_net();
  if (io_net_ == NULL) io_net_ = new ::draiosproto::counter_time_bytes;
  return io_net_;
}
inline ::draiosproto::counter_time_bytes* time_categories::release_io_net() {
  clear_has_io_net();
  ::draiosproto::counter_time_bytes* temp = io_net_;
  io_net_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_io_net(::draiosproto::counter_time_bytes* io_net) {
  delete io_net_;
  io_net_ = io_net;
  if (io_net) {
    set_has_io_net();
  } else {
    clear_has_io_net();
  }
}

// optional .draiosproto.counter_time_bytes io_other = 15;
inline bool time_categories::has_io_other() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void time_categories::set_has_io_other() {
  _has_bits_[0] |= 0x00004000u;
}
inline void time_categories::clear_has_io_other() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void time_categories::clear_io_other() {
  if (io_other_ != NULL) io_other_->::draiosproto::counter_time_bytes::Clear();
  clear_has_io_other();
}
inline const ::draiosproto::counter_time_bytes& time_categories::io_other() const {
  return io_other_ != NULL ? *io_other_ : *default_instance_->io_other_;
}
inline ::draiosproto::counter_time_bytes* time_categories::mutable_io_other() {
  set_has_io_other();
  if (io_other_ == NULL) io_other_ = new ::draiosproto::counter_time_bytes;
  return io_other_;
}
inline ::draiosproto::counter_time_bytes* time_categories::release_io_other() {
  clear_has_io_other();
  ::draiosproto::counter_time_bytes* temp = io_other_;
  io_other_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_io_other(::draiosproto::counter_time_bytes* io_other) {
  delete io_other_;
  io_other_ = io_other;
  if (io_other) {
    set_has_io_other();
  } else {
    clear_has_io_other();
  }
}

// optional .draiosproto.counter_time wait = 16;
inline bool time_categories::has_wait() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void time_categories::set_has_wait() {
  _has_bits_[0] |= 0x00008000u;
}
inline void time_categories::clear_has_wait() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void time_categories::clear_wait() {
  if (wait_ != NULL) wait_->::draiosproto::counter_time::Clear();
  clear_has_wait();
}
inline const ::draiosproto::counter_time& time_categories::wait() const {
  return wait_ != NULL ? *wait_ : *default_instance_->wait_;
}
inline ::draiosproto::counter_time* time_categories::mutable_wait() {
  set_has_wait();
  if (wait_ == NULL) wait_ = new ::draiosproto::counter_time;
  return wait_;
}
inline ::draiosproto::counter_time* time_categories::release_wait() {
  clear_has_wait();
  ::draiosproto::counter_time* temp = wait_;
  wait_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_wait(::draiosproto::counter_time* wait) {
  delete wait_;
  wait_ = wait;
  if (wait) {
    set_has_wait();
  } else {
    clear_has_wait();
  }
}

// optional .draiosproto.counter_time processing = 17;
inline bool time_categories::has_processing() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void time_categories::set_has_processing() {
  _has_bits_[0] |= 0x00010000u;
}
inline void time_categories::clear_has_processing() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void time_categories::clear_processing() {
  if (processing_ != NULL) processing_->::draiosproto::counter_time::Clear();
  clear_has_processing();
}
inline const ::draiosproto::counter_time& time_categories::processing() const {
  return processing_ != NULL ? *processing_ : *default_instance_->processing_;
}
inline ::draiosproto::counter_time* time_categories::mutable_processing() {
  set_has_processing();
  if (processing_ == NULL) processing_ = new ::draiosproto::counter_time;
  return processing_;
}
inline ::draiosproto::counter_time* time_categories::release_processing() {
  clear_has_processing();
  ::draiosproto::counter_time* temp = processing_;
  processing_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_processing(::draiosproto::counter_time* processing) {
  delete processing_;
  processing_ = processing;
  if (processing) {
    set_has_processing();
  } else {
    clear_has_processing();
  }
}

// -------------------------------------------------------------------

// transaction_breakdown_categories

// optional .draiosproto.counter_time other = 2;
inline bool transaction_breakdown_categories::has_other() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void transaction_breakdown_categories::set_has_other() {
  _has_bits_[0] |= 0x00000001u;
}
inline void transaction_breakdown_categories::clear_has_other() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void transaction_breakdown_categories::clear_other() {
  if (other_ != NULL) other_->::draiosproto::counter_time::Clear();
  clear_has_other();
}
inline const ::draiosproto::counter_time& transaction_breakdown_categories::other() const {
  return other_ != NULL ? *other_ : *default_instance_->other_;
}
inline ::draiosproto::counter_time* transaction_breakdown_categories::mutable_other() {
  set_has_other();
  if (other_ == NULL) other_ = new ::draiosproto::counter_time;
  return other_;
}
inline ::draiosproto::counter_time* transaction_breakdown_categories::release_other() {
  clear_has_other();
  ::draiosproto::counter_time* temp = other_;
  other_ = NULL;
  return temp;
}
inline void transaction_breakdown_categories::set_allocated_other(::draiosproto::counter_time* other) {
  delete other_;
  other_ = other;
  if (other) {
    set_has_other();
  } else {
    clear_has_other();
  }
}

// optional .draiosproto.counter_time_bytes io_file = 13;
inline bool transaction_breakdown_categories::has_io_file() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void transaction_breakdown_categories::set_has_io_file() {
  _has_bits_[0] |= 0x00000002u;
}
inline void transaction_breakdown_categories::clear_has_io_file() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void transaction_breakdown_categories::clear_io_file() {
  if (io_file_ != NULL) io_file_->::draiosproto::counter_time_bytes::Clear();
  clear_has_io_file();
}
inline const ::draiosproto::counter_time_bytes& transaction_breakdown_categories::io_file() const {
  return io_file_ != NULL ? *io_file_ : *default_instance_->io_file_;
}
inline ::draiosproto::counter_time_bytes* transaction_breakdown_categories::mutable_io_file() {
  set_has_io_file();
  if (io_file_ == NULL) io_file_ = new ::draiosproto::counter_time_bytes;
  return io_file_;
}
inline ::draiosproto::counter_time_bytes* transaction_breakdown_categories::release_io_file() {
  clear_has_io_file();
  ::draiosproto::counter_time_bytes* temp = io_file_;
  io_file_ = NULL;
  return temp;
}
inline void transaction_breakdown_categories::set_allocated_io_file(::draiosproto::counter_time_bytes* io_file) {
  delete io_file_;
  io_file_ = io_file;
  if (io_file) {
    set_has_io_file();
  } else {
    clear_has_io_file();
  }
}

// optional .draiosproto.counter_time_bytes io_net = 14;
inline bool transaction_breakdown_categories::has_io_net() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void transaction_breakdown_categories::set_has_io_net() {
  _has_bits_[0] |= 0x00000004u;
}
inline void transaction_breakdown_categories::clear_has_io_net() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void transaction_breakdown_categories::clear_io_net() {
  if (io_net_ != NULL) io_net_->::draiosproto::counter_time_bytes::Clear();
  clear_has_io_net();
}
inline const ::draiosproto::counter_time_bytes& transaction_breakdown_categories::io_net() const {
  return io_net_ != NULL ? *io_net_ : *default_instance_->io_net_;
}
inline ::draiosproto::counter_time_bytes* transaction_breakdown_categories::mutable_io_net() {
  set_has_io_net();
  if (io_net_ == NULL) io_net_ = new ::draiosproto::counter_time_bytes;
  return io_net_;
}
inline ::draiosproto::counter_time_bytes* transaction_breakdown_categories::release_io_net() {
  clear_has_io_net();
  ::draiosproto::counter_time_bytes* temp = io_net_;
  io_net_ = NULL;
  return temp;
}
inline void transaction_breakdown_categories::set_allocated_io_net(::draiosproto::counter_time_bytes* io_net) {
  delete io_net_;
  io_net_ = io_net;
  if (io_net) {
    set_has_io_net();
  } else {
    clear_has_io_net();
  }
}

// optional .draiosproto.counter_time processing = 17;
inline bool transaction_breakdown_categories::has_processing() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void transaction_breakdown_categories::set_has_processing() {
  _has_bits_[0] |= 0x00000008u;
}
inline void transaction_breakdown_categories::clear_has_processing() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void transaction_breakdown_categories::clear_processing() {
  if (processing_ != NULL) processing_->::draiosproto::counter_time::Clear();
  clear_has_processing();
}
inline const ::draiosproto::counter_time& transaction_breakdown_categories::processing() const {
  return processing_ != NULL ? *processing_ : *default_instance_->processing_;
}
inline ::draiosproto::counter_time* transaction_breakdown_categories::mutable_processing() {
  set_has_processing();
  if (processing_ == NULL) processing_ = new ::draiosproto::counter_time;
  return processing_;
}
inline ::draiosproto::counter_time* transaction_breakdown_categories::release_processing() {
  clear_has_processing();
  ::draiosproto::counter_time* temp = processing_;
  processing_ = NULL;
  return temp;
}
inline void transaction_breakdown_categories::set_allocated_processing(::draiosproto::counter_time* processing) {
  delete processing_;
  processing_ = processing;
  if (processing) {
    set_has_processing();
  } else {
    clear_has_processing();
  }
}

// -------------------------------------------------------------------

// counter_syscall_errors

// required uint32 count = 1;
inline bool counter_syscall_errors::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void counter_syscall_errors::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void counter_syscall_errors::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void counter_syscall_errors::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 counter_syscall_errors::count() const {
  return count_;
}
inline void counter_syscall_errors::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated uint32 top_error_codes = 2;
inline int counter_syscall_errors::top_error_codes_size() const {
  return top_error_codes_.size();
}
inline void counter_syscall_errors::clear_top_error_codes() {
  top_error_codes_.Clear();
}
inline ::google::protobuf::uint32 counter_syscall_errors::top_error_codes(int index) const {
  return top_error_codes_.Get(index);
}
inline void counter_syscall_errors::set_top_error_codes(int index, ::google::protobuf::uint32 value) {
  top_error_codes_.Set(index, value);
}
inline void counter_syscall_errors::add_top_error_codes(::google::protobuf::uint32 value) {
  top_error_codes_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
counter_syscall_errors::top_error_codes() const {
  return top_error_codes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
counter_syscall_errors::mutable_top_error_codes() {
  return &top_error_codes_;
}

// optional uint32 count_file = 4;
inline bool counter_syscall_errors::has_count_file() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void counter_syscall_errors::set_has_count_file() {
  _has_bits_[0] |= 0x00000004u;
}
inline void counter_syscall_errors::clear_has_count_file() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void counter_syscall_errors::clear_count_file() {
  count_file_ = 0u;
  clear_has_count_file();
}
inline ::google::protobuf::uint32 counter_syscall_errors::count_file() const {
  return count_file_;
}
inline void counter_syscall_errors::set_count_file(::google::protobuf::uint32 value) {
  set_has_count_file();
  count_file_ = value;
}

// optional uint32 count_file_open = 5;
inline bool counter_syscall_errors::has_count_file_open() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void counter_syscall_errors::set_has_count_file_open() {
  _has_bits_[0] |= 0x00000008u;
}
inline void counter_syscall_errors::clear_has_count_file_open() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void counter_syscall_errors::clear_count_file_open() {
  count_file_open_ = 0u;
  clear_has_count_file_open();
}
inline ::google::protobuf::uint32 counter_syscall_errors::count_file_open() const {
  return count_file_open_;
}
inline void counter_syscall_errors::set_count_file_open(::google::protobuf::uint32 value) {
  set_has_count_file_open();
  count_file_open_ = value;
}

// optional uint32 count_net = 6;
inline bool counter_syscall_errors::has_count_net() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void counter_syscall_errors::set_has_count_net() {
  _has_bits_[0] |= 0x00000010u;
}
inline void counter_syscall_errors::clear_has_count_net() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void counter_syscall_errors::clear_count_net() {
  count_net_ = 0u;
  clear_has_count_net();
}
inline ::google::protobuf::uint32 counter_syscall_errors::count_net() const {
  return count_net_;
}
inline void counter_syscall_errors::set_count_net(::google::protobuf::uint32 value) {
  set_has_count_net();
  count_net_ = value;
}

// -------------------------------------------------------------------

// resource_categories

// optional uint32 capacity_score = 1;
inline bool resource_categories::has_capacity_score() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void resource_categories::set_has_capacity_score() {
  _has_bits_[0] |= 0x00000001u;
}
inline void resource_categories::clear_has_capacity_score() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void resource_categories::clear_capacity_score() {
  capacity_score_ = 0u;
  clear_has_capacity_score();
}
inline ::google::protobuf::uint32 resource_categories::capacity_score() const {
  return capacity_score_;
}
inline void resource_categories::set_capacity_score(::google::protobuf::uint32 value) {
  set_has_capacity_score();
  capacity_score_ = value;
}

// optional uint32 stolen_capacity_score = 6;
inline bool resource_categories::has_stolen_capacity_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void resource_categories::set_has_stolen_capacity_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void resource_categories::clear_has_stolen_capacity_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void resource_categories::clear_stolen_capacity_score() {
  stolen_capacity_score_ = 0u;
  clear_has_stolen_capacity_score();
}
inline ::google::protobuf::uint32 resource_categories::stolen_capacity_score() const {
  return stolen_capacity_score_;
}
inline void resource_categories::set_stolen_capacity_score(::google::protobuf::uint32 value) {
  set_has_stolen_capacity_score();
  stolen_capacity_score_ = value;
}

// optional uint32 connection_queue_usage_pct = 2;
inline bool resource_categories::has_connection_queue_usage_pct() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void resource_categories::set_has_connection_queue_usage_pct() {
  _has_bits_[0] |= 0x00000004u;
}
inline void resource_categories::clear_has_connection_queue_usage_pct() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void resource_categories::clear_connection_queue_usage_pct() {
  connection_queue_usage_pct_ = 0u;
  clear_has_connection_queue_usage_pct();
}
inline ::google::protobuf::uint32 resource_categories::connection_queue_usage_pct() const {
  return connection_queue_usage_pct_;
}
inline void resource_categories::set_connection_queue_usage_pct(::google::protobuf::uint32 value) {
  set_has_connection_queue_usage_pct();
  connection_queue_usage_pct_ = value;
}

// optional uint32 fd_usage_pct = 3;
inline bool resource_categories::has_fd_usage_pct() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void resource_categories::set_has_fd_usage_pct() {
  _has_bits_[0] |= 0x00000008u;
}
inline void resource_categories::clear_has_fd_usage_pct() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void resource_categories::clear_fd_usage_pct() {
  fd_usage_pct_ = 0u;
  clear_has_fd_usage_pct();
}
inline ::google::protobuf::uint32 resource_categories::fd_usage_pct() const {
  return fd_usage_pct_;
}
inline void resource_categories::set_fd_usage_pct(::google::protobuf::uint32 value) {
  set_has_fd_usage_pct();
  fd_usage_pct_ = value;
}

// optional uint32 cpu_pct = 4;
inline bool resource_categories::has_cpu_pct() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void resource_categories::set_has_cpu_pct() {
  _has_bits_[0] |= 0x00000010u;
}
inline void resource_categories::clear_has_cpu_pct() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void resource_categories::clear_cpu_pct() {
  cpu_pct_ = 0u;
  clear_has_cpu_pct();
}
inline ::google::protobuf::uint32 resource_categories::cpu_pct() const {
  return cpu_pct_;
}
inline void resource_categories::set_cpu_pct(::google::protobuf::uint32 value) {
  set_has_cpu_pct();
  cpu_pct_ = value;
}

// optional uint32 resident_memory_usage_kb = 5;
inline bool resource_categories::has_resident_memory_usage_kb() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void resource_categories::set_has_resident_memory_usage_kb() {
  _has_bits_[0] |= 0x00000020u;
}
inline void resource_categories::clear_has_resident_memory_usage_kb() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void resource_categories::clear_resident_memory_usage_kb() {
  resident_memory_usage_kb_ = 0u;
  clear_has_resident_memory_usage_kb();
}
inline ::google::protobuf::uint32 resource_categories::resident_memory_usage_kb() const {
  return resident_memory_usage_kb_;
}
inline void resource_categories::set_resident_memory_usage_kb(::google::protobuf::uint32 value) {
  set_has_resident_memory_usage_kb();
  resident_memory_usage_kb_ = value;
}

// optional uint32 virtual_memory_usage_kb = 13;
inline bool resource_categories::has_virtual_memory_usage_kb() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void resource_categories::set_has_virtual_memory_usage_kb() {
  _has_bits_[0] |= 0x00000040u;
}
inline void resource_categories::clear_has_virtual_memory_usage_kb() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void resource_categories::clear_virtual_memory_usage_kb() {
  virtual_memory_usage_kb_ = 0u;
  clear_has_virtual_memory_usage_kb();
}
inline ::google::protobuf::uint32 resource_categories::virtual_memory_usage_kb() const {
  return virtual_memory_usage_kb_;
}
inline void resource_categories::set_virtual_memory_usage_kb(::google::protobuf::uint32 value) {
  set_has_virtual_memory_usage_kb();
  virtual_memory_usage_kb_ = value;
}

// optional uint32 swap_memory_usage_kb = 14;
inline bool resource_categories::has_swap_memory_usage_kb() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void resource_categories::set_has_swap_memory_usage_kb() {
  _has_bits_[0] |= 0x00000080u;
}
inline void resource_categories::clear_has_swap_memory_usage_kb() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void resource_categories::clear_swap_memory_usage_kb() {
  swap_memory_usage_kb_ = 0u;
  clear_has_swap_memory_usage_kb();
}
inline ::google::protobuf::uint32 resource_categories::swap_memory_usage_kb() const {
  return swap_memory_usage_kb_;
}
inline void resource_categories::set_swap_memory_usage_kb(::google::protobuf::uint32 value) {
  set_has_swap_memory_usage_kb();
  swap_memory_usage_kb_ = value;
}

// optional uint64 major_pagefaults = 15;
inline bool resource_categories::has_major_pagefaults() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void resource_categories::set_has_major_pagefaults() {
  _has_bits_[0] |= 0x00000100u;
}
inline void resource_categories::clear_has_major_pagefaults() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void resource_categories::clear_major_pagefaults() {
  major_pagefaults_ = GOOGLE_ULONGLONG(0);
  clear_has_major_pagefaults();
}
inline ::google::protobuf::uint64 resource_categories::major_pagefaults() const {
  return major_pagefaults_;
}
inline void resource_categories::set_major_pagefaults(::google::protobuf::uint64 value) {
  set_has_major_pagefaults();
  major_pagefaults_ = value;
}

// optional uint64 minor_pagefaults = 16;
inline bool resource_categories::has_minor_pagefaults() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void resource_categories::set_has_minor_pagefaults() {
  _has_bits_[0] |= 0x00000200u;
}
inline void resource_categories::clear_has_minor_pagefaults() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void resource_categories::clear_minor_pagefaults() {
  minor_pagefaults_ = GOOGLE_ULONGLONG(0);
  clear_has_minor_pagefaults();
}
inline ::google::protobuf::uint64 resource_categories::minor_pagefaults() const {
  return minor_pagefaults_;
}
inline void resource_categories::set_minor_pagefaults(::google::protobuf::uint64 value) {
  set_has_minor_pagefaults();
  minor_pagefaults_ = value;
}

// optional uint32 fd_count = 21;
inline bool resource_categories::has_fd_count() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void resource_categories::set_has_fd_count() {
  _has_bits_[0] |= 0x00000400u;
}
inline void resource_categories::clear_has_fd_count() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void resource_categories::clear_fd_count() {
  fd_count_ = 0u;
  clear_has_fd_count();
}
inline ::google::protobuf::uint32 resource_categories::fd_count() const {
  return fd_count_;
}
inline void resource_categories::set_fd_count(::google::protobuf::uint32 value) {
  set_has_fd_count();
  fd_count_ = value;
}

// optional uint32 cpu_limit_pct = 23;
inline bool resource_categories::has_cpu_limit_pct() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void resource_categories::set_has_cpu_limit_pct() {
  _has_bits_[0] |= 0x00000800u;
}
inline void resource_categories::clear_has_cpu_limit_pct() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void resource_categories::clear_cpu_limit_pct() {
  cpu_limit_pct_ = 0u;
  clear_has_cpu_limit_pct();
}
inline ::google::protobuf::uint32 resource_categories::cpu_limit_pct() const {
  return cpu_limit_pct_;
}
inline void resource_categories::set_cpu_limit_pct(::google::protobuf::uint32 value) {
  set_has_cpu_limit_pct();
  cpu_limit_pct_ = value;
}

// optional uint32 memory_limit_kb = 24;
inline bool resource_categories::has_memory_limit_kb() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void resource_categories::set_has_memory_limit_kb() {
  _has_bits_[0] |= 0x00001000u;
}
inline void resource_categories::clear_has_memory_limit_kb() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void resource_categories::clear_memory_limit_kb() {
  memory_limit_kb_ = 0u;
  clear_has_memory_limit_kb();
}
inline ::google::protobuf::uint32 resource_categories::memory_limit_kb() const {
  return memory_limit_kb_;
}
inline void resource_categories::set_memory_limit_kb(::google::protobuf::uint32 value) {
  set_has_memory_limit_kb();
  memory_limit_kb_ = value;
}

// optional uint32 swap_limit_kb = 25;
inline bool resource_categories::has_swap_limit_kb() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void resource_categories::set_has_swap_limit_kb() {
  _has_bits_[0] |= 0x00002000u;
}
inline void resource_categories::clear_has_swap_limit_kb() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void resource_categories::clear_swap_limit_kb() {
  swap_limit_kb_ = 0u;
  clear_has_swap_limit_kb();
}
inline ::google::protobuf::uint32 resource_categories::swap_limit_kb() const {
  return swap_limit_kb_;
}
inline void resource_categories::set_swap_limit_kb(::google::protobuf::uint32 value) {
  set_has_swap_limit_kb();
  swap_limit_kb_ = value;
}

// -------------------------------------------------------------------

// connection_categories

// optional .draiosproto.counter_bytes server = 1;
inline bool connection_categories::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void connection_categories::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void connection_categories::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void connection_categories::clear_server() {
  if (server_ != NULL) server_->::draiosproto::counter_bytes::Clear();
  clear_has_server();
}
inline const ::draiosproto::counter_bytes& connection_categories::server() const {
  return server_ != NULL ? *server_ : *default_instance_->server_;
}
inline ::draiosproto::counter_bytes* connection_categories::mutable_server() {
  set_has_server();
  if (server_ == NULL) server_ = new ::draiosproto::counter_bytes;
  return server_;
}
inline ::draiosproto::counter_bytes* connection_categories::release_server() {
  clear_has_server();
  ::draiosproto::counter_bytes* temp = server_;
  server_ = NULL;
  return temp;
}
inline void connection_categories::set_allocated_server(::draiosproto::counter_bytes* server) {
  delete server_;
  server_ = server;
  if (server) {
    set_has_server();
  } else {
    clear_has_server();
  }
}

// optional .draiosproto.counter_bytes client = 2;
inline bool connection_categories::has_client() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void connection_categories::set_has_client() {
  _has_bits_[0] |= 0x00000002u;
}
inline void connection_categories::clear_has_client() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void connection_categories::clear_client() {
  if (client_ != NULL) client_->::draiosproto::counter_bytes::Clear();
  clear_has_client();
}
inline const ::draiosproto::counter_bytes& connection_categories::client() const {
  return client_ != NULL ? *client_ : *default_instance_->client_;
}
inline ::draiosproto::counter_bytes* connection_categories::mutable_client() {
  set_has_client();
  if (client_ == NULL) client_ = new ::draiosproto::counter_bytes;
  return client_;
}
inline ::draiosproto::counter_bytes* connection_categories::release_client() {
  clear_has_client();
  ::draiosproto::counter_bytes* temp = client_;
  client_ = NULL;
  return temp;
}
inline void connection_categories::set_allocated_client(::draiosproto::counter_bytes* client) {
  delete client_;
  client_ = client;
  if (client) {
    set_has_client();
  } else {
    clear_has_client();
  }
}

// optional .draiosproto.counter_time_bidirectional transaction_counters = 3;
inline bool connection_categories::has_transaction_counters() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void connection_categories::set_has_transaction_counters() {
  _has_bits_[0] |= 0x00000004u;
}
inline void connection_categories::clear_has_transaction_counters() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void connection_categories::clear_transaction_counters() {
  if (transaction_counters_ != NULL) transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& connection_categories::transaction_counters() const {
  return transaction_counters_ != NULL ? *transaction_counters_ : *default_instance_->transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* connection_categories::mutable_transaction_counters() {
  set_has_transaction_counters();
  if (transaction_counters_ == NULL) transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  return transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* connection_categories::release_transaction_counters() {
  clear_has_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = transaction_counters_;
  transaction_counters_ = NULL;
  return temp;
}
inline void connection_categories::set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters) {
  delete transaction_counters_;
  transaction_counters_ = transaction_counters;
  if (transaction_counters) {
    set_has_transaction_counters();
  } else {
    clear_has_transaction_counters();
  }
}

// optional .draiosproto.counter_time_bidirectional min_transaction_counters = 18;
inline bool connection_categories::has_min_transaction_counters() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void connection_categories::set_has_min_transaction_counters() {
  _has_bits_[0] |= 0x00000008u;
}
inline void connection_categories::clear_has_min_transaction_counters() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void connection_categories::clear_min_transaction_counters() {
  if (min_transaction_counters_ != NULL) min_transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_min_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& connection_categories::min_transaction_counters() const {
  return min_transaction_counters_ != NULL ? *min_transaction_counters_ : *default_instance_->min_transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* connection_categories::mutable_min_transaction_counters() {
  set_has_min_transaction_counters();
  if (min_transaction_counters_ == NULL) min_transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  return min_transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* connection_categories::release_min_transaction_counters() {
  clear_has_min_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = min_transaction_counters_;
  min_transaction_counters_ = NULL;
  return temp;
}
inline void connection_categories::set_allocated_min_transaction_counters(::draiosproto::counter_time_bidirectional* min_transaction_counters) {
  delete min_transaction_counters_;
  min_transaction_counters_ = min_transaction_counters;
  if (min_transaction_counters) {
    set_has_min_transaction_counters();
  } else {
    clear_has_min_transaction_counters();
  }
}

// optional .draiosproto.counter_time_bidirectional max_transaction_counters = 19;
inline bool connection_categories::has_max_transaction_counters() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void connection_categories::set_has_max_transaction_counters() {
  _has_bits_[0] |= 0x00000010u;
}
inline void connection_categories::clear_has_max_transaction_counters() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void connection_categories::clear_max_transaction_counters() {
  if (max_transaction_counters_ != NULL) max_transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_max_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& connection_categories::max_transaction_counters() const {
  return max_transaction_counters_ != NULL ? *max_transaction_counters_ : *default_instance_->max_transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* connection_categories::mutable_max_transaction_counters() {
  set_has_max_transaction_counters();
  if (max_transaction_counters_ == NULL) max_transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  return max_transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* connection_categories::release_max_transaction_counters() {
  clear_has_max_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = max_transaction_counters_;
  max_transaction_counters_ = NULL;
  return temp;
}
inline void connection_categories::set_allocated_max_transaction_counters(::draiosproto::counter_time_bidirectional* max_transaction_counters) {
  delete max_transaction_counters_;
  max_transaction_counters_ = max_transaction_counters;
  if (max_transaction_counters) {
    set_has_max_transaction_counters();
  } else {
    clear_has_max_transaction_counters();
  }
}

// optional uint32 n_aggregated_connections = 4;
inline bool connection_categories::has_n_aggregated_connections() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void connection_categories::set_has_n_aggregated_connections() {
  _has_bits_[0] |= 0x00000020u;
}
inline void connection_categories::clear_has_n_aggregated_connections() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void connection_categories::clear_n_aggregated_connections() {
  n_aggregated_connections_ = 0u;
  clear_has_n_aggregated_connections();
}
inline ::google::protobuf::uint32 connection_categories::n_aggregated_connections() const {
  return n_aggregated_connections_;
}
inline void connection_categories::set_n_aggregated_connections(::google::protobuf::uint32 value) {
  set_has_n_aggregated_connections();
  n_aggregated_connections_ = value;
}

// -------------------------------------------------------------------

// process_details

// required string comm = 1;
inline bool process_details::has_comm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void process_details::set_has_comm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void process_details::clear_has_comm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void process_details::clear_comm() {
  if (comm_ != &::google::protobuf::internal::kEmptyString) {
    comm_->clear();
  }
  clear_has_comm();
}
inline const ::std::string& process_details::comm() const {
  return *comm_;
}
inline void process_details::set_comm(const ::std::string& value) {
  set_has_comm();
  if (comm_ == &::google::protobuf::internal::kEmptyString) {
    comm_ = new ::std::string;
  }
  comm_->assign(value);
}
inline void process_details::set_comm(const char* value) {
  set_has_comm();
  if (comm_ == &::google::protobuf::internal::kEmptyString) {
    comm_ = new ::std::string;
  }
  comm_->assign(value);
}
inline void process_details::set_comm(const char* value, size_t size) {
  set_has_comm();
  if (comm_ == &::google::protobuf::internal::kEmptyString) {
    comm_ = new ::std::string;
  }
  comm_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* process_details::mutable_comm() {
  set_has_comm();
  if (comm_ == &::google::protobuf::internal::kEmptyString) {
    comm_ = new ::std::string;
  }
  return comm_;
}
inline ::std::string* process_details::release_comm() {
  clear_has_comm();
  if (comm_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comm_;
    comm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void process_details::set_allocated_comm(::std::string* comm) {
  if (comm_ != &::google::protobuf::internal::kEmptyString) {
    delete comm_;
  }
  if (comm) {
    set_has_comm();
    comm_ = comm;
  } else {
    clear_has_comm();
    comm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string exe = 2;
inline bool process_details::has_exe() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void process_details::set_has_exe() {
  _has_bits_[0] |= 0x00000002u;
}
inline void process_details::clear_has_exe() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void process_details::clear_exe() {
  if (exe_ != &::google::protobuf::internal::kEmptyString) {
    exe_->clear();
  }
  clear_has_exe();
}
inline const ::std::string& process_details::exe() const {
  return *exe_;
}
inline void process_details::set_exe(const ::std::string& value) {
  set_has_exe();
  if (exe_ == &::google::protobuf::internal::kEmptyString) {
    exe_ = new ::std::string;
  }
  exe_->assign(value);
}
inline void process_details::set_exe(const char* value) {
  set_has_exe();
  if (exe_ == &::google::protobuf::internal::kEmptyString) {
    exe_ = new ::std::string;
  }
  exe_->assign(value);
}
inline void process_details::set_exe(const char* value, size_t size) {
  set_has_exe();
  if (exe_ == &::google::protobuf::internal::kEmptyString) {
    exe_ = new ::std::string;
  }
  exe_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* process_details::mutable_exe() {
  set_has_exe();
  if (exe_ == &::google::protobuf::internal::kEmptyString) {
    exe_ = new ::std::string;
  }
  return exe_;
}
inline ::std::string* process_details::release_exe() {
  clear_has_exe();
  if (exe_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exe_;
    exe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void process_details::set_allocated_exe(::std::string* exe) {
  if (exe_ != &::google::protobuf::internal::kEmptyString) {
    delete exe_;
  }
  if (exe) {
    set_has_exe();
    exe_ = exe;
  } else {
    clear_has_exe();
    exe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string args = 3;
inline int process_details::args_size() const {
  return args_.size();
}
inline void process_details::clear_args() {
  args_.Clear();
}
inline const ::std::string& process_details::args(int index) const {
  return args_.Get(index);
}
inline ::std::string* process_details::mutable_args(int index) {
  return args_.Mutable(index);
}
inline void process_details::set_args(int index, const ::std::string& value) {
  args_.Mutable(index)->assign(value);
}
inline void process_details::set_args(int index, const char* value) {
  args_.Mutable(index)->assign(value);
}
inline void process_details::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* process_details::add_args() {
  return args_.Add();
}
inline void process_details::add_args(const ::std::string& value) {
  args_.Add()->assign(value);
}
inline void process_details::add_args(const char* value) {
  args_.Add()->assign(value);
}
inline void process_details::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
process_details::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
process_details::mutable_args() {
  return &args_;
}

// optional string container_id = 4;
inline bool process_details::has_container_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void process_details::set_has_container_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void process_details::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void process_details::clear_container_id() {
  if (container_id_ != &::google::protobuf::internal::kEmptyString) {
    container_id_->clear();
  }
  clear_has_container_id();
}
inline const ::std::string& process_details::container_id() const {
  return *container_id_;
}
inline void process_details::set_container_id(const ::std::string& value) {
  set_has_container_id();
  if (container_id_ == &::google::protobuf::internal::kEmptyString) {
    container_id_ = new ::std::string;
  }
  container_id_->assign(value);
}
inline void process_details::set_container_id(const char* value) {
  set_has_container_id();
  if (container_id_ == &::google::protobuf::internal::kEmptyString) {
    container_id_ = new ::std::string;
  }
  container_id_->assign(value);
}
inline void process_details::set_container_id(const char* value, size_t size) {
  set_has_container_id();
  if (container_id_ == &::google::protobuf::internal::kEmptyString) {
    container_id_ = new ::std::string;
  }
  container_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* process_details::mutable_container_id() {
  set_has_container_id();
  if (container_id_ == &::google::protobuf::internal::kEmptyString) {
    container_id_ = new ::std::string;
  }
  return container_id_;
}
inline ::std::string* process_details::release_container_id() {
  clear_has_container_id();
  if (container_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = container_id_;
    container_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void process_details::set_allocated_container_id(::std::string* container_id) {
  if (container_id_ != &::google::protobuf::internal::kEmptyString) {
    delete container_id_;
  }
  if (container_id) {
    set_has_container_id();
    container_id_ = container_id;
  } else {
    clear_has_container_id();
    container_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// command_details

// required uint64 timestamp = 1;
inline bool command_details::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void command_details::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void command_details::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void command_details::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 command_details::timestamp() const {
  return timestamp_;
}
inline void command_details::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// required uint32 count = 2;
inline bool command_details::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void command_details::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void command_details::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void command_details::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 command_details::count() const {
  return count_;
}
inline void command_details::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// required string cmdline = 3;
inline bool command_details::has_cmdline() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void command_details::set_has_cmdline() {
  _has_bits_[0] |= 0x00000004u;
}
inline void command_details::clear_has_cmdline() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void command_details::clear_cmdline() {
  if (cmdline_ != &::google::protobuf::internal::kEmptyString) {
    cmdline_->clear();
  }
  clear_has_cmdline();
}
inline const ::std::string& command_details::cmdline() const {
  return *cmdline_;
}
inline void command_details::set_cmdline(const ::std::string& value) {
  set_has_cmdline();
  if (cmdline_ == &::google::protobuf::internal::kEmptyString) {
    cmdline_ = new ::std::string;
  }
  cmdline_->assign(value);
}
inline void command_details::set_cmdline(const char* value) {
  set_has_cmdline();
  if (cmdline_ == &::google::protobuf::internal::kEmptyString) {
    cmdline_ = new ::std::string;
  }
  cmdline_->assign(value);
}
inline void command_details::set_cmdline(const char* value, size_t size) {
  set_has_cmdline();
  if (cmdline_ == &::google::protobuf::internal::kEmptyString) {
    cmdline_ = new ::std::string;
  }
  cmdline_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* command_details::mutable_cmdline() {
  set_has_cmdline();
  if (cmdline_ == &::google::protobuf::internal::kEmptyString) {
    cmdline_ = new ::std::string;
  }
  return cmdline_;
}
inline ::std::string* command_details::release_cmdline() {
  clear_has_cmdline();
  if (cmdline_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmdline_;
    cmdline_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void command_details::set_allocated_cmdline(::std::string* cmdline) {
  if (cmdline_ != &::google::protobuf::internal::kEmptyString) {
    delete cmdline_;
  }
  if (cmdline) {
    set_has_cmdline();
    cmdline_ = cmdline;
  } else {
    clear_has_cmdline();
    cmdline_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string exe = 4;
inline bool command_details::has_exe() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void command_details::set_has_exe() {
  _has_bits_[0] |= 0x00000008u;
}
inline void command_details::clear_has_exe() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void command_details::clear_exe() {
  if (exe_ != &::google::protobuf::internal::kEmptyString) {
    exe_->clear();
  }
  clear_has_exe();
}
inline const ::std::string& command_details::exe() const {
  return *exe_;
}
inline void command_details::set_exe(const ::std::string& value) {
  set_has_exe();
  if (exe_ == &::google::protobuf::internal::kEmptyString) {
    exe_ = new ::std::string;
  }
  exe_->assign(value);
}
inline void command_details::set_exe(const char* value) {
  set_has_exe();
  if (exe_ == &::google::protobuf::internal::kEmptyString) {
    exe_ = new ::std::string;
  }
  exe_->assign(value);
}
inline void command_details::set_exe(const char* value, size_t size) {
  set_has_exe();
  if (exe_ == &::google::protobuf::internal::kEmptyString) {
    exe_ = new ::std::string;
  }
  exe_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* command_details::mutable_exe() {
  set_has_exe();
  if (exe_ == &::google::protobuf::internal::kEmptyString) {
    exe_ = new ::std::string;
  }
  return exe_;
}
inline ::std::string* command_details::release_exe() {
  clear_has_exe();
  if (exe_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exe_;
    exe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void command_details::set_allocated_exe(::std::string* exe) {
  if (exe_ != &::google::protobuf::internal::kEmptyString) {
    delete exe_;
  }
  if (exe) {
    set_has_exe();
    exe_ = exe;
  } else {
    clear_has_exe();
    exe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string parentcomm = 5;
inline bool command_details::has_parentcomm() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void command_details::set_has_parentcomm() {
  _has_bits_[0] |= 0x00000010u;
}
inline void command_details::clear_has_parentcomm() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void command_details::clear_parentcomm() {
  if (parentcomm_ != &::google::protobuf::internal::kEmptyString) {
    parentcomm_->clear();
  }
  clear_has_parentcomm();
}
inline const ::std::string& command_details::parentcomm() const {
  return *parentcomm_;
}
inline void command_details::set_parentcomm(const ::std::string& value) {
  set_has_parentcomm();
  if (parentcomm_ == &::google::protobuf::internal::kEmptyString) {
    parentcomm_ = new ::std::string;
  }
  parentcomm_->assign(value);
}
inline void command_details::set_parentcomm(const char* value) {
  set_has_parentcomm();
  if (parentcomm_ == &::google::protobuf::internal::kEmptyString) {
    parentcomm_ = new ::std::string;
  }
  parentcomm_->assign(value);
}
inline void command_details::set_parentcomm(const char* value, size_t size) {
  set_has_parentcomm();
  if (parentcomm_ == &::google::protobuf::internal::kEmptyString) {
    parentcomm_ = new ::std::string;
  }
  parentcomm_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* command_details::mutable_parentcomm() {
  set_has_parentcomm();
  if (parentcomm_ == &::google::protobuf::internal::kEmptyString) {
    parentcomm_ = new ::std::string;
  }
  return parentcomm_;
}
inline ::std::string* command_details::release_parentcomm() {
  clear_has_parentcomm();
  if (parentcomm_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parentcomm_;
    parentcomm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void command_details::set_allocated_parentcomm(::std::string* parentcomm) {
  if (parentcomm_ != &::google::protobuf::internal::kEmptyString) {
    delete parentcomm_;
  }
  if (parentcomm) {
    set_has_parentcomm();
    parentcomm_ = parentcomm;
  } else {
    clear_has_parentcomm();
    parentcomm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// counter_proto_entry

// required uint32 ncalls = 1;
inline bool counter_proto_entry::has_ncalls() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void counter_proto_entry::set_has_ncalls() {
  _has_bits_[0] |= 0x00000001u;
}
inline void counter_proto_entry::clear_has_ncalls() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void counter_proto_entry::clear_ncalls() {
  ncalls_ = 0u;
  clear_has_ncalls();
}
inline ::google::protobuf::uint32 counter_proto_entry::ncalls() const {
  return ncalls_;
}
inline void counter_proto_entry::set_ncalls(::google::protobuf::uint32 value) {
  set_has_ncalls();
  ncalls_ = value;
}

// required uint64 time_tot = 2;
inline bool counter_proto_entry::has_time_tot() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void counter_proto_entry::set_has_time_tot() {
  _has_bits_[0] |= 0x00000002u;
}
inline void counter_proto_entry::clear_has_time_tot() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void counter_proto_entry::clear_time_tot() {
  time_tot_ = GOOGLE_ULONGLONG(0);
  clear_has_time_tot();
}
inline ::google::protobuf::uint64 counter_proto_entry::time_tot() const {
  return time_tot_;
}
inline void counter_proto_entry::set_time_tot(::google::protobuf::uint64 value) {
  set_has_time_tot();
  time_tot_ = value;
}

// required uint64 time_max = 3;
inline bool counter_proto_entry::has_time_max() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void counter_proto_entry::set_has_time_max() {
  _has_bits_[0] |= 0x00000004u;
}
inline void counter_proto_entry::clear_has_time_max() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void counter_proto_entry::clear_time_max() {
  time_max_ = GOOGLE_ULONGLONG(0);
  clear_has_time_max();
}
inline ::google::protobuf::uint64 counter_proto_entry::time_max() const {
  return time_max_;
}
inline void counter_proto_entry::set_time_max(::google::protobuf::uint64 value) {
  set_has_time_max();
  time_max_ = value;
}

// required uint64 bytes_in = 4;
inline bool counter_proto_entry::has_bytes_in() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void counter_proto_entry::set_has_bytes_in() {
  _has_bits_[0] |= 0x00000008u;
}
inline void counter_proto_entry::clear_has_bytes_in() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void counter_proto_entry::clear_bytes_in() {
  bytes_in_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_in();
}
inline ::google::protobuf::uint64 counter_proto_entry::bytes_in() const {
  return bytes_in_;
}
inline void counter_proto_entry::set_bytes_in(::google::protobuf::uint64 value) {
  set_has_bytes_in();
  bytes_in_ = value;
}

// required uint64 bytes_out = 5;
inline bool counter_proto_entry::has_bytes_out() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void counter_proto_entry::set_has_bytes_out() {
  _has_bits_[0] |= 0x00000010u;
}
inline void counter_proto_entry::clear_has_bytes_out() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void counter_proto_entry::clear_bytes_out() {
  bytes_out_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_out();
}
inline ::google::protobuf::uint64 counter_proto_entry::bytes_out() const {
  return bytes_out_;
}
inline void counter_proto_entry::set_bytes_out(::google::protobuf::uint64 value) {
  set_has_bytes_out();
  bytes_out_ = value;
}

// required uint32 nerrors = 6;
inline bool counter_proto_entry::has_nerrors() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void counter_proto_entry::set_has_nerrors() {
  _has_bits_[0] |= 0x00000020u;
}
inline void counter_proto_entry::clear_has_nerrors() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void counter_proto_entry::clear_nerrors() {
  nerrors_ = 0u;
  clear_has_nerrors();
}
inline ::google::protobuf::uint32 counter_proto_entry::nerrors() const {
  return nerrors_;
}
inline void counter_proto_entry::set_nerrors(::google::protobuf::uint32 value) {
  set_has_nerrors();
  nerrors_ = value;
}

// -------------------------------------------------------------------

// url_details

// required string url = 1;
inline bool url_details::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void url_details::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void url_details::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void url_details::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& url_details::url() const {
  return *url_;
}
inline void url_details::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void url_details::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void url_details::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* url_details::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* url_details::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void url_details::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .draiosproto.counter_proto_entry counters = 2;
inline bool url_details::has_counters() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void url_details::set_has_counters() {
  _has_bits_[0] |= 0x00000002u;
}
inline void url_details::clear_has_counters() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void url_details::clear_counters() {
  if (counters_ != NULL) counters_->::draiosproto::counter_proto_entry::Clear();
  clear_has_counters();
}
inline const ::draiosproto::counter_proto_entry& url_details::counters() const {
  return counters_ != NULL ? *counters_ : *default_instance_->counters_;
}
inline ::draiosproto::counter_proto_entry* url_details::mutable_counters() {
  set_has_counters();
  if (counters_ == NULL) counters_ = new ::draiosproto::counter_proto_entry;
  return counters_;
}
inline ::draiosproto::counter_proto_entry* url_details::release_counters() {
  clear_has_counters();
  ::draiosproto::counter_proto_entry* temp = counters_;
  counters_ = NULL;
  return temp;
}
inline void url_details::set_allocated_counters(::draiosproto::counter_proto_entry* counters) {
  delete counters_;
  counters_ = counters;
  if (counters) {
    set_has_counters();
  } else {
    clear_has_counters();
  }
}

// -------------------------------------------------------------------

// status_code_details

// required uint32 status_code = 1;
inline bool status_code_details::has_status_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void status_code_details::set_has_status_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void status_code_details::clear_has_status_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void status_code_details::clear_status_code() {
  status_code_ = 0u;
  clear_has_status_code();
}
inline ::google::protobuf::uint32 status_code_details::status_code() const {
  return status_code_;
}
inline void status_code_details::set_status_code(::google::protobuf::uint32 value) {
  set_has_status_code();
  status_code_ = value;
}

// required uint32 ncalls = 2;
inline bool status_code_details::has_ncalls() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void status_code_details::set_has_ncalls() {
  _has_bits_[0] |= 0x00000002u;
}
inline void status_code_details::clear_has_ncalls() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void status_code_details::clear_ncalls() {
  ncalls_ = 0u;
  clear_has_ncalls();
}
inline ::google::protobuf::uint32 status_code_details::ncalls() const {
  return ncalls_;
}
inline void status_code_details::set_ncalls(::google::protobuf::uint32 value) {
  set_has_ncalls();
  ncalls_ = value;
}

// -------------------------------------------------------------------

// http_info

// repeated .draiosproto.url_details server_urls = 1;
inline int http_info::server_urls_size() const {
  return server_urls_.size();
}
inline void http_info::clear_server_urls() {
  server_urls_.Clear();
}
inline const ::draiosproto::url_details& http_info::server_urls(int index) const {
  return server_urls_.Get(index);
}
inline ::draiosproto::url_details* http_info::mutable_server_urls(int index) {
  return server_urls_.Mutable(index);
}
inline ::draiosproto::url_details* http_info::add_server_urls() {
  return server_urls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::url_details >&
http_info::server_urls() const {
  return server_urls_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::url_details >*
http_info::mutable_server_urls() {
  return &server_urls_;
}

// repeated .draiosproto.url_details client_urls = 2;
inline int http_info::client_urls_size() const {
  return client_urls_.size();
}
inline void http_info::clear_client_urls() {
  client_urls_.Clear();
}
inline const ::draiosproto::url_details& http_info::client_urls(int index) const {
  return client_urls_.Get(index);
}
inline ::draiosproto::url_details* http_info::mutable_client_urls(int index) {
  return client_urls_.Mutable(index);
}
inline ::draiosproto::url_details* http_info::add_client_urls() {
  return client_urls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::url_details >&
http_info::client_urls() const {
  return client_urls_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::url_details >*
http_info::mutable_client_urls() {
  return &client_urls_;
}

// repeated .draiosproto.status_code_details client_status_codes = 3;
inline int http_info::client_status_codes_size() const {
  return client_status_codes_.size();
}
inline void http_info::clear_client_status_codes() {
  client_status_codes_.Clear();
}
inline const ::draiosproto::status_code_details& http_info::client_status_codes(int index) const {
  return client_status_codes_.Get(index);
}
inline ::draiosproto::status_code_details* http_info::mutable_client_status_codes(int index) {
  return client_status_codes_.Mutable(index);
}
inline ::draiosproto::status_code_details* http_info::add_client_status_codes() {
  return client_status_codes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::status_code_details >&
http_info::client_status_codes() const {
  return client_status_codes_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::status_code_details >*
http_info::mutable_client_status_codes() {
  return &client_status_codes_;
}

// repeated .draiosproto.status_code_details server_status_codes = 4;
inline int http_info::server_status_codes_size() const {
  return server_status_codes_.size();
}
inline void http_info::clear_server_status_codes() {
  server_status_codes_.Clear();
}
inline const ::draiosproto::status_code_details& http_info::server_status_codes(int index) const {
  return server_status_codes_.Get(index);
}
inline ::draiosproto::status_code_details* http_info::mutable_server_status_codes(int index) {
  return server_status_codes_.Mutable(index);
}
inline ::draiosproto::status_code_details* http_info::add_server_status_codes() {
  return server_status_codes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::status_code_details >&
http_info::server_status_codes() const {
  return server_status_codes_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::status_code_details >*
http_info::mutable_server_status_codes() {
  return &server_status_codes_;
}

// -------------------------------------------------------------------

// sql_entry_details

// required string name = 1;
inline bool sql_entry_details::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sql_entry_details::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sql_entry_details::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sql_entry_details::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& sql_entry_details::name() const {
  return *name_;
}
inline void sql_entry_details::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void sql_entry_details::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void sql_entry_details::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* sql_entry_details::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* sql_entry_details::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void sql_entry_details::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .draiosproto.counter_proto_entry counters = 2;
inline bool sql_entry_details::has_counters() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sql_entry_details::set_has_counters() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sql_entry_details::clear_has_counters() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sql_entry_details::clear_counters() {
  if (counters_ != NULL) counters_->::draiosproto::counter_proto_entry::Clear();
  clear_has_counters();
}
inline const ::draiosproto::counter_proto_entry& sql_entry_details::counters() const {
  return counters_ != NULL ? *counters_ : *default_instance_->counters_;
}
inline ::draiosproto::counter_proto_entry* sql_entry_details::mutable_counters() {
  set_has_counters();
  if (counters_ == NULL) counters_ = new ::draiosproto::counter_proto_entry;
  return counters_;
}
inline ::draiosproto::counter_proto_entry* sql_entry_details::release_counters() {
  clear_has_counters();
  ::draiosproto::counter_proto_entry* temp = counters_;
  counters_ = NULL;
  return temp;
}
inline void sql_entry_details::set_allocated_counters(::draiosproto::counter_proto_entry* counters) {
  delete counters_;
  counters_ = counters;
  if (counters) {
    set_has_counters();
  } else {
    clear_has_counters();
  }
}

// -------------------------------------------------------------------

// sql_query_type_details

// required .draiosproto.sql_statement_type type = 1;
inline bool sql_query_type_details::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sql_query_type_details::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sql_query_type_details::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sql_query_type_details::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::draiosproto::sql_statement_type sql_query_type_details::type() const {
  return static_cast< ::draiosproto::sql_statement_type >(type_);
}
inline void sql_query_type_details::set_type(::draiosproto::sql_statement_type value) {
  assert(::draiosproto::sql_statement_type_IsValid(value));
  set_has_type();
  type_ = value;
}

// required .draiosproto.counter_proto_entry counters = 2;
inline bool sql_query_type_details::has_counters() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sql_query_type_details::set_has_counters() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sql_query_type_details::clear_has_counters() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sql_query_type_details::clear_counters() {
  if (counters_ != NULL) counters_->::draiosproto::counter_proto_entry::Clear();
  clear_has_counters();
}
inline const ::draiosproto::counter_proto_entry& sql_query_type_details::counters() const {
  return counters_ != NULL ? *counters_ : *default_instance_->counters_;
}
inline ::draiosproto::counter_proto_entry* sql_query_type_details::mutable_counters() {
  set_has_counters();
  if (counters_ == NULL) counters_ = new ::draiosproto::counter_proto_entry;
  return counters_;
}
inline ::draiosproto::counter_proto_entry* sql_query_type_details::release_counters() {
  clear_has_counters();
  ::draiosproto::counter_proto_entry* temp = counters_;
  counters_ = NULL;
  return temp;
}
inline void sql_query_type_details::set_allocated_counters(::draiosproto::counter_proto_entry* counters) {
  delete counters_;
  counters_ = counters;
  if (counters) {
    set_has_counters();
  } else {
    clear_has_counters();
  }
}

// -------------------------------------------------------------------

// sql_info

// repeated .draiosproto.sql_entry_details server_queries = 1;
inline int sql_info::server_queries_size() const {
  return server_queries_.size();
}
inline void sql_info::clear_server_queries() {
  server_queries_.Clear();
}
inline const ::draiosproto::sql_entry_details& sql_info::server_queries(int index) const {
  return server_queries_.Get(index);
}
inline ::draiosproto::sql_entry_details* sql_info::mutable_server_queries(int index) {
  return server_queries_.Mutable(index);
}
inline ::draiosproto::sql_entry_details* sql_info::add_server_queries() {
  return server_queries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >&
sql_info::server_queries() const {
  return server_queries_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >*
sql_info::mutable_server_queries() {
  return &server_queries_;
}

// repeated .draiosproto.sql_entry_details client_queries = 2;
inline int sql_info::client_queries_size() const {
  return client_queries_.size();
}
inline void sql_info::clear_client_queries() {
  client_queries_.Clear();
}
inline const ::draiosproto::sql_entry_details& sql_info::client_queries(int index) const {
  return client_queries_.Get(index);
}
inline ::draiosproto::sql_entry_details* sql_info::mutable_client_queries(int index) {
  return client_queries_.Mutable(index);
}
inline ::draiosproto::sql_entry_details* sql_info::add_client_queries() {
  return client_queries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >&
sql_info::client_queries() const {
  return client_queries_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >*
sql_info::mutable_client_queries() {
  return &client_queries_;
}

// repeated .draiosproto.sql_query_type_details server_query_types = 3;
inline int sql_info::server_query_types_size() const {
  return server_query_types_.size();
}
inline void sql_info::clear_server_query_types() {
  server_query_types_.Clear();
}
inline const ::draiosproto::sql_query_type_details& sql_info::server_query_types(int index) const {
  return server_query_types_.Get(index);
}
inline ::draiosproto::sql_query_type_details* sql_info::mutable_server_query_types(int index) {
  return server_query_types_.Mutable(index);
}
inline ::draiosproto::sql_query_type_details* sql_info::add_server_query_types() {
  return server_query_types_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_query_type_details >&
sql_info::server_query_types() const {
  return server_query_types_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_query_type_details >*
sql_info::mutable_server_query_types() {
  return &server_query_types_;
}

// repeated .draiosproto.sql_query_type_details client_query_types = 4;
inline int sql_info::client_query_types_size() const {
  return client_query_types_.size();
}
inline void sql_info::clear_client_query_types() {
  client_query_types_.Clear();
}
inline const ::draiosproto::sql_query_type_details& sql_info::client_query_types(int index) const {
  return client_query_types_.Get(index);
}
inline ::draiosproto::sql_query_type_details* sql_info::mutable_client_query_types(int index) {
  return client_query_types_.Mutable(index);
}
inline ::draiosproto::sql_query_type_details* sql_info::add_client_query_types() {
  return client_query_types_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_query_type_details >&
sql_info::client_query_types() const {
  return client_query_types_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_query_type_details >*
sql_info::mutable_client_query_types() {
  return &client_query_types_;
}

// repeated .draiosproto.sql_entry_details server_tables = 5;
inline int sql_info::server_tables_size() const {
  return server_tables_.size();
}
inline void sql_info::clear_server_tables() {
  server_tables_.Clear();
}
inline const ::draiosproto::sql_entry_details& sql_info::server_tables(int index) const {
  return server_tables_.Get(index);
}
inline ::draiosproto::sql_entry_details* sql_info::mutable_server_tables(int index) {
  return server_tables_.Mutable(index);
}
inline ::draiosproto::sql_entry_details* sql_info::add_server_tables() {
  return server_tables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >&
sql_info::server_tables() const {
  return server_tables_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >*
sql_info::mutable_server_tables() {
  return &server_tables_;
}

// repeated .draiosproto.sql_entry_details client_tables = 6;
inline int sql_info::client_tables_size() const {
  return client_tables_.size();
}
inline void sql_info::clear_client_tables() {
  client_tables_.Clear();
}
inline const ::draiosproto::sql_entry_details& sql_info::client_tables(int index) const {
  return client_tables_.Get(index);
}
inline ::draiosproto::sql_entry_details* sql_info::mutable_client_tables(int index) {
  return client_tables_.Mutable(index);
}
inline ::draiosproto::sql_entry_details* sql_info::add_client_tables() {
  return client_tables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >&
sql_info::client_tables() const {
  return client_tables_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::sql_entry_details >*
sql_info::mutable_client_tables() {
  return &client_tables_;
}

// -------------------------------------------------------------------

// mongodb_collection_details

// required string name = 1;
inline bool mongodb_collection_details::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mongodb_collection_details::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mongodb_collection_details::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mongodb_collection_details::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& mongodb_collection_details::name() const {
  return *name_;
}
inline void mongodb_collection_details::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void mongodb_collection_details::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void mongodb_collection_details::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mongodb_collection_details::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* mongodb_collection_details::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mongodb_collection_details::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .draiosproto.counter_proto_entry counters = 2;
inline bool mongodb_collection_details::has_counters() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mongodb_collection_details::set_has_counters() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mongodb_collection_details::clear_has_counters() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mongodb_collection_details::clear_counters() {
  if (counters_ != NULL) counters_->::draiosproto::counter_proto_entry::Clear();
  clear_has_counters();
}
inline const ::draiosproto::counter_proto_entry& mongodb_collection_details::counters() const {
  return counters_ != NULL ? *counters_ : *default_instance_->counters_;
}
inline ::draiosproto::counter_proto_entry* mongodb_collection_details::mutable_counters() {
  set_has_counters();
  if (counters_ == NULL) counters_ = new ::draiosproto::counter_proto_entry;
  return counters_;
}
inline ::draiosproto::counter_proto_entry* mongodb_collection_details::release_counters() {
  clear_has_counters();
  ::draiosproto::counter_proto_entry* temp = counters_;
  counters_ = NULL;
  return temp;
}
inline void mongodb_collection_details::set_allocated_counters(::draiosproto::counter_proto_entry* counters) {
  delete counters_;
  counters_ = counters;
  if (counters) {
    set_has_counters();
  } else {
    clear_has_counters();
  }
}

// -------------------------------------------------------------------

// mongodb_op_type_details

// required .draiosproto.mongodb_op_type op = 1;
inline bool mongodb_op_type_details::has_op() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mongodb_op_type_details::set_has_op() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mongodb_op_type_details::clear_has_op() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mongodb_op_type_details::clear_op() {
  op_ = 0;
  clear_has_op();
}
inline ::draiosproto::mongodb_op_type mongodb_op_type_details::op() const {
  return static_cast< ::draiosproto::mongodb_op_type >(op_);
}
inline void mongodb_op_type_details::set_op(::draiosproto::mongodb_op_type value) {
  assert(::draiosproto::mongodb_op_type_IsValid(value));
  set_has_op();
  op_ = value;
}

// required .draiosproto.counter_proto_entry counters = 2;
inline bool mongodb_op_type_details::has_counters() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mongodb_op_type_details::set_has_counters() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mongodb_op_type_details::clear_has_counters() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mongodb_op_type_details::clear_counters() {
  if (counters_ != NULL) counters_->::draiosproto::counter_proto_entry::Clear();
  clear_has_counters();
}
inline const ::draiosproto::counter_proto_entry& mongodb_op_type_details::counters() const {
  return counters_ != NULL ? *counters_ : *default_instance_->counters_;
}
inline ::draiosproto::counter_proto_entry* mongodb_op_type_details::mutable_counters() {
  set_has_counters();
  if (counters_ == NULL) counters_ = new ::draiosproto::counter_proto_entry;
  return counters_;
}
inline ::draiosproto::counter_proto_entry* mongodb_op_type_details::release_counters() {
  clear_has_counters();
  ::draiosproto::counter_proto_entry* temp = counters_;
  counters_ = NULL;
  return temp;
}
inline void mongodb_op_type_details::set_allocated_counters(::draiosproto::counter_proto_entry* counters) {
  delete counters_;
  counters_ = counters;
  if (counters) {
    set_has_counters();
  } else {
    clear_has_counters();
  }
}

// -------------------------------------------------------------------

// mongodb_info

// repeated .draiosproto.mongodb_op_type_details servers_ops = 1;
inline int mongodb_info::servers_ops_size() const {
  return servers_ops_.size();
}
inline void mongodb_info::clear_servers_ops() {
  servers_ops_.Clear();
}
inline const ::draiosproto::mongodb_op_type_details& mongodb_info::servers_ops(int index) const {
  return servers_ops_.Get(index);
}
inline ::draiosproto::mongodb_op_type_details* mongodb_info::mutable_servers_ops(int index) {
  return servers_ops_.Mutable(index);
}
inline ::draiosproto::mongodb_op_type_details* mongodb_info::add_servers_ops() {
  return servers_ops_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_op_type_details >&
mongodb_info::servers_ops() const {
  return servers_ops_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_op_type_details >*
mongodb_info::mutable_servers_ops() {
  return &servers_ops_;
}

// repeated .draiosproto.mongodb_op_type_details client_ops = 2;
inline int mongodb_info::client_ops_size() const {
  return client_ops_.size();
}
inline void mongodb_info::clear_client_ops() {
  client_ops_.Clear();
}
inline const ::draiosproto::mongodb_op_type_details& mongodb_info::client_ops(int index) const {
  return client_ops_.Get(index);
}
inline ::draiosproto::mongodb_op_type_details* mongodb_info::mutable_client_ops(int index) {
  return client_ops_.Mutable(index);
}
inline ::draiosproto::mongodb_op_type_details* mongodb_info::add_client_ops() {
  return client_ops_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_op_type_details >&
mongodb_info::client_ops() const {
  return client_ops_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_op_type_details >*
mongodb_info::mutable_client_ops() {
  return &client_ops_;
}

// repeated .draiosproto.mongodb_collection_details server_collections = 3;
inline int mongodb_info::server_collections_size() const {
  return server_collections_.size();
}
inline void mongodb_info::clear_server_collections() {
  server_collections_.Clear();
}
inline const ::draiosproto::mongodb_collection_details& mongodb_info::server_collections(int index) const {
  return server_collections_.Get(index);
}
inline ::draiosproto::mongodb_collection_details* mongodb_info::mutable_server_collections(int index) {
  return server_collections_.Mutable(index);
}
inline ::draiosproto::mongodb_collection_details* mongodb_info::add_server_collections() {
  return server_collections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_collection_details >&
mongodb_info::server_collections() const {
  return server_collections_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_collection_details >*
mongodb_info::mutable_server_collections() {
  return &server_collections_;
}

// repeated .draiosproto.mongodb_collection_details client_collections = 4;
inline int mongodb_info::client_collections_size() const {
  return client_collections_.size();
}
inline void mongodb_info::clear_client_collections() {
  client_collections_.Clear();
}
inline const ::draiosproto::mongodb_collection_details& mongodb_info::client_collections(int index) const {
  return client_collections_.Get(index);
}
inline ::draiosproto::mongodb_collection_details* mongodb_info::mutable_client_collections(int index) {
  return client_collections_.Mutable(index);
}
inline ::draiosproto::mongodb_collection_details* mongodb_info::add_client_collections() {
  return client_collections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_collection_details >&
mongodb_info::client_collections() const {
  return client_collections_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mongodb_collection_details >*
mongodb_info::mutable_client_collections() {
  return &client_collections_;
}

// -------------------------------------------------------------------

// jmx_attribute

// optional string name = 1;
inline bool jmx_attribute::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void jmx_attribute::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void jmx_attribute::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void jmx_attribute::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& jmx_attribute::name() const {
  return *name_;
}
inline void jmx_attribute::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void jmx_attribute::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void jmx_attribute::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* jmx_attribute::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* jmx_attribute::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void jmx_attribute::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double value = 2;
inline bool jmx_attribute::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void jmx_attribute::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void jmx_attribute::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void jmx_attribute::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double jmx_attribute::value() const {
  return value_;
}
inline void jmx_attribute::set_value(double value) {
  set_has_value();
  value_ = value;
}

// optional string alias = 5;
inline bool jmx_attribute::has_alias() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void jmx_attribute::set_has_alias() {
  _has_bits_[0] |= 0x00000004u;
}
inline void jmx_attribute::clear_has_alias() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void jmx_attribute::clear_alias() {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    alias_->clear();
  }
  clear_has_alias();
}
inline const ::std::string& jmx_attribute::alias() const {
  return *alias_;
}
inline void jmx_attribute::set_alias(const ::std::string& value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void jmx_attribute::set_alias(const char* value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void jmx_attribute::set_alias(const char* value, size_t size) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* jmx_attribute::mutable_alias() {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  return alias_;
}
inline ::std::string* jmx_attribute::release_alias() {
  clear_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alias_;
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void jmx_attribute::set_allocated_alias(::std::string* alias) {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    delete alias_;
  }
  if (alias) {
    set_has_alias();
    alias_ = alias;
  } else {
    clear_has_alias();
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .draiosproto.jmx_metric_type type = 7;
inline bool jmx_attribute::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void jmx_attribute::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void jmx_attribute::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void jmx_attribute::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::draiosproto::jmx_metric_type jmx_attribute::type() const {
  return static_cast< ::draiosproto::jmx_metric_type >(type_);
}
inline void jmx_attribute::set_type(::draiosproto::jmx_metric_type value) {
  assert(::draiosproto::jmx_metric_type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .draiosproto.unit unit = 8;
inline bool jmx_attribute::has_unit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void jmx_attribute::set_has_unit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void jmx_attribute::clear_has_unit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void jmx_attribute::clear_unit() {
  unit_ = 0;
  clear_has_unit();
}
inline ::draiosproto::unit jmx_attribute::unit() const {
  return static_cast< ::draiosproto::unit >(unit_);
}
inline void jmx_attribute::set_unit(::draiosproto::unit value) {
  assert(::draiosproto::unit_IsValid(value));
  set_has_unit();
  unit_ = value;
}

// optional .draiosproto.scale scale = 9;
inline bool jmx_attribute::has_scale() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void jmx_attribute::set_has_scale() {
  _has_bits_[0] |= 0x00000020u;
}
inline void jmx_attribute::clear_has_scale() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void jmx_attribute::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline ::draiosproto::scale jmx_attribute::scale() const {
  return static_cast< ::draiosproto::scale >(scale_);
}
inline void jmx_attribute::set_scale(::draiosproto::scale value) {
  assert(::draiosproto::scale_IsValid(value));
  set_has_scale();
  scale_ = value;
}

// repeated .draiosproto.jmx_attribute subattributes = 3;
inline int jmx_attribute::subattributes_size() const {
  return subattributes_.size();
}
inline void jmx_attribute::clear_subattributes() {
  subattributes_.Clear();
}
inline const ::draiosproto::jmx_attribute& jmx_attribute::subattributes(int index) const {
  return subattributes_.Get(index);
}
inline ::draiosproto::jmx_attribute* jmx_attribute::mutable_subattributes(int index) {
  return subattributes_.Mutable(index);
}
inline ::draiosproto::jmx_attribute* jmx_attribute::add_subattributes() {
  return subattributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_attribute >&
jmx_attribute::subattributes() const {
  return subattributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_attribute >*
jmx_attribute::mutable_subattributes() {
  return &subattributes_;
}

// -------------------------------------------------------------------

// jmx_bean

// optional string name = 1;
inline bool jmx_bean::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void jmx_bean::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void jmx_bean::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void jmx_bean::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& jmx_bean::name() const {
  return *name_;
}
inline void jmx_bean::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void jmx_bean::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void jmx_bean::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* jmx_bean::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* jmx_bean::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void jmx_bean::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .draiosproto.jmx_attribute attributes = 2;
inline int jmx_bean::attributes_size() const {
  return attributes_.size();
}
inline void jmx_bean::clear_attributes() {
  attributes_.Clear();
}
inline const ::draiosproto::jmx_attribute& jmx_bean::attributes(int index) const {
  return attributes_.Get(index);
}
inline ::draiosproto::jmx_attribute* jmx_bean::mutable_attributes(int index) {
  return attributes_.Mutable(index);
}
inline ::draiosproto::jmx_attribute* jmx_bean::add_attributes() {
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_attribute >&
jmx_bean::attributes() const {
  return attributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_attribute >*
jmx_bean::mutable_attributes() {
  return &attributes_;
}

// -------------------------------------------------------------------

// java_info

// optional string process_name = 1;
inline bool java_info::has_process_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void java_info::set_has_process_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void java_info::clear_has_process_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void java_info::clear_process_name() {
  if (process_name_ != &::google::protobuf::internal::kEmptyString) {
    process_name_->clear();
  }
  clear_has_process_name();
}
inline const ::std::string& java_info::process_name() const {
  return *process_name_;
}
inline void java_info::set_process_name(const ::std::string& value) {
  set_has_process_name();
  if (process_name_ == &::google::protobuf::internal::kEmptyString) {
    process_name_ = new ::std::string;
  }
  process_name_->assign(value);
}
inline void java_info::set_process_name(const char* value) {
  set_has_process_name();
  if (process_name_ == &::google::protobuf::internal::kEmptyString) {
    process_name_ = new ::std::string;
  }
  process_name_->assign(value);
}
inline void java_info::set_process_name(const char* value, size_t size) {
  set_has_process_name();
  if (process_name_ == &::google::protobuf::internal::kEmptyString) {
    process_name_ = new ::std::string;
  }
  process_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* java_info::mutable_process_name() {
  set_has_process_name();
  if (process_name_ == &::google::protobuf::internal::kEmptyString) {
    process_name_ = new ::std::string;
  }
  return process_name_;
}
inline ::std::string* java_info::release_process_name() {
  clear_has_process_name();
  if (process_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = process_name_;
    process_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void java_info::set_allocated_process_name(::std::string* process_name) {
  if (process_name_ != &::google::protobuf::internal::kEmptyString) {
    delete process_name_;
  }
  if (process_name) {
    set_has_process_name();
    process_name_ = process_name;
  } else {
    clear_has_process_name();
    process_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .draiosproto.jmx_bean beans = 2;
inline int java_info::beans_size() const {
  return beans_.size();
}
inline void java_info::clear_beans() {
  beans_.Clear();
}
inline const ::draiosproto::jmx_bean& java_info::beans(int index) const {
  return beans_.Get(index);
}
inline ::draiosproto::jmx_bean* java_info::mutable_beans(int index) {
  return beans_.Mutable(index);
}
inline ::draiosproto::jmx_bean* java_info::add_beans() {
  return beans_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_bean >&
java_info::beans() const {
  return beans_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::jmx_bean >*
java_info::mutable_beans() {
  return &beans_;
}

// -------------------------------------------------------------------

// statsd_tag

// required string key = 1;
inline bool statsd_tag::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void statsd_tag::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void statsd_tag::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void statsd_tag::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& statsd_tag::key() const {
  return *key_;
}
inline void statsd_tag::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void statsd_tag::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void statsd_tag::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* statsd_tag::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* statsd_tag::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void statsd_tag::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value = 2;
inline bool statsd_tag::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void statsd_tag::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void statsd_tag::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void statsd_tag::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& statsd_tag::value() const {
  return *value_;
}
inline void statsd_tag::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void statsd_tag::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void statsd_tag::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* statsd_tag::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* statsd_tag::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void statsd_tag::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// statsd_metric

// optional string name = 1;
inline bool statsd_metric::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void statsd_metric::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void statsd_metric::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void statsd_metric::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& statsd_metric::name() const {
  return *name_;
}
inline void statsd_metric::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void statsd_metric::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void statsd_metric::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* statsd_metric::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* statsd_metric::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void statsd_metric::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .draiosproto.statsd_tag tags = 2;
inline int statsd_metric::tags_size() const {
  return tags_.size();
}
inline void statsd_metric::clear_tags() {
  tags_.Clear();
}
inline const ::draiosproto::statsd_tag& statsd_metric::tags(int index) const {
  return tags_.Get(index);
}
inline ::draiosproto::statsd_tag* statsd_metric::mutable_tags(int index) {
  return tags_.Mutable(index);
}
inline ::draiosproto::statsd_tag* statsd_metric::add_tags() {
  return tags_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::statsd_tag >&
statsd_metric::tags() const {
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::statsd_tag >*
statsd_metric::mutable_tags() {
  return &tags_;
}

// optional .draiosproto.statsd_metric_type type = 3;
inline bool statsd_metric::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void statsd_metric::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void statsd_metric::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void statsd_metric::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::draiosproto::statsd_metric_type statsd_metric::type() const {
  return static_cast< ::draiosproto::statsd_metric_type >(type_);
}
inline void statsd_metric::set_type(::draiosproto::statsd_metric_type value) {
  assert(::draiosproto::statsd_metric_type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional double value = 4;
inline bool statsd_metric::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void statsd_metric::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void statsd_metric::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void statsd_metric::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double statsd_metric::value() const {
  return value_;
}
inline void statsd_metric::set_value(double value) {
  set_has_value();
  value_ = value;
}

// optional double sum = 5;
inline bool statsd_metric::has_sum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void statsd_metric::set_has_sum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void statsd_metric::clear_has_sum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void statsd_metric::clear_sum() {
  sum_ = 0;
  clear_has_sum();
}
inline double statsd_metric::sum() const {
  return sum_;
}
inline void statsd_metric::set_sum(double value) {
  set_has_sum();
  sum_ = value;
}

// optional double min = 6;
inline bool statsd_metric::has_min() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void statsd_metric::set_has_min() {
  _has_bits_[0] |= 0x00000020u;
}
inline void statsd_metric::clear_has_min() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void statsd_metric::clear_min() {
  min_ = 0;
  clear_has_min();
}
inline double statsd_metric::min() const {
  return min_;
}
inline void statsd_metric::set_min(double value) {
  set_has_min();
  min_ = value;
}

// optional double max = 7;
inline bool statsd_metric::has_max() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void statsd_metric::set_has_max() {
  _has_bits_[0] |= 0x00000040u;
}
inline void statsd_metric::clear_has_max() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void statsd_metric::clear_max() {
  max_ = 0;
  clear_has_max();
}
inline double statsd_metric::max() const {
  return max_;
}
inline void statsd_metric::set_max(double value) {
  set_has_max();
  max_ = value;
}

// optional double count = 8;
inline bool statsd_metric::has_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void statsd_metric::set_has_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void statsd_metric::clear_has_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void statsd_metric::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline double statsd_metric::count() const {
  return count_;
}
inline void statsd_metric::set_count(double value) {
  set_has_count();
  count_ = value;
}

// optional double median = 9;
inline bool statsd_metric::has_median() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void statsd_metric::set_has_median() {
  _has_bits_[0] |= 0x00000100u;
}
inline void statsd_metric::clear_has_median() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void statsd_metric::clear_median() {
  median_ = 0;
  clear_has_median();
}
inline double statsd_metric::median() const {
  return median_;
}
inline void statsd_metric::set_median(double value) {
  set_has_median();
  median_ = value;
}

// optional double percentile_95 = 10;
inline bool statsd_metric::has_percentile_95() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void statsd_metric::set_has_percentile_95() {
  _has_bits_[0] |= 0x00000200u;
}
inline void statsd_metric::clear_has_percentile_95() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void statsd_metric::clear_percentile_95() {
  percentile_95_ = 0;
  clear_has_percentile_95();
}
inline double statsd_metric::percentile_95() const {
  return percentile_95_;
}
inline void statsd_metric::set_percentile_95(double value) {
  set_has_percentile_95();
  percentile_95_ = value;
}

// optional double percentile_99 = 11;
inline bool statsd_metric::has_percentile_99() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void statsd_metric::set_has_percentile_99() {
  _has_bits_[0] |= 0x00000400u;
}
inline void statsd_metric::clear_has_percentile_99() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void statsd_metric::clear_percentile_99() {
  percentile_99_ = 0;
  clear_has_percentile_99();
}
inline double statsd_metric::percentile_99() const {
  return percentile_99_;
}
inline void statsd_metric::set_percentile_99(double value) {
  set_has_percentile_99();
  percentile_99_ = value;
}

// -------------------------------------------------------------------

// statsd_info

// repeated .draiosproto.statsd_metric statsd_metrics = 1;
inline int statsd_info::statsd_metrics_size() const {
  return statsd_metrics_.size();
}
inline void statsd_info::clear_statsd_metrics() {
  statsd_metrics_.Clear();
}
inline const ::draiosproto::statsd_metric& statsd_info::statsd_metrics(int index) const {
  return statsd_metrics_.Get(index);
}
inline ::draiosproto::statsd_metric* statsd_info::mutable_statsd_metrics(int index) {
  return statsd_metrics_.Mutable(index);
}
inline ::draiosproto::statsd_metric* statsd_info::add_statsd_metrics() {
  return statsd_metrics_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::statsd_metric >&
statsd_info::statsd_metrics() const {
  return statsd_metrics_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::statsd_metric >*
statsd_info::mutable_statsd_metrics() {
  return &statsd_metrics_;
}

// -------------------------------------------------------------------

// app_tag

// required string key = 1;
inline bool app_tag::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void app_tag::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void app_tag::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void app_tag::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& app_tag::key() const {
  return *key_;
}
inline void app_tag::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void app_tag::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void app_tag::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* app_tag::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* app_tag::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void app_tag::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value = 2;
inline bool app_tag::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void app_tag::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void app_tag::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void app_tag::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& app_tag::value() const {
  return *value_;
}
inline void app_tag::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void app_tag::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void app_tag::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* app_tag::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* app_tag::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void app_tag::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// app_metric

// optional string name = 1;
inline bool app_metric::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void app_metric::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void app_metric::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void app_metric::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& app_metric::name() const {
  return *name_;
}
inline void app_metric::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void app_metric::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void app_metric::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* app_metric::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* app_metric::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void app_metric::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .draiosproto.app_metric_type type = 2;
inline bool app_metric::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void app_metric::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void app_metric::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void app_metric::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::draiosproto::app_metric_type app_metric::type() const {
  return static_cast< ::draiosproto::app_metric_type >(type_);
}
inline void app_metric::set_type(::draiosproto::app_metric_type value) {
  assert(::draiosproto::app_metric_type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional double value = 3;
inline bool app_metric::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void app_metric::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void app_metric::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void app_metric::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double app_metric::value() const {
  return value_;
}
inline void app_metric::set_value(double value) {
  set_has_value();
  value_ = value;
}

// repeated .draiosproto.app_tag tags = 4;
inline int app_metric::tags_size() const {
  return tags_.size();
}
inline void app_metric::clear_tags() {
  tags_.Clear();
}
inline const ::draiosproto::app_tag& app_metric::tags(int index) const {
  return tags_.Get(index);
}
inline ::draiosproto::app_tag* app_metric::mutable_tags(int index) {
  return tags_.Mutable(index);
}
inline ::draiosproto::app_tag* app_metric::add_tags() {
  return tags_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::app_tag >&
app_metric::tags() const {
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::app_tag >*
app_metric::mutable_tags() {
  return &tags_;
}

// -------------------------------------------------------------------

// app_check

// optional string name = 1;
inline bool app_check::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void app_check::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void app_check::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void app_check::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& app_check::name() const {
  return *name_;
}
inline void app_check::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void app_check::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void app_check::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* app_check::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* app_check::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void app_check::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .draiosproto.app_check_value value = 2;
inline bool app_check::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void app_check::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void app_check::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void app_check::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::draiosproto::app_check_value app_check::value() const {
  return static_cast< ::draiosproto::app_check_value >(value_);
}
inline void app_check::set_value(::draiosproto::app_check_value value) {
  assert(::draiosproto::app_check_value_IsValid(value));
  set_has_value();
  value_ = value;
}

// repeated .draiosproto.app_tag tags = 3;
inline int app_check::tags_size() const {
  return tags_.size();
}
inline void app_check::clear_tags() {
  tags_.Clear();
}
inline const ::draiosproto::app_tag& app_check::tags(int index) const {
  return tags_.Get(index);
}
inline ::draiosproto::app_tag* app_check::mutable_tags(int index) {
  return tags_.Mutable(index);
}
inline ::draiosproto::app_tag* app_check::add_tags() {
  return tags_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::app_tag >&
app_check::tags() const {
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::app_tag >*
app_check::mutable_tags() {
  return &tags_;
}

// -------------------------------------------------------------------

// app_info

// optional string process_name = 1;
inline bool app_info::has_process_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void app_info::set_has_process_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void app_info::clear_has_process_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void app_info::clear_process_name() {
  if (process_name_ != &::google::protobuf::internal::kEmptyString) {
    process_name_->clear();
  }
  clear_has_process_name();
}
inline const ::std::string& app_info::process_name() const {
  return *process_name_;
}
inline void app_info::set_process_name(const ::std::string& value) {
  set_has_process_name();
  if (process_name_ == &::google::protobuf::internal::kEmptyString) {
    process_name_ = new ::std::string;
  }
  process_name_->assign(value);
}
inline void app_info::set_process_name(const char* value) {
  set_has_process_name();
  if (process_name_ == &::google::protobuf::internal::kEmptyString) {
    process_name_ = new ::std::string;
  }
  process_name_->assign(value);
}
inline void app_info::set_process_name(const char* value, size_t size) {
  set_has_process_name();
  if (process_name_ == &::google::protobuf::internal::kEmptyString) {
    process_name_ = new ::std::string;
  }
  process_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* app_info::mutable_process_name() {
  set_has_process_name();
  if (process_name_ == &::google::protobuf::internal::kEmptyString) {
    process_name_ = new ::std::string;
  }
  return process_name_;
}
inline ::std::string* app_info::release_process_name() {
  clear_has_process_name();
  if (process_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = process_name_;
    process_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void app_info::set_allocated_process_name(::std::string* process_name) {
  if (process_name_ != &::google::protobuf::internal::kEmptyString) {
    delete process_name_;
  }
  if (process_name) {
    set_has_process_name();
    process_name_ = process_name;
  } else {
    clear_has_process_name();
    process_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .draiosproto.app_metric metrics = 2;
inline int app_info::metrics_size() const {
  return metrics_.size();
}
inline void app_info::clear_metrics() {
  metrics_.Clear();
}
inline const ::draiosproto::app_metric& app_info::metrics(int index) const {
  return metrics_.Get(index);
}
inline ::draiosproto::app_metric* app_info::mutable_metrics(int index) {
  return metrics_.Mutable(index);
}
inline ::draiosproto::app_metric* app_info::add_metrics() {
  return metrics_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::app_metric >&
app_info::metrics() const {
  return metrics_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::app_metric >*
app_info::mutable_metrics() {
  return &metrics_;
}

// repeated .draiosproto.app_check checks = 3;
inline int app_info::checks_size() const {
  return checks_.size();
}
inline void app_info::clear_checks() {
  checks_.Clear();
}
inline const ::draiosproto::app_check& app_info::checks(int index) const {
  return checks_.Get(index);
}
inline ::draiosproto::app_check* app_info::mutable_checks(int index) {
  return checks_.Mutable(index);
}
inline ::draiosproto::app_check* app_info::add_checks() {
  return checks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::app_check >&
app_info::checks() const {
  return checks_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::app_check >*
app_info::mutable_checks() {
  return &checks_;
}

// -------------------------------------------------------------------

// proto_info

// optional .draiosproto.http_info http = 1;
inline bool proto_info::has_http() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void proto_info::set_has_http() {
  _has_bits_[0] |= 0x00000001u;
}
inline void proto_info::clear_has_http() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void proto_info::clear_http() {
  if (http_ != NULL) http_->::draiosproto::http_info::Clear();
  clear_has_http();
}
inline const ::draiosproto::http_info& proto_info::http() const {
  return http_ != NULL ? *http_ : *default_instance_->http_;
}
inline ::draiosproto::http_info* proto_info::mutable_http() {
  set_has_http();
  if (http_ == NULL) http_ = new ::draiosproto::http_info;
  return http_;
}
inline ::draiosproto::http_info* proto_info::release_http() {
  clear_has_http();
  ::draiosproto::http_info* temp = http_;
  http_ = NULL;
  return temp;
}
inline void proto_info::set_allocated_http(::draiosproto::http_info* http) {
  delete http_;
  http_ = http;
  if (http) {
    set_has_http();
  } else {
    clear_has_http();
  }
}

// optional .draiosproto.sql_info mysql = 2;
inline bool proto_info::has_mysql() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void proto_info::set_has_mysql() {
  _has_bits_[0] |= 0x00000002u;
}
inline void proto_info::clear_has_mysql() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void proto_info::clear_mysql() {
  if (mysql_ != NULL) mysql_->::draiosproto::sql_info::Clear();
  clear_has_mysql();
}
inline const ::draiosproto::sql_info& proto_info::mysql() const {
  return mysql_ != NULL ? *mysql_ : *default_instance_->mysql_;
}
inline ::draiosproto::sql_info* proto_info::mutable_mysql() {
  set_has_mysql();
  if (mysql_ == NULL) mysql_ = new ::draiosproto::sql_info;
  return mysql_;
}
inline ::draiosproto::sql_info* proto_info::release_mysql() {
  clear_has_mysql();
  ::draiosproto::sql_info* temp = mysql_;
  mysql_ = NULL;
  return temp;
}
inline void proto_info::set_allocated_mysql(::draiosproto::sql_info* mysql) {
  delete mysql_;
  mysql_ = mysql;
  if (mysql) {
    set_has_mysql();
  } else {
    clear_has_mysql();
  }
}

// optional .draiosproto.sql_info postgres = 3;
inline bool proto_info::has_postgres() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void proto_info::set_has_postgres() {
  _has_bits_[0] |= 0x00000004u;
}
inline void proto_info::clear_has_postgres() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void proto_info::clear_postgres() {
  if (postgres_ != NULL) postgres_->::draiosproto::sql_info::Clear();
  clear_has_postgres();
}
inline const ::draiosproto::sql_info& proto_info::postgres() const {
  return postgres_ != NULL ? *postgres_ : *default_instance_->postgres_;
}
inline ::draiosproto::sql_info* proto_info::mutable_postgres() {
  set_has_postgres();
  if (postgres_ == NULL) postgres_ = new ::draiosproto::sql_info;
  return postgres_;
}
inline ::draiosproto::sql_info* proto_info::release_postgres() {
  clear_has_postgres();
  ::draiosproto::sql_info* temp = postgres_;
  postgres_ = NULL;
  return temp;
}
inline void proto_info::set_allocated_postgres(::draiosproto::sql_info* postgres) {
  delete postgres_;
  postgres_ = postgres;
  if (postgres) {
    set_has_postgres();
  } else {
    clear_has_postgres();
  }
}

// optional .draiosproto.mongodb_info mongodb = 4;
inline bool proto_info::has_mongodb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void proto_info::set_has_mongodb() {
  _has_bits_[0] |= 0x00000008u;
}
inline void proto_info::clear_has_mongodb() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void proto_info::clear_mongodb() {
  if (mongodb_ != NULL) mongodb_->::draiosproto::mongodb_info::Clear();
  clear_has_mongodb();
}
inline const ::draiosproto::mongodb_info& proto_info::mongodb() const {
  return mongodb_ != NULL ? *mongodb_ : *default_instance_->mongodb_;
}
inline ::draiosproto::mongodb_info* proto_info::mutable_mongodb() {
  set_has_mongodb();
  if (mongodb_ == NULL) mongodb_ = new ::draiosproto::mongodb_info;
  return mongodb_;
}
inline ::draiosproto::mongodb_info* proto_info::release_mongodb() {
  clear_has_mongodb();
  ::draiosproto::mongodb_info* temp = mongodb_;
  mongodb_ = NULL;
  return temp;
}
inline void proto_info::set_allocated_mongodb(::draiosproto::mongodb_info* mongodb) {
  delete mongodb_;
  mongodb_ = mongodb;
  if (mongodb) {
    set_has_mongodb();
  } else {
    clear_has_mongodb();
  }
}

// optional .draiosproto.java_info java = 5;
inline bool proto_info::has_java() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void proto_info::set_has_java() {
  _has_bits_[0] |= 0x00000010u;
}
inline void proto_info::clear_has_java() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void proto_info::clear_java() {
  if (java_ != NULL) java_->::draiosproto::java_info::Clear();
  clear_has_java();
}
inline const ::draiosproto::java_info& proto_info::java() const {
  return java_ != NULL ? *java_ : *default_instance_->java_;
}
inline ::draiosproto::java_info* proto_info::mutable_java() {
  set_has_java();
  if (java_ == NULL) java_ = new ::draiosproto::java_info;
  return java_;
}
inline ::draiosproto::java_info* proto_info::release_java() {
  clear_has_java();
  ::draiosproto::java_info* temp = java_;
  java_ = NULL;
  return temp;
}
inline void proto_info::set_allocated_java(::draiosproto::java_info* java) {
  delete java_;
  java_ = java;
  if (java) {
    set_has_java();
  } else {
    clear_has_java();
  }
}

// optional .draiosproto.statsd_info statsd = 6;
inline bool proto_info::has_statsd() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void proto_info::set_has_statsd() {
  _has_bits_[0] |= 0x00000020u;
}
inline void proto_info::clear_has_statsd() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void proto_info::clear_statsd() {
  if (statsd_ != NULL) statsd_->::draiosproto::statsd_info::Clear();
  clear_has_statsd();
}
inline const ::draiosproto::statsd_info& proto_info::statsd() const {
  return statsd_ != NULL ? *statsd_ : *default_instance_->statsd_;
}
inline ::draiosproto::statsd_info* proto_info::mutable_statsd() {
  set_has_statsd();
  if (statsd_ == NULL) statsd_ = new ::draiosproto::statsd_info;
  return statsd_;
}
inline ::draiosproto::statsd_info* proto_info::release_statsd() {
  clear_has_statsd();
  ::draiosproto::statsd_info* temp = statsd_;
  statsd_ = NULL;
  return temp;
}
inline void proto_info::set_allocated_statsd(::draiosproto::statsd_info* statsd) {
  delete statsd_;
  statsd_ = statsd;
  if (statsd) {
    set_has_statsd();
  } else {
    clear_has_statsd();
  }
}

// optional .draiosproto.app_info app = 7;
inline bool proto_info::has_app() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void proto_info::set_has_app() {
  _has_bits_[0] |= 0x00000040u;
}
inline void proto_info::clear_has_app() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void proto_info::clear_app() {
  if (app_ != NULL) app_->::draiosproto::app_info::Clear();
  clear_has_app();
}
inline const ::draiosproto::app_info& proto_info::app() const {
  return app_ != NULL ? *app_ : *default_instance_->app_;
}
inline ::draiosproto::app_info* proto_info::mutable_app() {
  set_has_app();
  if (app_ == NULL) app_ = new ::draiosproto::app_info;
  return app_;
}
inline ::draiosproto::app_info* proto_info::release_app() {
  clear_has_app();
  ::draiosproto::app_info* temp = app_;
  app_ = NULL;
  return temp;
}
inline void proto_info::set_allocated_app(::draiosproto::app_info* app) {
  delete app_;
  app_ = app;
  if (app) {
    set_has_app();
  } else {
    clear_has_app();
  }
}

// -------------------------------------------------------------------

// network_by_port

// required uint32 port = 1;
inline bool network_by_port::has_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void network_by_port::set_has_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void network_by_port::clear_has_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void network_by_port::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 network_by_port::port() const {
  return port_;
}
inline void network_by_port::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// required .draiosproto.connection_categories counters = 2;
inline bool network_by_port::has_counters() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void network_by_port::set_has_counters() {
  _has_bits_[0] |= 0x00000002u;
}
inline void network_by_port::clear_has_counters() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void network_by_port::clear_counters() {
  if (counters_ != NULL) counters_->::draiosproto::connection_categories::Clear();
  clear_has_counters();
}
inline const ::draiosproto::connection_categories& network_by_port::counters() const {
  return counters_ != NULL ? *counters_ : *default_instance_->counters_;
}
inline ::draiosproto::connection_categories* network_by_port::mutable_counters() {
  set_has_counters();
  if (counters_ == NULL) counters_ = new ::draiosproto::connection_categories;
  return counters_;
}
inline ::draiosproto::connection_categories* network_by_port::release_counters() {
  clear_has_counters();
  ::draiosproto::connection_categories* temp = counters_;
  counters_ = NULL;
  return temp;
}
inline void network_by_port::set_allocated_counters(::draiosproto::connection_categories* counters) {
  delete counters_;
  counters_ = counters;
  if (counters) {
    set_has_counters();
  } else {
    clear_has_counters();
  }
}

// -------------------------------------------------------------------

// host

// optional string hostname = 1;
inline bool host::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void host::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void host::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void host::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& host::hostname() const {
  return *hostname_;
}
inline void host::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void host::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void host::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* host::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* host::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void host::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 num_cpus = 2;
inline bool host::has_num_cpus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void host::set_has_num_cpus() {
  _has_bits_[0] |= 0x00000002u;
}
inline void host::clear_has_num_cpus() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void host::clear_num_cpus() {
  num_cpus_ = 0u;
  clear_has_num_cpus();
}
inline ::google::protobuf::uint32 host::num_cpus() const {
  return num_cpus_;
}
inline void host::set_num_cpus(::google::protobuf::uint32 value) {
  set_has_num_cpus();
  num_cpus_ = value;
}

// repeated uint32 cpu_loads = 3;
inline int host::cpu_loads_size() const {
  return cpu_loads_.size();
}
inline void host::clear_cpu_loads() {
  cpu_loads_.Clear();
}
inline ::google::protobuf::uint32 host::cpu_loads(int index) const {
  return cpu_loads_.Get(index);
}
inline void host::set_cpu_loads(int index, ::google::protobuf::uint32 value) {
  cpu_loads_.Set(index, value);
}
inline void host::add_cpu_loads(::google::protobuf::uint32 value) {
  cpu_loads_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
host::cpu_loads() const {
  return cpu_loads_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
host::mutable_cpu_loads() {
  return &cpu_loads_;
}

// repeated uint32 cpu_steal = 11;
inline int host::cpu_steal_size() const {
  return cpu_steal_.size();
}
inline void host::clear_cpu_steal() {
  cpu_steal_.Clear();
}
inline ::google::protobuf::uint32 host::cpu_steal(int index) const {
  return cpu_steal_.Get(index);
}
inline void host::set_cpu_steal(int index, ::google::protobuf::uint32 value) {
  cpu_steal_.Set(index, value);
}
inline void host::add_cpu_steal(::google::protobuf::uint32 value) {
  cpu_steal_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
host::cpu_steal() const {
  return cpu_steal_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
host::mutable_cpu_steal() {
  return &cpu_steal_;
}

// required uint64 physical_memory_size_bytes = 4;
inline bool host::has_physical_memory_size_bytes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void host::set_has_physical_memory_size_bytes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void host::clear_has_physical_memory_size_bytes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void host::clear_physical_memory_size_bytes() {
  physical_memory_size_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_physical_memory_size_bytes();
}
inline ::google::protobuf::uint64 host::physical_memory_size_bytes() const {
  return physical_memory_size_bytes_;
}
inline void host::set_physical_memory_size_bytes(::google::protobuf::uint64 value) {
  set_has_physical_memory_size_bytes();
  physical_memory_size_bytes_ = value;
}

// optional .draiosproto.time_categories tcounters = 5;
inline bool host::has_tcounters() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void host::set_has_tcounters() {
  _has_bits_[0] |= 0x00000020u;
}
inline void host::clear_has_tcounters() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void host::clear_tcounters() {
  if (tcounters_ != NULL) tcounters_->::draiosproto::time_categories::Clear();
  clear_has_tcounters();
}
inline const ::draiosproto::time_categories& host::tcounters() const {
  return tcounters_ != NULL ? *tcounters_ : *default_instance_->tcounters_;
}
inline ::draiosproto::time_categories* host::mutable_tcounters() {
  set_has_tcounters();
  if (tcounters_ == NULL) tcounters_ = new ::draiosproto::time_categories;
  return tcounters_;
}
inline ::draiosproto::time_categories* host::release_tcounters() {
  clear_has_tcounters();
  ::draiosproto::time_categories* temp = tcounters_;
  tcounters_ = NULL;
  return temp;
}
inline void host::set_allocated_tcounters(::draiosproto::time_categories* tcounters) {
  delete tcounters_;
  tcounters_ = tcounters;
  if (tcounters) {
    set_has_tcounters();
  } else {
    clear_has_tcounters();
  }
}

// optional .draiosproto.transaction_breakdown_categories reqcounters = 12;
inline bool host::has_reqcounters() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void host::set_has_reqcounters() {
  _has_bits_[0] |= 0x00000040u;
}
inline void host::clear_has_reqcounters() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void host::clear_reqcounters() {
  if (reqcounters_ != NULL) reqcounters_->::draiosproto::transaction_breakdown_categories::Clear();
  clear_has_reqcounters();
}
inline const ::draiosproto::transaction_breakdown_categories& host::reqcounters() const {
  return reqcounters_ != NULL ? *reqcounters_ : *default_instance_->reqcounters_;
}
inline ::draiosproto::transaction_breakdown_categories* host::mutable_reqcounters() {
  set_has_reqcounters();
  if (reqcounters_ == NULL) reqcounters_ = new ::draiosproto::transaction_breakdown_categories;
  return reqcounters_;
}
inline ::draiosproto::transaction_breakdown_categories* host::release_reqcounters() {
  clear_has_reqcounters();
  ::draiosproto::transaction_breakdown_categories* temp = reqcounters_;
  reqcounters_ = NULL;
  return temp;
}
inline void host::set_allocated_reqcounters(::draiosproto::transaction_breakdown_categories* reqcounters) {
  delete reqcounters_;
  reqcounters_ = reqcounters;
  if (reqcounters) {
    set_has_reqcounters();
  } else {
    clear_has_reqcounters();
  }
}

// optional .draiosproto.counter_time_bidirectional transaction_counters = 6;
inline bool host::has_transaction_counters() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void host::set_has_transaction_counters() {
  _has_bits_[0] |= 0x00000080u;
}
inline void host::clear_has_transaction_counters() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void host::clear_transaction_counters() {
  if (transaction_counters_ != NULL) transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& host::transaction_counters() const {
  return transaction_counters_ != NULL ? *transaction_counters_ : *default_instance_->transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* host::mutable_transaction_counters() {
  set_has_transaction_counters();
  if (transaction_counters_ == NULL) transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  return transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* host::release_transaction_counters() {
  clear_has_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = transaction_counters_;
  transaction_counters_ = NULL;
  return temp;
}
inline void host::set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters) {
  delete transaction_counters_;
  transaction_counters_ = transaction_counters;
  if (transaction_counters) {
    set_has_transaction_counters();
  } else {
    clear_has_transaction_counters();
  }
}

// optional .draiosproto.counter_time_bidirectional min_transaction_counters = 22;
inline bool host::has_min_transaction_counters() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void host::set_has_min_transaction_counters() {
  _has_bits_[0] |= 0x00000100u;
}
inline void host::clear_has_min_transaction_counters() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void host::clear_min_transaction_counters() {
  if (min_transaction_counters_ != NULL) min_transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_min_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& host::min_transaction_counters() const {
  return min_transaction_counters_ != NULL ? *min_transaction_counters_ : *default_instance_->min_transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* host::mutable_min_transaction_counters() {
  set_has_min_transaction_counters();
  if (min_transaction_counters_ == NULL) min_transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  return min_transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* host::release_min_transaction_counters() {
  clear_has_min_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = min_transaction_counters_;
  min_transaction_counters_ = NULL;
  return temp;
}
inline void host::set_allocated_min_transaction_counters(::draiosproto::counter_time_bidirectional* min_transaction_counters) {
  delete min_transaction_counters_;
  min_transaction_counters_ = min_transaction_counters;
  if (min_transaction_counters) {
    set_has_min_transaction_counters();
  } else {
    clear_has_min_transaction_counters();
  }
}

// optional .draiosproto.counter_time_bidirectional max_transaction_counters = 23;
inline bool host::has_max_transaction_counters() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void host::set_has_max_transaction_counters() {
  _has_bits_[0] |= 0x00000200u;
}
inline void host::clear_has_max_transaction_counters() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void host::clear_max_transaction_counters() {
  if (max_transaction_counters_ != NULL) max_transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_max_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& host::max_transaction_counters() const {
  return max_transaction_counters_ != NULL ? *max_transaction_counters_ : *default_instance_->max_transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* host::mutable_max_transaction_counters() {
  set_has_max_transaction_counters();
  if (max_transaction_counters_ == NULL) max_transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  return max_transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* host::release_max_transaction_counters() {
  clear_has_max_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = max_transaction_counters_;
  max_transaction_counters_ = NULL;
  return temp;
}
inline void host::set_allocated_max_transaction_counters(::draiosproto::counter_time_bidirectional* max_transaction_counters) {
  delete max_transaction_counters_;
  max_transaction_counters_ = max_transaction_counters;
  if (max_transaction_counters) {
    set_has_max_transaction_counters();
  } else {
    clear_has_max_transaction_counters();
  }
}

// optional uint64 transaction_processing_delay = 7;
inline bool host::has_transaction_processing_delay() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void host::set_has_transaction_processing_delay() {
  _has_bits_[0] |= 0x00000400u;
}
inline void host::clear_has_transaction_processing_delay() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void host::clear_transaction_processing_delay() {
  transaction_processing_delay_ = GOOGLE_ULONGLONG(0);
  clear_has_transaction_processing_delay();
}
inline ::google::protobuf::uint64 host::transaction_processing_delay() const {
  return transaction_processing_delay_;
}
inline void host::set_transaction_processing_delay(::google::protobuf::uint64 value) {
  set_has_transaction_processing_delay();
  transaction_processing_delay_ = value;
}

// optional uint64 next_tiers_delay = 13;
inline bool host::has_next_tiers_delay() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void host::set_has_next_tiers_delay() {
  _has_bits_[0] |= 0x00000800u;
}
inline void host::clear_has_next_tiers_delay() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void host::clear_next_tiers_delay() {
  next_tiers_delay_ = GOOGLE_ULONGLONG(0);
  clear_has_next_tiers_delay();
}
inline ::google::protobuf::uint64 host::next_tiers_delay() const {
  return next_tiers_delay_;
}
inline void host::set_next_tiers_delay(::google::protobuf::uint64 value) {
  set_has_next_tiers_delay();
  next_tiers_delay_ = value;
}

// optional .draiosproto.resource_categories resource_counters = 8;
inline bool host::has_resource_counters() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void host::set_has_resource_counters() {
  _has_bits_[0] |= 0x00001000u;
}
inline void host::clear_has_resource_counters() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void host::clear_resource_counters() {
  if (resource_counters_ != NULL) resource_counters_->::draiosproto::resource_categories::Clear();
  clear_has_resource_counters();
}
inline const ::draiosproto::resource_categories& host::resource_counters() const {
  return resource_counters_ != NULL ? *resource_counters_ : *default_instance_->resource_counters_;
}
inline ::draiosproto::resource_categories* host::mutable_resource_counters() {
  set_has_resource_counters();
  if (resource_counters_ == NULL) resource_counters_ = new ::draiosproto::resource_categories;
  return resource_counters_;
}
inline ::draiosproto::resource_categories* host::release_resource_counters() {
  clear_has_resource_counters();
  ::draiosproto::resource_categories* temp = resource_counters_;
  resource_counters_ = NULL;
  return temp;
}
inline void host::set_allocated_resource_counters(::draiosproto::resource_categories* resource_counters) {
  delete resource_counters_;
  resource_counters_ = resource_counters;
  if (resource_counters) {
    set_has_resource_counters();
  } else {
    clear_has_resource_counters();
  }
}

// optional .draiosproto.counter_syscall_errors syscall_errors = 9;
inline bool host::has_syscall_errors() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void host::set_has_syscall_errors() {
  _has_bits_[0] |= 0x00002000u;
}
inline void host::clear_has_syscall_errors() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void host::clear_syscall_errors() {
  if (syscall_errors_ != NULL) syscall_errors_->::draiosproto::counter_syscall_errors::Clear();
  clear_has_syscall_errors();
}
inline const ::draiosproto::counter_syscall_errors& host::syscall_errors() const {
  return syscall_errors_ != NULL ? *syscall_errors_ : *default_instance_->syscall_errors_;
}
inline ::draiosproto::counter_syscall_errors* host::mutable_syscall_errors() {
  set_has_syscall_errors();
  if (syscall_errors_ == NULL) syscall_errors_ = new ::draiosproto::counter_syscall_errors;
  return syscall_errors_;
}
inline ::draiosproto::counter_syscall_errors* host::release_syscall_errors() {
  clear_has_syscall_errors();
  ::draiosproto::counter_syscall_errors* temp = syscall_errors_;
  syscall_errors_ = NULL;
  return temp;
}
inline void host::set_allocated_syscall_errors(::draiosproto::counter_syscall_errors* syscall_errors) {
  delete syscall_errors_;
  syscall_errors_ = syscall_errors;
  if (syscall_errors) {
    set_has_syscall_errors();
  } else {
    clear_has_syscall_errors();
  }
}

// optional .draiosproto.counter_time_bytes external_io_net = 10;
inline bool host::has_external_io_net() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void host::set_has_external_io_net() {
  _has_bits_[0] |= 0x00004000u;
}
inline void host::clear_has_external_io_net() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void host::clear_external_io_net() {
  if (external_io_net_ != NULL) external_io_net_->::draiosproto::counter_time_bytes::Clear();
  clear_has_external_io_net();
}
inline const ::draiosproto::counter_time_bytes& host::external_io_net() const {
  return external_io_net_ != NULL ? *external_io_net_ : *default_instance_->external_io_net_;
}
inline ::draiosproto::counter_time_bytes* host::mutable_external_io_net() {
  set_has_external_io_net();
  if (external_io_net_ == NULL) external_io_net_ = new ::draiosproto::counter_time_bytes;
  return external_io_net_;
}
inline ::draiosproto::counter_time_bytes* host::release_external_io_net() {
  clear_has_external_io_net();
  ::draiosproto::counter_time_bytes* temp = external_io_net_;
  external_io_net_ = NULL;
  return temp;
}
inline void host::set_allocated_external_io_net(::draiosproto::counter_time_bytes* external_io_net) {
  delete external_io_net_;
  external_io_net_ = external_io_net;
  if (external_io_net) {
    set_has_external_io_net();
  } else {
    clear_has_external_io_net();
  }
}

// repeated .draiosproto.network_by_port network_by_serverports = 24;
inline int host::network_by_serverports_size() const {
  return network_by_serverports_.size();
}
inline void host::clear_network_by_serverports() {
  network_by_serverports_.Clear();
}
inline const ::draiosproto::network_by_port& host::network_by_serverports(int index) const {
  return network_by_serverports_.Get(index);
}
inline ::draiosproto::network_by_port* host::mutable_network_by_serverports(int index) {
  return network_by_serverports_.Mutable(index);
}
inline ::draiosproto::network_by_port* host::add_network_by_serverports() {
  return network_by_serverports_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::network_by_port >&
host::network_by_serverports() const {
  return network_by_serverports_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::network_by_port >*
host::mutable_network_by_serverports() {
  return &network_by_serverports_;
}

// -------------------------------------------------------------------

// process

// optional .draiosproto.process_details details = 2;
inline bool process::has_details() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void process::set_has_details() {
  _has_bits_[0] |= 0x00000001u;
}
inline void process::clear_has_details() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void process::clear_details() {
  if (details_ != NULL) details_->::draiosproto::process_details::Clear();
  clear_has_details();
}
inline const ::draiosproto::process_details& process::details() const {
  return details_ != NULL ? *details_ : *default_instance_->details_;
}
inline ::draiosproto::process_details* process::mutable_details() {
  set_has_details();
  if (details_ == NULL) details_ = new ::draiosproto::process_details;
  return details_;
}
inline ::draiosproto::process_details* process::release_details() {
  clear_has_details();
  ::draiosproto::process_details* temp = details_;
  details_ = NULL;
  return temp;
}
inline void process::set_allocated_details(::draiosproto::process_details* details) {
  delete details_;
  details_ = details;
  if (details) {
    set_has_details();
  } else {
    clear_has_details();
  }
}

// optional bool is_ipv4_transaction_server = 3;
inline bool process::has_is_ipv4_transaction_server() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void process::set_has_is_ipv4_transaction_server() {
  _has_bits_[0] |= 0x00000002u;
}
inline void process::clear_has_is_ipv4_transaction_server() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void process::clear_is_ipv4_transaction_server() {
  is_ipv4_transaction_server_ = false;
  clear_has_is_ipv4_transaction_server();
}
inline bool process::is_ipv4_transaction_server() const {
  return is_ipv4_transaction_server_;
}
inline void process::set_is_ipv4_transaction_server(bool value) {
  set_has_is_ipv4_transaction_server();
  is_ipv4_transaction_server_ = value;
}

// optional bool is_unix_transaction_server = 4;
inline bool process::has_is_unix_transaction_server() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void process::set_has_is_unix_transaction_server() {
  _has_bits_[0] |= 0x00000004u;
}
inline void process::clear_has_is_unix_transaction_server() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void process::clear_is_unix_transaction_server() {
  is_unix_transaction_server_ = false;
  clear_has_is_unix_transaction_server();
}
inline bool process::is_unix_transaction_server() const {
  return is_unix_transaction_server_;
}
inline void process::set_is_unix_transaction_server(bool value) {
  set_has_is_unix_transaction_server();
  is_unix_transaction_server_ = value;
}

// optional bool is_ipv4_transaction_client = 10;
inline bool process::has_is_ipv4_transaction_client() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void process::set_has_is_ipv4_transaction_client() {
  _has_bits_[0] |= 0x00000008u;
}
inline void process::clear_has_is_ipv4_transaction_client() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void process::clear_is_ipv4_transaction_client() {
  is_ipv4_transaction_client_ = false;
  clear_has_is_ipv4_transaction_client();
}
inline bool process::is_ipv4_transaction_client() const {
  return is_ipv4_transaction_client_;
}
inline void process::set_is_ipv4_transaction_client(bool value) {
  set_has_is_ipv4_transaction_client();
  is_ipv4_transaction_client_ = value;
}

// optional bool is_unix_transaction_client = 11;
inline bool process::has_is_unix_transaction_client() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void process::set_has_is_unix_transaction_client() {
  _has_bits_[0] |= 0x00000010u;
}
inline void process::clear_has_is_unix_transaction_client() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void process::clear_is_unix_transaction_client() {
  is_unix_transaction_client_ = false;
  clear_has_is_unix_transaction_client();
}
inline bool process::is_unix_transaction_client() const {
  return is_unix_transaction_client_;
}
inline void process::set_is_unix_transaction_client(bool value) {
  set_has_is_unix_transaction_client();
  is_unix_transaction_client_ = value;
}

// optional uint32 netrole = 13;
inline bool process::has_netrole() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void process::set_has_netrole() {
  _has_bits_[0] |= 0x00000020u;
}
inline void process::clear_has_netrole() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void process::clear_netrole() {
  netrole_ = 0u;
  clear_has_netrole();
}
inline ::google::protobuf::uint32 process::netrole() const {
  return netrole_;
}
inline void process::set_netrole(::google::protobuf::uint32 value) {
  set_has_netrole();
  netrole_ = value;
}

// optional .draiosproto.time_categories tcounters = 5;
inline bool process::has_tcounters() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void process::set_has_tcounters() {
  _has_bits_[0] |= 0x00000040u;
}
inline void process::clear_has_tcounters() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void process::clear_tcounters() {
  if (tcounters_ != NULL) tcounters_->::draiosproto::time_categories::Clear();
  clear_has_tcounters();
}
inline const ::draiosproto::time_categories& process::tcounters() const {
  return tcounters_ != NULL ? *tcounters_ : *default_instance_->tcounters_;
}
inline ::draiosproto::time_categories* process::mutable_tcounters() {
  set_has_tcounters();
  if (tcounters_ == NULL) tcounters_ = new ::draiosproto::time_categories;
  return tcounters_;
}
inline ::draiosproto::time_categories* process::release_tcounters() {
  clear_has_tcounters();
  ::draiosproto::time_categories* temp = tcounters_;
  tcounters_ = NULL;
  return temp;
}
inline void process::set_allocated_tcounters(::draiosproto::time_categories* tcounters) {
  delete tcounters_;
  tcounters_ = tcounters;
  if (tcounters) {
    set_has_tcounters();
  } else {
    clear_has_tcounters();
  }
}

// optional .draiosproto.counter_time_bidirectional transaction_counters = 6;
inline bool process::has_transaction_counters() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void process::set_has_transaction_counters() {
  _has_bits_[0] |= 0x00000080u;
}
inline void process::clear_has_transaction_counters() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void process::clear_transaction_counters() {
  if (transaction_counters_ != NULL) transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& process::transaction_counters() const {
  return transaction_counters_ != NULL ? *transaction_counters_ : *default_instance_->transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* process::mutable_transaction_counters() {
  set_has_transaction_counters();
  if (transaction_counters_ == NULL) transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  return transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* process::release_transaction_counters() {
  clear_has_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = transaction_counters_;
  transaction_counters_ = NULL;
  return temp;
}
inline void process::set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters) {
  delete transaction_counters_;
  transaction_counters_ = transaction_counters;
  if (transaction_counters) {
    set_has_transaction_counters();
  } else {
    clear_has_transaction_counters();
  }
}

// optional .draiosproto.counter_time_bidirectional min_transaction_counters = 18;
inline bool process::has_min_transaction_counters() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void process::set_has_min_transaction_counters() {
  _has_bits_[0] |= 0x00000100u;
}
inline void process::clear_has_min_transaction_counters() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void process::clear_min_transaction_counters() {
  if (min_transaction_counters_ != NULL) min_transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_min_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& process::min_transaction_counters() const {
  return min_transaction_counters_ != NULL ? *min_transaction_counters_ : *default_instance_->min_transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* process::mutable_min_transaction_counters() {
  set_has_min_transaction_counters();
  if (min_transaction_counters_ == NULL) min_transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  return min_transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* process::release_min_transaction_counters() {
  clear_has_min_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = min_transaction_counters_;
  min_transaction_counters_ = NULL;
  return temp;
}
inline void process::set_allocated_min_transaction_counters(::draiosproto::counter_time_bidirectional* min_transaction_counters) {
  delete min_transaction_counters_;
  min_transaction_counters_ = min_transaction_counters;
  if (min_transaction_counters) {
    set_has_min_transaction_counters();
  } else {
    clear_has_min_transaction_counters();
  }
}

// optional .draiosproto.counter_time_bidirectional max_transaction_counters = 19;
inline bool process::has_max_transaction_counters() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void process::set_has_max_transaction_counters() {
  _has_bits_[0] |= 0x00000200u;
}
inline void process::clear_has_max_transaction_counters() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void process::clear_max_transaction_counters() {
  if (max_transaction_counters_ != NULL) max_transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_max_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& process::max_transaction_counters() const {
  return max_transaction_counters_ != NULL ? *max_transaction_counters_ : *default_instance_->max_transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* process::mutable_max_transaction_counters() {
  set_has_max_transaction_counters();
  if (max_transaction_counters_ == NULL) max_transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  return max_transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* process::release_max_transaction_counters() {
  clear_has_max_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = max_transaction_counters_;
  max_transaction_counters_ = NULL;
  return temp;
}
inline void process::set_allocated_max_transaction_counters(::draiosproto::counter_time_bidirectional* max_transaction_counters) {
  delete max_transaction_counters_;
  max_transaction_counters_ = max_transaction_counters;
  if (max_transaction_counters) {
    set_has_max_transaction_counters();
  } else {
    clear_has_max_transaction_counters();
  }
}

// optional uint64 transaction_processing_delay = 7;
inline bool process::has_transaction_processing_delay() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void process::set_has_transaction_processing_delay() {
  _has_bits_[0] |= 0x00000400u;
}
inline void process::clear_has_transaction_processing_delay() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void process::clear_transaction_processing_delay() {
  transaction_processing_delay_ = GOOGLE_ULONGLONG(0);
  clear_has_transaction_processing_delay();
}
inline ::google::protobuf::uint64 process::transaction_processing_delay() const {
  return transaction_processing_delay_;
}
inline void process::set_transaction_processing_delay(::google::protobuf::uint64 value) {
  set_has_transaction_processing_delay();
  transaction_processing_delay_ = value;
}

// optional uint64 next_tiers_delay = 12;
inline bool process::has_next_tiers_delay() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void process::set_has_next_tiers_delay() {
  _has_bits_[0] |= 0x00000800u;
}
inline void process::clear_has_next_tiers_delay() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void process::clear_next_tiers_delay() {
  next_tiers_delay_ = GOOGLE_ULONGLONG(0);
  clear_has_next_tiers_delay();
}
inline ::google::protobuf::uint64 process::next_tiers_delay() const {
  return next_tiers_delay_;
}
inline void process::set_next_tiers_delay(::google::protobuf::uint64 value) {
  set_has_next_tiers_delay();
  next_tiers_delay_ = value;
}

// optional .draiosproto.resource_categories resource_counters = 8;
inline bool process::has_resource_counters() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void process::set_has_resource_counters() {
  _has_bits_[0] |= 0x00001000u;
}
inline void process::clear_has_resource_counters() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void process::clear_resource_counters() {
  if (resource_counters_ != NULL) resource_counters_->::draiosproto::resource_categories::Clear();
  clear_has_resource_counters();
}
inline const ::draiosproto::resource_categories& process::resource_counters() const {
  return resource_counters_ != NULL ? *resource_counters_ : *default_instance_->resource_counters_;
}
inline ::draiosproto::resource_categories* process::mutable_resource_counters() {
  set_has_resource_counters();
  if (resource_counters_ == NULL) resource_counters_ = new ::draiosproto::resource_categories;
  return resource_counters_;
}
inline ::draiosproto::resource_categories* process::release_resource_counters() {
  clear_has_resource_counters();
  ::draiosproto::resource_categories* temp = resource_counters_;
  resource_counters_ = NULL;
  return temp;
}
inline void process::set_allocated_resource_counters(::draiosproto::resource_categories* resource_counters) {
  delete resource_counters_;
  resource_counters_ = resource_counters;
  if (resource_counters) {
    set_has_resource_counters();
  } else {
    clear_has_resource_counters();
  }
}

// optional .draiosproto.counter_syscall_errors syscall_errors = 9;
inline bool process::has_syscall_errors() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void process::set_has_syscall_errors() {
  _has_bits_[0] |= 0x00002000u;
}
inline void process::clear_has_syscall_errors() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void process::clear_syscall_errors() {
  if (syscall_errors_ != NULL) syscall_errors_->::draiosproto::counter_syscall_errors::Clear();
  clear_has_syscall_errors();
}
inline const ::draiosproto::counter_syscall_errors& process::syscall_errors() const {
  return syscall_errors_ != NULL ? *syscall_errors_ : *default_instance_->syscall_errors_;
}
inline ::draiosproto::counter_syscall_errors* process::mutable_syscall_errors() {
  set_has_syscall_errors();
  if (syscall_errors_ == NULL) syscall_errors_ = new ::draiosproto::counter_syscall_errors;
  return syscall_errors_;
}
inline ::draiosproto::counter_syscall_errors* process::release_syscall_errors() {
  clear_has_syscall_errors();
  ::draiosproto::counter_syscall_errors* temp = syscall_errors_;
  syscall_errors_ = NULL;
  return temp;
}
inline void process::set_allocated_syscall_errors(::draiosproto::counter_syscall_errors* syscall_errors) {
  delete syscall_errors_;
  syscall_errors_ = syscall_errors;
  if (syscall_errors) {
    set_has_syscall_errors();
  } else {
    clear_has_syscall_errors();
  }
}

// optional .draiosproto.proto_info protos = 20;
inline bool process::has_protos() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void process::set_has_protos() {
  _has_bits_[0] |= 0x00004000u;
}
inline void process::clear_has_protos() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void process::clear_protos() {
  if (protos_ != NULL) protos_->::draiosproto::proto_info::Clear();
  clear_has_protos();
}
inline const ::draiosproto::proto_info& process::protos() const {
  return protos_ != NULL ? *protos_ : *default_instance_->protos_;
}
inline ::draiosproto::proto_info* process::mutable_protos() {
  set_has_protos();
  if (protos_ == NULL) protos_ = new ::draiosproto::proto_info;
  return protos_;
}
inline ::draiosproto::proto_info* process::release_protos() {
  clear_has_protos();
  ::draiosproto::proto_info* temp = protos_;
  protos_ = NULL;
  return temp;
}
inline void process::set_allocated_protos(::draiosproto::proto_info* protos) {
  delete protos_;
  protos_ = protos;
  if (protos) {
    set_has_protos();
  } else {
    clear_has_protos();
  }
}

// optional uint64 start_count = 21;
inline bool process::has_start_count() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void process::set_has_start_count() {
  _has_bits_[0] |= 0x00008000u;
}
inline void process::clear_has_start_count() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void process::clear_start_count() {
  start_count_ = GOOGLE_ULONGLONG(0);
  clear_has_start_count();
}
inline ::google::protobuf::uint64 process::start_count() const {
  return start_count_;
}
inline void process::set_start_count(::google::protobuf::uint64 value) {
  set_has_start_count();
  start_count_ = value;
}

// -------------------------------------------------------------------

// program

// required .draiosproto.process procinfo = 1;
inline bool program::has_procinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void program::set_has_procinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void program::clear_has_procinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void program::clear_procinfo() {
  if (procinfo_ != NULL) procinfo_->::draiosproto::process::Clear();
  clear_has_procinfo();
}
inline const ::draiosproto::process& program::procinfo() const {
  return procinfo_ != NULL ? *procinfo_ : *default_instance_->procinfo_;
}
inline ::draiosproto::process* program::mutable_procinfo() {
  set_has_procinfo();
  if (procinfo_ == NULL) procinfo_ = new ::draiosproto::process;
  return procinfo_;
}
inline ::draiosproto::process* program::release_procinfo() {
  clear_has_procinfo();
  ::draiosproto::process* temp = procinfo_;
  procinfo_ = NULL;
  return temp;
}
inline void program::set_allocated_procinfo(::draiosproto::process* procinfo) {
  delete procinfo_;
  procinfo_ = procinfo;
  if (procinfo) {
    set_has_procinfo();
  } else {
    clear_has_procinfo();
  }
}

// repeated uint64 pids = 2;
inline int program::pids_size() const {
  return pids_.size();
}
inline void program::clear_pids() {
  pids_.Clear();
}
inline ::google::protobuf::uint64 program::pids(int index) const {
  return pids_.Get(index);
}
inline void program::set_pids(int index, ::google::protobuf::uint64 value) {
  pids_.Set(index, value);
}
inline void program::add_pids(::google::protobuf::uint64 value) {
  pids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
program::pids() const {
  return pids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
program::mutable_pids() {
  return &pids_;
}

// -------------------------------------------------------------------

// ipv4tuple

// required uint32 sip = 1;
inline bool ipv4tuple::has_sip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ipv4tuple::set_has_sip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ipv4tuple::clear_has_sip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ipv4tuple::clear_sip() {
  sip_ = 0u;
  clear_has_sip();
}
inline ::google::protobuf::uint32 ipv4tuple::sip() const {
  return sip_;
}
inline void ipv4tuple::set_sip(::google::protobuf::uint32 value) {
  set_has_sip();
  sip_ = value;
}

// required uint32 dip = 2;
inline bool ipv4tuple::has_dip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ipv4tuple::set_has_dip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ipv4tuple::clear_has_dip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ipv4tuple::clear_dip() {
  dip_ = 0u;
  clear_has_dip();
}
inline ::google::protobuf::uint32 ipv4tuple::dip() const {
  return dip_;
}
inline void ipv4tuple::set_dip(::google::protobuf::uint32 value) {
  set_has_dip();
  dip_ = value;
}

// required uint32 sport = 3;
inline bool ipv4tuple::has_sport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ipv4tuple::set_has_sport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ipv4tuple::clear_has_sport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ipv4tuple::clear_sport() {
  sport_ = 0u;
  clear_has_sport();
}
inline ::google::protobuf::uint32 ipv4tuple::sport() const {
  return sport_;
}
inline void ipv4tuple::set_sport(::google::protobuf::uint32 value) {
  set_has_sport();
  sport_ = value;
}

// required uint32 dport = 4;
inline bool ipv4tuple::has_dport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ipv4tuple::set_has_dport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ipv4tuple::clear_has_dport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ipv4tuple::clear_dport() {
  dport_ = 0u;
  clear_has_dport();
}
inline ::google::protobuf::uint32 ipv4tuple::dport() const {
  return dport_;
}
inline void ipv4tuple::set_dport(::google::protobuf::uint32 value) {
  set_has_dport();
  dport_ = value;
}

// required uint32 l4proto = 5;
inline bool ipv4tuple::has_l4proto() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ipv4tuple::set_has_l4proto() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ipv4tuple::clear_has_l4proto() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ipv4tuple::clear_l4proto() {
  l4proto_ = 0u;
  clear_has_l4proto();
}
inline ::google::protobuf::uint32 ipv4tuple::l4proto() const {
  return l4proto_;
}
inline void ipv4tuple::set_l4proto(::google::protobuf::uint32 value) {
  set_has_l4proto();
  l4proto_ = value;
}

// -------------------------------------------------------------------

// ipv4_connection

// required .draiosproto.ipv4tuple tuple = 1;
inline bool ipv4_connection::has_tuple() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ipv4_connection::set_has_tuple() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ipv4_connection::clear_has_tuple() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ipv4_connection::clear_tuple() {
  if (tuple_ != NULL) tuple_->::draiosproto::ipv4tuple::Clear();
  clear_has_tuple();
}
inline const ::draiosproto::ipv4tuple& ipv4_connection::tuple() const {
  return tuple_ != NULL ? *tuple_ : *default_instance_->tuple_;
}
inline ::draiosproto::ipv4tuple* ipv4_connection::mutable_tuple() {
  set_has_tuple();
  if (tuple_ == NULL) tuple_ = new ::draiosproto::ipv4tuple;
  return tuple_;
}
inline ::draiosproto::ipv4tuple* ipv4_connection::release_tuple() {
  clear_has_tuple();
  ::draiosproto::ipv4tuple* temp = tuple_;
  tuple_ = NULL;
  return temp;
}
inline void ipv4_connection::set_allocated_tuple(::draiosproto::ipv4tuple* tuple) {
  delete tuple_;
  tuple_ = tuple;
  if (tuple) {
    set_has_tuple();
  } else {
    clear_has_tuple();
  }
}

// optional uint64 spid = 2;
inline bool ipv4_connection::has_spid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ipv4_connection::set_has_spid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ipv4_connection::clear_has_spid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ipv4_connection::clear_spid() {
  spid_ = GOOGLE_ULONGLONG(0);
  clear_has_spid();
}
inline ::google::protobuf::uint64 ipv4_connection::spid() const {
  return spid_;
}
inline void ipv4_connection::set_spid(::google::protobuf::uint64 value) {
  set_has_spid();
  spid_ = value;
}

// optional uint64 dpid = 5;
inline bool ipv4_connection::has_dpid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ipv4_connection::set_has_dpid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ipv4_connection::clear_has_dpid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ipv4_connection::clear_dpid() {
  dpid_ = GOOGLE_ULONGLONG(0);
  clear_has_dpid();
}
inline ::google::protobuf::uint64 ipv4_connection::dpid() const {
  return dpid_;
}
inline void ipv4_connection::set_dpid(::google::protobuf::uint64 value) {
  set_has_dpid();
  dpid_ = value;
}

// required .draiosproto.connection_categories counters = 8;
inline bool ipv4_connection::has_counters() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ipv4_connection::set_has_counters() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ipv4_connection::clear_has_counters() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ipv4_connection::clear_counters() {
  if (counters_ != NULL) counters_->::draiosproto::connection_categories::Clear();
  clear_has_counters();
}
inline const ::draiosproto::connection_categories& ipv4_connection::counters() const {
  return counters_ != NULL ? *counters_ : *default_instance_->counters_;
}
inline ::draiosproto::connection_categories* ipv4_connection::mutable_counters() {
  set_has_counters();
  if (counters_ == NULL) counters_ = new ::draiosproto::connection_categories;
  return counters_;
}
inline ::draiosproto::connection_categories* ipv4_connection::release_counters() {
  clear_has_counters();
  ::draiosproto::connection_categories* temp = counters_;
  counters_ = NULL;
  return temp;
}
inline void ipv4_connection::set_allocated_counters(::draiosproto::connection_categories* counters) {
  delete counters_;
  counters_ = counters;
  if (counters) {
    set_has_counters();
  } else {
    clear_has_counters();
  }
}

// -------------------------------------------------------------------

// ipv4_network_interface

// required string name = 1;
inline bool ipv4_network_interface::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ipv4_network_interface::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ipv4_network_interface::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ipv4_network_interface::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ipv4_network_interface::name() const {
  return *name_;
}
inline void ipv4_network_interface::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ipv4_network_interface::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ipv4_network_interface::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ipv4_network_interface::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ipv4_network_interface::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ipv4_network_interface::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 addr = 2;
inline bool ipv4_network_interface::has_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ipv4_network_interface::set_has_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ipv4_network_interface::clear_has_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ipv4_network_interface::clear_addr() {
  addr_ = 0u;
  clear_has_addr();
}
inline ::google::protobuf::uint32 ipv4_network_interface::addr() const {
  return addr_;
}
inline void ipv4_network_interface::set_addr(::google::protobuf::uint32 value) {
  set_has_addr();
  addr_ = value;
}

// required uint32 netmask = 3;
inline bool ipv4_network_interface::has_netmask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ipv4_network_interface::set_has_netmask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ipv4_network_interface::clear_has_netmask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ipv4_network_interface::clear_netmask() {
  netmask_ = 0u;
  clear_has_netmask();
}
inline ::google::protobuf::uint32 ipv4_network_interface::netmask() const {
  return netmask_;
}
inline void ipv4_network_interface::set_netmask(::google::protobuf::uint32 value) {
  set_has_netmask();
  netmask_ = value;
}

// optional uint32 bcast = 4;
inline bool ipv4_network_interface::has_bcast() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ipv4_network_interface::set_has_bcast() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ipv4_network_interface::clear_has_bcast() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ipv4_network_interface::clear_bcast() {
  bcast_ = 0u;
  clear_has_bcast();
}
inline ::google::protobuf::uint32 ipv4_network_interface::bcast() const {
  return bcast_;
}
inline void ipv4_network_interface::set_bcast(::google::protobuf::uint32 value) {
  set_has_bcast();
  bcast_ = value;
}

// -------------------------------------------------------------------

// mounted_fs

// required string device = 1;
inline bool mounted_fs::has_device() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mounted_fs::set_has_device() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mounted_fs::clear_has_device() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mounted_fs::clear_device() {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    device_->clear();
  }
  clear_has_device();
}
inline const ::std::string& mounted_fs::device() const {
  return *device_;
}
inline void mounted_fs::set_device(const ::std::string& value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void mounted_fs::set_device(const char* value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void mounted_fs::set_device(const char* value, size_t size) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mounted_fs::mutable_device() {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  return device_;
}
inline ::std::string* mounted_fs::release_device() {
  clear_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_;
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mounted_fs::set_allocated_device(::std::string* device) {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    delete device_;
  }
  if (device) {
    set_has_device();
    device_ = device;
  } else {
    clear_has_device();
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string mount_dir = 2;
inline bool mounted_fs::has_mount_dir() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mounted_fs::set_has_mount_dir() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mounted_fs::clear_has_mount_dir() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mounted_fs::clear_mount_dir() {
  if (mount_dir_ != &::google::protobuf::internal::kEmptyString) {
    mount_dir_->clear();
  }
  clear_has_mount_dir();
}
inline const ::std::string& mounted_fs::mount_dir() const {
  return *mount_dir_;
}
inline void mounted_fs::set_mount_dir(const ::std::string& value) {
  set_has_mount_dir();
  if (mount_dir_ == &::google::protobuf::internal::kEmptyString) {
    mount_dir_ = new ::std::string;
  }
  mount_dir_->assign(value);
}
inline void mounted_fs::set_mount_dir(const char* value) {
  set_has_mount_dir();
  if (mount_dir_ == &::google::protobuf::internal::kEmptyString) {
    mount_dir_ = new ::std::string;
  }
  mount_dir_->assign(value);
}
inline void mounted_fs::set_mount_dir(const char* value, size_t size) {
  set_has_mount_dir();
  if (mount_dir_ == &::google::protobuf::internal::kEmptyString) {
    mount_dir_ = new ::std::string;
  }
  mount_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mounted_fs::mutable_mount_dir() {
  set_has_mount_dir();
  if (mount_dir_ == &::google::protobuf::internal::kEmptyString) {
    mount_dir_ = new ::std::string;
  }
  return mount_dir_;
}
inline ::std::string* mounted_fs::release_mount_dir() {
  clear_has_mount_dir();
  if (mount_dir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mount_dir_;
    mount_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mounted_fs::set_allocated_mount_dir(::std::string* mount_dir) {
  if (mount_dir_ != &::google::protobuf::internal::kEmptyString) {
    delete mount_dir_;
  }
  if (mount_dir) {
    set_has_mount_dir();
    mount_dir_ = mount_dir;
  } else {
    clear_has_mount_dir();
    mount_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string type = 3;
inline bool mounted_fs::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mounted_fs::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mounted_fs::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mounted_fs::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& mounted_fs::type() const {
  return *type_;
}
inline void mounted_fs::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void mounted_fs::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void mounted_fs::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mounted_fs::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* mounted_fs::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mounted_fs::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 size_bytes = 4;
inline bool mounted_fs::has_size_bytes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void mounted_fs::set_has_size_bytes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void mounted_fs::clear_has_size_bytes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void mounted_fs::clear_size_bytes() {
  size_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_size_bytes();
}
inline ::google::protobuf::uint64 mounted_fs::size_bytes() const {
  return size_bytes_;
}
inline void mounted_fs::set_size_bytes(::google::protobuf::uint64 value) {
  set_has_size_bytes();
  size_bytes_ = value;
}

// required uint64 used_bytes = 5;
inline bool mounted_fs::has_used_bytes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void mounted_fs::set_has_used_bytes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void mounted_fs::clear_has_used_bytes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void mounted_fs::clear_used_bytes() {
  used_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_used_bytes();
}
inline ::google::protobuf::uint64 mounted_fs::used_bytes() const {
  return used_bytes_;
}
inline void mounted_fs::set_used_bytes(::google::protobuf::uint64 value) {
  set_has_used_bytes();
  used_bytes_ = value;
}

// required uint64 available_bytes = 6;
inline bool mounted_fs::has_available_bytes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void mounted_fs::set_has_available_bytes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void mounted_fs::clear_has_available_bytes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void mounted_fs::clear_available_bytes() {
  available_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_available_bytes();
}
inline ::google::protobuf::uint64 mounted_fs::available_bytes() const {
  return available_bytes_;
}
inline void mounted_fs::set_available_bytes(::google::protobuf::uint64 value) {
  set_has_available_bytes();
  available_bytes_ = value;
}

// -------------------------------------------------------------------

// file_stat

// required string name = 1;
inline bool file_stat::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void file_stat::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void file_stat::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void file_stat::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& file_stat::name() const {
  return *name_;
}
inline void file_stat::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void file_stat::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void file_stat::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* file_stat::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* file_stat::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void file_stat::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 bytes = 2;
inline bool file_stat::has_bytes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void file_stat::set_has_bytes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void file_stat::clear_has_bytes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void file_stat::clear_bytes() {
  bytes_ = 0u;
  clear_has_bytes();
}
inline ::google::protobuf::uint32 file_stat::bytes() const {
  return bytes_;
}
inline void file_stat::set_bytes(::google::protobuf::uint32 value) {
  set_has_bytes();
  bytes_ = value;
}

// required uint64 time_ns = 3;
inline bool file_stat::has_time_ns() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void file_stat::set_has_time_ns() {
  _has_bits_[0] |= 0x00000004u;
}
inline void file_stat::clear_has_time_ns() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void file_stat::clear_time_ns() {
  time_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_time_ns();
}
inline ::google::protobuf::uint64 file_stat::time_ns() const {
  return time_ns_;
}
inline void file_stat::set_time_ns(::google::protobuf::uint64 value) {
  set_has_time_ns();
  time_ns_ = value;
}

// required uint32 open_count = 4;
inline bool file_stat::has_open_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void file_stat::set_has_open_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void file_stat::clear_has_open_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void file_stat::clear_open_count() {
  open_count_ = 0u;
  clear_has_open_count();
}
inline ::google::protobuf::uint32 file_stat::open_count() const {
  return open_count_;
}
inline void file_stat::set_open_count(::google::protobuf::uint32 value) {
  set_has_open_count();
  open_count_ = value;
}

// required uint32 errors = 5;
inline bool file_stat::has_errors() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void file_stat::set_has_errors() {
  _has_bits_[0] |= 0x00000010u;
}
inline void file_stat::clear_has_errors() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void file_stat::clear_errors() {
  errors_ = 0u;
  clear_has_errors();
}
inline ::google::protobuf::uint32 file_stat::errors() const {
  return errors_;
}
inline void file_stat::set_errors(::google::protobuf::uint32 value) {
  set_has_errors();
  errors_ = value;
}

// -------------------------------------------------------------------

// container_port_mapping

// optional uint32 host_ip = 1;
inline bool container_port_mapping::has_host_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void container_port_mapping::set_has_host_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void container_port_mapping::clear_has_host_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void container_port_mapping::clear_host_ip() {
  host_ip_ = 0u;
  clear_has_host_ip();
}
inline ::google::protobuf::uint32 container_port_mapping::host_ip() const {
  return host_ip_;
}
inline void container_port_mapping::set_host_ip(::google::protobuf::uint32 value) {
  set_has_host_ip();
  host_ip_ = value;
}

// optional uint32 host_port = 2;
inline bool container_port_mapping::has_host_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void container_port_mapping::set_has_host_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void container_port_mapping::clear_has_host_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void container_port_mapping::clear_host_port() {
  host_port_ = 0u;
  clear_has_host_port();
}
inline ::google::protobuf::uint32 container_port_mapping::host_port() const {
  return host_port_;
}
inline void container_port_mapping::set_host_port(::google::protobuf::uint32 value) {
  set_has_host_port();
  host_port_ = value;
}

// optional uint32 container_ip = 3;
inline bool container_port_mapping::has_container_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void container_port_mapping::set_has_container_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void container_port_mapping::clear_has_container_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void container_port_mapping::clear_container_ip() {
  container_ip_ = 0u;
  clear_has_container_ip();
}
inline ::google::protobuf::uint32 container_port_mapping::container_ip() const {
  return container_ip_;
}
inline void container_port_mapping::set_container_ip(::google::protobuf::uint32 value) {
  set_has_container_ip();
  container_ip_ = value;
}

// optional uint32 container_port = 4;
inline bool container_port_mapping::has_container_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void container_port_mapping::set_has_container_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void container_port_mapping::clear_has_container_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void container_port_mapping::clear_container_port() {
  container_port_ = 0u;
  clear_has_container_port();
}
inline ::google::protobuf::uint32 container_port_mapping::container_port() const {
  return container_port_;
}
inline void container_port_mapping::set_container_port(::google::protobuf::uint32 value) {
  set_has_container_port();
  container_port_ = value;
}

// -------------------------------------------------------------------

// container_label

// required string key = 1;
inline bool container_label::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void container_label::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void container_label::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void container_label::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& container_label::key() const {
  return *key_;
}
inline void container_label::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void container_label::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void container_label::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* container_label::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* container_label::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void container_label::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value = 2;
inline bool container_label::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void container_label::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void container_label::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void container_label::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& container_label::value() const {
  return *value_;
}
inline void container_label::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void container_label::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void container_label::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* container_label::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* container_label::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void container_label::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// container

// required string id = 1;
inline bool container::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void container::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void container::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void container::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& container::id() const {
  return *id_;
}
inline void container::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void container::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void container::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* container::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* container::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void container::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .draiosproto.container_type type = 2;
inline bool container::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void container::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void container::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void container::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::draiosproto::container_type container::type() const {
  return static_cast< ::draiosproto::container_type >(type_);
}
inline void container::set_type(::draiosproto::container_type value) {
  assert(::draiosproto::container_type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string name = 3;
inline bool container::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void container::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void container::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void container::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& container::name() const {
  return *name_;
}
inline void container::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void container::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void container::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* container::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* container::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void container::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string image = 4;
inline bool container::has_image() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void container::set_has_image() {
  _has_bits_[0] |= 0x00000008u;
}
inline void container::clear_has_image() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void container::clear_image() {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    image_->clear();
  }
  clear_has_image();
}
inline const ::std::string& container::image() const {
  return *image_;
}
inline void container::set_image(const ::std::string& value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void container::set_image(const char* value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void container::set_image(const char* value, size_t size) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* container::mutable_image() {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  return image_;
}
inline ::std::string* container::release_image() {
  clear_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_;
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void container::set_allocated_image(::std::string* image) {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    delete image_;
  }
  if (image) {
    set_has_image();
    image_ = image;
  } else {
    clear_has_image();
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .draiosproto.time_categories tcounters = 5;
inline bool container::has_tcounters() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void container::set_has_tcounters() {
  _has_bits_[0] |= 0x00000010u;
}
inline void container::clear_has_tcounters() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void container::clear_tcounters() {
  if (tcounters_ != NULL) tcounters_->::draiosproto::time_categories::Clear();
  clear_has_tcounters();
}
inline const ::draiosproto::time_categories& container::tcounters() const {
  return tcounters_ != NULL ? *tcounters_ : *default_instance_->tcounters_;
}
inline ::draiosproto::time_categories* container::mutable_tcounters() {
  set_has_tcounters();
  if (tcounters_ == NULL) tcounters_ = new ::draiosproto::time_categories;
  return tcounters_;
}
inline ::draiosproto::time_categories* container::release_tcounters() {
  clear_has_tcounters();
  ::draiosproto::time_categories* temp = tcounters_;
  tcounters_ = NULL;
  return temp;
}
inline void container::set_allocated_tcounters(::draiosproto::time_categories* tcounters) {
  delete tcounters_;
  tcounters_ = tcounters;
  if (tcounters) {
    set_has_tcounters();
  } else {
    clear_has_tcounters();
  }
}

// optional .draiosproto.transaction_breakdown_categories reqcounters = 6;
inline bool container::has_reqcounters() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void container::set_has_reqcounters() {
  _has_bits_[0] |= 0x00000020u;
}
inline void container::clear_has_reqcounters() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void container::clear_reqcounters() {
  if (reqcounters_ != NULL) reqcounters_->::draiosproto::transaction_breakdown_categories::Clear();
  clear_has_reqcounters();
}
inline const ::draiosproto::transaction_breakdown_categories& container::reqcounters() const {
  return reqcounters_ != NULL ? *reqcounters_ : *default_instance_->reqcounters_;
}
inline ::draiosproto::transaction_breakdown_categories* container::mutable_reqcounters() {
  set_has_reqcounters();
  if (reqcounters_ == NULL) reqcounters_ = new ::draiosproto::transaction_breakdown_categories;
  return reqcounters_;
}
inline ::draiosproto::transaction_breakdown_categories* container::release_reqcounters() {
  clear_has_reqcounters();
  ::draiosproto::transaction_breakdown_categories* temp = reqcounters_;
  reqcounters_ = NULL;
  return temp;
}
inline void container::set_allocated_reqcounters(::draiosproto::transaction_breakdown_categories* reqcounters) {
  delete reqcounters_;
  reqcounters_ = reqcounters;
  if (reqcounters) {
    set_has_reqcounters();
  } else {
    clear_has_reqcounters();
  }
}

// optional .draiosproto.counter_time_bidirectional transaction_counters = 7;
inline bool container::has_transaction_counters() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void container::set_has_transaction_counters() {
  _has_bits_[0] |= 0x00000040u;
}
inline void container::clear_has_transaction_counters() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void container::clear_transaction_counters() {
  if (transaction_counters_ != NULL) transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& container::transaction_counters() const {
  return transaction_counters_ != NULL ? *transaction_counters_ : *default_instance_->transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* container::mutable_transaction_counters() {
  set_has_transaction_counters();
  if (transaction_counters_ == NULL) transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  return transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* container::release_transaction_counters() {
  clear_has_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = transaction_counters_;
  transaction_counters_ = NULL;
  return temp;
}
inline void container::set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters) {
  delete transaction_counters_;
  transaction_counters_ = transaction_counters;
  if (transaction_counters) {
    set_has_transaction_counters();
  } else {
    clear_has_transaction_counters();
  }
}

// optional .draiosproto.counter_time_bidirectional min_transaction_counters = 8;
inline bool container::has_min_transaction_counters() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void container::set_has_min_transaction_counters() {
  _has_bits_[0] |= 0x00000080u;
}
inline void container::clear_has_min_transaction_counters() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void container::clear_min_transaction_counters() {
  if (min_transaction_counters_ != NULL) min_transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_min_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& container::min_transaction_counters() const {
  return min_transaction_counters_ != NULL ? *min_transaction_counters_ : *default_instance_->min_transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* container::mutable_min_transaction_counters() {
  set_has_min_transaction_counters();
  if (min_transaction_counters_ == NULL) min_transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  return min_transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* container::release_min_transaction_counters() {
  clear_has_min_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = min_transaction_counters_;
  min_transaction_counters_ = NULL;
  return temp;
}
inline void container::set_allocated_min_transaction_counters(::draiosproto::counter_time_bidirectional* min_transaction_counters) {
  delete min_transaction_counters_;
  min_transaction_counters_ = min_transaction_counters;
  if (min_transaction_counters) {
    set_has_min_transaction_counters();
  } else {
    clear_has_min_transaction_counters();
  }
}

// optional .draiosproto.counter_time_bidirectional max_transaction_counters = 9;
inline bool container::has_max_transaction_counters() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void container::set_has_max_transaction_counters() {
  _has_bits_[0] |= 0x00000100u;
}
inline void container::clear_has_max_transaction_counters() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void container::clear_max_transaction_counters() {
  if (max_transaction_counters_ != NULL) max_transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_max_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& container::max_transaction_counters() const {
  return max_transaction_counters_ != NULL ? *max_transaction_counters_ : *default_instance_->max_transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* container::mutable_max_transaction_counters() {
  set_has_max_transaction_counters();
  if (max_transaction_counters_ == NULL) max_transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  return max_transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* container::release_max_transaction_counters() {
  clear_has_max_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = max_transaction_counters_;
  max_transaction_counters_ = NULL;
  return temp;
}
inline void container::set_allocated_max_transaction_counters(::draiosproto::counter_time_bidirectional* max_transaction_counters) {
  delete max_transaction_counters_;
  max_transaction_counters_ = max_transaction_counters;
  if (max_transaction_counters) {
    set_has_max_transaction_counters();
  } else {
    clear_has_max_transaction_counters();
  }
}

// optional uint64 transaction_processing_delay = 10;
inline bool container::has_transaction_processing_delay() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void container::set_has_transaction_processing_delay() {
  _has_bits_[0] |= 0x00000200u;
}
inline void container::clear_has_transaction_processing_delay() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void container::clear_transaction_processing_delay() {
  transaction_processing_delay_ = GOOGLE_ULONGLONG(0);
  clear_has_transaction_processing_delay();
}
inline ::google::protobuf::uint64 container::transaction_processing_delay() const {
  return transaction_processing_delay_;
}
inline void container::set_transaction_processing_delay(::google::protobuf::uint64 value) {
  set_has_transaction_processing_delay();
  transaction_processing_delay_ = value;
}

// optional uint64 next_tiers_delay = 12;
inline bool container::has_next_tiers_delay() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void container::set_has_next_tiers_delay() {
  _has_bits_[0] |= 0x00000400u;
}
inline void container::clear_has_next_tiers_delay() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void container::clear_next_tiers_delay() {
  next_tiers_delay_ = GOOGLE_ULONGLONG(0);
  clear_has_next_tiers_delay();
}
inline ::google::protobuf::uint64 container::next_tiers_delay() const {
  return next_tiers_delay_;
}
inline void container::set_next_tiers_delay(::google::protobuf::uint64 value) {
  set_has_next_tiers_delay();
  next_tiers_delay_ = value;
}

// optional .draiosproto.resource_categories resource_counters = 13;
inline bool container::has_resource_counters() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void container::set_has_resource_counters() {
  _has_bits_[0] |= 0x00000800u;
}
inline void container::clear_has_resource_counters() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void container::clear_resource_counters() {
  if (resource_counters_ != NULL) resource_counters_->::draiosproto::resource_categories::Clear();
  clear_has_resource_counters();
}
inline const ::draiosproto::resource_categories& container::resource_counters() const {
  return resource_counters_ != NULL ? *resource_counters_ : *default_instance_->resource_counters_;
}
inline ::draiosproto::resource_categories* container::mutable_resource_counters() {
  set_has_resource_counters();
  if (resource_counters_ == NULL) resource_counters_ = new ::draiosproto::resource_categories;
  return resource_counters_;
}
inline ::draiosproto::resource_categories* container::release_resource_counters() {
  clear_has_resource_counters();
  ::draiosproto::resource_categories* temp = resource_counters_;
  resource_counters_ = NULL;
  return temp;
}
inline void container::set_allocated_resource_counters(::draiosproto::resource_categories* resource_counters) {
  delete resource_counters_;
  resource_counters_ = resource_counters;
  if (resource_counters) {
    set_has_resource_counters();
  } else {
    clear_has_resource_counters();
  }
}

// optional .draiosproto.counter_syscall_errors syscall_errors = 14;
inline bool container::has_syscall_errors() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void container::set_has_syscall_errors() {
  _has_bits_[0] |= 0x00001000u;
}
inline void container::clear_has_syscall_errors() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void container::clear_syscall_errors() {
  if (syscall_errors_ != NULL) syscall_errors_->::draiosproto::counter_syscall_errors::Clear();
  clear_has_syscall_errors();
}
inline const ::draiosproto::counter_syscall_errors& container::syscall_errors() const {
  return syscall_errors_ != NULL ? *syscall_errors_ : *default_instance_->syscall_errors_;
}
inline ::draiosproto::counter_syscall_errors* container::mutable_syscall_errors() {
  set_has_syscall_errors();
  if (syscall_errors_ == NULL) syscall_errors_ = new ::draiosproto::counter_syscall_errors;
  return syscall_errors_;
}
inline ::draiosproto::counter_syscall_errors* container::release_syscall_errors() {
  clear_has_syscall_errors();
  ::draiosproto::counter_syscall_errors* temp = syscall_errors_;
  syscall_errors_ = NULL;
  return temp;
}
inline void container::set_allocated_syscall_errors(::draiosproto::counter_syscall_errors* syscall_errors) {
  delete syscall_errors_;
  syscall_errors_ = syscall_errors;
  if (syscall_errors) {
    set_has_syscall_errors();
  } else {
    clear_has_syscall_errors();
  }
}

// repeated .draiosproto.container_port_mapping port_mappings = 18;
inline int container::port_mappings_size() const {
  return port_mappings_.size();
}
inline void container::clear_port_mappings() {
  port_mappings_.Clear();
}
inline const ::draiosproto::container_port_mapping& container::port_mappings(int index) const {
  return port_mappings_.Get(index);
}
inline ::draiosproto::container_port_mapping* container::mutable_port_mappings(int index) {
  return port_mappings_.Mutable(index);
}
inline ::draiosproto::container_port_mapping* container::add_port_mappings() {
  return port_mappings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::container_port_mapping >&
container::port_mappings() const {
  return port_mappings_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::container_port_mapping >*
container::mutable_port_mappings() {
  return &port_mappings_;
}

// optional .draiosproto.proto_info protos = 19;
inline bool container::has_protos() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void container::set_has_protos() {
  _has_bits_[0] |= 0x00004000u;
}
inline void container::clear_has_protos() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void container::clear_protos() {
  if (protos_ != NULL) protos_->::draiosproto::proto_info::Clear();
  clear_has_protos();
}
inline const ::draiosproto::proto_info& container::protos() const {
  return protos_ != NULL ? *protos_ : *default_instance_->protos_;
}
inline ::draiosproto::proto_info* container::mutable_protos() {
  set_has_protos();
  if (protos_ == NULL) protos_ = new ::draiosproto::proto_info;
  return protos_;
}
inline ::draiosproto::proto_info* container::release_protos() {
  clear_has_protos();
  ::draiosproto::proto_info* temp = protos_;
  protos_ = NULL;
  return temp;
}
inline void container::set_allocated_protos(::draiosproto::proto_info* protos) {
  delete protos_;
  protos_ = protos;
  if (protos) {
    set_has_protos();
  } else {
    clear_has_protos();
  }
}

// repeated .draiosproto.container_label labels = 20;
inline int container::labels_size() const {
  return labels_.size();
}
inline void container::clear_labels() {
  labels_.Clear();
}
inline const ::draiosproto::container_label& container::labels(int index) const {
  return labels_.Get(index);
}
inline ::draiosproto::container_label* container::mutable_labels(int index) {
  return labels_.Mutable(index);
}
inline ::draiosproto::container_label* container::add_labels() {
  return labels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::container_label >&
container::labels() const {
  return labels_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::container_label >*
container::mutable_labels() {
  return &labels_;
}

// repeated .draiosproto.mounted_fs mounts = 21;
inline int container::mounts_size() const {
  return mounts_.size();
}
inline void container::clear_mounts() {
  mounts_.Clear();
}
inline const ::draiosproto::mounted_fs& container::mounts(int index) const {
  return mounts_.Get(index);
}
inline ::draiosproto::mounted_fs* container::mutable_mounts(int index) {
  return mounts_.Mutable(index);
}
inline ::draiosproto::mounted_fs* container::add_mounts() {
  return mounts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mounted_fs >&
container::mounts() const {
  return mounts_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mounted_fs >*
container::mutable_mounts() {
  return &mounts_;
}

// repeated .draiosproto.network_by_port network_by_serverports = 22;
inline int container::network_by_serverports_size() const {
  return network_by_serverports_.size();
}
inline void container::clear_network_by_serverports() {
  network_by_serverports_.Clear();
}
inline const ::draiosproto::network_by_port& container::network_by_serverports(int index) const {
  return network_by_serverports_.Get(index);
}
inline ::draiosproto::network_by_port* container::mutable_network_by_serverports(int index) {
  return network_by_serverports_.Mutable(index);
}
inline ::draiosproto::network_by_port* container::add_network_by_serverports() {
  return network_by_serverports_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::network_by_port >&
container::network_by_serverports() const {
  return network_by_serverports_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::network_by_port >*
container::mutable_network_by_serverports() {
  return &network_by_serverports_;
}

// optional string mesos_task_id = 23;
inline bool container::has_mesos_task_id() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void container::set_has_mesos_task_id() {
  _has_bits_[0] |= 0x00040000u;
}
inline void container::clear_has_mesos_task_id() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void container::clear_mesos_task_id() {
  if (mesos_task_id_ != &::google::protobuf::internal::kEmptyString) {
    mesos_task_id_->clear();
  }
  clear_has_mesos_task_id();
}
inline const ::std::string& container::mesos_task_id() const {
  return *mesos_task_id_;
}
inline void container::set_mesos_task_id(const ::std::string& value) {
  set_has_mesos_task_id();
  if (mesos_task_id_ == &::google::protobuf::internal::kEmptyString) {
    mesos_task_id_ = new ::std::string;
  }
  mesos_task_id_->assign(value);
}
inline void container::set_mesos_task_id(const char* value) {
  set_has_mesos_task_id();
  if (mesos_task_id_ == &::google::protobuf::internal::kEmptyString) {
    mesos_task_id_ = new ::std::string;
  }
  mesos_task_id_->assign(value);
}
inline void container::set_mesos_task_id(const char* value, size_t size) {
  set_has_mesos_task_id();
  if (mesos_task_id_ == &::google::protobuf::internal::kEmptyString) {
    mesos_task_id_ = new ::std::string;
  }
  mesos_task_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* container::mutable_mesos_task_id() {
  set_has_mesos_task_id();
  if (mesos_task_id_ == &::google::protobuf::internal::kEmptyString) {
    mesos_task_id_ = new ::std::string;
  }
  return mesos_task_id_;
}
inline ::std::string* container::release_mesos_task_id() {
  clear_has_mesos_task_id();
  if (mesos_task_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mesos_task_id_;
    mesos_task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void container::set_allocated_mesos_task_id(::std::string* mesos_task_id) {
  if (mesos_task_id_ != &::google::protobuf::internal::kEmptyString) {
    delete mesos_task_id_;
  }
  if (mesos_task_id) {
    set_has_mesos_task_id();
    mesos_task_id_ = mesos_task_id;
  } else {
    clear_has_mesos_task_id();
    mesos_task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// k8s_pair

// required string key = 1;
inline bool k8s_pair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void k8s_pair::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void k8s_pair::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void k8s_pair::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& k8s_pair::key() const {
  return *key_;
}
inline void k8s_pair::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void k8s_pair::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void k8s_pair::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* k8s_pair::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* k8s_pair::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void k8s_pair::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool k8s_pair::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void k8s_pair::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void k8s_pair::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void k8s_pair::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& k8s_pair::value() const {
  return *value_;
}
inline void k8s_pair::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void k8s_pair::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void k8s_pair::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* k8s_pair::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* k8s_pair::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void k8s_pair::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// k8s_common

// required string name = 1;
inline bool k8s_common::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void k8s_common::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void k8s_common::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void k8s_common::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& k8s_common::name() const {
  return *name_;
}
inline void k8s_common::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void k8s_common::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void k8s_common::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* k8s_common::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* k8s_common::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void k8s_common::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string uid = 2;
inline bool k8s_common::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void k8s_common::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void k8s_common::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void k8s_common::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& k8s_common::uid() const {
  return *uid_;
}
inline void k8s_common::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void k8s_common::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void k8s_common::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* k8s_common::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* k8s_common::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void k8s_common::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string namespace = 3;
inline bool k8s_common::has_namespace_() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void k8s_common::set_has_namespace_() {
  _has_bits_[0] |= 0x00000004u;
}
inline void k8s_common::clear_has_namespace_() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void k8s_common::clear_namespace_() {
  if (namespace__ != &::google::protobuf::internal::kEmptyString) {
    namespace__->clear();
  }
  clear_has_namespace_();
}
inline const ::std::string& k8s_common::namespace_() const {
  return *namespace__;
}
inline void k8s_common::set_namespace_(const ::std::string& value) {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::kEmptyString) {
    namespace__ = new ::std::string;
  }
  namespace__->assign(value);
}
inline void k8s_common::set_namespace_(const char* value) {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::kEmptyString) {
    namespace__ = new ::std::string;
  }
  namespace__->assign(value);
}
inline void k8s_common::set_namespace_(const char* value, size_t size) {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::kEmptyString) {
    namespace__ = new ::std::string;
  }
  namespace__->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* k8s_common::mutable_namespace_() {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::kEmptyString) {
    namespace__ = new ::std::string;
  }
  return namespace__;
}
inline ::std::string* k8s_common::release_namespace_() {
  clear_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = namespace__;
    namespace__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void k8s_common::set_allocated_namespace_(::std::string* namespace_) {
  if (namespace__ != &::google::protobuf::internal::kEmptyString) {
    delete namespace__;
  }
  if (namespace_) {
    set_has_namespace_();
    namespace__ = namespace_;
  } else {
    clear_has_namespace_();
    namespace__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .draiosproto.k8s_pair labels = 4;
inline int k8s_common::labels_size() const {
  return labels_.size();
}
inline void k8s_common::clear_labels() {
  labels_.Clear();
}
inline const ::draiosproto::k8s_pair& k8s_common::labels(int index) const {
  return labels_.Get(index);
}
inline ::draiosproto::k8s_pair* k8s_common::mutable_labels(int index) {
  return labels_.Mutable(index);
}
inline ::draiosproto::k8s_pair* k8s_common::add_labels() {
  return labels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pair >&
k8s_common::labels() const {
  return labels_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pair >*
k8s_common::mutable_labels() {
  return &labels_;
}

// repeated .draiosproto.k8s_pair selectors = 5;
inline int k8s_common::selectors_size() const {
  return selectors_.size();
}
inline void k8s_common::clear_selectors() {
  selectors_.Clear();
}
inline const ::draiosproto::k8s_pair& k8s_common::selectors(int index) const {
  return selectors_.Get(index);
}
inline ::draiosproto::k8s_pair* k8s_common::mutable_selectors(int index) {
  return selectors_.Mutable(index);
}
inline ::draiosproto::k8s_pair* k8s_common::add_selectors() {
  return selectors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pair >&
k8s_common::selectors() const {
  return selectors_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pair >*
k8s_common::mutable_selectors() {
  return &selectors_;
}

// -------------------------------------------------------------------

// k8s_namespace

// required .draiosproto.k8s_common common = 1;
inline bool k8s_namespace::has_common() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void k8s_namespace::set_has_common() {
  _has_bits_[0] |= 0x00000001u;
}
inline void k8s_namespace::clear_has_common() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void k8s_namespace::clear_common() {
  if (common_ != NULL) common_->::draiosproto::k8s_common::Clear();
  clear_has_common();
}
inline const ::draiosproto::k8s_common& k8s_namespace::common() const {
  return common_ != NULL ? *common_ : *default_instance_->common_;
}
inline ::draiosproto::k8s_common* k8s_namespace::mutable_common() {
  set_has_common();
  if (common_ == NULL) common_ = new ::draiosproto::k8s_common;
  return common_;
}
inline ::draiosproto::k8s_common* k8s_namespace::release_common() {
  clear_has_common();
  ::draiosproto::k8s_common* temp = common_;
  common_ = NULL;
  return temp;
}
inline void k8s_namespace::set_allocated_common(::draiosproto::k8s_common* common) {
  delete common_;
  common_ = common;
  if (common) {
    set_has_common();
  } else {
    clear_has_common();
  }
}

// -------------------------------------------------------------------

// k8s_node

// required .draiosproto.k8s_common common = 1;
inline bool k8s_node::has_common() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void k8s_node::set_has_common() {
  _has_bits_[0] |= 0x00000001u;
}
inline void k8s_node::clear_has_common() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void k8s_node::clear_common() {
  if (common_ != NULL) common_->::draiosproto::k8s_common::Clear();
  clear_has_common();
}
inline const ::draiosproto::k8s_common& k8s_node::common() const {
  return common_ != NULL ? *common_ : *default_instance_->common_;
}
inline ::draiosproto::k8s_common* k8s_node::mutable_common() {
  set_has_common();
  if (common_ == NULL) common_ = new ::draiosproto::k8s_common;
  return common_;
}
inline ::draiosproto::k8s_common* k8s_node::release_common() {
  clear_has_common();
  ::draiosproto::k8s_common* temp = common_;
  common_ = NULL;
  return temp;
}
inline void k8s_node::set_allocated_common(::draiosproto::k8s_common* common) {
  delete common_;
  common_ = common;
  if (common) {
    set_has_common();
  } else {
    clear_has_common();
  }
}

// repeated string host_ips = 2;
inline int k8s_node::host_ips_size() const {
  return host_ips_.size();
}
inline void k8s_node::clear_host_ips() {
  host_ips_.Clear();
}
inline const ::std::string& k8s_node::host_ips(int index) const {
  return host_ips_.Get(index);
}
inline ::std::string* k8s_node::mutable_host_ips(int index) {
  return host_ips_.Mutable(index);
}
inline void k8s_node::set_host_ips(int index, const ::std::string& value) {
  host_ips_.Mutable(index)->assign(value);
}
inline void k8s_node::set_host_ips(int index, const char* value) {
  host_ips_.Mutable(index)->assign(value);
}
inline void k8s_node::set_host_ips(int index, const char* value, size_t size) {
  host_ips_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* k8s_node::add_host_ips() {
  return host_ips_.Add();
}
inline void k8s_node::add_host_ips(const ::std::string& value) {
  host_ips_.Add()->assign(value);
}
inline void k8s_node::add_host_ips(const char* value) {
  host_ips_.Add()->assign(value);
}
inline void k8s_node::add_host_ips(const char* value, size_t size) {
  host_ips_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
k8s_node::host_ips() const {
  return host_ips_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
k8s_node::mutable_host_ips() {
  return &host_ips_;
}

// -------------------------------------------------------------------

// k8s_pod

// required .draiosproto.k8s_common common = 1;
inline bool k8s_pod::has_common() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void k8s_pod::set_has_common() {
  _has_bits_[0] |= 0x00000001u;
}
inline void k8s_pod::clear_has_common() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void k8s_pod::clear_common() {
  if (common_ != NULL) common_->::draiosproto::k8s_common::Clear();
  clear_has_common();
}
inline const ::draiosproto::k8s_common& k8s_pod::common() const {
  return common_ != NULL ? *common_ : *default_instance_->common_;
}
inline ::draiosproto::k8s_common* k8s_pod::mutable_common() {
  set_has_common();
  if (common_ == NULL) common_ = new ::draiosproto::k8s_common;
  return common_;
}
inline ::draiosproto::k8s_common* k8s_pod::release_common() {
  clear_has_common();
  ::draiosproto::k8s_common* temp = common_;
  common_ = NULL;
  return temp;
}
inline void k8s_pod::set_allocated_common(::draiosproto::k8s_common* common) {
  delete common_;
  common_ = common;
  if (common) {
    set_has_common();
  } else {
    clear_has_common();
  }
}

// repeated string container_ids = 2;
inline int k8s_pod::container_ids_size() const {
  return container_ids_.size();
}
inline void k8s_pod::clear_container_ids() {
  container_ids_.Clear();
}
inline const ::std::string& k8s_pod::container_ids(int index) const {
  return container_ids_.Get(index);
}
inline ::std::string* k8s_pod::mutable_container_ids(int index) {
  return container_ids_.Mutable(index);
}
inline void k8s_pod::set_container_ids(int index, const ::std::string& value) {
  container_ids_.Mutable(index)->assign(value);
}
inline void k8s_pod::set_container_ids(int index, const char* value) {
  container_ids_.Mutable(index)->assign(value);
}
inline void k8s_pod::set_container_ids(int index, const char* value, size_t size) {
  container_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* k8s_pod::add_container_ids() {
  return container_ids_.Add();
}
inline void k8s_pod::add_container_ids(const ::std::string& value) {
  container_ids_.Add()->assign(value);
}
inline void k8s_pod::add_container_ids(const char* value) {
  container_ids_.Add()->assign(value);
}
inline void k8s_pod::add_container_ids(const char* value, size_t size) {
  container_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
k8s_pod::container_ids() const {
  return container_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
k8s_pod::mutable_container_ids() {
  return &container_ids_;
}

// optional string node_name = 3;
inline bool k8s_pod::has_node_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void k8s_pod::set_has_node_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void k8s_pod::clear_has_node_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void k8s_pod::clear_node_name() {
  if (node_name_ != &::google::protobuf::internal::kEmptyString) {
    node_name_->clear();
  }
  clear_has_node_name();
}
inline const ::std::string& k8s_pod::node_name() const {
  return *node_name_;
}
inline void k8s_pod::set_node_name(const ::std::string& value) {
  set_has_node_name();
  if (node_name_ == &::google::protobuf::internal::kEmptyString) {
    node_name_ = new ::std::string;
  }
  node_name_->assign(value);
}
inline void k8s_pod::set_node_name(const char* value) {
  set_has_node_name();
  if (node_name_ == &::google::protobuf::internal::kEmptyString) {
    node_name_ = new ::std::string;
  }
  node_name_->assign(value);
}
inline void k8s_pod::set_node_name(const char* value, size_t size) {
  set_has_node_name();
  if (node_name_ == &::google::protobuf::internal::kEmptyString) {
    node_name_ = new ::std::string;
  }
  node_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* k8s_pod::mutable_node_name() {
  set_has_node_name();
  if (node_name_ == &::google::protobuf::internal::kEmptyString) {
    node_name_ = new ::std::string;
  }
  return node_name_;
}
inline ::std::string* k8s_pod::release_node_name() {
  clear_has_node_name();
  if (node_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = node_name_;
    node_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void k8s_pod::set_allocated_node_name(::std::string* node_name) {
  if (node_name_ != &::google::protobuf::internal::kEmptyString) {
    delete node_name_;
  }
  if (node_name) {
    set_has_node_name();
    node_name_ = node_name;
  } else {
    clear_has_node_name();
    node_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string host_ip = 4;
inline bool k8s_pod::has_host_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void k8s_pod::set_has_host_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void k8s_pod::clear_has_host_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void k8s_pod::clear_host_ip() {
  if (host_ip_ != &::google::protobuf::internal::kEmptyString) {
    host_ip_->clear();
  }
  clear_has_host_ip();
}
inline const ::std::string& k8s_pod::host_ip() const {
  return *host_ip_;
}
inline void k8s_pod::set_host_ip(const ::std::string& value) {
  set_has_host_ip();
  if (host_ip_ == &::google::protobuf::internal::kEmptyString) {
    host_ip_ = new ::std::string;
  }
  host_ip_->assign(value);
}
inline void k8s_pod::set_host_ip(const char* value) {
  set_has_host_ip();
  if (host_ip_ == &::google::protobuf::internal::kEmptyString) {
    host_ip_ = new ::std::string;
  }
  host_ip_->assign(value);
}
inline void k8s_pod::set_host_ip(const char* value, size_t size) {
  set_has_host_ip();
  if (host_ip_ == &::google::protobuf::internal::kEmptyString) {
    host_ip_ = new ::std::string;
  }
  host_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* k8s_pod::mutable_host_ip() {
  set_has_host_ip();
  if (host_ip_ == &::google::protobuf::internal::kEmptyString) {
    host_ip_ = new ::std::string;
  }
  return host_ip_;
}
inline ::std::string* k8s_pod::release_host_ip() {
  clear_has_host_ip();
  if (host_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_ip_;
    host_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void k8s_pod::set_allocated_host_ip(::std::string* host_ip) {
  if (host_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete host_ip_;
  }
  if (host_ip) {
    set_has_host_ip();
    host_ip_ = host_ip;
  } else {
    clear_has_host_ip();
    host_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string internal_ip = 5;
inline bool k8s_pod::has_internal_ip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void k8s_pod::set_has_internal_ip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void k8s_pod::clear_has_internal_ip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void k8s_pod::clear_internal_ip() {
  if (internal_ip_ != &::google::protobuf::internal::kEmptyString) {
    internal_ip_->clear();
  }
  clear_has_internal_ip();
}
inline const ::std::string& k8s_pod::internal_ip() const {
  return *internal_ip_;
}
inline void k8s_pod::set_internal_ip(const ::std::string& value) {
  set_has_internal_ip();
  if (internal_ip_ == &::google::protobuf::internal::kEmptyString) {
    internal_ip_ = new ::std::string;
  }
  internal_ip_->assign(value);
}
inline void k8s_pod::set_internal_ip(const char* value) {
  set_has_internal_ip();
  if (internal_ip_ == &::google::protobuf::internal::kEmptyString) {
    internal_ip_ = new ::std::string;
  }
  internal_ip_->assign(value);
}
inline void k8s_pod::set_internal_ip(const char* value, size_t size) {
  set_has_internal_ip();
  if (internal_ip_ == &::google::protobuf::internal::kEmptyString) {
    internal_ip_ = new ::std::string;
  }
  internal_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* k8s_pod::mutable_internal_ip() {
  set_has_internal_ip();
  if (internal_ip_ == &::google::protobuf::internal::kEmptyString) {
    internal_ip_ = new ::std::string;
  }
  return internal_ip_;
}
inline ::std::string* k8s_pod::release_internal_ip() {
  clear_has_internal_ip();
  if (internal_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = internal_ip_;
    internal_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void k8s_pod::set_allocated_internal_ip(::std::string* internal_ip) {
  if (internal_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete internal_ip_;
  }
  if (internal_ip) {
    set_has_internal_ip();
    internal_ip_ = internal_ip;
  } else {
    clear_has_internal_ip();
    internal_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// k8s_replication_controller

// required .draiosproto.k8s_common common = 1;
inline bool k8s_replication_controller::has_common() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void k8s_replication_controller::set_has_common() {
  _has_bits_[0] |= 0x00000001u;
}
inline void k8s_replication_controller::clear_has_common() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void k8s_replication_controller::clear_common() {
  if (common_ != NULL) common_->::draiosproto::k8s_common::Clear();
  clear_has_common();
}
inline const ::draiosproto::k8s_common& k8s_replication_controller::common() const {
  return common_ != NULL ? *common_ : *default_instance_->common_;
}
inline ::draiosproto::k8s_common* k8s_replication_controller::mutable_common() {
  set_has_common();
  if (common_ == NULL) common_ = new ::draiosproto::k8s_common;
  return common_;
}
inline ::draiosproto::k8s_common* k8s_replication_controller::release_common() {
  clear_has_common();
  ::draiosproto::k8s_common* temp = common_;
  common_ = NULL;
  return temp;
}
inline void k8s_replication_controller::set_allocated_common(::draiosproto::k8s_common* common) {
  delete common_;
  common_ = common;
  if (common) {
    set_has_common();
  } else {
    clear_has_common();
  }
}

// -------------------------------------------------------------------

// k8s_service_net_port

// required uint32 port = 1;
inline bool k8s_service_net_port::has_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void k8s_service_net_port::set_has_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void k8s_service_net_port::clear_has_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void k8s_service_net_port::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 k8s_service_net_port::port() const {
  return port_;
}
inline void k8s_service_net_port::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// required uint32 target_port = 2;
inline bool k8s_service_net_port::has_target_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void k8s_service_net_port::set_has_target_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void k8s_service_net_port::clear_has_target_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void k8s_service_net_port::clear_target_port() {
  target_port_ = 0u;
  clear_has_target_port();
}
inline ::google::protobuf::uint32 k8s_service_net_port::target_port() const {
  return target_port_;
}
inline void k8s_service_net_port::set_target_port(::google::protobuf::uint32 value) {
  set_has_target_port();
  target_port_ = value;
}

// optional string protocol = 3;
inline bool k8s_service_net_port::has_protocol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void k8s_service_net_port::set_has_protocol() {
  _has_bits_[0] |= 0x00000004u;
}
inline void k8s_service_net_port::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void k8s_service_net_port::clear_protocol() {
  if (protocol_ != &::google::protobuf::internal::kEmptyString) {
    protocol_->clear();
  }
  clear_has_protocol();
}
inline const ::std::string& k8s_service_net_port::protocol() const {
  return *protocol_;
}
inline void k8s_service_net_port::set_protocol(const ::std::string& value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
}
inline void k8s_service_net_port::set_protocol(const char* value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
}
inline void k8s_service_net_port::set_protocol(const char* value, size_t size) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* k8s_service_net_port::mutable_protocol() {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  return protocol_;
}
inline ::std::string* k8s_service_net_port::release_protocol() {
  clear_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = protocol_;
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void k8s_service_net_port::set_allocated_protocol(::std::string* protocol) {
  if (protocol_ != &::google::protobuf::internal::kEmptyString) {
    delete protocol_;
  }
  if (protocol) {
    set_has_protocol();
    protocol_ = protocol;
  } else {
    clear_has_protocol();
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 node_port = 4;
inline bool k8s_service_net_port::has_node_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void k8s_service_net_port::set_has_node_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void k8s_service_net_port::clear_has_node_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void k8s_service_net_port::clear_node_port() {
  node_port_ = 0u;
  clear_has_node_port();
}
inline ::google::protobuf::uint32 k8s_service_net_port::node_port() const {
  return node_port_;
}
inline void k8s_service_net_port::set_node_port(::google::protobuf::uint32 value) {
  set_has_node_port();
  node_port_ = value;
}

// -------------------------------------------------------------------

// k8s_service

// required .draiosproto.k8s_common common = 1;
inline bool k8s_service::has_common() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void k8s_service::set_has_common() {
  _has_bits_[0] |= 0x00000001u;
}
inline void k8s_service::clear_has_common() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void k8s_service::clear_common() {
  if (common_ != NULL) common_->::draiosproto::k8s_common::Clear();
  clear_has_common();
}
inline const ::draiosproto::k8s_common& k8s_service::common() const {
  return common_ != NULL ? *common_ : *default_instance_->common_;
}
inline ::draiosproto::k8s_common* k8s_service::mutable_common() {
  set_has_common();
  if (common_ == NULL) common_ = new ::draiosproto::k8s_common;
  return common_;
}
inline ::draiosproto::k8s_common* k8s_service::release_common() {
  clear_has_common();
  ::draiosproto::k8s_common* temp = common_;
  common_ = NULL;
  return temp;
}
inline void k8s_service::set_allocated_common(::draiosproto::k8s_common* common) {
  delete common_;
  common_ = common;
  if (common) {
    set_has_common();
  } else {
    clear_has_common();
  }
}

// optional string cluster_ip = 2;
inline bool k8s_service::has_cluster_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void k8s_service::set_has_cluster_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void k8s_service::clear_has_cluster_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void k8s_service::clear_cluster_ip() {
  if (cluster_ip_ != &::google::protobuf::internal::kEmptyString) {
    cluster_ip_->clear();
  }
  clear_has_cluster_ip();
}
inline const ::std::string& k8s_service::cluster_ip() const {
  return *cluster_ip_;
}
inline void k8s_service::set_cluster_ip(const ::std::string& value) {
  set_has_cluster_ip();
  if (cluster_ip_ == &::google::protobuf::internal::kEmptyString) {
    cluster_ip_ = new ::std::string;
  }
  cluster_ip_->assign(value);
}
inline void k8s_service::set_cluster_ip(const char* value) {
  set_has_cluster_ip();
  if (cluster_ip_ == &::google::protobuf::internal::kEmptyString) {
    cluster_ip_ = new ::std::string;
  }
  cluster_ip_->assign(value);
}
inline void k8s_service::set_cluster_ip(const char* value, size_t size) {
  set_has_cluster_ip();
  if (cluster_ip_ == &::google::protobuf::internal::kEmptyString) {
    cluster_ip_ = new ::std::string;
  }
  cluster_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* k8s_service::mutable_cluster_ip() {
  set_has_cluster_ip();
  if (cluster_ip_ == &::google::protobuf::internal::kEmptyString) {
    cluster_ip_ = new ::std::string;
  }
  return cluster_ip_;
}
inline ::std::string* k8s_service::release_cluster_ip() {
  clear_has_cluster_ip();
  if (cluster_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cluster_ip_;
    cluster_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void k8s_service::set_allocated_cluster_ip(::std::string* cluster_ip) {
  if (cluster_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete cluster_ip_;
  }
  if (cluster_ip) {
    set_has_cluster_ip();
    cluster_ip_ = cluster_ip;
  } else {
    clear_has_cluster_ip();
    cluster_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .draiosproto.k8s_service.net_port ports = 3;
inline int k8s_service::ports_size() const {
  return ports_.size();
}
inline void k8s_service::clear_ports() {
  ports_.Clear();
}
inline const ::draiosproto::k8s_service_net_port& k8s_service::ports(int index) const {
  return ports_.Get(index);
}
inline ::draiosproto::k8s_service_net_port* k8s_service::mutable_ports(int index) {
  return ports_.Mutable(index);
}
inline ::draiosproto::k8s_service_net_port* k8s_service::add_ports() {
  return ports_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_service_net_port >&
k8s_service::ports() const {
  return ports_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_service_net_port >*
k8s_service::mutable_ports() {
  return &ports_;
}

// -------------------------------------------------------------------

// k8s_state

// repeated .draiosproto.k8s_namespace namespaces = 1;
inline int k8s_state::namespaces_size() const {
  return namespaces_.size();
}
inline void k8s_state::clear_namespaces() {
  namespaces_.Clear();
}
inline const ::draiosproto::k8s_namespace& k8s_state::namespaces(int index) const {
  return namespaces_.Get(index);
}
inline ::draiosproto::k8s_namespace* k8s_state::mutable_namespaces(int index) {
  return namespaces_.Mutable(index);
}
inline ::draiosproto::k8s_namespace* k8s_state::add_namespaces() {
  return namespaces_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_namespace >&
k8s_state::namespaces() const {
  return namespaces_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_namespace >*
k8s_state::mutable_namespaces() {
  return &namespaces_;
}

// repeated .draiosproto.k8s_node nodes = 2;
inline int k8s_state::nodes_size() const {
  return nodes_.size();
}
inline void k8s_state::clear_nodes() {
  nodes_.Clear();
}
inline const ::draiosproto::k8s_node& k8s_state::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::draiosproto::k8s_node* k8s_state::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::draiosproto::k8s_node* k8s_state::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_node >&
k8s_state::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_node >*
k8s_state::mutable_nodes() {
  return &nodes_;
}

// repeated .draiosproto.k8s_pod pods = 3;
inline int k8s_state::pods_size() const {
  return pods_.size();
}
inline void k8s_state::clear_pods() {
  pods_.Clear();
}
inline const ::draiosproto::k8s_pod& k8s_state::pods(int index) const {
  return pods_.Get(index);
}
inline ::draiosproto::k8s_pod* k8s_state::mutable_pods(int index) {
  return pods_.Mutable(index);
}
inline ::draiosproto::k8s_pod* k8s_state::add_pods() {
  return pods_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pod >&
k8s_state::pods() const {
  return pods_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_pod >*
k8s_state::mutable_pods() {
  return &pods_;
}

// repeated .draiosproto.k8s_replication_controller controllers = 4;
inline int k8s_state::controllers_size() const {
  return controllers_.size();
}
inline void k8s_state::clear_controllers() {
  controllers_.Clear();
}
inline const ::draiosproto::k8s_replication_controller& k8s_state::controllers(int index) const {
  return controllers_.Get(index);
}
inline ::draiosproto::k8s_replication_controller* k8s_state::mutable_controllers(int index) {
  return controllers_.Mutable(index);
}
inline ::draiosproto::k8s_replication_controller* k8s_state::add_controllers() {
  return controllers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_replication_controller >&
k8s_state::controllers() const {
  return controllers_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_replication_controller >*
k8s_state::mutable_controllers() {
  return &controllers_;
}

// repeated .draiosproto.k8s_service services = 5;
inline int k8s_state::services_size() const {
  return services_.size();
}
inline void k8s_state::clear_services() {
  services_.Clear();
}
inline const ::draiosproto::k8s_service& k8s_state::services(int index) const {
  return services_.Get(index);
}
inline ::draiosproto::k8s_service* k8s_state::mutable_services(int index) {
  return services_.Mutable(index);
}
inline ::draiosproto::k8s_service* k8s_state::add_services() {
  return services_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_service >&
k8s_state::services() const {
  return services_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::k8s_service >*
k8s_state::mutable_services() {
  return &services_;
}

// -------------------------------------------------------------------

// mesos_pair

// required string key = 1;
inline bool mesos_pair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mesos_pair::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mesos_pair::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mesos_pair::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& mesos_pair::key() const {
  return *key_;
}
inline void mesos_pair::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void mesos_pair::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void mesos_pair::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mesos_pair::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* mesos_pair::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mesos_pair::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool mesos_pair::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mesos_pair::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mesos_pair::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mesos_pair::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& mesos_pair::value() const {
  return *value_;
}
inline void mesos_pair::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void mesos_pair::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void mesos_pair::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mesos_pair::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* mesos_pair::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mesos_pair::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// mesos_common

// required string uid = 1;
inline bool mesos_common::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mesos_common::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mesos_common::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mesos_common::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& mesos_common::uid() const {
  return *uid_;
}
inline void mesos_common::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void mesos_common::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void mesos_common::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mesos_common::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* mesos_common::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mesos_common::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool mesos_common::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mesos_common::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mesos_common::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mesos_common::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& mesos_common::name() const {
  return *name_;
}
inline void mesos_common::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void mesos_common::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void mesos_common::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mesos_common::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* mesos_common::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mesos_common::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .draiosproto.mesos_pair labels = 3;
inline int mesos_common::labels_size() const {
  return labels_.size();
}
inline void mesos_common::clear_labels() {
  labels_.Clear();
}
inline const ::draiosproto::mesos_pair& mesos_common::labels(int index) const {
  return labels_.Get(index);
}
inline ::draiosproto::mesos_pair* mesos_common::mutable_labels(int index) {
  return labels_.Mutable(index);
}
inline ::draiosproto::mesos_pair* mesos_common::add_labels() {
  return labels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_pair >&
mesos_common::labels() const {
  return labels_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_pair >*
mesos_common::mutable_labels() {
  return &labels_;
}

// -------------------------------------------------------------------

// mesos_task

// required .draiosproto.mesos_common common = 1;
inline bool mesos_task::has_common() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mesos_task::set_has_common() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mesos_task::clear_has_common() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mesos_task::clear_common() {
  if (common_ != NULL) common_->::draiosproto::mesos_common::Clear();
  clear_has_common();
}
inline const ::draiosproto::mesos_common& mesos_task::common() const {
  return common_ != NULL ? *common_ : *default_instance_->common_;
}
inline ::draiosproto::mesos_common* mesos_task::mutable_common() {
  set_has_common();
  if (common_ == NULL) common_ = new ::draiosproto::mesos_common;
  return common_;
}
inline ::draiosproto::mesos_common* mesos_task::release_common() {
  clear_has_common();
  ::draiosproto::mesos_common* temp = common_;
  common_ = NULL;
  return temp;
}
inline void mesos_task::set_allocated_common(::draiosproto::mesos_common* common) {
  delete common_;
  common_ = common;
  if (common) {
    set_has_common();
  } else {
    clear_has_common();
  }
}

// required string slave_id = 2;
inline bool mesos_task::has_slave_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mesos_task::set_has_slave_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mesos_task::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mesos_task::clear_slave_id() {
  if (slave_id_ != &::google::protobuf::internal::kEmptyString) {
    slave_id_->clear();
  }
  clear_has_slave_id();
}
inline const ::std::string& mesos_task::slave_id() const {
  return *slave_id_;
}
inline void mesos_task::set_slave_id(const ::std::string& value) {
  set_has_slave_id();
  if (slave_id_ == &::google::protobuf::internal::kEmptyString) {
    slave_id_ = new ::std::string;
  }
  slave_id_->assign(value);
}
inline void mesos_task::set_slave_id(const char* value) {
  set_has_slave_id();
  if (slave_id_ == &::google::protobuf::internal::kEmptyString) {
    slave_id_ = new ::std::string;
  }
  slave_id_->assign(value);
}
inline void mesos_task::set_slave_id(const char* value, size_t size) {
  set_has_slave_id();
  if (slave_id_ == &::google::protobuf::internal::kEmptyString) {
    slave_id_ = new ::std::string;
  }
  slave_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mesos_task::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == &::google::protobuf::internal::kEmptyString) {
    slave_id_ = new ::std::string;
  }
  return slave_id_;
}
inline ::std::string* mesos_task::release_slave_id() {
  clear_has_slave_id();
  if (slave_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = slave_id_;
    slave_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mesos_task::set_allocated_slave_id(::std::string* slave_id) {
  if (slave_id_ != &::google::protobuf::internal::kEmptyString) {
    delete slave_id_;
  }
  if (slave_id) {
    set_has_slave_id();
    slave_id_ = slave_id;
  } else {
    clear_has_slave_id();
    slave_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// marathon_app

// required string id = 1;
inline bool marathon_app::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void marathon_app::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void marathon_app::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void marathon_app::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& marathon_app::id() const {
  return *id_;
}
inline void marathon_app::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void marathon_app::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void marathon_app::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* marathon_app::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* marathon_app::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void marathon_app::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string task_ids = 2;
inline int marathon_app::task_ids_size() const {
  return task_ids_.size();
}
inline void marathon_app::clear_task_ids() {
  task_ids_.Clear();
}
inline const ::std::string& marathon_app::task_ids(int index) const {
  return task_ids_.Get(index);
}
inline ::std::string* marathon_app::mutable_task_ids(int index) {
  return task_ids_.Mutable(index);
}
inline void marathon_app::set_task_ids(int index, const ::std::string& value) {
  task_ids_.Mutable(index)->assign(value);
}
inline void marathon_app::set_task_ids(int index, const char* value) {
  task_ids_.Mutable(index)->assign(value);
}
inline void marathon_app::set_task_ids(int index, const char* value, size_t size) {
  task_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* marathon_app::add_task_ids() {
  return task_ids_.Add();
}
inline void marathon_app::add_task_ids(const ::std::string& value) {
  task_ids_.Add()->assign(value);
}
inline void marathon_app::add_task_ids(const char* value) {
  task_ids_.Add()->assign(value);
}
inline void marathon_app::add_task_ids(const char* value, size_t size) {
  task_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
marathon_app::task_ids() const {
  return task_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
marathon_app::mutable_task_ids() {
  return &task_ids_;
}

// -------------------------------------------------------------------

// marathon_group

// required string id = 1;
inline bool marathon_group::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void marathon_group::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void marathon_group::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void marathon_group::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& marathon_group::id() const {
  return *id_;
}
inline void marathon_group::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void marathon_group::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void marathon_group::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* marathon_group::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* marathon_group::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void marathon_group::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .draiosproto.marathon_app apps = 2;
inline int marathon_group::apps_size() const {
  return apps_.size();
}
inline void marathon_group::clear_apps() {
  apps_.Clear();
}
inline const ::draiosproto::marathon_app& marathon_group::apps(int index) const {
  return apps_.Get(index);
}
inline ::draiosproto::marathon_app* marathon_group::mutable_apps(int index) {
  return apps_.Mutable(index);
}
inline ::draiosproto::marathon_app* marathon_group::add_apps() {
  return apps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_app >&
marathon_group::apps() const {
  return apps_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_app >*
marathon_group::mutable_apps() {
  return &apps_;
}

// repeated .draiosproto.marathon_group groups = 3;
inline int marathon_group::groups_size() const {
  return groups_.size();
}
inline void marathon_group::clear_groups() {
  groups_.Clear();
}
inline const ::draiosproto::marathon_group& marathon_group::groups(int index) const {
  return groups_.Get(index);
}
inline ::draiosproto::marathon_group* marathon_group::mutable_groups(int index) {
  return groups_.Mutable(index);
}
inline ::draiosproto::marathon_group* marathon_group::add_groups() {
  return groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_group >&
marathon_group::groups() const {
  return groups_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_group >*
marathon_group::mutable_groups() {
  return &groups_;
}

// -------------------------------------------------------------------

// mesos_framework

// required .draiosproto.mesos_common common = 1;
inline bool mesos_framework::has_common() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mesos_framework::set_has_common() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mesos_framework::clear_has_common() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mesos_framework::clear_common() {
  if (common_ != NULL) common_->::draiosproto::mesos_common::Clear();
  clear_has_common();
}
inline const ::draiosproto::mesos_common& mesos_framework::common() const {
  return common_ != NULL ? *common_ : *default_instance_->common_;
}
inline ::draiosproto::mesos_common* mesos_framework::mutable_common() {
  set_has_common();
  if (common_ == NULL) common_ = new ::draiosproto::mesos_common;
  return common_;
}
inline ::draiosproto::mesos_common* mesos_framework::release_common() {
  clear_has_common();
  ::draiosproto::mesos_common* temp = common_;
  common_ = NULL;
  return temp;
}
inline void mesos_framework::set_allocated_common(::draiosproto::mesos_common* common) {
  delete common_;
  common_ = common;
  if (common) {
    set_has_common();
  } else {
    clear_has_common();
  }
}

// repeated .draiosproto.mesos_task tasks = 2;
inline int mesos_framework::tasks_size() const {
  return tasks_.size();
}
inline void mesos_framework::clear_tasks() {
  tasks_.Clear();
}
inline const ::draiosproto::mesos_task& mesos_framework::tasks(int index) const {
  return tasks_.Get(index);
}
inline ::draiosproto::mesos_task* mesos_framework::mutable_tasks(int index) {
  return tasks_.Mutable(index);
}
inline ::draiosproto::mesos_task* mesos_framework::add_tasks() {
  return tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_task >&
mesos_framework::tasks() const {
  return tasks_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_task >*
mesos_framework::mutable_tasks() {
  return &tasks_;
}

// -------------------------------------------------------------------

// mesos_slave

// required .draiosproto.mesos_common common = 1;
inline bool mesos_slave::has_common() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mesos_slave::set_has_common() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mesos_slave::clear_has_common() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mesos_slave::clear_common() {
  if (common_ != NULL) common_->::draiosproto::mesos_common::Clear();
  clear_has_common();
}
inline const ::draiosproto::mesos_common& mesos_slave::common() const {
  return common_ != NULL ? *common_ : *default_instance_->common_;
}
inline ::draiosproto::mesos_common* mesos_slave::mutable_common() {
  set_has_common();
  if (common_ == NULL) common_ = new ::draiosproto::mesos_common;
  return common_;
}
inline ::draiosproto::mesos_common* mesos_slave::release_common() {
  clear_has_common();
  ::draiosproto::mesos_common* temp = common_;
  common_ = NULL;
  return temp;
}
inline void mesos_slave::set_allocated_common(::draiosproto::mesos_common* common) {
  delete common_;
  common_ = common;
  if (common) {
    set_has_common();
  } else {
    clear_has_common();
  }
}

// -------------------------------------------------------------------

// mesos_state

// repeated .draiosproto.mesos_framework frameworks = 1;
inline int mesos_state::frameworks_size() const {
  return frameworks_.size();
}
inline void mesos_state::clear_frameworks() {
  frameworks_.Clear();
}
inline const ::draiosproto::mesos_framework& mesos_state::frameworks(int index) const {
  return frameworks_.Get(index);
}
inline ::draiosproto::mesos_framework* mesos_state::mutable_frameworks(int index) {
  return frameworks_.Mutable(index);
}
inline ::draiosproto::mesos_framework* mesos_state::add_frameworks() {
  return frameworks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_framework >&
mesos_state::frameworks() const {
  return frameworks_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_framework >*
mesos_state::mutable_frameworks() {
  return &frameworks_;
}

// repeated .draiosproto.marathon_group groups = 2;
inline int mesos_state::groups_size() const {
  return groups_.size();
}
inline void mesos_state::clear_groups() {
  groups_.Clear();
}
inline const ::draiosproto::marathon_group& mesos_state::groups(int index) const {
  return groups_.Get(index);
}
inline ::draiosproto::marathon_group* mesos_state::mutable_groups(int index) {
  return groups_.Mutable(index);
}
inline ::draiosproto::marathon_group* mesos_state::add_groups() {
  return groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_group >&
mesos_state::groups() const {
  return groups_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::marathon_group >*
mesos_state::mutable_groups() {
  return &groups_;
}

// repeated .draiosproto.mesos_slave slaves = 3;
inline int mesos_state::slaves_size() const {
  return slaves_.size();
}
inline void mesos_state::clear_slaves() {
  slaves_.Clear();
}
inline const ::draiosproto::mesos_slave& mesos_state::slaves(int index) const {
  return slaves_.Get(index);
}
inline ::draiosproto::mesos_slave* mesos_state::mutable_slaves(int index) {
  return slaves_.Mutable(index);
}
inline ::draiosproto::mesos_slave* mesos_state::add_slaves() {
  return slaves_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_slave >&
mesos_state::slaves() const {
  return slaves_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mesos_slave >*
mesos_state::mutable_slaves() {
  return &slaves_;
}

// -------------------------------------------------------------------

// metrics

// required uint64 timestamp_ns = 1;
inline bool metrics::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void metrics::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void metrics::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void metrics::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 metrics::timestamp_ns() const {
  return timestamp_ns_;
}
inline void metrics::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
}

// required string machine_id = 2;
inline bool metrics::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void metrics::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void metrics::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void metrics::clear_machine_id() {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    machine_id_->clear();
  }
  clear_has_machine_id();
}
inline const ::std::string& metrics::machine_id() const {
  return *machine_id_;
}
inline void metrics::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void metrics::set_machine_id(const char* value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void metrics::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* metrics::mutable_machine_id() {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  return machine_id_;
}
inline ::std::string* metrics::release_machine_id() {
  clear_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_id_;
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void metrics::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_id_;
  }
  if (machine_id) {
    set_has_machine_id();
    machine_id_ = machine_id;
  } else {
    clear_has_machine_id();
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string customer_id = 3;
inline bool metrics::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void metrics::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void metrics::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void metrics::clear_customer_id() {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    customer_id_->clear();
  }
  clear_has_customer_id();
}
inline const ::std::string& metrics::customer_id() const {
  return *customer_id_;
}
inline void metrics::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void metrics::set_customer_id(const char* value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void metrics::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* metrics::mutable_customer_id() {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  return customer_id_;
}
inline ::std::string* metrics::release_customer_id() {
  clear_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customer_id_;
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void metrics::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete customer_id_;
  }
  if (customer_id) {
    set_has_customer_id();
    customer_id_ = customer_id;
  } else {
    clear_has_customer_id();
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 sampling_ratio = 10;
inline bool metrics::has_sampling_ratio() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void metrics::set_has_sampling_ratio() {
  _has_bits_[0] |= 0x00000008u;
}
inline void metrics::clear_has_sampling_ratio() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void metrics::clear_sampling_ratio() {
  sampling_ratio_ = 0u;
  clear_has_sampling_ratio();
}
inline ::google::protobuf::uint32 metrics::sampling_ratio() const {
  return sampling_ratio_;
}
inline void metrics::set_sampling_ratio(::google::protobuf::uint32 value) {
  set_has_sampling_ratio();
  sampling_ratio_ = value;
}

// optional string host_custom_name = 11;
inline bool metrics::has_host_custom_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void metrics::set_has_host_custom_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void metrics::clear_has_host_custom_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void metrics::clear_host_custom_name() {
  if (host_custom_name_ != &::google::protobuf::internal::kEmptyString) {
    host_custom_name_->clear();
  }
  clear_has_host_custom_name();
}
inline const ::std::string& metrics::host_custom_name() const {
  return *host_custom_name_;
}
inline void metrics::set_host_custom_name(const ::std::string& value) {
  set_has_host_custom_name();
  if (host_custom_name_ == &::google::protobuf::internal::kEmptyString) {
    host_custom_name_ = new ::std::string;
  }
  host_custom_name_->assign(value);
}
inline void metrics::set_host_custom_name(const char* value) {
  set_has_host_custom_name();
  if (host_custom_name_ == &::google::protobuf::internal::kEmptyString) {
    host_custom_name_ = new ::std::string;
  }
  host_custom_name_->assign(value);
}
inline void metrics::set_host_custom_name(const char* value, size_t size) {
  set_has_host_custom_name();
  if (host_custom_name_ == &::google::protobuf::internal::kEmptyString) {
    host_custom_name_ = new ::std::string;
  }
  host_custom_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* metrics::mutable_host_custom_name() {
  set_has_host_custom_name();
  if (host_custom_name_ == &::google::protobuf::internal::kEmptyString) {
    host_custom_name_ = new ::std::string;
  }
  return host_custom_name_;
}
inline ::std::string* metrics::release_host_custom_name() {
  clear_has_host_custom_name();
  if (host_custom_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_custom_name_;
    host_custom_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void metrics::set_allocated_host_custom_name(::std::string* host_custom_name) {
  if (host_custom_name_ != &::google::protobuf::internal::kEmptyString) {
    delete host_custom_name_;
  }
  if (host_custom_name) {
    set_has_host_custom_name();
    host_custom_name_ = host_custom_name;
  } else {
    clear_has_host_custom_name();
    host_custom_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string host_tags = 12;
inline bool metrics::has_host_tags() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void metrics::set_has_host_tags() {
  _has_bits_[0] |= 0x00000020u;
}
inline void metrics::clear_has_host_tags() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void metrics::clear_host_tags() {
  if (host_tags_ != &::google::protobuf::internal::kEmptyString) {
    host_tags_->clear();
  }
  clear_has_host_tags();
}
inline const ::std::string& metrics::host_tags() const {
  return *host_tags_;
}
inline void metrics::set_host_tags(const ::std::string& value) {
  set_has_host_tags();
  if (host_tags_ == &::google::protobuf::internal::kEmptyString) {
    host_tags_ = new ::std::string;
  }
  host_tags_->assign(value);
}
inline void metrics::set_host_tags(const char* value) {
  set_has_host_tags();
  if (host_tags_ == &::google::protobuf::internal::kEmptyString) {
    host_tags_ = new ::std::string;
  }
  host_tags_->assign(value);
}
inline void metrics::set_host_tags(const char* value, size_t size) {
  set_has_host_tags();
  if (host_tags_ == &::google::protobuf::internal::kEmptyString) {
    host_tags_ = new ::std::string;
  }
  host_tags_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* metrics::mutable_host_tags() {
  set_has_host_tags();
  if (host_tags_ == &::google::protobuf::internal::kEmptyString) {
    host_tags_ = new ::std::string;
  }
  return host_tags_;
}
inline ::std::string* metrics::release_host_tags() {
  clear_has_host_tags();
  if (host_tags_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_tags_;
    host_tags_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void metrics::set_allocated_host_tags(::std::string* host_tags) {
  if (host_tags_ != &::google::protobuf::internal::kEmptyString) {
    delete host_tags_;
  }
  if (host_tags) {
    set_has_host_tags();
    host_tags_ = host_tags;
  } else {
    clear_has_host_tags();
    host_tags_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_host_hidden = 14;
inline bool metrics::has_is_host_hidden() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void metrics::set_has_is_host_hidden() {
  _has_bits_[0] |= 0x00000040u;
}
inline void metrics::clear_has_is_host_hidden() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void metrics::clear_is_host_hidden() {
  is_host_hidden_ = false;
  clear_has_is_host_hidden();
}
inline bool metrics::is_host_hidden() const {
  return is_host_hidden_;
}
inline void metrics::set_is_host_hidden(bool value) {
  set_has_is_host_hidden();
  is_host_hidden_ = value;
}

// optional string hidden_processes = 15;
inline bool metrics::has_hidden_processes() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void metrics::set_has_hidden_processes() {
  _has_bits_[0] |= 0x00000080u;
}
inline void metrics::clear_has_hidden_processes() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void metrics::clear_hidden_processes() {
  if (hidden_processes_ != &::google::protobuf::internal::kEmptyString) {
    hidden_processes_->clear();
  }
  clear_has_hidden_processes();
}
inline const ::std::string& metrics::hidden_processes() const {
  return *hidden_processes_;
}
inline void metrics::set_hidden_processes(const ::std::string& value) {
  set_has_hidden_processes();
  if (hidden_processes_ == &::google::protobuf::internal::kEmptyString) {
    hidden_processes_ = new ::std::string;
  }
  hidden_processes_->assign(value);
}
inline void metrics::set_hidden_processes(const char* value) {
  set_has_hidden_processes();
  if (hidden_processes_ == &::google::protobuf::internal::kEmptyString) {
    hidden_processes_ = new ::std::string;
  }
  hidden_processes_->assign(value);
}
inline void metrics::set_hidden_processes(const char* value, size_t size) {
  set_has_hidden_processes();
  if (hidden_processes_ == &::google::protobuf::internal::kEmptyString) {
    hidden_processes_ = new ::std::string;
  }
  hidden_processes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* metrics::mutable_hidden_processes() {
  set_has_hidden_processes();
  if (hidden_processes_ == &::google::protobuf::internal::kEmptyString) {
    hidden_processes_ = new ::std::string;
  }
  return hidden_processes_;
}
inline ::std::string* metrics::release_hidden_processes() {
  clear_has_hidden_processes();
  if (hidden_processes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hidden_processes_;
    hidden_processes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void metrics::set_allocated_hidden_processes(::std::string* hidden_processes) {
  if (hidden_processes_ != &::google::protobuf::internal::kEmptyString) {
    delete hidden_processes_;
  }
  if (hidden_processes) {
    set_has_hidden_processes();
    hidden_processes_ = hidden_processes;
  } else {
    clear_has_hidden_processes();
    hidden_processes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string version = 16;
inline bool metrics::has_version() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void metrics::set_has_version() {
  _has_bits_[0] |= 0x00000100u;
}
inline void metrics::clear_has_version() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void metrics::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& metrics::version() const {
  return *version_;
}
inline void metrics::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void metrics::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void metrics::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* metrics::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* metrics::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void metrics::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string instance_id = 21;
inline bool metrics::has_instance_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void metrics::set_has_instance_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void metrics::clear_has_instance_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void metrics::clear_instance_id() {
  if (instance_id_ != &::google::protobuf::internal::kEmptyString) {
    instance_id_->clear();
  }
  clear_has_instance_id();
}
inline const ::std::string& metrics::instance_id() const {
  return *instance_id_;
}
inline void metrics::set_instance_id(const ::std::string& value) {
  set_has_instance_id();
  if (instance_id_ == &::google::protobuf::internal::kEmptyString) {
    instance_id_ = new ::std::string;
  }
  instance_id_->assign(value);
}
inline void metrics::set_instance_id(const char* value) {
  set_has_instance_id();
  if (instance_id_ == &::google::protobuf::internal::kEmptyString) {
    instance_id_ = new ::std::string;
  }
  instance_id_->assign(value);
}
inline void metrics::set_instance_id(const char* value, size_t size) {
  set_has_instance_id();
  if (instance_id_ == &::google::protobuf::internal::kEmptyString) {
    instance_id_ = new ::std::string;
  }
  instance_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* metrics::mutable_instance_id() {
  set_has_instance_id();
  if (instance_id_ == &::google::protobuf::internal::kEmptyString) {
    instance_id_ = new ::std::string;
  }
  return instance_id_;
}
inline ::std::string* metrics::release_instance_id() {
  clear_has_instance_id();
  if (instance_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instance_id_;
    instance_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void metrics::set_allocated_instance_id(::std::string* instance_id) {
  if (instance_id_ != &::google::protobuf::internal::kEmptyString) {
    delete instance_id_;
  }
  if (instance_id) {
    set_has_instance_id();
    instance_id_ = instance_id;
  } else {
    clear_has_instance_id();
    instance_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .draiosproto.host hostinfo = 4;
inline bool metrics::has_hostinfo() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void metrics::set_has_hostinfo() {
  _has_bits_[0] |= 0x00000400u;
}
inline void metrics::clear_has_hostinfo() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void metrics::clear_hostinfo() {
  if (hostinfo_ != NULL) hostinfo_->::draiosproto::host::Clear();
  clear_has_hostinfo();
}
inline const ::draiosproto::host& metrics::hostinfo() const {
  return hostinfo_ != NULL ? *hostinfo_ : *default_instance_->hostinfo_;
}
inline ::draiosproto::host* metrics::mutable_hostinfo() {
  set_has_hostinfo();
  if (hostinfo_ == NULL) hostinfo_ = new ::draiosproto::host;
  return hostinfo_;
}
inline ::draiosproto::host* metrics::release_hostinfo() {
  clear_has_hostinfo();
  ::draiosproto::host* temp = hostinfo_;
  hostinfo_ = NULL;
  return temp;
}
inline void metrics::set_allocated_hostinfo(::draiosproto::host* hostinfo) {
  delete hostinfo_;
  hostinfo_ = hostinfo;
  if (hostinfo) {
    set_has_hostinfo();
  } else {
    clear_has_hostinfo();
  }
}

// repeated .draiosproto.program programs = 9;
inline int metrics::programs_size() const {
  return programs_.size();
}
inline void metrics::clear_programs() {
  programs_.Clear();
}
inline const ::draiosproto::program& metrics::programs(int index) const {
  return programs_.Get(index);
}
inline ::draiosproto::program* metrics::mutable_programs(int index) {
  return programs_.Mutable(index);
}
inline ::draiosproto::program* metrics::add_programs() {
  return programs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::program >&
metrics::programs() const {
  return programs_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::program >*
metrics::mutable_programs() {
  return &programs_;
}

// repeated .draiosproto.ipv4_connection ipv4_connections = 7;
inline int metrics::ipv4_connections_size() const {
  return ipv4_connections_.size();
}
inline void metrics::clear_ipv4_connections() {
  ipv4_connections_.Clear();
}
inline const ::draiosproto::ipv4_connection& metrics::ipv4_connections(int index) const {
  return ipv4_connections_.Get(index);
}
inline ::draiosproto::ipv4_connection* metrics::mutable_ipv4_connections(int index) {
  return ipv4_connections_.Mutable(index);
}
inline ::draiosproto::ipv4_connection* metrics::add_ipv4_connections() {
  return ipv4_connections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_connection >&
metrics::ipv4_connections() const {
  return ipv4_connections_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_connection >*
metrics::mutable_ipv4_connections() {
  return &ipv4_connections_;
}

// repeated .draiosproto.ipv4_network_interface ipv4_network_interfaces = 8;
inline int metrics::ipv4_network_interfaces_size() const {
  return ipv4_network_interfaces_.size();
}
inline void metrics::clear_ipv4_network_interfaces() {
  ipv4_network_interfaces_.Clear();
}
inline const ::draiosproto::ipv4_network_interface& metrics::ipv4_network_interfaces(int index) const {
  return ipv4_network_interfaces_.Get(index);
}
inline ::draiosproto::ipv4_network_interface* metrics::mutable_ipv4_network_interfaces(int index) {
  return ipv4_network_interfaces_.Mutable(index);
}
inline ::draiosproto::ipv4_network_interface* metrics::add_ipv4_network_interfaces() {
  return ipv4_network_interfaces_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_network_interface >&
metrics::ipv4_network_interfaces() const {
  return ipv4_network_interfaces_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_network_interface >*
metrics::mutable_ipv4_network_interfaces() {
  return &ipv4_network_interfaces_;
}

// repeated .draiosproto.command_details commands = 17;
inline int metrics::commands_size() const {
  return commands_.size();
}
inline void metrics::clear_commands() {
  commands_.Clear();
}
inline const ::draiosproto::command_details& metrics::commands(int index) const {
  return commands_.Get(index);
}
inline ::draiosproto::command_details* metrics::mutable_commands(int index) {
  return commands_.Mutable(index);
}
inline ::draiosproto::command_details* metrics::add_commands() {
  return commands_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::command_details >&
metrics::commands() const {
  return commands_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::command_details >*
metrics::mutable_commands() {
  return &commands_;
}

// repeated .draiosproto.mounted_fs mounts = 18;
inline int metrics::mounts_size() const {
  return mounts_.size();
}
inline void metrics::clear_mounts() {
  mounts_.Clear();
}
inline const ::draiosproto::mounted_fs& metrics::mounts(int index) const {
  return mounts_.Get(index);
}
inline ::draiosproto::mounted_fs* metrics::mutable_mounts(int index) {
  return mounts_.Mutable(index);
}
inline ::draiosproto::mounted_fs* metrics::add_mounts() {
  return mounts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::mounted_fs >&
metrics::mounts() const {
  return mounts_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::mounted_fs >*
metrics::mutable_mounts() {
  return &mounts_;
}

// repeated .draiosproto.file_stat top_files = 19;
inline int metrics::top_files_size() const {
  return top_files_.size();
}
inline void metrics::clear_top_files() {
  top_files_.Clear();
}
inline const ::draiosproto::file_stat& metrics::top_files(int index) const {
  return top_files_.Get(index);
}
inline ::draiosproto::file_stat* metrics::mutable_top_files(int index) {
  return top_files_.Mutable(index);
}
inline ::draiosproto::file_stat* metrics::add_top_files() {
  return top_files_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::file_stat >&
metrics::top_files() const {
  return top_files_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::file_stat >*
metrics::mutable_top_files() {
  return &top_files_;
}

// optional .draiosproto.proto_info protos = 20;
inline bool metrics::has_protos() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void metrics::set_has_protos() {
  _has_bits_[0] |= 0x00020000u;
}
inline void metrics::clear_has_protos() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void metrics::clear_protos() {
  if (protos_ != NULL) protos_->::draiosproto::proto_info::Clear();
  clear_has_protos();
}
inline const ::draiosproto::proto_info& metrics::protos() const {
  return protos_ != NULL ? *protos_ : *default_instance_->protos_;
}
inline ::draiosproto::proto_info* metrics::mutable_protos() {
  set_has_protos();
  if (protos_ == NULL) protos_ = new ::draiosproto::proto_info;
  return protos_;
}
inline ::draiosproto::proto_info* metrics::release_protos() {
  clear_has_protos();
  ::draiosproto::proto_info* temp = protos_;
  protos_ = NULL;
  return temp;
}
inline void metrics::set_allocated_protos(::draiosproto::proto_info* protos) {
  delete protos_;
  protos_ = protos;
  if (protos) {
    set_has_protos();
  } else {
    clear_has_protos();
  }
}

// repeated .draiosproto.container containers = 22;
inline int metrics::containers_size() const {
  return containers_.size();
}
inline void metrics::clear_containers() {
  containers_.Clear();
}
inline const ::draiosproto::container& metrics::containers(int index) const {
  return containers_.Get(index);
}
inline ::draiosproto::container* metrics::mutable_containers(int index) {
  return containers_.Mutable(index);
}
inline ::draiosproto::container* metrics::add_containers() {
  return containers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::container >&
metrics::containers() const {
  return containers_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::container >*
metrics::mutable_containers() {
  return &containers_;
}

// optional .draiosproto.k8s_state kubernetes = 24;
inline bool metrics::has_kubernetes() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void metrics::set_has_kubernetes() {
  _has_bits_[0] |= 0x00080000u;
}
inline void metrics::clear_has_kubernetes() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void metrics::clear_kubernetes() {
  if (kubernetes_ != NULL) kubernetes_->::draiosproto::k8s_state::Clear();
  clear_has_kubernetes();
}
inline const ::draiosproto::k8s_state& metrics::kubernetes() const {
  return kubernetes_ != NULL ? *kubernetes_ : *default_instance_->kubernetes_;
}
inline ::draiosproto::k8s_state* metrics::mutable_kubernetes() {
  set_has_kubernetes();
  if (kubernetes_ == NULL) kubernetes_ = new ::draiosproto::k8s_state;
  return kubernetes_;
}
inline ::draiosproto::k8s_state* metrics::release_kubernetes() {
  clear_has_kubernetes();
  ::draiosproto::k8s_state* temp = kubernetes_;
  kubernetes_ = NULL;
  return temp;
}
inline void metrics::set_allocated_kubernetes(::draiosproto::k8s_state* kubernetes) {
  delete kubernetes_;
  kubernetes_ = kubernetes;
  if (kubernetes) {
    set_has_kubernetes();
  } else {
    clear_has_kubernetes();
  }
}

// optional .draiosproto.mesos_state mesos = 25;
inline bool metrics::has_mesos() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void metrics::set_has_mesos() {
  _has_bits_[0] |= 0x00100000u;
}
inline void metrics::clear_has_mesos() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void metrics::clear_mesos() {
  if (mesos_ != NULL) mesos_->::draiosproto::mesos_state::Clear();
  clear_has_mesos();
}
inline const ::draiosproto::mesos_state& metrics::mesos() const {
  return mesos_ != NULL ? *mesos_ : *default_instance_->mesos_;
}
inline ::draiosproto::mesos_state* metrics::mutable_mesos() {
  set_has_mesos();
  if (mesos_ == NULL) mesos_ = new ::draiosproto::mesos_state;
  return mesos_;
}
inline ::draiosproto::mesos_state* metrics::release_mesos() {
  clear_has_mesos();
  ::draiosproto::mesos_state* temp = mesos_;
  mesos_ = NULL;
  return temp;
}
inline void metrics::set_allocated_mesos(::draiosproto::mesos_state* mesos) {
  delete mesos_;
  mesos_ = mesos;
  if (mesos) {
    set_has_mesos();
  } else {
    clear_has_mesos();
  }
}

// -------------------------------------------------------------------

// dump_request_start

// required uint64 timestamp_ns = 1;
inline bool dump_request_start::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dump_request_start::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dump_request_start::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dump_request_start::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 dump_request_start::timestamp_ns() const {
  return timestamp_ns_;
}
inline void dump_request_start::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
}

// required string machine_id = 2;
inline bool dump_request_start::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dump_request_start::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dump_request_start::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dump_request_start::clear_machine_id() {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    machine_id_->clear();
  }
  clear_has_machine_id();
}
inline const ::std::string& dump_request_start::machine_id() const {
  return *machine_id_;
}
inline void dump_request_start::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void dump_request_start::set_machine_id(const char* value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void dump_request_start::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dump_request_start::mutable_machine_id() {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  return machine_id_;
}
inline ::std::string* dump_request_start::release_machine_id() {
  clear_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_id_;
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dump_request_start::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_id_;
  }
  if (machine_id) {
    set_has_machine_id();
    machine_id_ = machine_id;
  } else {
    clear_has_machine_id();
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string customer_id = 3;
inline bool dump_request_start::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dump_request_start::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dump_request_start::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dump_request_start::clear_customer_id() {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    customer_id_->clear();
  }
  clear_has_customer_id();
}
inline const ::std::string& dump_request_start::customer_id() const {
  return *customer_id_;
}
inline void dump_request_start::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void dump_request_start::set_customer_id(const char* value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void dump_request_start::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dump_request_start::mutable_customer_id() {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  return customer_id_;
}
inline ::std::string* dump_request_start::release_customer_id() {
  clear_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customer_id_;
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dump_request_start::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete customer_id_;
  }
  if (customer_id) {
    set_has_customer_id();
    customer_id_ = customer_id;
  } else {
    clear_has_customer_id();
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 duration_ns = 4;
inline bool dump_request_start::has_duration_ns() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dump_request_start::set_has_duration_ns() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dump_request_start::clear_has_duration_ns() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dump_request_start::clear_duration_ns() {
  duration_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_duration_ns();
}
inline ::google::protobuf::uint64 dump_request_start::duration_ns() const {
  return duration_ns_;
}
inline void dump_request_start::set_duration_ns(::google::protobuf::uint64 value) {
  set_has_duration_ns();
  duration_ns_ = value;
}

// optional string filters = 5;
inline bool dump_request_start::has_filters() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void dump_request_start::set_has_filters() {
  _has_bits_[0] |= 0x00000010u;
}
inline void dump_request_start::clear_has_filters() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void dump_request_start::clear_filters() {
  if (filters_ != &::google::protobuf::internal::kEmptyString) {
    filters_->clear();
  }
  clear_has_filters();
}
inline const ::std::string& dump_request_start::filters() const {
  return *filters_;
}
inline void dump_request_start::set_filters(const ::std::string& value) {
  set_has_filters();
  if (filters_ == &::google::protobuf::internal::kEmptyString) {
    filters_ = new ::std::string;
  }
  filters_->assign(value);
}
inline void dump_request_start::set_filters(const char* value) {
  set_has_filters();
  if (filters_ == &::google::protobuf::internal::kEmptyString) {
    filters_ = new ::std::string;
  }
  filters_->assign(value);
}
inline void dump_request_start::set_filters(const char* value, size_t size) {
  set_has_filters();
  if (filters_ == &::google::protobuf::internal::kEmptyString) {
    filters_ = new ::std::string;
  }
  filters_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dump_request_start::mutable_filters() {
  set_has_filters();
  if (filters_ == &::google::protobuf::internal::kEmptyString) {
    filters_ = new ::std::string;
  }
  return filters_;
}
inline ::std::string* dump_request_start::release_filters() {
  clear_has_filters();
  if (filters_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filters_;
    filters_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dump_request_start::set_allocated_filters(::std::string* filters) {
  if (filters_ != &::google::protobuf::internal::kEmptyString) {
    delete filters_;
  }
  if (filters) {
    set_has_filters();
    filters_ = filters;
  } else {
    clear_has_filters();
    filters_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 max_size = 7;
inline bool dump_request_start::has_max_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void dump_request_start::set_has_max_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void dump_request_start::clear_has_max_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void dump_request_start::clear_max_size() {
  max_size_ = GOOGLE_ULONGLONG(0);
  clear_has_max_size();
}
inline ::google::protobuf::uint64 dump_request_start::max_size() const {
  return max_size_;
}
inline void dump_request_start::set_max_size(::google::protobuf::uint64 value) {
  set_has_max_size();
  max_size_ = value;
}

// required string token = 6;
inline bool dump_request_start::has_token() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void dump_request_start::set_has_token() {
  _has_bits_[0] |= 0x00000040u;
}
inline void dump_request_start::clear_has_token() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void dump_request_start::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& dump_request_start::token() const {
  return *token_;
}
inline void dump_request_start::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void dump_request_start::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void dump_request_start::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dump_request_start::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* dump_request_start::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dump_request_start::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// dump_request_stop

// required uint64 timestamp_ns = 1;
inline bool dump_request_stop::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dump_request_stop::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dump_request_stop::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dump_request_stop::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 dump_request_stop::timestamp_ns() const {
  return timestamp_ns_;
}
inline void dump_request_stop::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
}

// required string machine_id = 2;
inline bool dump_request_stop::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dump_request_stop::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dump_request_stop::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dump_request_stop::clear_machine_id() {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    machine_id_->clear();
  }
  clear_has_machine_id();
}
inline const ::std::string& dump_request_stop::machine_id() const {
  return *machine_id_;
}
inline void dump_request_stop::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void dump_request_stop::set_machine_id(const char* value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void dump_request_stop::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dump_request_stop::mutable_machine_id() {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  return machine_id_;
}
inline ::std::string* dump_request_stop::release_machine_id() {
  clear_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_id_;
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dump_request_stop::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_id_;
  }
  if (machine_id) {
    set_has_machine_id();
    machine_id_ = machine_id;
  } else {
    clear_has_machine_id();
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string customer_id = 3;
inline bool dump_request_stop::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dump_request_stop::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dump_request_stop::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dump_request_stop::clear_customer_id() {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    customer_id_->clear();
  }
  clear_has_customer_id();
}
inline const ::std::string& dump_request_stop::customer_id() const {
  return *customer_id_;
}
inline void dump_request_stop::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void dump_request_stop::set_customer_id(const char* value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void dump_request_stop::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dump_request_stop::mutable_customer_id() {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  return customer_id_;
}
inline ::std::string* dump_request_stop::release_customer_id() {
  clear_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customer_id_;
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dump_request_stop::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete customer_id_;
  }
  if (customer_id) {
    set_has_customer_id();
    customer_id_ = customer_id;
  } else {
    clear_has_customer_id();
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string token = 4;
inline bool dump_request_stop::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dump_request_stop::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dump_request_stop::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dump_request_stop::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& dump_request_stop::token() const {
  return *token_;
}
inline void dump_request_stop::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void dump_request_stop::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void dump_request_stop::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dump_request_stop::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* dump_request_stop::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dump_request_stop::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// dump_response

// required uint64 timestamp_ns = 1;
inline bool dump_response::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dump_response::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dump_response::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dump_response::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 dump_response::timestamp_ns() const {
  return timestamp_ns_;
}
inline void dump_response::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
}

// required string machine_id = 2;
inline bool dump_response::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dump_response::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dump_response::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dump_response::clear_machine_id() {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    machine_id_->clear();
  }
  clear_has_machine_id();
}
inline const ::std::string& dump_response::machine_id() const {
  return *machine_id_;
}
inline void dump_response::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void dump_response::set_machine_id(const char* value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void dump_response::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dump_response::mutable_machine_id() {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  return machine_id_;
}
inline ::std::string* dump_response::release_machine_id() {
  clear_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_id_;
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dump_response::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_id_;
  }
  if (machine_id) {
    set_has_machine_id();
    machine_id_ = machine_id;
  } else {
    clear_has_machine_id();
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string customer_id = 3;
inline bool dump_response::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dump_response::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dump_response::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dump_response::clear_customer_id() {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    customer_id_->clear();
  }
  clear_has_customer_id();
}
inline const ::std::string& dump_response::customer_id() const {
  return *customer_id_;
}
inline void dump_response::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void dump_response::set_customer_id(const char* value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void dump_response::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dump_response::mutable_customer_id() {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  return customer_id_;
}
inline ::std::string* dump_response::release_customer_id() {
  clear_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customer_id_;
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dump_response::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete customer_id_;
  }
  if (customer_id) {
    set_has_customer_id();
    customer_id_ = customer_id;
  } else {
    clear_has_customer_id();
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 chunk_no = 7;
inline bool dump_response::has_chunk_no() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dump_response::set_has_chunk_no() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dump_response::clear_has_chunk_no() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dump_response::clear_chunk_no() {
  chunk_no_ = 0u;
  clear_has_chunk_no();
}
inline ::google::protobuf::uint32 dump_response::chunk_no() const {
  return chunk_no_;
}
inline void dump_response::set_chunk_no(::google::protobuf::uint32 value) {
  set_has_chunk_no();
  chunk_no_ = value;
}

// optional bool final_chunk = 8;
inline bool dump_response::has_final_chunk() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void dump_response::set_has_final_chunk() {
  _has_bits_[0] |= 0x00000010u;
}
inline void dump_response::clear_has_final_chunk() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void dump_response::clear_final_chunk() {
  final_chunk_ = false;
  clear_has_final_chunk();
}
inline bool dump_response::final_chunk() const {
  return final_chunk_;
}
inline void dump_response::set_final_chunk(bool value) {
  set_has_final_chunk();
  final_chunk_ = value;
}

// optional bool keep_alive = 9;
inline bool dump_response::has_keep_alive() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void dump_response::set_has_keep_alive() {
  _has_bits_[0] |= 0x00000020u;
}
inline void dump_response::clear_has_keep_alive() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void dump_response::clear_keep_alive() {
  keep_alive_ = false;
  clear_has_keep_alive();
}
inline bool dump_response::keep_alive() const {
  return keep_alive_;
}
inline void dump_response::set_keep_alive(bool value) {
  set_has_keep_alive();
  keep_alive_ = value;
}

// optional bytes content = 4;
inline bool dump_response::has_content() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void dump_response::set_has_content() {
  _has_bits_[0] |= 0x00000040u;
}
inline void dump_response::clear_has_content() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void dump_response::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& dump_response::content() const {
  return *content_;
}
inline void dump_response::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void dump_response::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void dump_response::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dump_response::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* dump_response::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dump_response::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 final_size_bytes = 10;
inline bool dump_response::has_final_size_bytes() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void dump_response::set_has_final_size_bytes() {
  _has_bits_[0] |= 0x00000080u;
}
inline void dump_response::clear_has_final_size_bytes() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void dump_response::clear_final_size_bytes() {
  final_size_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_final_size_bytes();
}
inline ::google::protobuf::uint64 dump_response::final_size_bytes() const {
  return final_size_bytes_;
}
inline void dump_response::set_final_size_bytes(::google::protobuf::uint64 value) {
  set_has_final_size_bytes();
  final_size_bytes_ = value;
}

// optional string error = 5;
inline bool dump_response::has_error() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void dump_response::set_has_error() {
  _has_bits_[0] |= 0x00000100u;
}
inline void dump_response::clear_has_error() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void dump_response::clear_error() {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& dump_response::error() const {
  return *error_;
}
inline void dump_response::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void dump_response::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void dump_response::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dump_response::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  return error_;
}
inline ::std::string* dump_response::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dump_response::set_allocated_error(::std::string* error) {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    delete error_;
  }
  if (error) {
    set_has_error();
    error_ = error;
  } else {
    clear_has_error();
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string token = 6;
inline bool dump_response::has_token() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void dump_response::set_has_token() {
  _has_bits_[0] |= 0x00000200u;
}
inline void dump_response::clear_has_token() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void dump_response::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& dump_response::token() const {
  return *token_;
}
inline void dump_response::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void dump_response::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void dump_response::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dump_response::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* dump_response::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dump_response::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ssh_open_channel

// required uint64 timestamp_ns = 1;
inline bool ssh_open_channel::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ssh_open_channel::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ssh_open_channel::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ssh_open_channel::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 ssh_open_channel::timestamp_ns() const {
  return timestamp_ns_;
}
inline void ssh_open_channel::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
}

// required string machine_id = 2;
inline bool ssh_open_channel::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ssh_open_channel::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ssh_open_channel::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ssh_open_channel::clear_machine_id() {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    machine_id_->clear();
  }
  clear_has_machine_id();
}
inline const ::std::string& ssh_open_channel::machine_id() const {
  return *machine_id_;
}
inline void ssh_open_channel::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void ssh_open_channel::set_machine_id(const char* value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void ssh_open_channel::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_open_channel::mutable_machine_id() {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  return machine_id_;
}
inline ::std::string* ssh_open_channel::release_machine_id() {
  clear_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_id_;
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_open_channel::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_id_;
  }
  if (machine_id) {
    set_has_machine_id();
    machine_id_ = machine_id;
  } else {
    clear_has_machine_id();
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string customer_id = 3;
inline bool ssh_open_channel::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ssh_open_channel::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ssh_open_channel::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ssh_open_channel::clear_customer_id() {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    customer_id_->clear();
  }
  clear_has_customer_id();
}
inline const ::std::string& ssh_open_channel::customer_id() const {
  return *customer_id_;
}
inline void ssh_open_channel::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void ssh_open_channel::set_customer_id(const char* value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void ssh_open_channel::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_open_channel::mutable_customer_id() {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  return customer_id_;
}
inline ::std::string* ssh_open_channel::release_customer_id() {
  clear_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customer_id_;
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_open_channel::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete customer_id_;
  }
  if (customer_id) {
    set_has_customer_id();
    customer_id_ = customer_id;
  } else {
    clear_has_customer_id();
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string token = 4;
inline bool ssh_open_channel::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ssh_open_channel::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ssh_open_channel::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ssh_open_channel::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& ssh_open_channel::token() const {
  return *token_;
}
inline void ssh_open_channel::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ssh_open_channel::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ssh_open_channel::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_open_channel::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* ssh_open_channel::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_open_channel::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string user = 5;
inline bool ssh_open_channel::has_user() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ssh_open_channel::set_has_user() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ssh_open_channel::clear_has_user() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ssh_open_channel::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& ssh_open_channel::user() const {
  return *user_;
}
inline void ssh_open_channel::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void ssh_open_channel::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void ssh_open_channel::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_open_channel::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* ssh_open_channel::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_open_channel::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 6;
inline bool ssh_open_channel::has_password() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ssh_open_channel::set_has_password() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ssh_open_channel::clear_has_password() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ssh_open_channel::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& ssh_open_channel::password() const {
  return *password_;
}
inline void ssh_open_channel::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ssh_open_channel::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ssh_open_channel::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_open_channel::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* ssh_open_channel::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_open_channel::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string key = 7;
inline bool ssh_open_channel::has_key() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ssh_open_channel::set_has_key() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ssh_open_channel::clear_has_key() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ssh_open_channel::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& ssh_open_channel::key() const {
  return *key_;
}
inline void ssh_open_channel::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void ssh_open_channel::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void ssh_open_channel::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_open_channel::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* ssh_open_channel::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_open_channel::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string passphrase = 8;
inline bool ssh_open_channel::has_passphrase() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ssh_open_channel::set_has_passphrase() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ssh_open_channel::clear_has_passphrase() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ssh_open_channel::clear_passphrase() {
  if (passphrase_ != &::google::protobuf::internal::kEmptyString) {
    passphrase_->clear();
  }
  clear_has_passphrase();
}
inline const ::std::string& ssh_open_channel::passphrase() const {
  return *passphrase_;
}
inline void ssh_open_channel::set_passphrase(const ::std::string& value) {
  set_has_passphrase();
  if (passphrase_ == &::google::protobuf::internal::kEmptyString) {
    passphrase_ = new ::std::string;
  }
  passphrase_->assign(value);
}
inline void ssh_open_channel::set_passphrase(const char* value) {
  set_has_passphrase();
  if (passphrase_ == &::google::protobuf::internal::kEmptyString) {
    passphrase_ = new ::std::string;
  }
  passphrase_->assign(value);
}
inline void ssh_open_channel::set_passphrase(const char* value, size_t size) {
  set_has_passphrase();
  if (passphrase_ == &::google::protobuf::internal::kEmptyString) {
    passphrase_ = new ::std::string;
  }
  passphrase_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_open_channel::mutable_passphrase() {
  set_has_passphrase();
  if (passphrase_ == &::google::protobuf::internal::kEmptyString) {
    passphrase_ = new ::std::string;
  }
  return passphrase_;
}
inline ::std::string* ssh_open_channel::release_passphrase() {
  clear_has_passphrase();
  if (passphrase_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passphrase_;
    passphrase_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_open_channel::set_allocated_passphrase(::std::string* passphrase) {
  if (passphrase_ != &::google::protobuf::internal::kEmptyString) {
    delete passphrase_;
  }
  if (passphrase) {
    set_has_passphrase();
    passphrase_ = passphrase;
  } else {
    clear_has_passphrase();
    passphrase_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 port = 9;
inline bool ssh_open_channel::has_port() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ssh_open_channel::set_has_port() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ssh_open_channel::clear_has_port() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ssh_open_channel::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 ssh_open_channel::port() const {
  return port_;
}
inline void ssh_open_channel::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// ssh_data

// required uint64 timestamp_ns = 1;
inline bool ssh_data::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ssh_data::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ssh_data::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ssh_data::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 ssh_data::timestamp_ns() const {
  return timestamp_ns_;
}
inline void ssh_data::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
}

// required string machine_id = 2;
inline bool ssh_data::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ssh_data::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ssh_data::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ssh_data::clear_machine_id() {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    machine_id_->clear();
  }
  clear_has_machine_id();
}
inline const ::std::string& ssh_data::machine_id() const {
  return *machine_id_;
}
inline void ssh_data::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void ssh_data::set_machine_id(const char* value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void ssh_data::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_data::mutable_machine_id() {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  return machine_id_;
}
inline ::std::string* ssh_data::release_machine_id() {
  clear_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_id_;
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_data::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_id_;
  }
  if (machine_id) {
    set_has_machine_id();
    machine_id_ = machine_id;
  } else {
    clear_has_machine_id();
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string customer_id = 3;
inline bool ssh_data::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ssh_data::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ssh_data::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ssh_data::clear_customer_id() {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    customer_id_->clear();
  }
  clear_has_customer_id();
}
inline const ::std::string& ssh_data::customer_id() const {
  return *customer_id_;
}
inline void ssh_data::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void ssh_data::set_customer_id(const char* value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void ssh_data::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_data::mutable_customer_id() {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  return customer_id_;
}
inline ::std::string* ssh_data::release_customer_id() {
  clear_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customer_id_;
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_data::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete customer_id_;
  }
  if (customer_id) {
    set_has_customer_id();
    customer_id_ = customer_id;
  } else {
    clear_has_customer_id();
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string token = 4;
inline bool ssh_data::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ssh_data::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ssh_data::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ssh_data::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& ssh_data::token() const {
  return *token_;
}
inline void ssh_data::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ssh_data::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ssh_data::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_data::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* ssh_data::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_data::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes data = 5;
inline bool ssh_data::has_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ssh_data::set_has_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ssh_data::clear_has_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ssh_data::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ssh_data::data() const {
  return *data_;
}
inline void ssh_data::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ssh_data::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ssh_data::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_data::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* ssh_data::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_data::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string error = 6;
inline bool ssh_data::has_error() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ssh_data::set_has_error() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ssh_data::clear_has_error() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ssh_data::clear_error() {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& ssh_data::error() const {
  return *error_;
}
inline void ssh_data::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void ssh_data::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void ssh_data::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_data::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  return error_;
}
inline ::std::string* ssh_data::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_data::set_allocated_error(::std::string* error) {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    delete error_;
  }
  if (error) {
    set_has_error();
    error_ = error;
  } else {
    clear_has_error();
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 exit_status = 7;
inline bool ssh_data::has_exit_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ssh_data::set_has_exit_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ssh_data::clear_has_exit_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ssh_data::clear_exit_status() {
  exit_status_ = 0;
  clear_has_exit_status();
}
inline ::google::protobuf::int32 ssh_data::exit_status() const {
  return exit_status_;
}
inline void ssh_data::set_exit_status(::google::protobuf::int32 value) {
  set_has_exit_status();
  exit_status_ = value;
}

// -------------------------------------------------------------------

// ssh_close_channel

// required uint64 timestamp_ns = 1;
inline bool ssh_close_channel::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ssh_close_channel::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ssh_close_channel::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ssh_close_channel::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 ssh_close_channel::timestamp_ns() const {
  return timestamp_ns_;
}
inline void ssh_close_channel::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
}

// required string machine_id = 2;
inline bool ssh_close_channel::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ssh_close_channel::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ssh_close_channel::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ssh_close_channel::clear_machine_id() {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    machine_id_->clear();
  }
  clear_has_machine_id();
}
inline const ::std::string& ssh_close_channel::machine_id() const {
  return *machine_id_;
}
inline void ssh_close_channel::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void ssh_close_channel::set_machine_id(const char* value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void ssh_close_channel::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_close_channel::mutable_machine_id() {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  return machine_id_;
}
inline ::std::string* ssh_close_channel::release_machine_id() {
  clear_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_id_;
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_close_channel::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_id_;
  }
  if (machine_id) {
    set_has_machine_id();
    machine_id_ = machine_id;
  } else {
    clear_has_machine_id();
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string customer_id = 3;
inline bool ssh_close_channel::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ssh_close_channel::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ssh_close_channel::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ssh_close_channel::clear_customer_id() {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    customer_id_->clear();
  }
  clear_has_customer_id();
}
inline const ::std::string& ssh_close_channel::customer_id() const {
  return *customer_id_;
}
inline void ssh_close_channel::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void ssh_close_channel::set_customer_id(const char* value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void ssh_close_channel::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_close_channel::mutable_customer_id() {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  return customer_id_;
}
inline ::std::string* ssh_close_channel::release_customer_id() {
  clear_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customer_id_;
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_close_channel::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete customer_id_;
  }
  if (customer_id) {
    set_has_customer_id();
    customer_id_ = customer_id;
  } else {
    clear_has_customer_id();
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string token = 4;
inline bool ssh_close_channel::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ssh_close_channel::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ssh_close_channel::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ssh_close_channel::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& ssh_close_channel::token() const {
  return *token_;
}
inline void ssh_close_channel::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ssh_close_channel::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ssh_close_channel::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssh_close_channel::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* ssh_close_channel::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ssh_close_channel::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// auto_update_request

// required uint64 timestamp_ns = 1;
inline bool auto_update_request::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void auto_update_request::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void auto_update_request::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void auto_update_request::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 auto_update_request::timestamp_ns() const {
  return timestamp_ns_;
}
inline void auto_update_request::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
}

// required string machine_id = 2;
inline bool auto_update_request::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void auto_update_request::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void auto_update_request::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void auto_update_request::clear_machine_id() {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    machine_id_->clear();
  }
  clear_has_machine_id();
}
inline const ::std::string& auto_update_request::machine_id() const {
  return *machine_id_;
}
inline void auto_update_request::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void auto_update_request::set_machine_id(const char* value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void auto_update_request::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* auto_update_request::mutable_machine_id() {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  return machine_id_;
}
inline ::std::string* auto_update_request::release_machine_id() {
  clear_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_id_;
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void auto_update_request::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_id_;
  }
  if (machine_id) {
    set_has_machine_id();
    machine_id_ = machine_id;
  } else {
    clear_has_machine_id();
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string customer_id = 3;
inline bool auto_update_request::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void auto_update_request::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void auto_update_request::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void auto_update_request::clear_customer_id() {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    customer_id_->clear();
  }
  clear_has_customer_id();
}
inline const ::std::string& auto_update_request::customer_id() const {
  return *customer_id_;
}
inline void auto_update_request::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void auto_update_request::set_customer_id(const char* value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void auto_update_request::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* auto_update_request::mutable_customer_id() {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  return customer_id_;
}
inline ::std::string* auto_update_request::release_customer_id() {
  clear_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customer_id_;
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void auto_update_request::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete customer_id_;
  }
  if (customer_id) {
    set_has_customer_id();
    customer_id_ = customer_id;
  } else {
    clear_has_customer_id();
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// dirty_shutdown_report

// required uint64 timestamp_ns = 1;
inline bool dirty_shutdown_report::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dirty_shutdown_report::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dirty_shutdown_report::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dirty_shutdown_report::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 dirty_shutdown_report::timestamp_ns() const {
  return timestamp_ns_;
}
inline void dirty_shutdown_report::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
}

// required string machine_id = 2;
inline bool dirty_shutdown_report::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dirty_shutdown_report::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dirty_shutdown_report::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dirty_shutdown_report::clear_machine_id() {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    machine_id_->clear();
  }
  clear_has_machine_id();
}
inline const ::std::string& dirty_shutdown_report::machine_id() const {
  return *machine_id_;
}
inline void dirty_shutdown_report::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void dirty_shutdown_report::set_machine_id(const char* value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void dirty_shutdown_report::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dirty_shutdown_report::mutable_machine_id() {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  return machine_id_;
}
inline ::std::string* dirty_shutdown_report::release_machine_id() {
  clear_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_id_;
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dirty_shutdown_report::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_id_;
  }
  if (machine_id) {
    set_has_machine_id();
    machine_id_ = machine_id;
  } else {
    clear_has_machine_id();
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string customer_id = 3;
inline bool dirty_shutdown_report::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dirty_shutdown_report::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dirty_shutdown_report::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dirty_shutdown_report::clear_customer_id() {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    customer_id_->clear();
  }
  clear_has_customer_id();
}
inline const ::std::string& dirty_shutdown_report::customer_id() const {
  return *customer_id_;
}
inline void dirty_shutdown_report::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void dirty_shutdown_report::set_customer_id(const char* value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void dirty_shutdown_report::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dirty_shutdown_report::mutable_customer_id() {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  return customer_id_;
}
inline ::std::string* dirty_shutdown_report::release_customer_id() {
  clear_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customer_id_;
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dirty_shutdown_report::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete customer_id_;
  }
  if (customer_id) {
    set_has_customer_id();
    customer_id_ = customer_id;
  } else {
    clear_has_customer_id();
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string log = 4;
inline bool dirty_shutdown_report::has_log() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dirty_shutdown_report::set_has_log() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dirty_shutdown_report::clear_has_log() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dirty_shutdown_report::clear_log() {
  if (log_ != &::google::protobuf::internal::kEmptyString) {
    log_->clear();
  }
  clear_has_log();
}
inline const ::std::string& dirty_shutdown_report::log() const {
  return *log_;
}
inline void dirty_shutdown_report::set_log(const ::std::string& value) {
  set_has_log();
  if (log_ == &::google::protobuf::internal::kEmptyString) {
    log_ = new ::std::string;
  }
  log_->assign(value);
}
inline void dirty_shutdown_report::set_log(const char* value) {
  set_has_log();
  if (log_ == &::google::protobuf::internal::kEmptyString) {
    log_ = new ::std::string;
  }
  log_->assign(value);
}
inline void dirty_shutdown_report::set_log(const char* value, size_t size) {
  set_has_log();
  if (log_ == &::google::protobuf::internal::kEmptyString) {
    log_ = new ::std::string;
  }
  log_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dirty_shutdown_report::mutable_log() {
  set_has_log();
  if (log_ == &::google::protobuf::internal::kEmptyString) {
    log_ = new ::std::string;
  }
  return log_;
}
inline ::std::string* dirty_shutdown_report::release_log() {
  clear_has_log();
  if (log_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = log_;
    log_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dirty_shutdown_report::set_allocated_log(::std::string* log) {
  if (log_ != &::google::protobuf::internal::kEmptyString) {
    delete log_;
  }
  if (log) {
    set_has_log();
    log_ = log;
  } else {
    clear_has_log();
    log_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace draiosproto

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::draiosproto::sql_statement_type>() {
  return ::draiosproto::sql_statement_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::draiosproto::mongodb_op_type>() {
  return ::draiosproto::mongodb_op_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::draiosproto::unit>() {
  return ::draiosproto::unit_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::draiosproto::scale>() {
  return ::draiosproto::scale_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::draiosproto::jmx_metric_type>() {
  return ::draiosproto::jmx_metric_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::draiosproto::statsd_metric_type>() {
  return ::draiosproto::statsd_metric_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::draiosproto::app_metric_type>() {
  return ::draiosproto::app_metric_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::draiosproto::app_check_value>() {
  return ::draiosproto::app_check_value_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::draiosproto::networkrole>() {
  return ::draiosproto::networkrole_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::draiosproto::message_type>() {
  return ::draiosproto::message_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::draiosproto::container_type>() {
  return ::draiosproto::container_type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_draios_2eproto__INCLUDED
