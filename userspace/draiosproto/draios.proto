syntax = "proto2";
package draiosproto;

// Java note:
//it compiles even if an error is highlighted; if you can't stand it and you are using IntelliJ
//plugin add 'legacy' path to 'Other Settings' -> 'Protobuf Support' -> 'Custom include paths'

import "common.proto";

option optimize_for = SPEED;
option java_package = "com.draios.model.protobuf";
option java_outer_classname = "Agent";

enum error_code {
    ERR_NONE = 0;
    ERR_EPERM = 1;
    ERR_ENOENT = 2;
    ERR_ESRCH = 3;
    ERR_EINTR = 4;
    ERR_EIO = 5;
    ERR_ENXIO = 6;
    ERR_E2BIG = 7;
    ERR_ENOEXEC = 8;
    ERR_EBADF = 9;
    ERR_ECHILD = 10;
    ERR_EAGAIN = 11;
    ERR_ENOMEM = 12;
    ERR_EACCES = 13;
    ERR_EFAULT = 14;
    ERR_ENOTBLK = 15;
    ERR_EBUSY = 16;
    ERR_EEXIST = 17;
    ERR_EXDEV = 18;
    ERR_ENODEV = 19;
    ERR_ENOTDIR = 20;
    ERR_EISDIR = 21;
    ERR_EINVAL = 22;
    ERR_ENFILE = 23;
    ERR_EMFILE = 24;
    ERR_ENOTTY = 25;
    ERR_ETXTBSY = 26;
    ERR_EFBIG = 27;
    ERR_ENOSPC = 28;
    ERR_ESPIPE = 29;
    ERR_EROFS = 30;
    ERR_EMLINK = 31;
    ERR_EPIPE = 32;
    ERR_EDOM = 33;
    ERR_ERANGE = 34;
    ERR_EDEADLK = 35;
    ERR_ENAMETOOLONG = 36;
    ERR_ENOLCK = 37;
    ERR_ENOSYS = 38;
    ERR_ENOTEMPTY = 39;
    ERR_ELOOP = 40;
    ERR_ENOMSG = 42;
    ERR_EIDRM = 43;
    ERR_ECHRNG = 44;
    ERR_EL2NSYNC = 45;
    ERR_EL3HLT = 46;
    ERR_EL3RST = 47;
    ERR_ELNRNG = 48;
    ERR_EUNATCH = 49;
    ERR_ENOCSI = 50;
    ERR_EL2HLT = 51;
    ERR_EBADE = 52;
    ERR_EBADR = 53;
    ERR_EXFULL = 54;
    ERR_ENOANO = 55;
    ERR_EBADRQC = 56;
    ERR_EBADSLT = 57;
    ERR_EBFONT = 59;
    ERR_ENOSTR = 60;
    ERR_ENODATA = 61;
    ERR_ETIME = 62;
    ERR_ENOSR = 63;
    ERR_ENONET = 64;
    ERR_ENOPKG = 65;
    ERR_EREMOTE = 66;
    ERR_ENOLINK = 67;
    ERR_EADV = 68;
    ERR_ESRMNT = 69;
    ERR_ECOMM = 70;
    ERR_EPROTO = 71;
    ERR_EMULTIHOP = 72;
    ERR_EDOTDOT = 73;
    ERR_EBADMSG = 74;
    ERR_EOVERFLOW = 75;
    ERR_ENOTUNIQ = 76;
    ERR_EBADFD = 77;
    ERR_EREMCHG = 78;
    ERR_ELIBACC = 79;
    ERR_ELIBBAD = 80;
    ERR_ELIBSCN = 81;
    ERR_ELIBMAX = 82;
    ERR_ELIBEXEC = 83;
    ERR_EILSEQ = 84;
    ERR_ERESTART = 85;
    ERR_ESTRPIPE = 86;
    ERR_EUSERS = 87;
    ERR_ENOTSOCK = 88;
    ERR_EDESTADDRREQ = 89;
    ERR_EMSGSIZE = 90;
    ERR_EPROTOTYPE = 91;
    ERR_ENOPROTOOPT = 92;
    ERR_EPROTONOSUPPORT = 93;
    ERR_ESOCKTNOSUPPORT = 94;
    ERR_EOPNOTSUPP = 95;
    ERR_EPFNOSUPPORT = 96;
    ERR_EAFNOSUPPORT = 97;
    ERR_EADDRINUSE = 98;
    ERR_EADDRNOTAVAIL = 99;
    ERR_ENETDOWN = 100;
    ERR_ENETUNREACH = 101;
    ERR_ENETRESET = 102;
    ERR_ECONNABORTED = 103;
    ERR_ECONNRESET = 104;
    ERR_ENOBUFS = 105;
    ERR_EISCONN = 106;
    ERR_ENOTCONN = 107;
    ERR_ESHUTDOWN = 108;
    ERR_ETOOMANYREFS = 109;
    ERR_ETIMEDOUT = 110;
    ERR_ECONNREFUSED = 111;
    ERR_EHOSTDOWN = 112;
    ERR_EHOSTUNREACH = 113;
    ERR_EALREADY = 114;
    ERR_EINPROGRESS = 115;
    ERR_ESTALE = 116;
    ERR_EUCLEAN = 117;
    ERR_ENOTNAM = 118;
    ERR_ENAVAIL = 119;
    ERR_EISNAM = 120;
    ERR_EREMOTEIO = 121;
    ERR_EDQUOT = 122;
    ERR_ENOMEDIUM = 123;
    ERR_EMEDIUMTYPE = 124;
    ERR_ECANCELED = 125;
    ERR_ERESTARTSYS = 512;
    ERR_ERESTARTNOINTR = 513;
    ERR_ERESTARTNOHAND = 514;
    ERR_ENOIOCTLCMD = 515;
    ERR_ERESTART_RESTARTBLOCK = 516;
    ERR_EBADHANDLE = 521;
    ERR_ENOTSYNC = 522;
    ERR_EBADCOOKIE = 523;
    ERR_ENOTSUPP = 524;
    ERR_ETOOSMALL = 525;
    ERR_ESERVERFAULT = 526;
    ERR_EBADTYPE = 527;
    ERR_EJUKEBOX = 528;
    ERR_EIOCBQUEUED = 529;
    ERR_EIOCBRETRY = 530;
}

message aggregations64 {
    required uint64 weight = 1;
    required uint64 max = 2;
    required uint64 min = 3;
    required uint64 sum = 4;
}

message aggregations64_repeated {
    required uint64 weight = 1;
    repeated uint64 max = 2;
    repeated uint64 min = 3;
    repeated uint64 sum = 4;
}

message counter_percentile {
    required uint32 percentile = 1;
    optional uint32 value = 2;
    optional aggregations64 aggr_value = 3;
    reserved 4;
}

message counter_time {
    optional uint32 count = 1;
    optional aggregations64 aggr_count = 4;

    optional uint64 time_ns = 2;
    optional aggregations64 aggr_time_ns = 5;

    optional uint32 time_percentage = 3;
    optional aggregations64 aggr_time_percentage = 6;

    optional bool is_null = 7; //tells if this object is just a placeholder (used when splitting on cassandra)
    repeated counter_percentile percentile = 8;
    reserved 9; // tag used by previous format of counter_percentile_data
    optional counter_percentile_data percentile_data = 10;
}

message counter_time_bidirectional {
    optional uint32 count_in = 1;
    optional aggregations64 aggr_count_in = 5;

    optional uint32 count_out = 2;
    optional aggregations64 aggr_count_out = 6;

    optional uint64 time_ns_in = 3;
    optional aggregations64 aggr_time_ns_in = 7;

    optional uint64 time_ns_out = 4;
    optional aggregations64 aggr_time_ns_out = 8;

    optional bool is_null = 9; //tells if this object is just a placeholder (used when splitting on cassandra)
    repeated counter_percentile percentile_in = 10;
    repeated counter_percentile percentile_out = 11;
    reserved 12, 13; // tags used by previous format of counter_percentile_data
    optional counter_percentile_data percentile_in_data = 14;
    optional counter_percentile_data percentile_out_data = 15;
}

message counter_bytes {
    optional uint32 count_in = 1;
    optional aggregations64 aggr_count_in = 5;

    optional uint32 count_out = 2;
    optional aggregations64 aggr_count_out = 6;

    optional uint32 bytes_in = 3;
    optional aggregations64 aggr_bytes_in = 7;

    optional uint32 bytes_out = 4;
    optional aggregations64 aggr_bytes_out = 8;

    optional bool is_null = 9; //tells if this object is just a placeholder (used when splitting on cassandra)
}

message counter_time_bytes {
    optional uint64 time_ns_in = 1;
    optional aggregations64 aggr_time_ns_in = 13;

    optional uint64 time_ns_out = 2;
    optional aggregations64 aggr_time_ns_out = 14;

    optional uint64 time_ns_other = 3;
    optional aggregations64 aggr_time_ns_other = 15;

    optional uint32 count_in = 4;
    optional aggregations64 aggr_count_in = 16;

    optional uint32 count_out = 5;
    optional aggregations64 aggr_count_out = 17;

    optional uint32 count_other = 6;
    optional aggregations64 aggr_count_other = 18;

    optional uint32 bytes_in = 7;
    optional aggregations64 aggr_bytes_in = 19;

    optional uint32 bytes_out = 8;
    optional aggregations64 aggr_bytes_out = 20;

    optional uint32 bytes_other = 9;
    optional aggregations64 aggr_bytes_other = 21;

    optional uint32 time_percentage_in = 10;
    optional aggregations64 aggr_time_percentage_in = 22;

    optional uint32 time_percentage_out = 11;
    optional aggregations64 aggr_time_percentage_out = 23;

    optional uint32 time_percentage_other = 12;
    optional aggregations64 aggr_time_percentage_other = 24;

    optional bool is_null = 25; //tells if this object is just a placeholder (used when splitting on cassandra)
    repeated counter_percentile percentile_in = 26;
    repeated counter_percentile percentile_out = 27;
    reserved 28, 29; // tags used by previous format of counter_percentile_data
    optional counter_percentile_data percentile_in_data = 30;
    optional counter_percentile_data percentile_out_data = 31;
}

message time_categories {
    optional counter_time unknown = 1;
    optional counter_time other = 2;
    optional counter_time file = 3;
    optional counter_time net = 4;
    optional counter_time ipc = 5;
    optional counter_time memory = 6;
    optional counter_time process = 7;
    optional counter_time sleep = 8;
    optional counter_time system = 9;
    optional counter_time signal = 10;
    optional counter_time user = 11;
    optional counter_time time = 12;
    optional counter_time_bytes io_file = 13;
    optional counter_time_bytes io_net = 14;
    optional counter_time_bytes io_other = 15;
    optional counter_time wait = 16;
    optional counter_time processing = 17;
    optional bool is_null = 18; //tells if this object is just a placeholder (used when splitting on cassandra)
}

//
// Stores how time is spent serving requests by the host
//
message transaction_breakdown_categories {
    optional counter_time other = 2;
    optional counter_time_bytes io_file = 13;
    optional counter_time_bytes io_net = 14;
    optional counter_time processing = 17;
    optional bool is_null = 18; //tells if this object is just a placeholder (used when splitting on cassandra)
}

message counter_syscall_errors {
    optional uint32 count = 1; // Syscall errors count
    optional aggregations64 aggr_count = 3;

    repeated uint32 top_error_codes = 2; // Error codes that were generated the most

    optional uint32 count_file = 4; // Number of file errors
    optional aggregations64 aggr_count_file = 7;

    optional uint32 count_file_open = 5; // Number of file open errors
    optional aggregations64 aggr_count_file_open = 8;

    optional uint32 count_net = 6; // Number of network errors
    optional aggregations64 aggr_count_net = 9;

    optional bool is_null = 10; //tells if this object is just a placeholder (used when splitting on cassandra)
}

message resource_categories {
    optional uint32 capacity_score = 1; // the request capacity score for this process or host. 0 means all the capacity is available, 10000 means that the entity (host or process) has reached the maximum mumber of requests it can serve.
    optional aggregations64 aggr_capacity_score = 12;

    optional uint32 stolen_capacity_score = 6; // the percentage of request capacity that is not available because of CPU steal. 0 means there was no CPU steal during the sample. 100 means that all the capacity was stolen and the machine essentially couldn't run.
    optional aggregations64 aggr_stolen_capacity_score = 7;

    optional uint32 connection_queue_usage_pct = 2; // if this process or host is serving connections, the occupation of the connection queue FOR THE WORST THREAD IN THIS PROCESS OR HOST (0=empty, 100=full)
    optional aggregations64 aggr_connection_queue_usage_pct = 8;

    optional uint32 fd_usage_pct = 3; // the ratio (open FDs / total available FDs) FOR THE WORST THREAD IN THIS PROCESS OR HOST. 0 means no FD in use, 100 means FD limit reached.
    optional aggregations64 aggr_fd_usage_pct = 9;

    // CPU load of a process (including all the children).
    // This is returned in ten-thousandths of a core. For example, a process
    // or container that was taking 1.2 cores would return a value of 12000.
    // Not present for the host.
    optional uint32 cpu_pct = 4;
    optional aggregations64 aggr_cpu_pct = 10;

    optional uint32 resident_memory_usage_kb = 5; // resident non-swapped memory (as kb).
    optional aggregations64 aggr_resident_memory_usage_kb = 11;

    optional uint32 virtual_memory_usage_kb = 13; // total virtual memory (as kb). Not present for the host and container.
    optional aggregations64 aggr_virtual_memory_usage_kb = 17;

    optional uint32 swap_memory_usage_kb = 14; // swapped memory usage (as kb).
    optional aggregations64 aggr_swap_memory_usage_kb = 18;

    optional uint64 major_pagefaults = 15; // number of major page faults since last sample.
    optional aggregations64 aggr_major_pagefaults = 19;

    optional uint64 minor_pagefaults = 16; // number of minor page faults since last sample.
    optional aggregations64 aggr_minor_pagefaults = 20;

    optional uint32 fd_count = 21; // Total number of FDs
    optional aggregations64 aggr_fd_count = 22;

    optional bool is_null = 23; //tells if this object is just a placeholder (used when splitting on cassandra)

    optional uint32 cpu_shares = 24;
    optional aggregations64 aggr_cpu_shares = 124;

    // CPU % of a container in terms of the cpu shares limit assigned to it.
    // This is returned in hundreths of a percent; a value of 340 would
    // represent 3.4%.
    // Container only
    optional uint32 cpu_shares_usage_pct = 25;
    optional aggregations64 aggr_cpu_shares_usage_pct = 125;

    optional uint32 memory_limit_kb = 26; // Max Resident memory allowed for a container
    optional aggregations64 aggr_memory_limit_kb = 126;

    optional uint32 swap_limit_kb = 27; // Max swap memory allowed for a container
    optional aggregations64 aggr_swap_limit_kb = 127;

    optional uint32 cpu_quota_used_pct = 28;
    optional aggregations64 aggr_cpu_quota_used_pct = 128;

    optional uint32 swap_memory_total_kb = 29; // swapped memory total (as kb).
    optional aggregations64 aggr_swap_memory_total_kb = 129;

    optional uint32 swap_memory_available_kb = 30; // swapped memory available (as kb).
    optional aggregations64 aggr_swap_memory_available_kb = 130;

    optional uint64 count_processes = 31; // total processes
    optional aggregations64 aggr_count_processes = 131; // aggr total processes

    optional uint64 proc_start_count = 32; // started processes
    optional aggregations64 aggr_proc_start_count = 132; // aggr total start count processes

    optional uint64 jmx_sent = 33;
    optional aggregations64 aggr_jmx_sent = 133;

    optional uint64 jmx_total = 34;
    optional aggregations64 aggr_jmx_total = 134;

    optional uint64 statsd_sent = 35;
    optional aggregations64 aggr_statsd_sent = 135;

    optional uint64 statsd_total = 36;
    optional aggregations64 aggr_statsd_total = 136;

    optional uint64 app_checks_sent = 37;
    optional aggregations64 aggr_app_checks_sent = 137;

    optional uint64 app_checks_total = 38;
    optional aggregations64 aggr_app_checks_total = 138;

    optional uint64 threads_count = 39; // number of threads
    optional aggregations64 aggr_threads_count = 139;

    optional uint64 prometheus_sent = 40;
    optional aggregations64 aggr_prometheus_sent = 140;

    optional uint64 prometheus_total = 41;
    optional aggregations64 aggr_prometheus_total = 141;

    optional uint64 syscall_count = 42; // total number of syscalls
    optional aggregations64 aggr_syscall_count = 142; // aggregation of syscall_count

    // The value of CFS quota limits (quota/period), in whole CPUs.
    // This is returned in hundredths of a percent of a core which is consistent
    // with similar metrics. For example, 2 cores would return 20000.
    // Container only.
    optional uint32 cpu_cores_quota_limit = 43;
    optional aggregations64 aggr_cpu_cores_quota_limit = 143;

    // CPU % of a container as a proportion of the number of cpus in the cpuset
    // to which the container is assigned. So if a container was taking 10% on a
    // 4-core machine, it would be taking 20% of a 2-core cpuset.
    // Container only.
    optional uint32 cpu_cpuset_usage_pct = 44;
    optional aggregations64 aggr_cpu_cpuset_usage_pct = 144;

    // The number of cores in the cpuset to which the container is assigned.
    // This is returned in hundredths of a percent of a core which is consistent
    // with similar metrics. For example, a cpuset with 2 cores would return 20000.
    // Container only.
    optional uint32 cpu_cores_cpuset_limit = 45;
    optional aggregations64 aggr_cpu_cores_cpuset_limit = 145;

    optional uint64 rw_bytes = 46;
    optional aggregations64 aggr_rw_bytes = 146;
}

message connection_categories {
    optional counter_bytes server = 1; // client-side metrics
    optional counter_bytes client = 2; // server-side metrics
    optional counter_time_bidirectional transaction_counters = 3; // The transaction counters for this connection

    optional uint32 n_aggregated_connections = 4; // If this is an aggregated connection, the number of real connections it represents
    optional aggregations64 aggr_n_aggregated_connections = 5;

    optional bool is_null = 6; //tells if this object is just a placeholder (used when splitting on cassandra)
    optional counter_time_bidirectional min_transaction_counters = 18; // The fastest transaction counters for this connection
    optional counter_time_bidirectional max_transaction_counters = 19; // The slowest transaction counters for this connection
}

message process_details {
    required string comm = 1; // Command name (e.g. "top")
    required string exe = 2; // argv[0] (e.g. "sshd: gianluca@pts/4")
    repeated string args = 3; // Command line arguments (e.g. "-d1")
    optional string container_id = 4;
}

// In some cases, a command has a category that identfies
// why it was run. Descriptions:
// CAT_NONE: no specific category
// CAT_CONTAINER: a process run in a container and *not* any
//                of the following more specific categories.
// CAT_HEALTHCHECK: part of a container healthcheck
// CAT_LIVENESS_PROBE: part of a k8s liveness probe
// CAT_READINESS_PROBE: part of a k8s readiness probe
enum command_category {
    CAT_NONE = 0;
    CAT_CONTAINER = 1;
    CAT_HEALTHCHECK = 2;
    CAT_LIVENESS_PROBE = 3;
    CAT_READINESS_PROBE = 4;
}

//
// Description of a command executed on the machine
//
message command_details {
    required uint64 timestamp = 1;
    optional uint32 count = 2; // How many times this command has been repeated during the sample interval
    required string cmdline = 3; // Program command line (e.g. "top -d1")
    required string comm = 4; // Program executable name
    required uint64 pid = 5; // Process pid
    required uint64 ppid = 6; // Parent process pid
    required uint64 uid = 7; // User ID
    optional string cwd = 8; // Process' current working directory
    optional uint64 login_shell_id = 9; // ID of the login shell (same as in the spy_users chisel)
    optional uint32 login_shell_distance = 10; // Distance from the login shell (same as in the spy_users chisel)
    optional uint32 tty = 11; // Tty
    optional bool is_healthcheck = 12; // If true, related to a container health check. Deprecated by category.
    optional command_category category = 13;
}

//
// Counters for a protocol-related dimension, like a URL or a query
//
message counter_proto_entry {
    required uint32 ncalls = 1;
    optional aggregations64 aggr_ncalls = 7;

    required uint64 time_tot = 2;
    optional aggregations64 aggr_time_tot = 8;

    required uint64 time_max = 3;
    optional aggregations64 aggr_time_max = 9;

    required uint64 bytes_in = 4;
    optional aggregations64 aggr_bytes_in = 10;

    required uint64 bytes_out = 5;
    optional aggregations64 aggr_bytes_out = 11;

    required uint32 nerrors = 6;
    optional aggregations64 aggr_nerrors = 12;

    repeated counter_percentile percentile = 13;
    reserved 14; // tag used by previous format of counter_percentile_data
    optional counter_percentile_data percentile_data = 15;
}

//
// URL information
//
message url_details {
    //
    // The URL, in the following format "TYPEADDR<:PORT>/PATH", e.g. "p172.16.189.128:9000/api/data".
    // Note: possible values foy type are:
    //   n for NONE
    //   g for GET
    //   p for POST
    //   o for OPTIONS
    //   h for HEAD
    //   P for PUT
    //   d for DELETE
    //   t for TRACE
    //   c for CONNECT
    //
    required string url = 1;
    required counter_proto_entry counters = 2;
}

message status_code_details {
    required uint32 status_code = 1;

    required uint32 ncalls = 2;
    optional aggregations64 aggr_ncalls = 3;
}

//
// HTTP protocol information
//
message http_info {
    repeated url_details server_urls = 1;
    repeated url_details client_urls = 2;
    repeated status_code_details client_status_codes = 3;
    repeated status_code_details server_status_codes = 4;
    optional counter_proto_entry server_totals = 5;
    optional counter_proto_entry client_totals = 6;
}

//
// SQL query information
//
message sql_entry_details {
    required string name = 1;
    required counter_proto_entry counters = 2;
}

//
// SQL statement information
//
enum sql_statement_type {
    SOP_NONE = 0;
    SOP_SELECT = 1;
    SOP_INSERT = 2;
    SOP_SET = 3;
    SOP_CREATE = 4;
    SOP_DELETE = 5;
    SOP_DROP = 6;
    SOP_REPLACE = 7;
    SOP_UPDATE = 8;
    SOP_USE = 9;
    SOP_SHOW = 10;
    SOP_LOCK = 11;
    SOP_UNLOCK = 12;
    SOP_ALTER = 13;
}

message sql_query_type_details {
    required sql_statement_type type = 1;
    required counter_proto_entry counters = 2;
}

//
// SQL protocol information
//
message sql_info {
    repeated sql_entry_details server_queries = 1; // the top server-side queries
    repeated sql_entry_details client_queries = 2; // the top client-side queries
    repeated sql_query_type_details server_query_types = 3; // the top server-side query types (e.g. SELECT, INSERT...)
    repeated sql_query_type_details client_query_types = 4; // the top client-side query types (e.g. SELECT, INSERT...)
    repeated sql_entry_details server_tables = 5; // the top server-side queries
    repeated sql_entry_details client_tables = 6; // the top client-side queries
    optional counter_proto_entry server_totals = 7;
    optional counter_proto_entry client_totals = 8;
}

message mongodb_collection_details {
    required string name = 1;
    required counter_proto_entry counters = 2;
}

enum mongodb_op_type {
    MONGODB_OP_NONE = 0;
    MONGODB_OP_INSERT = 1;
    MONGODB_OP_UPDATE = 2;
    MONGODB_OP_DELETE = 3;
    MONGODB_OP_GET_MORE = 4;
    MONGODB_OP_KILL_CURSORS = 5;
    MONGODB_OP_FIND = 6;
    MONGODB_OP_AGGREGATE = 7;
    MONGODB_OP_COMMAND = 8;
    MONGODB_OP_COUNT = 9;
    MONGODB_OP_DISTINCT = 10;
    MONGODB_OP_MAP_REDUCE = 11;
    MONGODB_OP_GEO_NEAR = 12;
    MONGODB_OP_GEO_SEARCH = 13;
    MONGODB_OP_FIND_AND_MODIFY = 14;
}

message mongodb_op_type_details {
    required mongodb_op_type op = 1;
    required counter_proto_entry counters = 2;
}

message mongodb_info {
    repeated mongodb_op_type_details servers_ops = 1;
    repeated mongodb_op_type_details client_ops = 2;
    repeated mongodb_collection_details server_collections = 3;
    repeated mongodb_collection_details client_collections = 4;
    optional counter_proto_entry server_totals = 5;
    optional counter_proto_entry client_totals = 6;
}

enum unit {
    UNIT_NONE = 0;
    UNIT_SECOND = 1;
    UNIT_BYTE = 2;
    UNIT_PERCENT = 3;
}

enum scale {
    SCALE_NONE = 0;

    SCALE_MILLI = 1;
    SCALE_MICRO = 2;
    SCALE_NANO = 3;
    SCALE_MINUTE = 4;
    SCALE_HOUR = 5;
    SCALE_DAY = 6;

    SCALE_KILO = 7;
    SCALE_MEGA = 8;
    SCALE_GIGA = 9;
    SCALE_TERA = 10;
    SCALE_KIBI = 11;
    SCALE_MEBI = 12;
    SCALE_GIBI = 13;
    SCALE_TEBI = 14;

    SCALE_PERCENT_0_1 = 15;
}

enum jmx_metric_type {
    JMX_METRIC_TYPE_COUNTER = 1;
    JMX_METRIC_TYPE_GAUGE = 2;
}

message statsd_tag {
    required string key = 1;
    optional string value = 2;
}

message jmx_attribute {
    optional string name = 1;

    optional double value = 2;
    optional aggregations64 aggr_value = 4;
    optional aggregations_double aggr_value_double = 6;

    repeated jmx_attribute subattributes = 3;
    optional string alias = 5;
    optional jmx_metric_type type = 7;
    optional unit unit = 8;
    optional scale scale = 9;
    // segment_by is a key-value pair
    // let's use statsd_tag that is an already defined
    // structure
    repeated statsd_tag segment_by = 10;
}

message jmx_bean {
    optional string name = 1;
    repeated jmx_attribute attributes = 2;
}

message java_info {
    optional string process_name = 1;
    repeated jmx_bean beans = 2;
}

enum statsd_metric_type {
    STATSD_COUNT = 1;
    STATSD_HISTOGRAM = 2;
    STATSD_GAUGE = 3;
    STATSD_SET = 4;
}

message statsd_metric {
    optional string name = 1;
    repeated statsd_tag tags = 2;
    optional statsd_metric_type type = 3;

    // Valid on COUNT, GAUGE and SET
    optional double value = 4;
    optional aggregations_double aggr_value = 104;

    // Valid only on HISTOGRAM type
    optional double sum = 5;
    optional aggregations_double aggr_sum = 105;

    optional double min = 6;
    optional aggregations_double aggr_min = 106;

    optional double max = 7;
    optional aggregations_double aggr_max = 107;

    optional double count = 8;
    optional aggregations_double aggr_count = 108;

    optional double median = 9;
    optional aggregations_double aggr_median = 109;

    optional double percentile_95 = 10;
    optional aggregations_double aggr_percentile_95 = 110;

    optional double percentile_99 = 11;
    optional aggregations_double aggr_percentile_99 = 111;

    repeated counter_percentile percentile = 12;
    reserved 13; // tag used by previous format of counter_percentile_data
    optional counter_percentile_data percentile_data = 14;
}

message statsd_info {
    // May be used in the future to add metadata
    repeated statsd_metric statsd_metrics = 1;
}

enum app_metric_type {
    APP_METRIC_TYPE_GAUGE = 1;
    APP_METRIC_TYPE_RATE = 2;
    APP_METRIC_TYPE_BUCKETS = 3;
    APP_METRIC_TYPE_PROMETHEUS_RAW = 4;
}

enum prometheus_type {
    PROMETHEUS_TYPE_INVALID = 0;
    PROMETHEUS_TYPE_COUNTER = 1;
    PROMETHEUS_TYPE_GAUGE = 2;
    PROMETHEUS_TYPE_HISTOGRAM = 3;
    PROMETHEUS_TYPE_SUMMARY = 4;
    // unknown is used either for prometheus "untyped" family,
    // or any other family type we don't recognize.
    PROMETHEUS_TYPE_UNKNOWN = 5;
}

message app_tag {
    required string key = 1;
    optional string value = 2;
}

message app_metric {
    optional string name = 1;
    optional app_metric_type type = 2;

    // Valid for gauge, rate, and the prometheus raw types
    optional double value = 3;
    optional aggregations_double aggr_value_double = 103;

    repeated app_tag tags = 4;

    // Valid for BUCKETS
    repeated app_metric_bucket buckets = 5;

    // Valid when type is APP_METRIC_TYPE_PROMETHEUS_RAW
    optional prometheus_type prometheus_type = 6;
}

enum app_check_value {
    APP_CHECK_VALUE_OK = 0;
    APP_CHECK_VALUE_WARNING = 1;
    APP_CHECK_VALUE_CRITICAL = 2;
    APP_CHECK_VALUE_UNKNOWN = 3;
}

message app_check {
    optional string name = 1;
    optional app_check_value value = 2;
    repeated app_tag tags = 3;
}

message app_info {
    optional string process_name = 1;
    repeated app_metric metrics = 2;
    repeated app_check checks = 3;
}

message prom_metric {
    optional string name = 1;
    optional app_metric_type type = 2;

    // Valid for gauge, rate, and the prometheus raw types
    optional double value = 3;
    optional aggregations_double aggr_value_double = 103;

    repeated app_tag tags = 4;

    // Valid for BUCKETS
    repeated app_metric_bucket buckets = 5;

    // Valid when type is APP_METRIC_TYPE_PROMETHEUS_RAW
    optional prometheus_type prometheus_type = 6;
}
message prometheus_info {
    optional string process_name = 1;
    repeated prom_metric metrics = 2;
}

//
// General protocol information
//
message proto_info {
    optional http_info http = 1;
    optional sql_info mysql = 2;
    optional sql_info postgres = 3;
    optional mongodb_info mongodb = 4;
    optional java_info java = 5; // These are not protocols but as backend is structured is better to save here these info
    optional statsd_info statsd = 6;
    optional app_info app = 7;
    optional bool is_null = 8; //tells if this object is just a placeholder (used when splitting on cassandra)

    // only used if 10s flush is disabled
    optional app_info prometheus = 9;

    // only used if 10s flush is enabled
    optional prometheus_info prom_info = 10;
}

/*
These maps are used to encode/decode only one element of the proto_info
depending on the enclosing cassandra column. Container/proc ids correspond
to the container/proc owning the proto_info content. In case of host-wide
column they shall be empty
 */
message proto_metric_map {
    repeated string containers_ids = 1;
    repeated uint32 process_ids = 2;
    repeated proto_info proto_info = 3;
}
message network_by_port {
    required uint32 port = 1;
    required connection_categories counters = 2;
}

//
// HOST
// global host info.
//
message host {
    optional string hostname = 1; // The name of the host sending the data

    optional uint32 num_cpus = 2; // Number of CPUs in the system
    optional aggregations64 aggr_num_cpus = 21;

    repeated uint32 cpu_loads = 3; // Array of CPU loads (0 to 100), with an entry for each CPU
    optional aggregations64_repeated aggr_cpu_loads = 15;
    
    required uint64 physical_memory_size_bytes = 4; // Physical RAM size
    optional aggregations64 aggr_physical_memory_size_bytes = 17;

    optional time_categories tcounters = 5; // The time counters for this thread
    optional counter_time_bidirectional transaction_counters = 6; // The transaction counters for the whole host

    optional uint64 transaction_processing_delay = 7; // the delay introduced by this host when processing transactions.
    optional aggregations64 aggr_transaction_processing_delay = 18;

    optional resource_categories resource_counters = 8; // The resource counters for this process
    optional counter_syscall_errors syscall_errors = 9; // Syscall error counter
    optional counter_time_bytes external_io_net = 10; // The I/O statistics filtered so that only the activity with the external world is used

    repeated uint32 cpu_steal = 11; // Array of CPU loads (0 to 100), with an entry for each CPU
    optional aggregations64_repeated aggr_cpu_steal = 16;

    optional transaction_breakdown_categories reqcounters = 12; // how time is spent when serving requests

    optional uint64 next_tiers_delay = 13; // the delay introduced by this host's next tiers when processing transactions.
    // It's calculated by subtracting outgoing connection time from incoming connection time.
    optional aggregations64 aggr_next_tiers_delay = 20;

    // NEVER USED optional uint64 merged_server_delay = 14; // the total merged time of all the incoming requests.
    reserved 19;
    optional counter_time_bidirectional min_transaction_counters = 22; // The fastest transaction counters for the whole host
    optional counter_time_bidirectional max_transaction_counters = 23; // The slowest transaction counters for the whole host
    repeated network_by_port network_by_serverports = 24;

    repeated uint32 cpu_idle = 25; // cpu_idle
    optional aggregations64_repeated aggr_cpu_idle = 125; // aggr cpu idle

    optional double system_load = 32; // system load
    optional aggregations_double aggr_system_load = 132;

    optional uint64 uptime = 33; // uptime to calculate the reboot
    optional aggregations64 aggr_uptime = 133; // aggregate uptime

    repeated uint32 system_cpu = 34; // system_cpu
    optional aggregations64_repeated aggr_system_cpu = 134; // aggr system cpu

    repeated uint32 user_cpu = 35; // user_cpu
    optional aggregations64_repeated aggr_user_cpu = 135; // aggr user cpu

    optional uint64 memory_bytes_available_kb = 36; // memory bytes available as kb
    optional aggregations64 aggr_memory_bytes_available_kb = 136;

    repeated uint32 iowait_cpu = 37; // iowait_cpu
    optional aggregations64_repeated aggr_iowait_cpu = 137; // aggr iowait cpu
 
    repeated uint32 nice_cpu = 38; // nice_cpu
    optional aggregations64_repeated aggr_nice_cpu = 138; // aggr nice cpu

    optional uint32 system_load_1 = 41; // avg system load 1 minute
    optional aggregations64 aggr_system_load_1 = 141; // aggregation system load 1

    optional uint32 system_load_5 = 42; // avg system load 5 minutes
    optional aggregations64 aggr_system_load_5 = 142; // aggregation system load 5

    optional uint32 system_load_15 = 43; // avg system load 15 minutes
    optional aggregations64 aggr_system_load_15 = 143; // aggregation system load 15
}

//
// PROCESS
// info for a process, i.e. a collection of threads.
// NOTE: this is process info only, when emitting threads, the main thread of a process will have a
// separate thread message with tid=process pid.
//
enum networkrole {
    NONE = 0; // set if this thread serves IPv4 transactions coming from the same machine.
    IS_LOCAL_IPV4_SERVER = 1; // set if this thread serves IPv4 transactions coming from the same machine.
    IS_REMOTE_IPV4_SERVER = 2; // set if this thread serves IPv4 transactions coming from another machine.
    IS_UNIX_SERVER = 4; // set if this thread serves unix transactions.
    IS_LOCAL_IPV4_CLIENT = 8; // set if this thread creates IPv4 transactions toward localhost.
    IS_REMOTE_IPV4_CLIENT = 16; // set if this thread creates IPv4 transactions toward another host.
    IS_UNIX_CLIENT = 32; // set if this thread creates unix transactions.
}

//
// TOP FILE STATISTICS
//
message file_stat {
    required string name = 1;

    required uint32 bytes = 2;
    optional aggregations64 aggr_bytes = 9;

    required uint64 time_ns = 3;
    optional aggregations64 aggr_time_ns = 6;

    required uint32 open_count = 4;
    optional aggregations64 aggr_open_count = 7;

    required uint32 errors = 5;
    optional aggregations64 aggr_errors = 8;

    optional uint32 bytes_in = 10;
    optional uint32 bytes_out = 11;
}

message process {
    optional process_details details = 2; // names and string constants relative to this process
    optional bool is_ipv4_transaction_server = 3; // True if this process has served at least one IPv4 transaction.
    optional bool is_unix_transaction_server = 4; // True if this process has served at least one unix transaction.
    optional time_categories tcounters = 5; // The time counters for this thread.
    optional counter_time_bidirectional transaction_counters = 6; // The transaction counters for this process.

    optional uint64 transaction_processing_delay = 7; // the delay introduced by this process when processing transactions.
    optional aggregations64 aggr_transaction_processing_delay = 15;

    optional resource_categories resource_counters = 8; // The resource counters for this process
    optional counter_syscall_errors syscall_errors = 9; // Syscall error counter
    optional bool is_ipv4_transaction_client = 10; // True if this process has been the client for at least one IPv4 transaction.
    optional bool is_unix_transaction_client = 11; // True if this process has been the client for at least one unix transaction.
    optional uint64 next_tiers_delay = 12; // the delay introduced by this process' next tiers when processing transactions.
    optional aggregations64 aggr_next_tiers_delay = 17;

    optional uint32 netrole = 13;
    // It's calculated by subtracting outgoing connection time from incoming connection time.
    // NEVER USED optional uint64 merged_server_delay = 14; // the total merged time of all the incoming requests.
    reserved 16;
    optional counter_time_bidirectional min_transaction_counters = 18; // The fastest transaction counters for this process.
    optional counter_time_bidirectional max_transaction_counters = 19; // The slowest transaction counters for this process.
    optional proto_info protos = 20; // Information about protocols that have been decoded

    optional uint64 start_count = 21; // start processes
    optional aggregations64 aggr_start_count = 22; // aggr start processes

    optional uint64 count_processes = 23; // number of instances with same command line
    optional aggregations64 aggr_count_processes = 123; // aggr number of instances with same command line

    repeated file_stat top_files = 24;
    repeated file_stat top_devices = 25;
}

//
// PROGRAM
// info for a program, i.e. a collection of processes with the same name and the same creator.
//
message program {
    required process procinfo = 1; // Information about this program
    repeated uint64 pids = 2; // The list of processes that are part of this program
    repeated uint64 uids = 3; // The list of user ids that are running the processes forming this program
    optional bytes environment_hash = 4; // the hash of all environment variables

    repeated uint32 program_reporting_group_id = 5; // maps to the group under which this program was reported
}

message id_map {
    optional uint64 id = 1;
    optional string name = 2;
}

message environment {
    optional bytes hash = 1; // the hash referenced in `message program`
    repeated string variables = 2; // individual variables as `KEY=value` strings
}

//
// IPv4 CONNECTION
//

//from sysdig
//typedef enum scap_l4_proto
//{
//    SCAP_L4_UNKNOWN = 0, ///< unknown protocol, likely caused by some parsing problem
//    SCAP_L4_NA = 1, ///< protocol not available, because the fd is not a socket
//    SCAP_L4_TCP = 2,
//    SCAP_L4_UDP = 3,
//    SCAP_L4_ICMP = 4,
//    SCAP_L4_RAW = 5, ///< Raw socket
//}scap_l4_proto;

message ipv4tuple {
    required uint32 sip = 1;
    required uint32 dip = 2;
    required uint32 sport = 3;
    required uint32 dport = 4;
    required uint32 l4proto = 5;
}

enum connection_state {
    CONN_SUCCESS = 0;
    CONN_PENDING = 1;
    CONN_FAILED = 2;
}

message ipv4_connection {
    required ipv4tuple tuple = 1;

    optional uint64 spid = 2; // The pid of the client
    optional uint64 dpid = 5; // The pid of the server

    required connection_categories counters = 8; // the metrics for this connection
    optional connection_state state = 9;
    optional error_code error_code = 10;
}

// Similar to ipv4 connection, but primary key is different
message ipv4_incomplete_connection {
    required ipv4tuple tuple = 1;

    optional uint64 spid = 2; // The pid of the client
    optional uint64 dpid = 5; // The pid of the server

    required connection_categories counters = 8; // the metrics for this connection
    optional connection_state state = 9;
    optional error_code error_code = 10;
}
//
// NETWORK INTERFACE
//
message ipv4_network_interface {
    required string name = 1; // ifconfig entry name, e.g. eth0
    required uint32 addr = 2; // IP address
    required uint32 netmask = 3; // netmask
    optional uint32 bcast = 4; // broadcast address
}

//
// MESSAGE TYPES
//
enum message_type {
    METRICS = 1;
    DUMP_REQUEST_START = 2;
    DUMP_REQUEST_STOP = 4;
    DUMP_RESPONSE = 3;
    SSH_OPEN_CHANNEL = 6;
    SSH_CLOSE_CHANNEL = 7;
    SSH_DATA = 8;
    AUTO_UPDATE_REQUEST = 9;
    DIRTY_SHUTDOWN_REPORT = 10;
    CONFIG_DATA = 11;
    ERROR_MESSAGE = 12;
    POLICIES = 13;
    POLICY_EVENTS = 14;
    THROTTLED_POLICY_EVENTS = 15;
    ORCHESTRATOR_EVENTS = 16;
    BASELINES = 17;
    COMP_RESULTS = 18;
    COMP_CALENDAR = 19;
    AUDIT_TAP = 20;
    COMP_RUN = 21;
    POLICIES_V2 = 22;
    SECURE_AUDIT = 23;
    PROTOCOL_INIT = 24;
    PROTOCOL_INIT_RESP = 25;
    PROTOCOL_HANDSHAKE_V1 = 26;
    PROTOCOL_HANDSHAKE_V1_RESP = 27;
    AGGREGATION_CONTEXT = 28;
    PROTOCOL_ACK = 29;
    SECURE_PROFILING_FINGERPRINT = 30;
}

//
// MOUNTED FILE SYSTEM
//
message mounted_fs {
    required string device = 1;
    required string mount_dir = 2;
    required string type = 3;

    required uint64 size_bytes = 4;
    optional aggregations64 aggr_size_bytes = 7;

    required uint64 used_bytes = 5;
    optional aggregations64 aggr_used_bytes = 8;

    required uint64 available_bytes = 6;
    optional aggregations64 aggr_available_bytes = 9;

    optional uint64 total_inodes = 10;
    optional aggregations64 aggr_total_inodes = 110;

    optional uint64 used_inodes = 11;
    optional aggregations64 aggr_used_inodes = 111;
}

enum container_type {
    DOCKER = 1;
    LXC = 2;
    LIBVIRT_LXC = 3;
    MESOS = 4;
    RKT = 5;
    CUSTOM = 6;
    CRI = 7;
    CONTAINERD = 8;
    CRIO = 9;
    COALESCE = 10;
}

message container_reporting_group {
    optional uint32 id = 1;
    repeated string label = 2; // simply a list of labels that might apply to a given container
    repeated string image = 3; // list of images which could match a container in this group
    optional bool require_match_all = 4; // if true, container must match all labels and one image. If false, must match at least one label or one image
}

message container_port_mapping {
    optional uint32 host_ip = 1;
    optional uint32 host_port = 2;
    optional uint32 container_ip = 3;
    optional uint32 container_port = 4;
}

message container_label {
    required string key = 1;
    optional string value = 2;
}

message container {
    required string id = 1;
    optional container_type type = 2;
    optional string name = 3;
    optional string image = 4;
    optional time_categories tcounters = 5; // The time counters for this thread
    optional transaction_breakdown_categories reqcounters = 6; // how time is spent when serving requests
    optional counter_time_bidirectional transaction_counters = 7; // The transaction counters for the whole host
    optional counter_time_bidirectional min_transaction_counters = 8; // The fastest transaction counters for the whole host
    optional counter_time_bidirectional max_transaction_counters = 9; // The slowest transaction counters for the whole host

    optional uint64 transaction_processing_delay = 10; // the delay introduced by this host when processing transactions.
    optional aggregations64 aggr_transaction_processing_delay = 15;

    // It's calculated by subtracting outgoing connection time from incoming connection time.
    // NEVER USED optional uint64 merged_server_delay = 11; // the total merged time of all the incoming requests.

    optional uint64 next_tiers_delay = 12; // the delay introduced by this host's next tiers when processing transactions.
    optional aggregations64 aggr_next_tiers_delay = 17;

    optional resource_categories resource_counters = 13; // The resource counters for this process
    optional counter_syscall_errors syscall_errors = 14; // Syscall error counter
    reserved 16;
    repeated container_port_mapping port_mappings = 18;
    optional proto_info protos = 19;
    repeated container_label labels = 20;
    repeated mounted_fs mounts = 21;
    repeated network_by_port network_by_serverports = 22;
    optional string mesos_task_id = 23;
    optional string image_id = 24;
    repeated command_details commands = 25; // List of commands executed in this container during the sample.
    repeated container_label orchestrators_fallback_labels = 26;
    optional string image_repo = 27;
    optional string image_tag = 28;
    optional string image_digest = 29;
    repeated uint32 container_reporting_group_id = 30; // maps to the group under which this group was reported
    repeated file_stat top_files = 31;
    repeated file_stat top_devices = 32;
}

//
// ORCHESTRATOR METADATA
//
message congroup_uid {
    optional string kind = 1;
    optional string id = 2;
}

message congroup_net_port {
    required uint32 port = 1;
    required uint32 target_port = 2;
    optional string protocol = 3;
    optional uint32 node_port = 4;
    optional uint32 published_port = 5; // swarm_port
}

// in the backend, this is used for the tags/internal_tags in container_group
// instead of the map
message map_tag_entry {
    optional string key = 1;
    optional string value = 2;
}

message container_group {
    optional congroup_uid uid = 1;
    map<string, string> tags = 3;
    map<string, string> internal_tags = 10;
    repeated string ip_addresses = 5;
    repeated congroup_net_port ports = 6;
    repeated app_metric metrics = 7;
    repeated congroup_uid children = 8;
    repeated congroup_uid parents = 9;
}

enum congroup_event_type {
    ADDED = 1;
    REMOVED = 2;
    UPDATED = 3;
}

message congroup_update_event {
    required congroup_event_type type = 1;
    required container_group object = 3;
}

message orchestrator_events {
    repeated congroup_update_event events = 1;
}

//
// KUBERNETES
//
message k8s_pair {
    required string key = 1;
    required string value = 2;
}

message k8s_common {
    required string name = 1;
    required string uid = 2;
    optional string namespace = 3;
    repeated k8s_pair labels = 4;
    repeated k8s_pair selectors = 5;
    repeated k8s_pair parents = 6;
}

message pod_status_count {
    optional string status = 1;
    optional uint64 count = 2;
    optional aggregations64 aggr_count = 100;
}

message k8s_namespace {
    // 8:   deprecated persistentvolume_count
    // 108: deprecated aggr_persistentvolumeclaim_count
    reserved 8, 108;
    required k8s_common common = 1;

    optional uint64 deployment_count = 2;
    optional aggregations64 aggr_deployment_count = 102;

    optional uint64 service_count = 3;
    optional aggregations64 aggr_service_count = 103;

    optional uint64 replicaset_count = 4;
    optional aggregations64 aggr_replicaset_count = 104;

    optional uint64 job_count = 5;
    optional aggregations64 aggr_job_count = 105;

    optional uint64 statefulset_count = 6;
    optional aggregations64 aggr_statefulset_count = 106;

    optional uint64 resourcequota_count = 7;
    optional aggregations64 aggr_resourcequota_count = 107;

    optional uint64 persistentvolumeclaim_count = 9;
    optional aggregations64 aggr_persistentvolumeclaim_count = 109;

    optional uint64 hpa_count = 10;
    optional aggregations64 aggr_hpa_count = 110;

    optional uint64 pod_desired_count = 11;
    optional aggregations64 aggr_pod_desired_count = 111;

    optional uint64 pod_available_count = 12;
    optional aggregations64 aggr_pod_available_count = 112;

    repeated pod_status_count pod_status_count = 13;
}

message k8s_node {
    required k8s_common common = 1;
    repeated string host_ips = 2;

    optional double capacity_cpu_cores = 3;
    optional aggregations_double aggr_capacity_cpu_cores = 103;

    optional uint64 capacity_mem_bytes = 4;
    optional aggregations64 aggr_capacity_mem_bytes = 104;

    optional uint32 capacity_pods = 5;
    optional aggregations64 aggr_capacity_pods = 105;

    optional double allocatable_cpu_cores = 6;
    optional aggregations_double aggr_allocatable_cpu_cores = 106;

    optional uint64 allocatable_mem_bytes = 7;
    optional aggregations64 aggr_allocatable_mem_bytes = 107;

    optional uint32 allocatable_pods = 8;
    optional aggregations64 aggr_allocatable_pods = 108;

    optional uint32 unschedulable = 9;
    optional aggregations64 aggr_unschedulable = 109;

    optional uint32 ready = 10;
    optional aggregations64 aggr_ready = 110;

    optional uint32 out_of_disk = 11;
    optional aggregations64 aggr_out_of_disk = 111;

    optional uint32 mem_pressure = 12;
    optional aggregations64 aggr_mem_pressure = 112;

    optional uint32 disk_pressure = 13;
    optional aggregations64 aggr_disk_pressure = 113;

    optional uint32 net_unavailable = 14;
    optional aggregations64 aggr_net_unavailable = 114;
}

message k8s_pod {
    required k8s_common common = 1;
    // pods have no selectors
    repeated string container_ids = 2;
    optional string node_name = 3;
    optional string host_ip = 4;
    optional string internal_ip = 5;

    optional uint32 restart_count = 6;
    optional aggregations64 aggr_restart_count = 106;

    optional uint32 containers_waiting = 7;
    optional aggregations64 aggr_containers_waiting = 107;

    optional string job_name = 8;

    optional uint32 status_ready = 9;
    optional aggregations64 aggr_status_ready = 108;

    optional double requests_cpu_cores = 10;
    optional aggregations_double aggr_requests_cpu_cores = 109;

    optional double limits_cpu_cores = 11;
    optional aggregations_double aggr_limits_cpu_cores = 110;

    optional uint64 requests_mem_bytes = 12;
    optional aggregations64 aggr_requests_mem_bytes = 111;

    optional uint64 limits_mem_bytes = 13;
    optional aggregations64 aggr_limits_mem_bytes = 112;

    optional uint32 restart_rate = 14;
    optional aggregations64 aggr_restart_rate = 113;
}

message k8s_replication_controller {
    required k8s_common common = 1;

    optional uint32 replicas_desired = 2;
    optional aggregations64 aggr_replicas_desired = 102;

    optional uint32 replicas_running = 3;
    optional aggregations64 aggr_replicas_running = 103;

    optional uint32 replicas_fully_labeled = 4;
    optional aggregations64 aggr_replicas_fully_labeled = 104;

    optional uint32 replicas_ready = 5;
    optional aggregations64 aggr_replicas_ready = 105;

    optional uint32 replicas_available = 6;
    optional aggregations64 aggr_replicas_available = 106;
}

message k8s_replica_set {
    required k8s_common common = 1;

    optional uint32 replicas_desired = 2;
    optional aggregations64 aggr_replicas_desired = 102;

    optional uint32 replicas_running = 3;
    optional aggregations64 aggr_replicas_running = 103;

    optional uint32 replicas_fully_labeled = 4;
    optional aggregations64 aggr_replicas_fully_labeled = 104;

    optional uint32 replicas_ready = 5;
    optional aggregations64 aggr_replicas_ready = 105;
}

message k8s_service_net_port {
	required uint32 port = 1;
	required uint32 target_port = 2;
	optional string protocol = 3;
	optional uint32 node_port = 4;
}

message k8s_service {
    required k8s_common common = 1;
    optional string cluster_ip = 2;
    repeated k8s_service_net_port ports = 3;
}

message k8s_deployment {
    required k8s_common common = 1;

    optional uint32 replicas_desired = 2;
    optional aggregations64 aggr_replicas_desired = 102;

    optional uint32 replicas_running = 3;
    optional aggregations64 aggr_replicas_running = 103;

    optional uint32 replicas_available = 4;
    optional aggregations64 aggr_replicas_available = 104;

    optional uint32 replicas_unavailable = 5;
    optional aggregations64 aggr_replicas_unavailable = 105;

    optional uint32 replicas_updated = 6;
    optional aggregations64 aggr_replicas_updated = 106;

    optional uint32 replicas_paused = 7;
    optional aggregations64 aggr_replicas_paused = 107;
}

message k8s_daemonset {
    required k8s_common common = 1;

    optional uint32 current_scheduled = 2;
    optional aggregations64 aggr_pods_scheduled = 102;

    optional uint32 desired_scheduled = 3;
    optional aggregations64 aggr_pods_desired = 103;

    optional uint32 pods_misscheduled = 4;
    optional aggregations64 aggr_pods_misscheduled = 104;

    optional uint32 pods_ready = 5;
    optional aggregations64 aggr_pods_ready = 105;
}

message k8s_job {
    required k8s_common common = 1;

    optional uint32 parallelism = 2;
    optional aggregations64 aggr_parallelism = 102;

    optional uint32 completions = 3;
    optional aggregations64 aggr_completions = 103;

    optional uint32 status_active = 4;
    optional aggregations64 aggr_status_active = 104;

    optional uint32 num_succeeded = 5;
    optional aggregations64 aggr_num_succeeded = 105;

    optional uint32 num_failed = 6;
    optional aggregations64 aggr_num_failed = 106;
}


message k8s_statefulset {
    required k8s_common common = 1;

    optional uint32 replicas = 2;
    optional aggregations64 aggr_replicas = 102;

    optional uint32 status_replicas = 3;
    optional aggregations64 aggr_status_replicas = 103;

    optional uint32 status_replicas_current = 4;
    optional aggregations64 aggr_status_replicas_current = 104;

    optional uint32 status_replicas_ready = 5;
    optional aggregations64 aggr_status_replicas_ready = 105;

    optional uint32 status_replicas_updated = 6;
    optional aggregations64 aggr_status_replicas_updated = 106;
}

message k8s_hpa {
    required k8s_common common = 1;

    optional uint32 replicas_min = 2;
    optional aggregations64 aggr_replicas_min = 102;

    optional uint32 replicas_max = 3;
    optional aggregations64 aggr_replicas_max = 103;

    optional uint32 replicas_current = 4;
    optional aggregations64 aggr_replicas_current = 104;

    optional uint32 replicas_desired = 5;
    optional aggregations64 aggr_replicas_desired = 105;
}

message k8s_resourcequota {
    // compute
    required k8s_common common                                = 1;

    optional uint32 limits_cpu_hard                           = 2;
    optional aggregations64 aggr_limits_cpu_hard              = 31;

    optional uint64 limits_memory_hard                        = 3;
    optional aggregations64 aggr_limits_memory_hard           = 32;

    optional uint32 requests_cpu_hard                         = 4;
    optional aggregations64 aggr_requests_cpu_hard            = 33;

    optional uint64 requests_memory_hard                      = 5;
    optional aggregations64 aggr_requests_memory_hard         = 34;

    optional uint32 limits_cpu_used                           = 6;
    optional aggregations64 aggr_limits_cpu_used              = 35;

    optional uint64 limits_memory_used                        = 7;
    optional aggregations64 aggr_limits_memory_used           = 36;

    optional uint32 requests_cpu_used                         = 8;
    optional aggregations64 aggr_requests_cpu_used            = 37;

    optional uint64 requests_memory_used                      = 9;
    optional aggregations64 aggr_requests_memory_used         = 38;

    optional double double_limits_cpu_hard                    = 10;
    optional aggregations_double aggr_double_limits_cpu_hard  = 39;

    optional double double_request_cpu_hard                   = 11;
    optional aggregations_double aggr_double_request_cpu_hard = 40;

    optional double double_limits_cpu_used                    = 12;
    optional aggregations_double aggr_double_limits_cpu_used  = 41;

    optional double double_request_cpu_used                   = 13;
    optional aggregations_double aggr_double_request_cpu_used = 42;

    //storage
    optional uint64 requests_storage_hard                     = 101;
    optional aggregations64 aggr_requests_storage_hard        = 131;

    optional uint64 requests_storage_used                     = 102;
    optional aggregations64 aggr_requests_storage_used        = 132;

    // count
    optional uint32 configmaps_hard                           = 201;
    optional aggregations64 aggr_configmaps_hard              = 231;

    optional uint32 persistentvolumeclaims_hard               = 202;
    optional aggregations64 aggr_persistentvolumeclaims_hard  = 232;

    optional uint32 pods_hard                                 = 203;
    optional aggregations64 aggr_pods_hard                    = 233;

    optional uint32 replicationcontrollers_hard               = 204;
    optional aggregations64 aggr_replicationcontrollers_hard  = 234;

    optional uint32 resourcequotas_hard                       = 205;
    optional aggregations64 aggr_resourcequotas_hard          = 235;

    optional uint32 services_hard                             = 206;
    optional aggregations64 aggr_services_hard                = 236;

    optional uint32 services_loadbalancers_hard               = 207;
    optional aggregations64 aggr_services_loadbalancers_hard  = 237;

    optional uint32 services_nodeports_hard                   = 208;
    optional aggregations64 aggr_services_nodeports_hard      = 238;

    optional uint32 secrets_hard                              = 209;
    optional aggregations64 aggr_secrets_hard                 = 239;

    optional uint32 configmaps_used                           = 210;
    optional aggregations64 aggr_configmaps_used              = 240;

    optional uint32 persistentvolumeclaims_used               = 211;
    optional aggregations64 aggr_persistentvolumeclaims_used  = 241;

    optional uint32 pods_used                                 = 212;
    optional aggregations64 aggr_pods_used                    = 242;

    optional uint32 replicationcontrollers_used               = 213;
    optional aggregations64 aggr_replicationcontrollers_used  = 243;

    optional uint32 resourcequotas_used                       = 214;
    optional aggregations64 aggr_resourcequotas_used          = 244;

    optional uint32 services_used                             = 215;
    optional aggregations64 aggr_services_used                = 245;

    optional uint32 services_loadbalancers_used               = 216;
    optional aggregations64 aggr_services_loadbalancers_used  = 246;

    optional uint32 services_nodeports_used                   = 217;
    optional aggregations64 aggr_services_nodeports_used      = 247;

    optional uint32 secrets_used                              = 218;
    optional aggregations64 aggr_secrets_used                 = 248;
}

message k8s_persistentvolume {
    required k8s_common common = 1;

    optional uint64 storage = 2;
    optional aggregations64 aggr_storage = 100;
}

message k8s_persistentvolumeclaim {
    required k8s_common common = 1;

    optional uint64 storage = 2;
    optional aggregations64 aggr_storage = 100;

    optional uint64 requests_storage = 3;
    optional aggregations64 aggr_requests_storage = 101;
}

message k8s_state {
    repeated k8s_namespace namespaces = 1;
    repeated k8s_node nodes = 2;
    repeated k8s_pod pods = 3;
    repeated k8s_replication_controller controllers = 4;
    repeated k8s_service services = 5;
    repeated k8s_replica_set replica_sets = 6;
    repeated k8s_deployment deployments = 7;
    repeated k8s_daemonset daemonsets = 8;
    optional string cluster_id = 9;
    optional string cluster_name = 10;
    repeated k8s_job jobs = 11;

    optional uint64 namespace_count = 12;
    optional aggregations64 aggr_namespace_count = 112;

    repeated k8s_statefulset statefulsets = 13;
    repeated k8s_resourcequota resourcequotas = 14;
    repeated k8s_persistentvolume persistentvolumes = 15;
    repeated k8s_persistentvolumeclaim persistentvolumeclaims = 16;
    repeated k8s_hpa hpas = 17;
}

//
// MESOS
//

message mesos_pair {
    required string key = 1;
    required string value = 2;
}

message mesos_common {
    required string uid = 1;
    optional string name = 2;
    repeated mesos_pair labels = 3;
}

message mesos_task {
    required mesos_common common = 1;
    required string slave_id = 2;
}

message marathon_app {
    required string id = 1;
    repeated string task_ids = 2;
}

message marathon_group {
    required string id = 1;
    repeated marathon_app apps = 2;
    repeated marathon_group groups = 3;
}

message mesos_framework {
    required mesos_common common = 1;
    repeated mesos_task tasks = 2;
}

message mesos_slave {
    required mesos_common common = 1;
}

message mesos_state {
    repeated mesos_framework frameworks = 1;
    repeated marathon_group groups = 2;
    repeated mesos_slave slaves = 3;
}

// Docker Swarm

message swarm_pair {
    required string key = 1;
    required string value = 2;
}

message swarm_port {
    optional uint32 port = 1;
    optional uint32 published_port = 2;
    optional string protocol = 3;
}

message swarm_common {
    optional string id = 1;
    optional string name = 2;
    repeated swarm_pair labels = 3;
}

enum swarm_service_mode {
    REPLICATED = 1;
    GLOBAL = 2;
}

message swarm_service {
    optional swarm_common common = 1;
    repeated string virtual_ips = 2;
    // Ports will be available only for published services
    // internal service don't need it, even if they load
    // balance traffic as well
    repeated swarm_port ports = 3;
    optional swarm_service_mode mode = 4;

    optional uint64 spec_replicas = 5; // Only defined for replicated mode
    optional aggregations64 aggr_spec_replicas = 7;

    optional uint64 tasks = 6; // running tasks associated with the service
    optional aggregations64 aggr_tasks = 8;
}

message swarm_task {
    optional swarm_common common = 1;
    optional string service_id = 2;
    optional string node_id = 3;
    optional string container_id = 4;
    optional string state = 5;
}

message swarm_manager {
    optional bool leader = 1;
    optional string reachability = 2;
}

message swarm_node {
    // hostname of the node is inside common.name
    optional swarm_common common = 1;
    optional string role = 2;
    optional string ip_address = 3;
    optional string version = 4;
    optional string availability = 5;
    optional string state = 6;
    optional swarm_manager manager = 7;
}

message swarm_state {
    // This values will be filled only
    // by swarm manager nodes
    repeated swarm_service services = 2;
    repeated swarm_node nodes = 3;
    repeated swarm_task tasks = 4;

    optional bool quorum = 5;
    optional aggregations64 aggr_quorum = 6;

    // Every node in the cluster will send its node_id
    // it can be used if we'll hit duplicate ip addresses
    optional string node_id = 7;
}

message orchestrator_state_t {
    repeated container_group groups = 1;
    // This is the UID of default namespace
    optional string cluster_id = 2;
    // This is a *likely* unique identifier set by customer or automatically
    // scraped by AWS, GCP and so on
    optional string cluster_name = 3;
}

message unreported_stats {
    optional time_categories tcounters = 1;
    optional transaction_breakdown_categories reqcounters = 2;
    optional counter_time_bidirectional max_transaction_counters = 3;
    optional resource_categories resource_counters = 4;
    optional counter_syscall_errors syscall_errors = 5;
    optional proto_info protos = 6;
    repeated string names = 7; // names of all containers herein reported
    optional counter_time_bidirectional transaction_counters = 8;
}

message key_value {
    required string key = 1;
    required string value = 2;
}

message agent_event {
    optional uint64 timestamp_sec = 1; // The message timestamp, in sec from epoch
    optional string scope = 2;
    optional string title = 3;
    optional string description = 4;
    optional uint32 severity = 5;
    repeated key_value tags = 6;
}

//
// FALCO BASELINE
//
message falco_subcategory {
    required string name = 1;
    repeated string d = 2;
    optional bool full = 3;
}

message falco_subcategory_container {
    repeated falco_subcategory subcats = 1;
}

message falco_category {
    required string name = 1;
    repeated falco_subcategory_container startup_subcats = 2;
    repeated falco_subcategory_container regular_subcats = 3;
}

message falco_prog {
    required string comm = 1;
    required string exe = 2;
    repeated string args = 3;
    required uint64 user_id = 4;
    optional string container_id = 5;
    repeated falco_category cats = 6;
}

message falco_container {
    required string id = 1;
    required string name = 2;
    optional string image_name = 3;
    optional string image_id = 4;
}

message falco_baseline {
    repeated falco_prog progs = 1;
    repeated falco_container containers = 2;
}

//
// ENTRY POINT MESSAGE
//
message metrics {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch

    optional uint64 index = 43;       // The message index; increases by 1 each message

    required string machine_id = 2; // The unique ID of the machine that is sending this data
    repeated string machine_ids = 23; //machine IDs aggregated for this group

    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    optional host hostinfo = 4; // The list of processes
    // NEVER USED repeated process processes = 5; // The list of processes
    repeated ipv4_connection ipv4_connections = 7; // The list of IPv4 connections
    repeated ipv4_network_interface ipv4_network_interfaces = 8; // The list of the machine network interfaces
    repeated program programs = 9; // The list of programs

    optional uint32 sampling_ratio = 10; // The sampling ratio when subsampling. If not present, assume 1, which means no subsampling.
    optional aggregations64 aggr_sampling_ratio = 17;

    optional string host_custom_name = 11; // This machines's user-set custom name for the draios map.
    optional string host_tags = 12; // This machines's user-set list of tags for the draios map.
    // NEVER USED optional string host_custom_map = 13; // This machines's user-set custom map for the draios UI.
    optional bool is_host_hidden = 14; // This machines's user-set visibility flag for the draios map.
    optional string hidden_processes = 15; // Comma-sparated list of process names that the user wants to hide in the draios map.
    optional string version = 16; // Agent/libsanalyzer/sysdig version
    repeated mounted_fs mounts = 18; // List of mounted file systems
    repeated file_stat top_files = 19; // Top files
    optional proto_info protos = 20; // Information about protocols that have been decoded
    optional string instance_id = 21; // AWS instance id
    repeated container containers = 22;
    optional k8s_state kubernetes = 24; // kubernetes cluster state
    optional mesos_state mesos = 25; // mesos cluster state
    repeated agent_event events = 26; // user-configured events
    optional falco_baseline falcobl = 27; // baseline information for falco
    repeated command_details commands = 28; // List of commands executed during the sample.
    optional swarm_state swarm = 29;
    repeated uint32 config_percentiles = 30; // configured percentiles
    optional statsd_info internal_metrics = 31;
    optional orchestrator_state_t global_orchestrator_state = 32;
    optional k8s_state global_kubernetes = 33; // used for storing entire cluster metrics/metadata
    optional orchestrator_state_t orchestrator_state = 34;
    optional k8s_state local_kubernetes = 35;
    repeated ipv4_connection ipv4_incomplete_connections = 36; // The list of incomplete IPv4 connections. not used if 10s flush is enabled
    repeated id_map userdb = 37; // uid->username mapping
    repeated environment environments = 38; // map of hash -> list of vars

    optional unreported_stats unreported_counters = 39; // stats for all containers which aren't explicitly reported
    repeated container_reporting_group reporting_groups = 40; // specification for all reporting groups which could contain a container
    repeated file_stat top_devices = 41;
    repeated ipv4_incomplete_connection ipv4_incomplete_connections_v2 = 42; // The list of incomplete IPv4 connections. only used if 10s flush is enabled.
}

message container_list_wrapper {
    repeated container_port_mapping port_mappings = 1;
    repeated mounted_fs mounts = 2;
    repeated network_by_port network_by_serverports = 3;
    repeated file_stat top_devices = 4;
    repeated file_stat top_files = 5;
}

message program_list_wrapper {
    repeated file_stat top_devices = 1;
    repeated file_stat top_files = 2;
}

message list_wrapper {
    repeated mounted_fs mounts = 1; // List of mounted file systems
    repeated file_stat top_files = 2; // Top files
    repeated program programs = 3; // The list of programs
    repeated program jmx_programs = 4; // The list of JMX progrmas
    repeated ipv4_connection ipv4_connections = 5; // The list of ipv4 connections
    repeated ipv4_network_interface ipv4_network_interfaces = 6; // The list of the machine network interfaces
    repeated container containers = 7; //The list of containers
    repeated program container_programs = 8; // The list of container programs
    repeated file_stat top_devices = 31;
    //containers splitting
    repeated time_categories containers_tcounters = 9;
    repeated transaction_breakdown_categories containers_reqcounters = 10;
    repeated resource_categories containers_resource_counters = 11;
    repeated counter_time_bidirectional containers_transaction_counters = 12;
    repeated counter_time_bidirectional containers_min_transaction_counters = 13;
    repeated counter_time_bidirectional containers_max_transaction_counters = 14;
    repeated proto_info containers_protos = 15;
    repeated container_list_wrapper containers_mounts = 16;
    repeated container_list_wrapper containers_network_by_serverports = 17;
    repeated counter_syscall_errors containers_syscall_errors = 18;
    repeated container_list_wrapper containers_top_devices = 32;
    repeated container_list_wrapper containers_top_files = 33;
    //programs splitting
    repeated time_categories programs_tcounters = 20;
    repeated transaction_breakdown_categories programs_reqcounters = 21;
    repeated resource_categories programs_resource_counters = 22;
    repeated counter_time_bidirectional programs_transaction_counters = 23;
    repeated counter_time_bidirectional programs_min_transaction_counters = 24;
    repeated counter_time_bidirectional programs_max_transaction_counters = 25;
    repeated proto_info programs_protos = 26;
    repeated process_details programs_details = 27;
    repeated counter_syscall_errors programs_syscall_errors = 28;
    repeated ipv4_connection ipv4_incomplete_connections = 29; // The list of incomplete IPv4 connections
    repeated id_map userdb = 30; // uid->username mapping
    repeated program_list_wrapper programs_top_devices = 34;
    repeated program_list_wrapper programs_top_files = 35;
}

message dump_request_start {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    optional uint64 duration_ns = 4; // The duration for the capture in ns
    optional string filters = 5; // Dump filters
    required string token = 6; // The token associated with the request
    optional uint64 max_size = 7; // Max size
    optional uint64 past_duration_ns = 8; // The duration before the current time to capture.
                                          // This works only if the agent has been configured with rotational capture
    optional uint64 past_size = 9; // The number of bytes already in the event circular buffer to capture.
                                   // This works only if the agent has been configured with rotational capture
}

message dump_request_stop {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    required string token = 4; // The token associated with the request
}

message dump_response {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    optional uint32 chunk_no = 7; // Index of the current chunk, starting from 0
    optional bool final_chunk = 8; // True if this is the last chunk
    optional bool keep_alive = 9; // True if this is a keep alive packet
    optional bytes content = 4; // The binary dump file
    optional uint64 final_size_bytes = 10; // Final size of the trace file
    optional string error = 5; // Dump errors
    required string token = 6; // The token associated with the request
}

message ssh_open_channel {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    required string token = 4; // The token associated with the request
    required string user = 5;
    optional string password = 6;
    optional string key = 7;
    optional string passphrase = 8;
    optional uint32 port = 9;
}

message ssh_data {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    required string token = 4; // The token associated with the request
    optional bytes data = 5; // Std input/output/error according to where this is sent from
    optional string error = 6;
    optional int32 exit_status = 7;
}

message ssh_close_channel {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    required string token = 4; // The token associated with the request
}

message auto_update_request {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
}

message dirty_shutdown_report {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    required string log = 4; // The log portion
}

message config_file {
    optional string name = 1;
    optional string content = 2;
}

message license_details {
    optional uint32 jmx_limits = 1;
    optional uint32 statsd_limits = 2;
    optional uint32 app_check_limits = 3;
    optional uint32 prometheus_limit = 4;
    optional uint32 connections_limit = 5;
}

message config_data {
    repeated config_file config_files = 1;
}

message stop_action {
    // This is the message to send to the thing being stopped.
    optional string msg = 1;
}

message pause_action {
    // This is the message to send to the thing being paused.
    optional string msg = 1;
}

message capture_action {
    required uint64 before_event_ns = 1;
    required uint64 after_event_ns = 2;
    optional string filter = 3;
    optional bool is_limited_to_container = 4;
}

enum action_type {
    ACTION_STOP = 1;
    ACTION_PAUSE = 2;
    ACTION_CAPTURE = 3;
}

// If we were using gproto >= 2.6, we could use oneof
message action {
    required action_type type = 1;

    // when type=ACTION_STOP
    optional stop_action stop = 2;

    // when type=ACTION_PAUSE
    optional pause_action pause = 3;

    // when type=ACTION_CAPTURE
    optional capture_action capture = 4;
}

message match_list {
    repeated string values = 1;
    required match_effect on_match = 2;
    // When present, this match_lists is for filesystem items and
    // determines whether the items should be read or read/write.
    optional path_access_type fs_access_type = 3;

    // When present, this match_lists is for network listening port
    // items and determines whether the items are tcp or udp ports
    optional net_proto proto = 4;
}

message match_lists {
    repeated match_list lists = 1;
    required match_effect on_default = 2;
    repeated string output_field_keys = 3;
}

message matchlist_detail {
    optional match_lists process_details = 1;
    optional match_lists fs_details = 2;
    optional match_lists syscall_details = 3;
    optional match_lists container_details = 4;
    optional match_lists listenport_details = 5;
    optional inoutbound inbound_details = 6;
    optional inoutbound outbound_details = 7;
}

// A scope value is a pair key/value (container.image=mysql, or
// k8s.ns=prod). Unlike predicate the key can only have 1 value, and
// it is a statement about a scope instead of a test.
message scope_value {
    required string key = 1;
    required string value = 2;
}

message baseline {
    required string id = 1;
    required string hash = 2;
    repeated scope_value scope = 3;
    required matchlist_detail matchlist_details = 4;
}

message baselines {
    repeated baseline baseline_list = 1;
}

// A scope indicator is a key only, without value
// (container.image, or k8s.ns).
message scope_indicator {
    required string key = 1;
}

message baseline_detail {
    repeated scope_indicator baselines_wanted = 1;
    // These default to false
    optional bool process_enabled = 2;
    optional bool fs_read_only_enabled = 3;
    optional bool fs_read_write_enabled = 4;
    optional bool syscall_enabled = 5;
    optional bool network_listening_enabled = 6;
    optional bool network_inoutbound_enabled = 7;
}

enum path_access_type {
    ACCESS_READ = 1;
    ACCESS_WRITE = 2;
}

enum net_proto {
    PROTO_TCP = 1;
    PROTO_UDP = 2;
}

message inoutbound {
    required match_effect on_default = 1;
    repeated string output_field_keys = 2;
}

message falco_rule_filter {
    repeated string tags = 1;
    optional string name = 2;
}

message falco_detail {
    required falco_rule_filter rule_filter = 1;
    repeated string output_field_keys = 2;
}

enum retired_policy_type {
    POLICY_BASELINE = 1;
    POLICY_FALCO = 2;
    POLICY_MANUAL = 3;
}

enum match_effect {
    EFFECT_ACCEPT = 1;
    EFFECT_DENY = 2;
    EFFECT_NEXT = 3;
}

enum scope_operator {
    EQ = 1;
    NOT_EQ = 2;
    IN_SET = 3;
    NOT_IN_SET = 4;
    CONTAINS = 5;
    NOT_CONTAINS = 6;
    STARTS_WITH = 7;
}

// A scope predicate contains both indicators and values
// (container.image=mysql and k8s.ns=prod) as well as a match
// operator. It is a test to apply to a given system event to see if
// it matches.
message scope_predicate {
    required string key = 1;
    // multiple values when using IN/NOT_IN, otherwise single
    repeated string values = 2;
    required scope_operator op = 3;
}

message policy {
    required uint64 id = 1;
    required string name = 2;
    // was required but not used anymore, so mark it optional and wait to retire until all Secure agents are upgraded.
    // backend will still send it to not break the old required.
    optional retired_policy_type retired_type = 3;

    required bool host_scope = 9;
    required bool container_scope = 10;
    // all scope_predicates must match against the entity
    repeated scope_predicate scope_predicates = 11;

    optional falco_detail falco_details = 5;
    optional matchlist_detail matchlist_details = 16;
    optional baseline_detail baseline_details = 17;

    repeated action actions = 7;
    required bool enabled = 8;

    optional uint64 severity = 18;
}

// It's repeated to allow for pushing multiple rule files from the
// backend (think a rules.d with many files below it). The rule files
// will be loaded in message order.
message falco_rules_contents {
    repeated string contents = 1;
}

message falco_rules_variant {
    optional uint64 required_engine_version = 1;
    optional string content = 2;
}

message falco_rules_file {
    optional string filename = 1;
    repeated falco_rules_variant variants = 2;
}

message falco_rules_files {
    // Not really needed by the agent, but might be used for logging.
    optional string tag = 1;
    repeated falco_rules_file files = 2;
}

message fastengine_rules_file {
    optional string filename = 1;

    // This is a json array containing rule objects that exactly match
    // the format defined by swagger.
    optional string json_content = 2;
}

// Structurally very similar to falco_rules_files, but keeping separate
// in case we want to extend either without changing both
message fastengine_rules_files {
    // Not really needed by the agent, but might be used for logging.
    optional string tag = 1;
    repeated fastengine_rules_file files = 2;
}

message falco_rules_group {
    optional falco_rules_files default_files = 1;
    optional falco_rules_files custom_files = 2;
}

message policies {
    repeated policy policy_list = 1;

    // Old format, which supports only a single system and single user
    // rules file, with no versioning.
    optional falco_rules_contents falco_rules = 2;

    // New format, which supports a set of system rules files and a
    // set of user rules files, with each file having multiple
    // variants for different falco engine versions.
    optional falco_rules_group falco_group = 3;
}

message policy_v2 {
    required uint64 id = 1;
    required string name = 2;

    // all scope_predicates must match against the entity
    repeated scope_predicate scope_predicates = 3;

    optional uint64 severity = 4;

    // The names of rules to use for this policy
    repeated string rule_names = 5;

    repeated action actions = 6;

    required bool enabled = 7;
}

message policies_v2 {
    repeated policy_v2 policy_list = 1;

    // New format, which supports a set of system rules files and a
    // set of user rules files, with each file having multiple
    // variants for different falco engine versions.
    optional falco_rules_group falco_group = 2;

    // A list of files containing "fast engine" rules.
    optional fastengine_rules_files fastengine_files = 3;
}

// this is only used by backend for output_event_detail.output_fields
message output_field {
    optional string output_key = 1;
    optional string output_value = 2;
}

message falco_event_detail {
    required string rule = 1;
    required string output = 2;
}

message baseline_event_detail {
    required string id = 1;
}

// The type as well as order of precedence of security
// policies modules. If an event matches more than one of
// these for a given policy, an earlier one will take
// precedence over a later one.
enum policy_type {
    PTYPE_PROCESS = 1;
    PTYPE_CONTAINER = 2;
    PTYPE_FILESYSTEM = 3;
    PTYPE_NETWORK = 4;
    PTYPE_SYSCALL = 5;
    PTYPE_FALCO = 6;
}

enum policy_subtype {
    PSTYPE_NOSUBTYPE = 0;
    PSTYPE_NETWORK_INBOUND = 1;
    PSTYPE_NETWORK_OUTBOUND = 2;
    PSTYPE_NETWORK_LISTENING = 3;
    PSTYPE_FILESYSTEM_READ = 4;
    PSTYPE_FILESYSTEM_READWRITE = 5;
}

message output_event_detail {
    required policy_type output_type = 1;        // policy type triggered (falco, process, network...)
    optional policy_subtype output_subtype = 2;  // policy subtype triggered (fs read, fs read/write,
                                                 // network in/out/listening_port)
    optional string output = 3;                  // human-readable string provided by agent
    map<string,string> output_fields = 4;        // key-value map (string->string)
                                                 // e.g. "container.image" -> "ubuntu"
                                                 //      "proc.name"       -> "apache"
                                                 //      "falco.rule"      -> "Write below binary dir"
}

message event_detail {
    optional output_event_detail output_details = 1;
    optional baseline_event_detail baseline_details = 2;
    // If true, then this policy event was the result of an on_default
    // action for some policy.
    required bool on_default = 3;
}

message action_result {
    required action_type type = 1;

    // Whether or not the action was completed successfully
    required bool successful = 2;

    // When successful == false, details on why the action failed
    optional string errmsg = 3;

    // An optional token that can be related to later messages. For
    // example, when the type is ACTION_CAPTURE, A series of
    // dump_response messages will follow. Each will have a token
    // field == this token.
    optional string token = 4;
}

// Once we add a scope, we'll want to also include the scope of the
// event as well.
message policy_event {
    required uint64 timestamp_ns = 1;
    required uint64 policy_id = 2;
    optional string container_id = 3;

    // Only used for backwards compatibility. If a policy for this
    // policy event has a falco_details section, the details will also
    // be here.
    optional falco_event_detail falco_details = 5;

    repeated action_result action_results = 7;

    optional event_detail event_details = 9;

    // If true, there were inspector events dropped recently, which
    // might have affected the details in this policy event.
    optional bool sinsp_events_dropped = 8;

    // The policy version that policy_id refers to. If not present, 1
    // is assumed.
    optional uint64 policy_version = 10;

    // Used to provide extra context to the event
    // adding a list of predefined labels
    map<string,string> event_labels = 11;

}

message policy_events {
    required string machine_id = 1; // The unique ID of the machine that is sending this data
    optional string customer_id = 2; // The unique ID of the customer that this machine belongs to

    repeated policy_event events = 3;
}

// This represents a count of policy events that couldn't be sent as
// policy_event messages due to exceeding the per-policy + scope rate
// limit. In these cases we simply report a count.

message throttled_policy_event {
    required uint64 timestamp_ns = 1;
    required uint64 policy_id = 2;
    optional string container_id = 3;

    required uint64 count = 4;
}

message throttled_policy_events {
    required string machine_id = 1; // The unique ID of the machine that is sending this data
    optional string customer_id = 2; // The unique ID of the customer that this machine belongs to

    repeated throttled_policy_event events = 3;
}

enum error_type {
    ERR_CONN_LIMIT = 1;
    ERR_INVALID_CUSTOMER_KEY = 2;
    ERR_DUPLICATE_AGENT = 3;
    ERR_SERVER_BUSY = 4;
    ERR_PROTO_MISMATCH = 5;
}

message error_message {
    optional error_type type = 1;
    optional string description = 2;
}

message secure_baseline_life_tracker {
    optional uint64 first_seen_us = 1;
    optional uint64 last_seen_us = 2;
    optional uint64 current_time_us = 3;
}
message secure_baseline_status_process {
    required uint32 score = 1;
    optional uint32 status = 2;
}
message secure_baseline_status_fs {
    required uint32 r_score = 1;
    required uint32 rw_score = 2;
    optional uint32 r_status = 3;
    optional uint32 rw_status = 4;
}
message secure_baseline_status_syscall {
    required uint32 score = 1;
    optional uint32 status = 2;
}
message secure_baseline_status_network {
    required uint32 tcp_score = 1;
    required uint32 udp_score = 2;
    required uint32 inbound_score = 3;
    required uint32 outbound_score = 4;
    optional uint32 tcp_status = 5;
    optional uint32 udp_status = 6;
    optional uint32 inbound_status = 7;
    optional uint32 outbound_status = 8;
}
message secure_baseline_status_container_images {
    required uint32 score = 1;
    optional uint32 status = 2;
}
message secure_baseline_status {
    required string name = 1;
    optional secure_baseline_status_process process = 2;
    optional secure_baseline_status_fs fs = 3;
    optional secure_baseline_status_syscall syscall = 4;
    optional secure_baseline_status_network network = 5;
    optional secure_baseline_status_container_images container_images = 6;
}
message secure_baseline_item {
    required string id = 1;
    repeated string main_keys_values = 2;
    required uint32 aggregator_id = 3;
    required secure_baseline_life_tracker life_tracker = 4;
    optional bytes unique_ids_filter = 5;
    optional bytes processes_configuration = 6;
    optional bytes file_system_configuration = 7;
    optional bytes syscalls_configuration = 8;
    optional bytes network_configuration = 9;
    optional bytes container_images_configuration = 10;
    optional uint32 count_existing = 11;
    optional uint32 count_new = 12;
}
message secure_baseline_index {
    optional string baseline_id = 1;
    optional string baseline_name = 2;
    optional uint32 baseline_group_id = 3;
    optional uint32 customer_id = 4;
    optional secure_baseline_status status = 5;
    required uint32 base = 6;
}

//
// Compliance-related messages
//

message comp_task_param {
    required string key = 1;
    required string val = 2;
}

message comp_task {

    // An identifier for the task. Should be 1-1 with name, but allows
    // for a compact way to identify the task.
    required uint64 id = 7;

    // The name of the task e.g. "Check Docker Compliance"
    required string name = 1;

    // The name of the module that implements this task. Separate from
    // task name in case you want to use the same module to run
    // separate tasks with different scopes or schedules.
    required string mod_name = 2;

    // If true, actually schedule the work in this task.
    optional bool enabled = 3;

    // The agent will only run the task on hosts matching these
    // predicates or on hosts where containers match these predicates.
    repeated draiosproto.scope_predicate scope_predicates = 4;

    // This should expressed as an ISO 8601 Duration
    // (PnYnMnDTnHnMnS).
    optional string schedule = 5;

    repeated comp_task_param task_params = 6;
}

message comp_calendar {
    repeated comp_task tasks = 1;
}

message comp_result {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch

    required string task_name = 2;

    required string mod_name = 9;

    optional uint64 task_id = 7;

    // A stringified json object adhering to the schema of
    // ExtendedComplianceResult in the swagger definition.
    optional string ext_result = 8;

    // If true, the result represents a task that ran successful. If
    // false, the result represents a task that did not run
    // successfully. If not present, assumed to be true.
    optional bool successful = 10;

    // Provides a full log of a failed result. Only present when
    // successful=false.
    optional string failure_details = 11;

    // Metrics accompanying this result, if any, will be in
    // metrics.internal_metrics.

// ALL REMAINING FIELDS DEPRECATED
    // The following fields will overlap with the information in
    // output_fields, but is in the message to ensure that they're
    // always available to the UI.

    // An overall count of the number of "tests" run by this task and
    // the number of tests that passed. The notion of a "test" is
    // generic and up to the module.
    optional uint32 tests_run = 3;
    optional uint32 tests_passed = 4;

    // An overall notion of whether this result indicates a low,
    // medium, or high risk environment.
    optional string risk = 5;

    // Can be combined with the result template to result in a
    // human-readable result message. This is a json object as a
    // string.
    optional string output_fields = 6;

}

message comp_results {
    required string machine_id = 1; // The unique ID of the machine that is sending this data
    optional string customer_id = 2; // The unique ID of the customer that this machine belongs to

    repeated comp_result results = 3;
}

message comp_run {
    // Ids of the tasks to be run immediately
    repeated uint64 task_ids = 1;
}

message comp_event {
    required uint64 timestamp_ns = 1;
    required string task_name = 2;
    optional string container_id = 3;

    optional string output = 4;

    map<string,string> output_fields = 5;
}


message comp_events {
    required string machine_id = 1; // The unique ID of the machine that is sending this data
    optional string customer_id = 2; // The unique ID of the customer that this machine belongs to

    repeated comp_event events = 3;
}


