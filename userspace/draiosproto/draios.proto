syntax = "proto2";
package draiosproto;

option optimize_for = SPEED;
option java_package = "com.draios.model.protobuf";
option java_outer_classname = "Agent";

enum error_code {
    ERR_NONE = 0;
    ERR_EPERM = 1;
    ERR_ENOENT = 2;
    ERR_ESRCH = 3;
    ERR_EINTR = 4;
    ERR_EIO = 5;
    ERR_ENXIO = 6;
    ERR_E2BIG = 7;
    ERR_ENOEXEC = 8;
    ERR_EBADF = 9;
    ERR_ECHILD = 10;
    ERR_EAGAIN = 11;
    ERR_ENOMEM = 12;
    ERR_EACCES = 13;
    ERR_EFAULT = 14;
    ERR_ENOTBLK = 15;
    ERR_EBUSY = 16;
    ERR_EEXIST = 17;
    ERR_EXDEV = 18;
    ERR_ENODEV = 19;
    ERR_ENOTDIR = 20;
    ERR_EISDIR = 21;
    ERR_EINVAL = 22;
    ERR_ENFILE = 23;
    ERR_EMFILE = 24;
    ERR_ENOTTY = 25;
    ERR_ETXTBSY = 26;
    ERR_EFBIG = 27;
    ERR_ENOSPC = 28;
    ERR_ESPIPE = 29;
    ERR_EROFS = 30;
    ERR_EMLINK = 31;
    ERR_EPIPE = 32;
    ERR_EDOM = 33;
    ERR_ERANGE = 34;
    ERR_EDEADLK = 35;
    ERR_ENAMETOOLONG = 36;
    ERR_ENOLCK = 37;
    ERR_ENOSYS = 38;
    ERR_ENOTEMPTY = 39;
    ERR_ELOOP = 40;
    ERR_ENOMSG = 42;
    ERR_EIDRM = 43;
    ERR_ECHRNG = 44;
    ERR_EL2NSYNC = 45;
    ERR_EL3HLT = 46;
    ERR_EL3RST = 47;
    ERR_ELNRNG = 48;
    ERR_EUNATCH = 49;
    ERR_ENOCSI = 50;
    ERR_EL2HLT = 51;
    ERR_EBADE = 52;
    ERR_EBADR = 53;
    ERR_EXFULL = 54;
    ERR_ENOANO = 55;
    ERR_EBADRQC = 56;
    ERR_EBADSLT = 57;
    ERR_EBFONT = 59;
    ERR_ENOSTR = 60;
    ERR_ENODATA = 61;
    ERR_ETIME = 62;
    ERR_ENOSR = 63;
    ERR_ENONET = 64;
    ERR_ENOPKG = 65;
    ERR_EREMOTE = 66;
    ERR_ENOLINK = 67;
    ERR_EADV = 68;
    ERR_ESRMNT = 69;
    ERR_ECOMM = 70;
    ERR_EPROTO = 71;
    ERR_EMULTIHOP = 72;
    ERR_EDOTDOT = 73;
    ERR_EBADMSG = 74;
    ERR_EOVERFLOW = 75;
    ERR_ENOTUNIQ = 76;
    ERR_EBADFD = 77;
    ERR_EREMCHG = 78;
    ERR_ELIBACC = 79;
    ERR_ELIBBAD = 80;
    ERR_ELIBSCN = 81;
    ERR_ELIBMAX = 82;
    ERR_ELIBEXEC = 83;
    ERR_EILSEQ = 84;
    ERR_ERESTART = 85;
    ERR_ESTRPIPE = 86;
    ERR_EUSERS = 87;
    ERR_ENOTSOCK = 88;
    ERR_EDESTADDRREQ = 89;
    ERR_EMSGSIZE = 90;
    ERR_EPROTOTYPE = 91;
    ERR_ENOPROTOOPT = 92;
    ERR_EPROTONOSUPPORT = 93;
    ERR_ESOCKTNOSUPPORT = 94;
    ERR_EOPNOTSUPP = 95;
    ERR_EPFNOSUPPORT = 96;
    ERR_EAFNOSUPPORT = 97;
    ERR_EADDRINUSE = 98;
    ERR_EADDRNOTAVAIL = 99;
    ERR_ENETDOWN = 100;
    ERR_ENETUNREACH = 101;
    ERR_ENETRESET = 102;
    ERR_ECONNABORTED = 103;
    ERR_ECONNRESET = 104;
    ERR_ENOBUFS = 105;
    ERR_EISCONN = 106;
    ERR_ENOTCONN = 107;
    ERR_ESHUTDOWN = 108;
    ERR_ETOOMANYREFS = 109;
    ERR_ETIMEDOUT = 110;
    ERR_ECONNREFUSED = 111;
    ERR_EHOSTDOWN = 112;
    ERR_EHOSTUNREACH = 113;
    ERR_EALREADY = 114;
    ERR_EINPROGRESS = 115;
    ERR_ESTALE = 116;
    ERR_EUCLEAN = 117;
    ERR_ENOTNAM = 118;
    ERR_ENAVAIL = 119;
    ERR_EISNAM = 120;
    ERR_EREMOTEIO = 121;
    ERR_EDQUOT = 122;
    ERR_ENOMEDIUM = 123;
    ERR_EMEDIUMTYPE = 124;
    ERR_ECANCELED = 125;
    ERR_ERESTARTSYS = 512;
    ERR_ERESTARTNOINTR = 513;
    ERR_ERESTARTNOHAND = 514;
    ERR_ENOIOCTLCMD = 515;
    ERR_ERESTART_RESTARTBLOCK = 516;
    ERR_EBADHANDLE = 521;
    ERR_ENOTSYNC = 522;
    ERR_EBADCOOKIE = 523;
    ERR_ENOTSUPP = 524;
    ERR_ETOOSMALL = 525;
    ERR_ESERVERFAULT = 526;
    ERR_EBADTYPE = 527;
    ERR_EJUKEBOX = 528;
    ERR_EIOCBQUEUED = 529;
    ERR_EIOCBRETRY = 530;
}

message counter_percentile_data {
    required uint32 scale = 1; // scale factor for min, max and means
    required uint32 num_samples = 2;
    required uint64 min = 3; // minimum of all the samples
    required uint64 max = 4; // maximum of all the samples
    repeated uint64 means = 5 [packed=true]; // the first value is the actual sample, the rest are relative diff compared to previous sample
    repeated uint32 weights = 6 [packed=true]; // weight of corresponding sample
}

message counter_percentile {
    optional uint32 percentile = 1;
    optional uint32 value = 2;
    reserved 3 to 4;
}

message counter_time {
    required uint32 count = 1;
    required uint64 time_ns = 2;
    optional uint32 time_percentage = 3;
    reserved 4 to 7;
    repeated counter_percentile percentile = 8;
    reserved 9; // tag used by previous format of counter_percentile_data
    optional counter_percentile_data percentile_data = 10;
}

message counter_time_bidirectional {
    required uint32 count_in = 1;
    required uint32 count_out = 2;
    required uint64 time_ns_in = 3;
    required uint64 time_ns_out = 4;
    reserved 5 to 9;
    repeated counter_percentile percentile_in = 10;
    repeated counter_percentile percentile_out = 11;
    reserved 12, 13; // tags used by previous format of counter_percentile_data
    optional counter_percentile_data percentile_in_data = 14;
    optional counter_percentile_data percentile_out_data = 15;
}

message counter_bytes {
    required uint32 count_in = 1;
    required uint32 count_out = 2;
    required uint32 bytes_in = 3;
    required uint32 bytes_out = 4;
    reserved 5 to 9;
}

message counter_time_bytes {
    required uint64 time_ns_in = 1;
    required uint64 time_ns_out = 2;
    required uint64 time_ns_other = 3;
    required uint32 count_in = 4;
    required uint32 count_out = 5;
    required uint32 count_other = 6;
    required uint32 bytes_in = 7;
    required uint32 bytes_out = 8;
    required uint32 bytes_other = 9;
    optional uint32 time_percentage_in = 10;
    optional uint32 time_percentage_out = 11;
    optional uint32 time_percentage_other = 12;
    reserved 13 to 25;
    repeated counter_percentile percentile_in = 26;
    repeated counter_percentile percentile_out = 27;
    reserved 28, 29; // tags used by previous format of counter_percentile_data
    optional counter_percentile_data percentile_in_data = 30;
    optional counter_percentile_data percentile_out_data = 31;
}

message time_categories {
    optional counter_time unknown = 1;
    optional counter_time other = 2;
    optional counter_time file = 3;
    optional counter_time net = 4;
    optional counter_time ipc = 5;
    optional counter_time memory = 6;
    optional counter_time process = 7;
    optional counter_time sleep = 8;
    optional counter_time system = 9;
    optional counter_time signal = 10;
    optional counter_time user = 11;
    optional counter_time time = 12;
    optional counter_time_bytes io_file = 13;
    optional counter_time_bytes io_net = 14;
    optional counter_time_bytes io_other = 15;
    optional counter_time wait = 16;
    optional counter_time processing = 17;
    reserved 18;
}

//
// Stores how time is spent serving requests by the host
//
message transaction_breakdown_categories {
    optional counter_time other = 2;
    optional counter_time_bytes io_file = 13;
    optional counter_time_bytes io_net = 14;
    optional counter_time processing = 17;
    reserved 18;
}

message counter_syscall_errors {
    required uint32 count = 1; // Syscall errors count
    repeated uint32 top_error_codes = 2; // Error codes that were generated the most
    reserved 3;
    optional uint32 count_file = 4; // Number of file errors
    optional uint32 count_file_open = 5; // Number of file open errors
    optional uint32 count_net = 6; // Number of network errors
    reserved 7 to 10;
}

message resource_categories {
    optional uint32 capacity_score = 1; // the request capacity score for this process or host. 0 means all the capacity is available, 10000 means that the entity (host or process) has reached the maximum mumber of requests it can serve.
    optional uint32 stolen_capacity_score = 6; // the percentage of request capacity that is not available because of CPU steal. 0 means there was no CPU steal during the sample. 100 means that all the capacity was stolen and the machine essentially couldn't run.
    optional uint32 connection_queue_usage_pct = 2; // if this process or host is serving connections, the occupation of the connection queue FOR THE WORST THREAD IN THIS PROCESS OR HOST (0=empty, 100=full)
    optional uint32 fd_usage_pct = 3; // the ratio (open FDs / total available FDs) FOR THE WORST THREAD IN THIS PROCESS OR HOST. 0 means no FD in use, 100 means FD limit reached.
    optional uint32 cpu_pct = 4; // CPU load of a process (including all the childs). Not present for the host.
    optional uint32 resident_memory_usage_kb = 5; // resident non-swapped memory (as kb).
    reserved 7 to 12;
    optional uint32 virtual_memory_usage_kb = 13; // total virtual memory (as kb). Not present for the host and container.
    optional uint32 swap_memory_usage_kb = 14; // swapped memory usage (as kb).
    optional uint64 major_pagefaults = 15; // number of major page faults since last sample.
    optional uint64 minor_pagefaults = 16; // number of minor page faults since last sample.
    reserved 17 to 20;
    optional uint32 fd_count = 21; // Total number of FDs
    reserved 22 to 23;
    optional uint32 cpu_shares = 24;
    optional uint32 cpu_shares_usage_pct = 25; // CPU % of a container in terms of the limit assigned to it
    optional uint32 memory_limit_kb = 26; // Max Resident memory allowed for a container
    optional uint32 swap_limit_kb = 27; // Max swap memory allowed for a container
    optional uint32 cpu_quota_used_pct = 28;
    optional uint32 swap_memory_total_kb = 29; // swapped memory total (as kb).
    optional uint32 swap_memory_available_kb = 30; // swapped memory available (as kb).
    optional uint64 count_processes = 31; // total processes
    optional uint64 proc_start_count = 32; // started processes
    optional uint64 jmx_sent = 33;
    optional uint64 jmx_total = 34;
    optional uint64 statsd_sent = 35;
    optional uint64 statsd_total = 36;
    optional uint64 app_checks_sent = 37;
    optional uint64 app_checks_total = 38;
    optional uint64 threads_count = 39; // number of threads
    optional uint64 prometheus_sent = 40;
    optional uint64 prometheus_total = 41;
    reserved 124 to 141;
}

message connection_categories {
    optional counter_bytes server = 1; // client-side metrics
    optional counter_bytes client = 2; // server-side metrics
    optional counter_time_bidirectional transaction_counters = 3; // The transaction counters for this connection
    optional uint32 n_aggregated_connections = 4; // If this is an aggregated connection, the number of real connections it represents
    reserved 5;
    reserved 6;
    reserved 18;
    optional counter_time_bidirectional max_transaction_counters = 19; // The slowest transaction counters for this connection
}

message process_details {
    required string comm = 1; // Command name (e.g. "top")
    required string exe = 2; // argv[0] (e.g. "sshd: gianluca@pts/4")
    repeated string args = 3; // Command line arguments (e.g. "-d1")
    optional string container_id = 4;
}

//
// Description of a command executed on the machine
//
message command_details {
    required uint64 timestamp = 1;
    optional uint32 count = 2; // How many times this command has been repeated during the sample interval
    required string cmdline = 3; // Program command line (e.g. "top -d1")
    required string comm = 4; // Program executable name
    required uint64 pid = 5; // Process pid
    required uint64 ppid = 6; // Parent process pid
    required uint64 uid = 7; // User ID
    optional string cwd = 8; // Process' current working directory
    optional uint64 login_shell_id = 9; // ID of the login shell (same as in the spy_users chisel)
    optional uint32 login_shell_distance = 10; // Distance from the login shell (same as in the spy_users chisel)
    optional uint32 tty = 11; // Tty
    optional bool is_healthcheck = 12; // If true, related to a container health check.
}

//
// Counters for a protocol-related dimension, like a URL or a query
//
message counter_proto_entry {
    required uint32 ncalls = 1;
    required uint64 time_tot = 2;
    required uint64 time_max = 3;
    required uint64 bytes_in = 4;
    required uint64 bytes_out = 5;
    required uint32 nerrors = 6;
    reserved 7 to 12;
    repeated counter_percentile percentile = 13;
    reserved 14; // tag used by previous format of counter_percentile_data
    optional counter_percentile_data percentile_data = 15;
}

//
// URL information
//
message url_details {
    //
    // The URL, in the following format "TYPEADDR<:PORT>/PATH", e.g. "p172.16.189.128:9000/api/data".
    // Note: possible values foy type are:
    //   n for NONE
    //   g for GET
    //   p for POST
    //   o for OPTIONS
    //   h for HEAD
    //   P for PUT
    //   d for DELETE
    //   t for TRACE
    //   c for CONNECT
    //
    required string url = 1;
    required counter_proto_entry counters = 2;
}

message status_code_details {
    required uint32 status_code = 1;
    required uint32 ncalls = 2;
    reserved 3;
}

//
// HTTP protocol information
//
message http_info {
    repeated url_details server_urls = 1;
    repeated url_details client_urls = 2;
    repeated status_code_details client_status_codes = 3;
    repeated status_code_details server_status_codes = 4;
    optional counter_proto_entry server_totals = 5;
    optional counter_proto_entry client_totals = 6;
}

//
// SQL query information
//
message sql_entry_details {
    required string name = 1;
    required counter_proto_entry counters = 2;
}

//
// SQL statement information
//
enum sql_statement_type {
    SOP_NONE = 0;
    SOP_SELECT = 1;
    SOP_INSERT = 2;
    SOP_SET = 3;
    SOP_CREATE = 4;
    SOP_DELETE = 5;
    SOP_DROP = 6;
    SOP_REPLACE = 7;
    SOP_UPDATE = 8;
    SOP_USE = 9;
    SOP_SHOW = 10;
    SOP_LOCK = 11;
    SOP_UNLOCK = 12;
    SOP_ALTER = 13;
}

message sql_query_type_details {
    required sql_statement_type type = 1;
    required counter_proto_entry counters = 2;
}

//
// SQL protocol information
//
message sql_info {
    repeated sql_entry_details server_queries = 1; // the top server-side queries
    repeated sql_entry_details client_queries = 2; // the top client-side queries
    repeated sql_query_type_details server_query_types = 3; // the top server-side query types (e.g. SELECT, INSERT...)
    repeated sql_query_type_details client_query_types = 4; // the top client-side query types (e.g. SELECT, INSERT...)
    repeated sql_entry_details server_tables = 5; // the top server-side queries
    repeated sql_entry_details client_tables = 6; // the top client-side queries
    optional counter_proto_entry server_totals = 7;
    optional counter_proto_entry client_totals = 8;
}

message mongodb_collection_details {
    required string name = 1;
    required counter_proto_entry counters = 2;
}

enum mongodb_op_type {
    MONGODB_OP_NONE = 0;
    MONGODB_OP_INSERT = 1;
    MONGODB_OP_UPDATE = 2;
    MONGODB_OP_DELETE = 3;
    MONGODB_OP_GET_MORE = 4;
    MONGODB_OP_KILL_CURSORS = 5;
    MONGODB_OP_FIND = 6;
    MONGODB_OP_AGGREGATE = 7;
    MONGODB_OP_COMMAND = 8;
    MONGODB_OP_COUNT = 9;
    MONGODB_OP_DISTINCT = 10;
    MONGODB_OP_MAP_REDUCE = 11;
    MONGODB_OP_GEO_NEAR = 12;
    MONGODB_OP_GEO_SEARCH = 13;
    MONGODB_OP_FIND_AND_MODIFY = 14;
}

message mongodb_op_type_details {
    required mongodb_op_type op = 1;
    required counter_proto_entry counters = 2;
}

message mongodb_info {
    repeated mongodb_op_type_details servers_ops = 1;
    repeated mongodb_op_type_details client_ops = 2;
    repeated mongodb_collection_details server_collections = 3;
    repeated mongodb_collection_details client_collections = 4;
    optional counter_proto_entry server_totals = 5;
    optional counter_proto_entry client_totals = 6;
}

enum unit {
    UNIT_NONE = 0;
    UNIT_SECOND = 1;
    UNIT_BYTE = 2;
    UNIT_PERCENT = 3;
}

enum scale {
    SCALE_NONE = 0;

    SCALE_MILLI = 1;
    SCALE_MICRO = 2;
    SCALE_NANO = 3;
    SCALE_MINUTE = 4;
    SCALE_HOUR = 5;
    SCALE_DAY = 6;

    SCALE_KILO = 7;
    SCALE_MEGA = 8;
    SCALE_GIGA = 9;
    SCALE_TERA = 10;
    SCALE_KIBI = 11;
    SCALE_MEBI = 12;
    SCALE_GIBI = 13;
    SCALE_TEBI = 14;

    SCALE_PERCENT_0_1 = 15;
}

enum jmx_metric_type {
    JMX_METRIC_TYPE_COUNTER = 1;
    JMX_METRIC_TYPE_GAUGE = 2;
}

message jmx_attribute {
    optional string name = 1;
    optional double value = 2;
    repeated jmx_attribute subattributes = 3;
    reserved 4;
    optional string alias = 5;
    reserved 6;
    optional jmx_metric_type type = 7;
    optional unit unit = 8;
    optional scale scale = 9;
    // segment_by is a key-value pair
    // let's use statsd_tag that is an already defined
    // structure
    repeated statsd_tag segment_by = 10;
}

message jmx_bean {
    optional string name = 1;
    repeated jmx_attribute attributes = 2;
}

message java_info {
    optional string process_name = 1;
    repeated jmx_bean beans = 2;
}

enum statsd_metric_type {
    STATSD_COUNT = 1;
    STATSD_HISTOGRAM = 2;
    STATSD_GAUGE = 3;
    STATSD_SET = 4;
}

message statsd_tag {
    required string key = 1;
    optional string value = 2;
}

message statsd_metric {
    optional string name = 1;
    repeated statsd_tag tags = 2;
    optional statsd_metric_type type = 3;

    // Valid on COUNT, GAUGE and SET
    optional double value = 4;

    // Valid only on HISTOGRAM type
    optional double sum = 5;
    optional double min = 6;
    optional double max = 7;
    optional double count = 8;
    reserved 9 to 11;
    repeated counter_percentile percentile = 12;
    reserved 13; // tag used by previous format of counter_percentile_data
    optional counter_percentile_data percentile_data = 14;
    reserved 104 to 111;
}

message statsd_info {
    // May be used in the future to add metadata
    repeated statsd_metric statsd_metrics = 1;
}

enum app_metric_type {
    APP_METRIC_TYPE_GAUGE = 1;
    APP_METRIC_TYPE_RATE = 2;
    APP_METRIC_TYPE_BUCKETS = 3;
    APP_METRIC_TYPE_PROMETHEUS_RAW = 4;
}

enum prometheus_type {
    PROMETHEUS_TYPE_INVALID = 0;
    PROMETHEUS_TYPE_COUNTER = 1;
    PROMETHEUS_TYPE_GAUGE = 2;
    PROMETHEUS_TYPE_HISTOGRAM = 3;
    PROMETHEUS_TYPE_SUMMARY = 4;
    // unknown is used either for prometheus "untyped" family,
    // or any other family type we don't recognize.
    PROMETHEUS_TYPE_UNKNOWN = 5;
}

message app_tag {
    required string key = 1;
    optional string value = 2;
}

message app_metric_bucket {
	required string label = 1;
	required uint64 count = 2;
}

message app_metric {
    optional string name = 1;
    optional app_metric_type type = 2;

    // Valid for gauge, rate, and the prometheus raw types
    optional double value = 3;
    reserved 103; // used for aggregration fields in backend

    repeated app_tag tags = 4;

    // Valid for BUCKETS
    repeated app_metric_bucket buckets = 5;

    // Valid when type is APP_METRIC_TYPE_PROMETHEUS_RAW
    optional prometheus_type prometheus_type = 6;
}

enum app_check_value {
    APP_CHECK_VALUE_OK = 0;
    APP_CHECK_VALUE_WARNING = 1;
    APP_CHECK_VALUE_CRITICAL = 2;
    APP_CHECK_VALUE_UNKNOWN = 3;
}

message app_check {
    optional string name = 1;
    optional app_check_value value = 2;
    repeated app_tag tags = 3;
}

message app_info {
    optional string process_name = 1;
    repeated app_metric metrics = 2;
    repeated app_check checks = 3;
}

//
// General protocol information
//
message proto_info {
    optional http_info http = 1;
    optional sql_info mysql = 2;
    optional sql_info postgres = 3;
    optional mongodb_info mongodb = 4;
    optional java_info java = 5; // These are not protocols but as backend is structured is better to save here these info
    optional statsd_info statsd = 6;
    optional app_info app = 7;
    reserved 8;
    optional app_info prometheus = 9;
}

message network_by_port {
    required uint32 port = 1;
    required connection_categories counters = 2;
}

//
// HOST
// global host info.
//
message host {
    optional string hostname = 1; // The name of the host sending the data
    optional uint32 num_cpus = 2; // Number of CPUs in the system
    repeated uint32 cpu_loads = 3; // Array of CPU loads (0 to 100), with an entry for each CPU
    required uint64 physical_memory_size_bytes = 4; // Physical RAM size
    optional time_categories tcounters = 5; // The time counters for this thread
    optional counter_time_bidirectional transaction_counters = 6; // The transaction counters for the whole host
    optional uint64 transaction_processing_delay = 7; // the delay introduced by this host when processing transactions.
    optional resource_categories resource_counters = 8; // The resource counters for this process
    optional counter_syscall_errors syscall_errors = 9; // Syscall error counter
    optional counter_time_bytes external_io_net = 10; // The I/O statistics filtered so that only the activity with the external world is used
    repeated uint32 cpu_steal = 11; // Array of CPU loads (0 to 100), with an entry for each CPU
    optional transaction_breakdown_categories reqcounters = 12; // how time is spent when serving requests
    optional uint64 next_tiers_delay = 13; // the delay introduced by this host's next tiers when processing transactions.
    // It's calculated by subtracting outgoing connection time from incoming connection time.
    // NEVER USED optional uint64 merged_server_delay = 14; // the total merged time of all the incoming requests.
    reserved 15 to 22;
    optional counter_time_bidirectional max_transaction_counters = 23; // The slowest transaction counters for the whole host
    repeated network_by_port network_by_serverports = 24;
    repeated uint32 cpu_idle = 25; // cpu_idle

    reserved 32;
    optional uint64 uptime = 33; // uptime to calculate the reboot
    repeated uint32 system_cpu = 34; // system_cpu
    repeated uint32 user_cpu = 35; // user_cpu
    optional uint64 memory_bytes_available_kb = 36; // memory bytes available as kb
    repeated uint32 iowait_cpu = 37; // iowait_cpu
    repeated uint32 nice_cpu = 38; // nice_cpu
    optional uint32 system_load_1 = 41; // avg system load 1 minute
    optional uint32 system_load_5 = 42; // avg system load 5 minutes
    optional uint32 system_load_15 = 43; // avg system load 15 minutes
    reserved 125;
    reserved 132 to 138;
    reserved 141 to 143;
}

//
// PROCESS
// info for a process, i.e. a collection of threads.
// NOTE: this is process info only, when emitting threads, the main thread of a process will have a
// separate thread message with tid=process pid.
//
enum networkrole {
    NONE = 0; // set if this thread serves IPv4 transactions coming from the same machine.
    IS_LOCAL_IPV4_SERVER = 1; // set if this thread serves IPv4 transactions coming from the same machine.
    IS_REMOTE_IPV4_SERVER = 2; // set if this thread serves IPv4 transactions coming from another machine.
    IS_UNIX_SERVER = 4; // set if this thread serves unix transactions.
    IS_LOCAL_IPV4_CLIENT = 8; // set if this thread creates IPv4 transactions toward localhost.
    IS_REMOTE_IPV4_CLIENT = 16; // set if this thread creates IPv4 transactions toward another host.
    IS_UNIX_CLIENT = 32; // set if this thread creates unix transactions.
}

message process {
    optional process_details details = 2; // names and string constants relative to this process
    reserved 3, 4;
    optional time_categories tcounters = 5; // The time counters for this thread.
    optional counter_time_bidirectional transaction_counters = 6; // The transaction counters for this process.
    optional uint64 transaction_processing_delay = 7; // the delay introduced by this process when processing transactions.
    optional resource_categories resource_counters = 8; // The resource counters for this process
    optional counter_syscall_errors syscall_errors = 9; // Syscall error counter
    reserved 10, 11;
    optional uint64 next_tiers_delay = 12; // the delay introduced by this process' next tiers when processing transactions.
    optional uint32 netrole = 13;
    // It's calculated by subtracting outgoing connection time from incoming connection time.
    // NEVER USED optional uint64 merged_server_delay = 14; // the total merged time of all the incoming requests.
    reserved 15 to 18;
    optional counter_time_bidirectional max_transaction_counters = 19; // The slowest transaction counters for this process.
    optional proto_info protos = 20; // Information about protocols that have been decoded
    optional uint64 start_count = 21; // start processes
    reserved 22;
    optional uint64 count_processes = 23; // number of instances with same command line
    repeated file_stat top_files = 24;
    repeated file_stat top_devices = 25;
    reserved 123;
}

//
// PROGRAM
// info for a program, i.e. a collection of processes with the same name and the same creator.
//
message program {
    required process procinfo = 1; // Information about this program
    repeated uint64 pids = 2; // The list of processes that are part of this program
    repeated uint64 uids = 3; // The list of user ids that are running the processes forming this program
    optional bytes environment_hash = 4; // the hash of all environment variables

    repeated uint32 program_reporting_group_id = 5; // maps to the group under which this program was reported
}

message id_map {
    optional uint64 id = 1;
    optional string name = 2;
}

message environment {
    optional bytes hash = 1; // the hash referenced in `message program`
    repeated string variables = 2; // individual variables as `KEY=value` strings
}

//
// IPv4 CONNECTION
//
message ipv4tuple {
    required uint32 sip = 1;
    required uint32 dip = 2;
    required uint32 sport = 3;
    required uint32 dport = 4;
    required uint32 l4proto = 5;
}

enum connection_state {
    CONN_SUCCESS = 0;
    CONN_PENDING = 1;
    CONN_FAILED = 2;
}

message ipv4_connection {
    required ipv4tuple tuple = 1;

    optional uint64 spid = 2; // The pid of the client
    optional uint64 dpid = 5; // The pid of the server

    required connection_categories counters = 8; // the metrics for this connection
    optional connection_state state = 9;
    optional error_code error_code = 10;
}

//
// NETWORK INTERFACE
//
message ipv4_network_interface {
    required string name = 1; // ifconfig entry name, e.g. eth0
    required uint32 addr = 2; // IP address
    required uint32 netmask = 3; // netmask
    optional uint32 bcast = 4; // broadcast address
}

//
// MESSAGE TYPES
//
enum message_type {
    METRICS = 1;
    DUMP_REQUEST_START = 2;
    DUMP_REQUEST_STOP = 4;
    DUMP_RESPONSE = 3;
    reserved 6 to 9;
    DIRTY_SHUTDOWN_REPORT = 10;
    CONFIG_DATA = 11;
    ERROR_MESSAGE = 12;
    POLICIES = 13;
    POLICY_EVENTS = 14;
    THROTTLED_POLICY_EVENTS = 15;
    ORCHESTRATOR_EVENTS = 16;
    BASELINES = 17;
    COMP_RESULTS = 18;
    COMP_CALENDAR = 19;
    AUDIT_TAP = 20;
    COMP_RUN = 21;
}

//
// MOUNTED FILE SYSTEM
//
message mounted_fs {
    required string device = 1;
    required string mount_dir = 2;
    required string type = 3;
    required uint64 size_bytes = 4;
    required uint64 used_bytes = 5;
    required uint64 available_bytes = 6;
    reserved 7 to 9;
    optional uint64 total_inodes = 10;
    optional uint64 used_inodes = 11;
    reserved 110 to 111;
}

//
// TOP FILE STATISTICS
//
message file_stat {
    required string name = 1;
    required uint32 bytes = 2;
    required uint64 time_ns = 3;
    required uint32 open_count = 4;
    required uint32 errors = 5;
    reserved 6 to 9;
}

enum container_type {
    DOCKER = 1;
    LXC = 2;
    LIBVIRT_LXC = 3;
    MESOS = 4;
    RKT = 5;
    CUSTOM = 6;
    CRI = 7;
    CONTAINERD = 8;
    CRIO = 9;
    COALESCE = 10;
}

message container_reporting_group {
    optional uint32 id = 1;
    repeated string label = 2; // simply a list of labels that might apply to a given container
    repeated string image = 3; // list of images which could match a container in this group
    optional bool require_match_all = 4; // if true, container must match all labels and one image. If false, must match at least one label or one image
}

message container_port_mapping {
    optional uint32 host_ip = 1;
    optional uint32 host_port = 2;
    optional uint32 container_ip = 3;
    optional uint32 container_port = 4;
}

message container_label {
    required string key = 1;
    optional string value = 2;
}

message container {
    required string id = 1;
    optional container_type type = 2;
    optional string name = 3;
    optional string image = 4;
    optional time_categories tcounters = 5; // The time counters for this thread
    optional transaction_breakdown_categories reqcounters = 6; // how time is spent when serving requests
    optional counter_time_bidirectional transaction_counters = 7; // The transaction counters for the whole host
    reserved 8;
    optional counter_time_bidirectional max_transaction_counters = 9; // The slowest transaction counters for the whole host
    optional uint64 transaction_processing_delay = 10; // the delay introduced by this host when processing transactions.
    // It's calculated by subtracting outgoing connection time from incoming connection time.
    // NEVER USED optional uint64 merged_server_delay = 11; // the total merged time of all the incoming requests.
    optional uint64 next_tiers_delay = 12; // the delay introduced by this host's next tiers when processing transactions.
    optional resource_categories resource_counters = 13; // The resource counters for this process
    optional counter_syscall_errors syscall_errors = 14; // Syscall error counter
    reserved 15 to 17;
    repeated container_port_mapping port_mappings = 18;
    optional proto_info protos = 19;
    repeated container_label labels = 20;
    repeated mounted_fs mounts = 21;
    repeated network_by_port network_by_serverports = 22;
    optional string mesos_task_id = 23;
    optional string image_id = 24;
    repeated command_details commands = 25; // List of commands executed in this container during the sample.
    repeated container_label orchestrators_fallback_labels = 26;
    optional string image_repo = 27;
    optional string image_tag = 28;
    optional string image_digest = 29;
    repeated uint32 container_reporting_group_id = 30; // maps to the group under which this group was reported
    repeated file_stat top_files = 31;
    repeated file_stat top_devices = 32;
}

//
// ORCHESTRATOR METADATA
//
message congroup_uid {
    optional string kind = 1;
    optional string id = 2;
}

message congroup_net_port {
    required uint32 port = 1;
    required uint32 target_port = 2;
    optional string protocol = 3;
    optional uint32 node_port = 4;
    optional uint32 published_port = 5; // swarm_port
}

message container_group {
    optional congroup_uid uid = 1;
    map<string, string> tags = 3;
    map<string, string> internal_tags = 10;
    repeated string ip_addresses = 5;
    repeated congroup_net_port ports = 6;
    repeated app_metric metrics = 7;
    repeated congroup_uid children = 8;
    repeated congroup_uid parents = 9;
}

enum congroup_event_type {
    ADDED = 1;
    REMOVED = 2;
    UPDATED = 3;
}

message congroup_update_event {
    required congroup_event_type type = 1;
    required container_group object = 3;
}

message orchestrator_events {
    repeated congroup_update_event events = 1;
}

//
// KUBERNETES
//
message k8s_pair {
    required string key = 1;
    required string value = 2;
}

message k8s_common {
    required string name = 1;
    required string uid = 2;
    optional string namespace = 3;
    repeated k8s_pair labels = 4;
    repeated k8s_pair selectors = 5;
}

message k8s_namespace {
    required k8s_common common = 1;
    reserved 2 to 6;
    reserved 102 to 106;
}

message k8s_node {
    required k8s_common common = 1;
    repeated string host_ips = 2;
    reserved 3 to 14;
    reserved 103 to 114;
    // TODO pod_count
}

message k8s_pod {
    required k8s_common common = 1;
    repeated string container_ids = 2;
    optional string node_name = 3;
    optional string host_ip = 4;
    optional string internal_ip = 5;
    optional uint32 restart_count = 6;
    reserved 7 to 13;
    reserved 106 to 112;
}

message k8s_replication_controller {
    required k8s_common common = 1;
    optional uint32 replicas_desired = 2;
    optional uint32 replicas_running = 3;
    reserved 102 to 103;
}

message k8s_replica_set {
    required k8s_common common = 1;
    optional uint32 replicas_desired = 2;
    optional uint32 replicas_running = 3;
    reserved 4 to 5;
    reserved 102 to 105;
}

message k8s_service {
    message net_port {
        required uint32 port = 1;
        required uint32 target_port = 2;
        optional string protocol = 3;
        optional uint32 node_port = 4;
    }
    required k8s_common common = 1;
    optional string cluster_ip = 2;
    repeated net_port ports = 3;
}

message k8s_deployment {
    required k8s_common common = 1;
    optional uint32 replicas_desired = 2;
    optional uint32 replicas_running = 3;
    reserved 4 to 7;
    reserved 102 to 107;
}

message k8s_daemonset {
    required k8s_common common = 1;
    optional uint32 current_scheduled = 2;
    optional uint32 desired_scheduled = 3;
    reserved 4 to 5;
    reserved 102 to 105;
}

message k8s_state {
    repeated k8s_namespace namespaces = 1;
    repeated k8s_node nodes = 2;
    repeated k8s_pod pods = 3;
    repeated k8s_replication_controller controllers = 4;
    repeated k8s_service services = 5;
    repeated k8s_replica_set replica_sets = 6;
    repeated k8s_deployment deployments = 7;
    repeated k8s_daemonset daemonsets = 8;
    reserved 9 to 13;
    reserved 112;
}

//
// MESOS
//

message mesos_pair {
    required string key = 1;
    required string value = 2;
}

message mesos_common {
    required string uid = 1;
    optional string name = 2;
    repeated mesos_pair labels = 3;
}

message mesos_task {
    required mesos_common common = 1;
    required string slave_id = 2;
}

message marathon_app {
    required string id = 1;
    repeated string task_ids = 2;
}

message marathon_group {
    required string id = 1;
    repeated marathon_app apps = 2;
    repeated marathon_group groups = 3;
}

message mesos_framework {
    required mesos_common common = 1;
    repeated mesos_task tasks = 2;
}

message mesos_slave {
    required mesos_common common = 1;
}

message mesos_state {
    repeated mesos_framework frameworks = 1;
    repeated marathon_group groups = 2;
    repeated mesos_slave slaves = 3;
}

// Docker Swarm

message swarm_pair {
    required string key = 1;
    required string value = 2;
}

message swarm_port {
    optional uint32 port = 1;
    optional uint32 published_port = 2;
    optional string protocol = 3;
}

message swarm_common {
    optional string id = 1;
    optional string name = 2;
    repeated swarm_pair labels = 3;
}

enum swarm_service_mode {
    REPLICATED = 1;
    GLOBAL = 2;
}

message swarm_service {
    optional swarm_common common = 1;
    repeated string virtual_ips = 2;
    // Ports will be available only for published services
    // internal service don't need it, even if they load
    // balance traffic as well
    repeated swarm_port ports = 3;
    optional swarm_service_mode mode = 4;
    optional uint64 spec_replicas = 5; // Only defined for replicated mode
    optional uint64 tasks = 6; // running tasks associated with the service
    reserved 7, 8;
}

message swarm_task {
    optional swarm_common common = 1;
    optional string service_id = 2;
    optional string node_id = 3;
    optional string container_id = 4;
    optional string state = 5;
}

message swarm_manager {
    optional bool leader = 1;
    optional string reachability = 2;
}

message swarm_node {
    // hostname of the node is inside common.name
    optional swarm_common common = 1;
    optional string role = 2;
    optional string ip_address = 3;
    optional string version = 4;
    optional string availability = 5;
    optional string state = 6;
    optional swarm_manager manager = 7;
}

message swarm_state {
    // This values will be filled only
    // by swarm manager nodes
    repeated swarm_service services = 2;
    repeated swarm_node nodes = 3;
    repeated swarm_task tasks = 4;
    optional bool quorum = 5;
    reserved 6;
    // Every node in the cluster will send its node_id
    // it can be used if we'll hit duplicate ip addresses
    optional string node_id = 7;
}

message orchestrator_state_t {
    repeated container_group groups = 1;
    // This is the UID of default namespace
    optional string cluster_id = 2;
    // This is a *likely* unique identifier set by customer or automatically
    // scraped by AWS, GCP and so on
    optional string cluster_name = 3;
}

message unreported_stats {
    optional time_categories tcounters = 1;
    optional transaction_breakdown_categories reqcounters = 2;
    optional counter_time_bidirectional max_transaction_counters = 3;
    optional resource_categories resource_counters = 4;
    optional counter_syscall_errors syscall_errors = 5;
    optional proto_info protos = 6;
    repeated string names = 7; // names of all containers herein reported
    optional counter_time_bidirectional transaction_counters = 8;
}
// ENTRY POINT MESSAGE
//
message metrics {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    optional host hostinfo = 4; // The list of processes
    // NEVER USED repeated process processes = 5; // The list of processes
    repeated ipv4_connection ipv4_connections = 7; // The list of IPv4 connections
    repeated ipv4_network_interface ipv4_network_interfaces = 8; // The list of the machine network interfaces
    repeated program programs = 9; // The list of programs
    optional uint32 sampling_ratio = 10; // The sampling ratio when subsampling. If not present, assume 1, which means no subsampling.
    optional string host_custom_name = 11; // This machines's user-set custom name for the draios map.
    optional string host_tags = 12; // This machines's user-set list of tags for the draios map.
    // NEVER USED optional string host_custom_map = 13; // This machines's user-set custom map for the draios UI.
    optional bool is_host_hidden = 14; // This machines's user-set visibility flag for the draios map.
    optional string hidden_processes = 15; // Comma-sparated list of process names that the user wants to hide in the draios map.
    optional string version = 16; // Agent/libsanalyzer/sysdig version
    reserved 17;
    repeated mounted_fs mounts = 18; // List of mounted file systems
    repeated file_stat top_files = 19; // Top files
    optional proto_info protos = 20; // Information about protocols that have been decoded
    optional string instance_id = 21; // AWS instance id
    repeated container containers = 22;
    // NEVER USED (used by back-end) repeated string machine_ids = 23; //machine IDs aggregated for this group
    optional k8s_state kubernetes = 24; // kubernetes cluster state
    optional mesos_state mesos = 25; // mesos cluster state
    repeated agent_event events = 26; // user-configured events
    optional falco_baseline falcobl = 27; // baseline information for falco
    repeated command_details commands = 28; // List of commands executed during the sample.
    optional swarm_state swarm = 29;
    repeated uint32 config_percentiles = 30; // configured percentiles
    optional statsd_info internal_metrics = 31;
    optional orchestrator_state_t global_orchestrator_state = 32;
    reserved 33;
    optional orchestrator_state_t orchestrator_state = 34;
    // 35 is free to reuse
    repeated ipv4_connection ipv4_incomplete_connections = 36; // The list of incomplete IPv4 connections
    repeated id_map userdb = 37; // uid->username mapping
    repeated environment environments = 38; // map of hash -> list of vars

    optional unreported_stats unreported_counters = 39; // stats for all containers which aren't explicitly reported
    repeated container_reporting_group reporting_groups = 40; // specification for all reporting groups which could contain a container
    repeated file_stat top_devices = 41;
}

message dump_request_start {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    optional uint64 duration_ns = 4; // The duration for the capture in ns
    optional string filters = 5; // Dump filters
    required string token = 6; // The token associated with the request
    optional uint64 max_size = 7; // Max size
    optional uint64 past_duration_ns = 8; // The duration before the current time to capture.
                                          // This works only if the agent has been configured with rotational capture
    optional uint64 past_size = 9; // The number of bytes already in the event circular buffer to capture.
                                   // This works only if the agent has been configured with rotational capture
}

message dump_request_stop {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    required string token = 4; // The token associated with the request
}

message dump_response {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    optional uint32 chunk_no = 7; // Index of the current chunk, starting from 0
    optional bool final_chunk = 8; // True if this is the last chunk
    optional bool keep_alive = 9; // True if this is a keep alive packet
    optional bytes content = 4; // The binary dump file
    optional uint64 final_size_bytes = 10; // Final size of the trace file
    optional string error = 5; // Dump errors
    required string token = 6; // The token associated with the request
}

message dirty_shutdown_report {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
    required string machine_id = 2; // The unique ID of the machine that is sending this data
    optional string customer_id = 3; // The unique ID of the customer that this machine belongs to
    required string log = 4; // The log portion
}

message key_value {
    required string key = 1;
    required string value = 2;
}

message agent_event {
    optional uint64 timestamp_sec = 1; // The message timestamp, in sec from epoch
    optional string scope = 2;
    optional string title = 3;
    optional string description = 4;
    optional uint32 severity = 5;
    repeated key_value tags = 6;
}

message config_file {
    optional string name = 1;
    optional string content = 2;
}

message config_data {
    repeated config_file config_files = 1;
}

message stop_action {
    // This is the message to send to the thing being stopped.
    optional string msg = 1;
}

message pause_action {
    // This is the message to send to the thing being paused.
    optional string msg = 1;
}

message capture_action {
    required uint64 before_event_ns = 1;
    required uint64 after_event_ns = 2;
    optional string filter = 3;
    optional bool is_limited_to_container = 4;
}

enum action_type {
    ACTION_STOP = 1;
    ACTION_PAUSE = 2;
    ACTION_CAPTURE = 3;
}

// If we were using gproto >= 2.6, we could use oneof
message action {
    required action_type type = 1;

    // when type=ACTION_STOP
    optional stop_action stop = 2;

    // when type=ACTION_PAUSE
    optional pause_action pause = 3;

    // when type=ACTION_CAPTURE
    optional capture_action capture = 4;
}

message match_lists {
    repeated match_list lists = 1;
    required match_effect on_default = 2;
    repeated string output_field_keys = 3;
}

message matchlist_detail {
    optional match_lists process_details = 1;
    optional match_lists fs_details = 2;
    optional match_lists syscall_details = 3;
    optional match_lists container_details = 4;
    optional match_lists listenport_details = 5;
    optional inoutbound inbound_details = 6;
    optional inoutbound outbound_details = 7;
}

message baseline {
    required string id = 1;
    required string hash = 2;
    repeated scope_value scope = 3;
    required matchlist_detail matchlist_details = 4;
}

message baselines {
    repeated baseline baseline_list = 1;
}

message baseline_detail {
    repeated scope_indicator baselines_wanted = 1;
    // These default to false
    optional bool process_enabled = 2;
    optional bool fs_read_only_enabled = 3;
    optional bool fs_read_write_enabled = 4;
    optional bool syscall_enabled = 5;
    optional bool network_listening_enabled = 6;
    optional bool network_inoutbound_enabled = 7;
}

message match_list {
    repeated string values = 1;
    required match_effect on_match = 2;
    // When present, this match_lists is for filesystem items and
    // determines whether the items should be read or read/write.
    optional path_access_type fs_access_type = 3;

    // When present, this match_lists is for network listening port
    // items and determines whether the items are tcp or udp ports
    optional net_proto proto = 4;
}

enum path_access_type {
    ACCESS_READ = 1;
    ACCESS_WRITE = 2;
}

enum net_proto {
    PROTO_TCP = 1;
    PROTO_UDP = 2;
}

message inoutbound {
    required match_effect on_default = 1;
    repeated string output_field_keys = 2;
}

message falco_rule_filter {
    repeated string tags = 1;
    optional string name = 2;
}

message falco_detail {
    required falco_rule_filter rule_filter = 1;
    repeated string output_field_keys = 2;
}

enum retired_policy_type {
    POLICY_BASELINE = 1;
    POLICY_FALCO = 2;
    POLICY_MANUAL = 3;
}

enum match_effect {
    EFFECT_ACCEPT = 1;
    EFFECT_DENY = 2;
    EFFECT_NEXT = 3;
}

enum scope_operator {
    EQ = 1;
    NOT_EQ = 2;
    IN_SET = 3;
    NOT_IN_SET = 4;
    CONTAINS = 5;
    NOT_CONTAINS = 6;
    STARTS_WITH = 7;
}

// A scope indicator is a key only, without value
// (container.image, or k8s.ns).
message scope_indicator {
    required string key = 1;
}

// A scope value is a pair key/value (container.image=mysql, or
// k8s.ns=prod). Unlike predicate the key can only have 1 value, and
// it is a statement about a scope instead of a test.
message scope_value {
    required string key = 1;
    required string value = 2;
}

// A scope predicate contains both indicators and values
// (container.image=mysql and k8s.ns=prod) as well as a match
// operator. It is a test to apply to a given system event to see if
// it matches.
message scope_predicate {
    required string key = 1;
    // multiple values when using IN/NOT_IN, otherwise single
    repeated string values = 2;
    required scope_operator op = 3;
}

message policy {
    required uint64 id = 1;
    required string name = 2;
    // was required but not used anymore, so mark it optional and wait to retire until all Secure agents are upgraded.
    // backend will still send it to not break the old required.
    optional retired_policy_type retired_type = 3;

    required bool host_scope = 9;
    required bool container_scope = 10;
    // all scope_predicates must match against the entity
    repeated scope_predicate scope_predicates = 11;

    optional falco_detail falco_details = 5;
    optional matchlist_detail matchlist_details = 16;
    optional baseline_detail baseline_details = 17;

    repeated action actions = 7;
    required bool enabled = 8;

    optional uint64 severity = 18;
}

// It's repeated to allow for pushing multiple rule files from the
// backend (think a rules.d with many files below it). The rule files
// will be loaded in message order.
message falco_rules_contents {
    repeated string contents = 1;
}

message falco_rules_variant {
    optional uint64 required_engine_version = 1;
    optional string content = 2;
}

message falco_rules_file {
    optional string filename = 1;
    repeated falco_rules_variant variants = 2;
}

message falco_rules_files {
    // Not really needed by the agent, but might be used for logging.
    optional string tag = 1;
    repeated falco_rules_file files = 2;
}

message falco_rules_group {
    optional falco_rules_files default_files = 1;
    optional falco_rules_files custom_files = 2;
}

message policies {
    repeated policy policy_list = 1;

    // Old format, which supports only a single system and single user
    // rules file, with no versioning.
    optional falco_rules_contents falco_rules = 2;

    // New format, which supports a set of system rules files and a
    // set of user rules files, with each file having multiple
    // variants for different falco engine versions.
    optional falco_rules_group falco_group = 3;
}

message falco_event_detail {
    required string rule = 1;
    required string output = 2;
}

message baseline_event_detail {
    required string id = 1;
}

// The type as well as order of precedence of security
// policies modules. If an event matches more than one of
// these for a given policy, an earlier one will take
// precedence over a later one.
enum policy_type {
    PTYPE_PROCESS = 1;
    PTYPE_CONTAINER = 2;
    PTYPE_FILESYSTEM = 3;
    PTYPE_NETWORK = 4;
    PTYPE_SYSCALL = 5;
    PTYPE_FALCO = 6;
}

enum policy_subtype {
    PSTYPE_NOSUBTYPE = 0;
    PSTYPE_NETWORK_INBOUND = 1;
    PSTYPE_NETWORK_OUTBOUND = 2;
    PSTYPE_NETWORK_LISTENING = 3;
    PSTYPE_FILESYSTEM_READ = 4;
    PSTYPE_FILESYSTEM_READWRITE = 5;
}

message output_event_detail {
    required policy_type output_type = 1;        // policy type triggered (falco, process, network...)
    optional policy_subtype output_subtype = 2;  // policy subtype triggered (fs read, fs read/write,
                                                 // network in/out/listening_port)
    optional string output = 3;                  // human-readable string provided by agent
    map<string,string> output_fields = 4;        // key-value map (string->string)
                                                 // e.g. "container.image" -> "ubuntu"
                                                 //      "proc.name"       -> "apache"
                                                 //      "falco.rule"      -> "Write below binary dir"
}

message event_detail {
    optional output_event_detail output_details = 1;
    optional baseline_event_detail baseline_details = 2;
    // If true, then this policy event was the result of an on_default
    // action for some policy.
    required bool on_default = 3;
}

message action_result {
    required action_type type = 1;

    // Whether or not the action was completed successfully
    required bool successful = 2;

    // When successful == false, details on why the action failed
    optional string errmsg = 3;

    // An optional token that can be related to later messages. For
    // example, when the type is ACTION_CAPTURE, A series of
    // dump_response messages will follow. Each will have a token
    // field == this token.
    optional string token = 4;
}

// Once we add a scope, we'll want to also include the scope of the
// event as well.
message policy_event {
    required uint64 timestamp_ns = 1;
    required uint64 policy_id = 2;
    optional string container_id = 3;

    // Only used for backwards compatibility. If a policy for this
    // policy event has a falco_details section, the details will also
    // be here.
    optional falco_event_detail falco_details = 5;

    repeated action_result action_results = 7;

    optional event_detail event_details = 9;

    // If true, there were inspector events dropped recently, which
    // might have affected the details in this policy event.
    optional bool sinsp_events_dropped = 8;
}

message policy_events {
    required string machine_id = 1; // The unique ID of the machine that is sending this data
    optional string customer_id = 2; // The unique ID of the customer that this machine belongs to

    repeated policy_event events = 3;
}

// This represents a count of policy events that couldn't be sent as
// policy_event messages due to exceeding the per-policy + scope rate
// limit. In these cases we simply report a count.

message throttled_policy_event {
    required uint64 timestamp_ns = 1;
    required uint64 policy_id = 2;
    optional string container_id = 3;

    required uint64 count = 4;
}

message throttled_policy_events {
    required string machine_id = 1; // The unique ID of the machine that is sending this data
    optional string customer_id = 2; // The unique ID of the customer that this machine belongs to

    repeated throttled_policy_event events = 3;
}

enum error_type {
    ERR_CONN_LIMIT = 1;
    ERR_INVALID_CUSTOMER_KEY = 2;
    ERR_DUPLICATE_AGENT = 3;
    ERR_SERVER_BUSY = 4;
    ERR_PROTO_MISMATCH = 5;
}

message error_message {
    optional error_type type = 1;
    optional string description = 2;
}

//
// FALCO BASELINE
//
message falco_subcategory {
    required string name = 1;
    repeated string d = 2;
    optional bool full = 3;
}

message falco_subcategory_container {
    repeated falco_subcategory subcats = 1;
}

message falco_category {
    required string name = 1;
    repeated falco_subcategory_container startup_subcats = 2;
    repeated falco_subcategory_container regular_subcats = 3;
}

message falco_prog {
    required string comm = 1;
    required string exe = 2;
    repeated string args = 3;
    required uint64 user_id = 4;
    optional string container_id = 5;
    repeated falco_category cats = 6;
}

message falco_container {
    required string id = 1;
    required string name = 2;
    optional string image_name = 3;
    optional string image_id = 4;
}

message falco_baseline {
    repeated falco_prog progs = 1;
    repeated falco_container containers = 2;
}

//
// Compliance-related messages
//

message comp_task_param {
    required string key = 1;
    required string val = 2;
}

message comp_task {

    // An identifier for the task. Should be 1-1 with name, but allows
    // for a compact way to identify the task.
    required uint64 id = 7;

    // The name of the task e.g. "Check Docker Compliance"
    required string name = 1;

    // The name of the module that implements this task. Separate from
    // task name in case you want to use the same module to run
    // separate tasks with different scopes or schedules.
    required string mod_name = 2;

    // If true, actually schedule the work in this task.
    optional bool enabled = 3;

    // The agent will only run the task on hosts matching these
    // predicates or on hosts where containers match these predicates.
    repeated draiosproto.scope_predicate scope_predicates = 4;

    // This should expressed as an ISO 8601 Duration
    // (PnYnMnDTnHnMnS).
    optional string schedule = 5;

    repeated comp_task_param task_params = 6;
}

message comp_calendar {
    repeated comp_task tasks = 1;
}

message comp_result {
    required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch

    required string task_name = 2;

    required string mod_name = 9;

    optional uint64 task_id = 7;

    // A stringified json object adhering to the schema of
    // ExtendedComplianceResult in the swagger definition.
    optional string ext_result = 8;

    // If true, the result represents a task that ran successful. If
    // false, the result represents a task that did not run
    // successfully. If not present, assumed to be true.
    optional bool successful = 10;

    // Provides a full log of a failed result. Only present when
    // successful=false.
    optional string failure_details = 11;

    // Metrics accompanying this result, if any, will be in
    // metrics.internal_metrics.

// ALL REMAINING FIELDS DEPRECATED
    // The following fields will overlap with the information in
    // output_fields, but is in the message to ensure that they're
    // always available to the UI.

    // An overall count of the number of "tests" run by this task and
    // the number of tests that passed. The notion of a "test" is
    // generic and up to the module.
    optional uint32 tests_run = 3;
    optional uint32 tests_passed = 4;

    // An overall notion of whether this result indicates a low,
    // medium, or high risk environment.
    optional string risk = 5;

    // Can be combined with the result template to result in a
    // human-readable result message. This is a json object as a
    // string.
    optional string output_fields = 6;

}

message comp_results {
    required string machine_id = 1; // The unique ID of the machine that is sending this data
    optional string customer_id = 2; // The unique ID of the customer that this machine belongs to

    repeated comp_result results = 3;
}

message comp_run {
    // Ids of the tasks to be run immediately
    repeated uint64 task_ids = 1;
}

message comp_event {
    required uint64 timestamp_ns = 1;
    required string task_name = 2;
    optional string container_id = 3;

    optional string output = 4;

    map<string,string> output_fields = 5;
}


message comp_events {
    required string machine_id = 1; // The unique ID of the machine that is sending this data
    optional string customer_id = 2; // The unique ID of the customer that this machine belongs to

    repeated comp_event events = 3;
}


