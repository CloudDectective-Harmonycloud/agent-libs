syntax = "proto2";

import "draios.proto";
package sdc_internal;

// Internal protobuf used by sysdig cloud agent components
// to talk each other. It uses some pieces in common with
// draios.proto so it can be more efficient

option optimize_for = SPEED;
//option java_package = "com.draios.model.protobuf";
//option java_outer_classname = "Agent";

message container_mounts {
    required string container_id = 1;
    repeated draiosproto.mounted_fs mounts = 2;
}

message mounted_device {
    required uint32 number = 1;
    required string name = 2;
}

message mounted_fs_response {
    repeated container_mounts containers = 1;
    repeated mounted_device devices = 2;
}

message container_info {
    required string id = 1;
    required uint64 pid = 2;
    required uint64 vpid = 3;
    required string root = 4;
}

message mounted_fs_request {
    repeated container_info containers = 1;
}

enum cointerface_message_type {
    PING = 1;
    PONG = 2;
    DOCKER_COMMAND = 3;
    DOCKER_COMMAND_RESULT = 4;
    SWARM_STATE_COMMAND = 5;
    SWARM_STATE_RESULT = 6;
    ORCHESTRATOR_EVENTS_STREAM_COMMAND = 7;
    ORCHESTRATOR_EVENTS_STREAM_RESULT = 8;
    ORCHESTRATOR_EVENT_MESSAGE_STREAM_COMMAND = 9;
    ORCHESTRATOR_EVENT_MESSAGE_STREAM_RESULT = 10;
    SET_K8S_OPTION_COMMAND = 11;
    SET_K8S_OPTION_RESULT = 12;
    CRI_COMMAND = 13;
    CRI_COMMAND_RESULT = 14;
}

enum container_cmd_type {
    STOP = 1;
    PAUSE = 2;
    UNPAUSE = 3;
    KILL = 4;
}

enum delegation_status {
    NOT_DELEGATED = 1;
    DELEGATED = 2;
}

message delegation {
    optional delegation_status status = 1;
    repeated string delegated_nodes = 2;
    optional bool delegation_failure = 3;
}

message ping {
    required int64 token = 1;
}

message pong {
    required int64 token = 1;
    required int32 pid = 2;
    required uint64 memory_used = 3;
    optional bool ready = 4;
    optional delegation delegation = 5;
}

message docker_command {
    required container_cmd_type cmd = 1;
    // Making optional in case other later commands want to work with images
    optional string container_id = 2;
}

message docker_command_result {
    required bool successful = 1;
    optional string errstr = 2;
}

message cri_command {
    required string cri_socket_path = 1;
    required container_cmd_type cmd = 2;
    // Making optional in case other later commands want to work with images
    optional string container_id = 3;
}

message cri_command_result {
    required bool successful = 1;
    optional string errstr = 2;
}

message swarm_state_command {
    optional string container_id = 2;
}

message swarm_state_result {
    required bool successful = 1;
    optional string errstr = 2;
    optional draiosproto.swarm_state state = 3;
}

message leader_election_conf {
	optional uint32 lease_duration = 1;
	optional uint32 renew_deadline = 2;
	optional uint32 retry_period = 3;
	optional string namespace = 4;
}

message annotation_conf {
    optional bool send_all_annotations = 1;
}

message orchestrator_events_stream_command {
    required string url = 1;
    required string ca_cert = 2;
    required string client_cert = 3;
    required string client_key = 4;
    required uint32 queue_len = 6;
    required int32 startup_gc = 7;
    required uint32 startup_inf_wait_time_s = 8;
    required uint32 startup_tick_interval_ms = 9;
    required uint32 startup_low_ticks_needed = 10;
    required uint32 startup_low_evt_threshold = 11;
    required bool filter_empty = 12;
    required bool ssl_verify_certificate = 13;
    required string auth_token = 14;
    repeated string annotation_filter = 15;
    repeated string include_types = 16;
    required uint32 event_counts_log_time = 17;
    required uint32 batch_msgs_queue_len = 18;
    required uint32 batch_msgs_tick_interval_ms = 19;
    required uint32 max_rnd_conn_delay = 23;
    repeated string pod_status_allowlist = 24;
    required bool thin_cointerface = 25;
    repeated string pod_prefix_for_cidr_retrieval = 26;
    required bool terminated_pods_enabled = 27;
    required uint32 cold_start_num = 28;
    required uint32 max_wait_for_lock = 29;
    required uint32 max_cold_start_duration = 30;
    required bool enforce_leader_election = 31;
    required int32 delegated_num = 32;
    required leader_election_conf leader_election = 33;
    required bool cointerface_delegation = 34;
    required uint32 min_rnd_conn_delay = 35;
    required double per_node_conn_delay = 36;
    required annotation_conf annotation_conf = 37;
    required bool completed_jobs_enabled = 38;
}

message orchestrator_attach_user_events_stream_command {
    optional uint32 user_event_queue_len = 1;
    optional bool collect_debug_events = 2; // by default, only collect a few events. If set, collect everything
    repeated string include_types = 3;  // string vector containing k8s_extra_resources
}

message array_congroup_update_event {
    repeated draiosproto.congroup_update_event events = 1;
}

message k8s_object {
    required string kind = 1;
    required string namespace = 2;
    required string name = 3;
    required string uid = 4;
    optional string api_version = 5;
    optional string resource_version = 6;
    optional string field_path = 7;
}

message k8s_source {
    optional string component = 1;
    optional string host = 2;
}

message k8s_user_event {
    required k8s_object obj = 1;
    optional k8s_source source = 2;
    optional string reason = 3;
    optional string message = 4;
    optional int64 first_timestamp = 5;
    optional int64 last_timestamp = 6;
    optional int32 count = 7;
    optional string type = 8;
}

message k8s_option_command {
    required string key = 1;
    required string value = 2;
}

message k8s_option_result {
    required bool successful = 1;
    optional string errstr = 2;
}

service CoInterface {
    rpc PerformDockerCommand(docker_command) returns (docker_command_result) {}
    rpc PerformCriCommand(cri_command) returns (cri_command_result) {}
    rpc PerformPing(ping) returns (pong) {}
    rpc PerformSwarmState(swarm_state_command) returns (swarm_state_result) {}
    rpc PerformOrchestratorEventMessageStream(orchestrator_attach_user_events_stream_command) returns (stream k8s_user_event) {}
    rpc PerformOrchestratorEventsStream(orchestrator_events_stream_command) returns (stream array_congroup_update_event) {}
    rpc PerformSetK8sOption(k8s_option_command) returns (k8s_option_result) {}
}

message comp_module_status {
    required string mod_name = 1;
    optional bool running = 2;
    optional string errstr = 3;
}

message comp_load_result {
    repeated comp_module_status statuses = 1;
}

message comp_start {
    optional string customer_id = 1;
    optional string machine_id = 2;
    required draiosproto.comp_calendar calendar = 3;
    optional bool include_desc = 4;
    optional bool send_failed_results = 5;
    optional bool save_temp_files = 6;
    optional uint32 metrics_statsd_port = 7;
}

message comp_stop {
}

message comp_stop_result {
    required bool successful = 1;
    optional string errstr = 2;
}

message comp_task_event {
    required string task_name = 1;
    required bool init_successful = 2;
    optional string errstr = 3;
    optional draiosproto.comp_events events = 4;
    optional draiosproto.comp_results results = 5;
    repeated string metrics = 6;
}

message comp_get_future_runs {
    required draiosproto.comp_task task = 1;
    required string start = 2;
    required uint32 num_runs = 3;
}

message comp_future_runs {
    required bool successful = 1;
    optional string errstr = 2;
    repeated string runs = 3;
}

message comp_run_result {
    required bool successful = 1;
    optional string errstr = 2;
}

service ComplianceModuleMgr {
    rpc Start(comp_start) returns (stream comp_task_event) {}
    rpc Stop(comp_stop) returns (comp_stop_result) {}
    rpc GetFutureRuns(comp_get_future_runs)returns (comp_future_runs){}
    rpc RunTasks(draiosproto.comp_run) returns (comp_run_result) {}
}

message k8s_audit_server_X509 {
    required string x509_cert_file = 1;
    required string x509_key_file = 2;
}

/* The K8s Audit Server sets up a single endpoint either HTTP or
 * HTTPS */

message k8s_audit_server_start {
    required string url = 1;
    required uint32 port = 2;
    required bool tls_enabled = 3;
    repeated k8s_audit_server_X509 x509 = 4;
    repeated string path_uris = 5;
}

message k8s_audit_server_stop {
}

message k8s_audit_event {
    optional uint64 evt_id = 2;
    optional string evt_json = 3;
    optional string errstr = 4;
}

message k8s_audit_server_stop_result {
    required bool successful = 1;
    optional string errstr = 2;
}

service K8sAudit {
    rpc Start(k8s_audit_server_start) returns (stream k8s_audit_event) {}
    rpc Stop(k8s_audit_server_stop) returns (k8s_audit_server_stop_result) {}
}

message lease_pool_init {
	required string id = 1; // A unique identifier for the node (i.e. hostname)
	required string lease_name = 2;
	required uint32 lease_num = 3;
	required orchestrator_events_stream_command cmd = 4;
}

message lease_pool_wait_result {
	required bool successful = 1;
	optional string reason = 2;
}

message lease_pool_null {
}

// represent the list of nodes holding a lease
message lease_nodes {
	repeated string node = 1;
}


service LeasePoolManager {
	rpc Init(lease_pool_init) returns (lease_pool_null) {}
	rpc WaitLease(lease_pool_null) returns (stream lease_pool_wait_result) {}
	rpc Release(lease_pool_null) returns (lease_pool_null) {}
	rpc GetNodesWithLease(lease_pool_null) returns (stream lease_nodes) {}
}
