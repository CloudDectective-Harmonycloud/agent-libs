syntax = "proto2";

import "draios.proto";
package sdc_internal;

// Internal protobuf used by sysdig cloud agent components
// to talk each other. It uses some pieces in common with
// draios.proto so it can be more efficient

option optimize_for = SPEED;
//option java_package = "com.draios.model.protobuf";
//option java_outer_classname = "Agent";

message container_mounts {
    required string container_id = 1;
    repeated draiosproto.mounted_fs mounts = 2; 
}

message mounted_fs_response {
    repeated container_mounts containers = 1;
}

message container_info {
    required string id = 1;
    required uint64 pid = 2;
    required uint64 vpid = 3;
    required string root = 4;
}

message mounted_fs_request {
    repeated container_info containers = 1;
}

enum cointerface_message_type {
    PING = 1;
    PONG = 2;
    DOCKER_COMMAND = 3;
    DOCKER_COMMAND_RESULT = 4;
    SWARM_STATE_COMMAND = 5;
    SWARM_STATE_RESULT = 6;
    ORCHESTRATOR_EVENTS_STREAM_COMMAND = 7;
    ORCHESTRATOR_EVENTS_STREAM_RESULT = 8;
}

enum docker_cmd_type {
    STOP = 1;
    PAUSE = 2;
    UNPAUSE = 3;
}

message ping {
    required int64 token = 1;
}

message pong {
    required int64 token = 1;
    required int32 pid = 2;
    required uint64 memory_used = 3;
}

message docker_command {
    required docker_cmd_type cmd = 1;
    // Making optional in case other later commands want to work with images
    optional string container_id = 2;
}

message docker_command_result {
    required bool successful = 1;
    optional string errstr = 2;
}

message swarm_state_command {
    optional string container_id = 2;
}

message swarm_state_result {
    required bool successful = 1;
    optional string errstr = 2;
    optional draiosproto.swarm_state state = 3;
}

message orchestrator_events_stream_command {
    required string url = 1;
    required string ca_cert = 2;
    required string client_cert = 3;
    required string client_key = 4;
    required uint32 queue_len = 6;
    required int32 startup_gc = 7;
    required uint32 startup_inf_wait_time_s = 8;
    required uint32 startup_tick_interval_ms = 9;
    required uint32 startup_low_ticks_needed = 10;
    required uint32 startup_low_evt_threshold = 11;
    required bool filter_empty = 12;
    required bool ssl_verify_certificate = 13;
    required string auth_token = 14;
    repeated string annotation_filter = 15;
    repeated string include_types = 16;
}

service CoInterface {
    rpc PerformDockerCommand(docker_command) returns (docker_command_result) {}
    rpc PerformPing(ping) returns (pong) {}
    rpc PerformSwarmState(swarm_state_command) returns (swarm_state_result) {}
    rpc PerformOrchestratorEventsStream(orchestrator_events_stream_command) returns (stream draiosproto.congroup_update_event) {}
}

message comp_module_status {
    required string mod_name = 1;
    optional bool running = 2;
    optional string errstr = 3;
}

message comp_load {
    required string customer_id = 1;
    required string machine_id = 2;
}

message comp_load_result {
    repeated comp_module_status statuses = 1;
}

message comp_start {
    optional string customer_id = 1;
    optional string machine_id = 2;
    required draiosproto.comp_calendar calendar = 3;
    optional bool include_desc = 4;
    optional bool send_failed_results = 5;
}

message comp_stop {
}

message comp_stop_result {
    required bool successful = 1;
    optional string errstr = 2;
}

message comp_task_event {
    required string task_name = 1;
    required bool call_successful = 2;
    optional string errstr = 3;
    optional draiosproto.comp_events events = 4;
    optional draiosproto.comp_results results = 5;
}

message comp_get_future_runs {
    required draiosproto.comp_task task = 1;
    required string start = 2;
    required uint32 num_runs = 3;
}

message comp_future_runs {
    required bool successful = 1;
    optional string errstr = 2;
    repeated string runs = 3;
}

service ComplianceModuleMgr {
    rpc Load(comp_load) returns (comp_load_result) {}
    rpc Start(comp_start) returns (stream comp_task_event) {}
    rpc Stop(comp_stop) returns (comp_stop_result) {}
    rpc GetFutureRuns(comp_get_future_runs)returns (comp_future_runs){}
}
