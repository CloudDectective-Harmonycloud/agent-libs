syntax = "proto2";

import "draios.proto";
package sdc_internal;

// Internal protobuf used by sysdig cloud agent components
// to talk each other. It uses some pieces in common with
// draios.proto so it can be more efficient

option optimize_for = SPEED;
//option java_package = "com.draios.model.protobuf";
//option java_outer_classname = "Agent";

message container_mounts {
    required string container_id = 1;
    repeated draiosproto.mounted_fs mounts = 2;
}

message mounted_device {
    required uint32 number = 1;
    required string name = 2;
}

message mounted_fs_response {
    repeated container_mounts containers = 1;
    repeated mounted_device devices = 2;
}

message container_info {
    required string id = 1;
    required uint64 pid = 2;
    required uint64 vpid = 3;
    required string root = 4;
}

message mounted_fs_request {
    repeated container_info containers = 1;
}

enum cointerface_message_type {
    PING = 1;
    PONG = 2;
    DOCKER_COMMAND = 3;
    DOCKER_COMMAND_RESULT = 4;
    SWARM_STATE_COMMAND = 5;
    SWARM_STATE_RESULT = 6;
    ORCHESTRATOR_EVENTS_STREAM_COMMAND = 7;
    ORCHESTRATOR_EVENTS_STREAM_RESULT = 8;
    ORCHESTRATOR_EVENT_MESSAGE_STREAM_COMMAND = 9;
    ORCHESTRATOR_EVENT_MESSAGE_STREAM_RESULT = 10;
    SET_K8S_OPTION_COMMAND = 11;
    SET_K8S_OPTION_RESULT = 12;
}

enum docker_cmd_type {
    STOP = 1;
    PAUSE = 2;
    UNPAUSE = 3;
}

message ping {
    required int64 token = 1;
}

message pong {
    required int64 token = 1;
    required int32 pid = 2;
    required uint64 memory_used = 3;
}

message docker_command {
    required docker_cmd_type cmd = 1;
    // Making optional in case other later commands want to work with images
    optional string container_id = 2;
}

message docker_command_result {
    required bool successful = 1;
    optional string errstr = 2;
}

message swarm_state_command {
    optional string container_id = 2;
}

message swarm_state_result {
    required bool successful = 1;
    optional string errstr = 2;
    optional draiosproto.swarm_state state = 3;
}

message orchestrator_events_stream_command {
    required string url = 1;
    required string ca_cert = 2;
    required string client_cert = 3;
    required string client_key = 4;
    required uint32 queue_len = 6;
    required int32 startup_gc = 7;
    required uint32 startup_inf_wait_time_s = 8;
    required uint32 startup_tick_interval_ms = 9;
    required uint32 startup_low_ticks_needed = 10;
    required uint32 startup_low_evt_threshold = 11;
    required bool filter_empty = 12;
    required bool ssl_verify_certificate = 13;
    required string auth_token = 14;
    repeated string annotation_filter = 15;
    repeated string include_types = 16;
    required uint32 event_counts_log_time = 17;
    required uint32 batch_msgs_queue_len = 18;
    required uint32 batch_msgs_tick_interval_ms = 19;
    required uint32 max_rnd_conn_delay = 23;
}

message orchestrator_attach_user_events_stream_command {
    optional uint32 user_event_queue_len = 1;
    optional bool collect_debug_events = 2; // by default, only collect a few events. If set, collect everything
    repeated string include_types = 3;  // string vector containing k8s_extra_resources
}

message array_congroup_update_event {
    repeated draiosproto.congroup_update_event events = 1;
}

message k8s_object {
    required string kind = 1;
    required string namespace = 2;
    required string name = 3;
    required string uid = 4;
    optional string api_version = 5;
    optional string resource_version = 6;
    optional string field_path = 7;
}

message k8s_source {
    optional string component = 1;
    optional string host = 2;
}

message k8s_user_event {
    required k8s_object obj = 1;
    optional k8s_source source = 2;
    optional string reason = 3;
    optional string message = 4;
    optional int64 first_timestamp = 5;
    optional int64 last_timestamp = 6;
    optional int32 count = 7;
    optional string type = 8;
}

message k8s_option_command {
    required string key = 1;
    required string value = 2;
}

message k8s_option_result {
    required bool successful = 1;
    optional string errstr = 2;
}

service CoInterface {
    rpc PerformDockerCommand(docker_command) returns (docker_command_result) {}
    rpc PerformPing(ping) returns (pong) {}
    rpc PerformSwarmState(swarm_state_command) returns (swarm_state_result) {}
    rpc PerformOrchestratorEventMessageStream(orchestrator_attach_user_events_stream_command) returns (stream k8s_user_event) {}
    rpc PerformOrchestratorEventsStream(orchestrator_events_stream_command) returns (stream array_congroup_update_event) {}
    rpc PerformSetK8sOption(k8s_option_command) returns (k8s_option_result) {}
}

message comp_module_status {
    required string mod_name = 1;
    optional bool running = 2;
    optional string errstr = 3;
}

message comp_load_result {
    repeated comp_module_status statuses = 1;
}

message comp_start {
    optional string customer_id = 1;
    optional string machine_id = 2;
    required draiosproto.comp_calendar calendar = 3;
    optional bool include_desc = 4;
    optional bool send_failed_results = 5;
    optional bool save_temp_files = 6;
    optional uint32 metrics_statsd_port = 7;
}

message comp_stop {
}

message comp_stop_result {
    required bool successful = 1;
    optional string errstr = 2;
}

message comp_task_event {
    required string task_name = 1;
    required bool init_successful = 2;
    optional string errstr = 3;
    optional draiosproto.comp_events events = 4;
    optional draiosproto.comp_results results = 5;
}

message comp_get_future_runs {
    required draiosproto.comp_task task = 1;
    required string start = 2;
    required uint32 num_runs = 3;
}

message comp_future_runs {
    required bool successful = 1;
    optional string errstr = 2;
    repeated string runs = 3;
}

message comp_run_result {
    required bool successful = 1;
    optional string errstr = 2;
}

service ComplianceModuleMgr {
    rpc Start(comp_start) returns (stream comp_task_event) {}
    rpc Stop(comp_stop) returns (comp_stop_result) {}
    rpc GetFutureRuns(comp_get_future_runs)returns (comp_future_runs){}
    rpc RunTasks(draiosproto.comp_run) returns (comp_run_result) {}
}

message k8s_audit_server_X509 {
    required string x509_cert_file = 1;
    required string x509_key_file = 2;
}

/* The K8s Audit Server sets up a single endpoint either HTTP or
 * HTTPS */
message k8s_audit_server_load {
    required string url = 1;
    required uint32 port = 2;
    required bool tls_enabled = 3;
    repeated k8s_audit_server_X509 x509 = 4;
}

message k8s_audit_server_load_result {
    required bool successful = 1;
    optional string errstr = 2;
}

message k8s_audit_server_start {
}

message k8s_audit_server_stop {
}

message k8s_audit_event {
    required bool successful = 1;
    optional uint64 evt_id = 2;
    optional string evt_json = 3;
    optional string errstr = 4;
}

message k8s_audit_stop_result {
    required bool successful = 1;
    optional string errstr = 2;
}

service K8sAudit {
    rpc Load(k8s_audit_server_load) returns (k8s_audit_server_load_result) {}
    rpc Start(k8s_audit_server_start) returns (stream k8s_audit_event) {}
    rpc Stop(k8s_audit_server_stop) returns (k8s_audit_stop_result) {}
}
