// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: draios.proto

/*
	Package draiosproto is a generated protocol buffer package.

	It is generated from these files:
		draios.proto

	It has these top-level messages:
		CounterPercentileData
		CounterPercentile
		CounterTime
		CounterTimeBidirectional
		CounterBytes
		CounterTimeBytes
		TimeCategories
		TransactionBreakdownCategories
		CounterSyscallErrors
		ResourceCategories
		ConnectionCategories
		ProcessDetails
		CommandDetails
		CounterProtoEntry
		UrlDetails
		StatusCodeDetails
		HttpInfo
		SqlEntryDetails
		SqlQueryTypeDetails
		SqlInfo
		MongodbCollectionDetails
		MongodbOpTypeDetails
		MongodbInfo
		JmxAttribute
		JmxBean
		JavaInfo
		StatsdTag
		StatsdMetric
		StatsdInfo
		AppTag
		AppMetric
		AppCheck
		AppInfo
		ProtoInfo
		NetworkByPort
		Host
		Process
		Program
		Ipv4Tuple
		Ipv4Connection
		Ipv4NetworkInterface
		MountedFs
		FileStat
		ContainerPortMapping
		ContainerLabel
		Container
		CongroupUid
		CongroupNetPort
		ContainerGroup
		CongroupUpdateEvent
		OrchestratorEvents
		K8SPair
		K8SCommon
		K8SNamespace
		K8SNode
		K8SPod
		K8SReplicationController
		K8SReplicaSet
		K8SService
		K8SDeployment
		K8SDaemonset
		K8SState
		MesosPair
		MesosCommon
		MesosTask
		MarathonApp
		MarathonGroup
		MesosFramework
		MesosSlave
		MesosState
		SwarmPair
		SwarmPort
		SwarmCommon
		SwarmService
		SwarmTask
		SwarmManager
		SwarmNode
		SwarmState
		OrchestratorStateT
		Metrics
		DumpRequestStart
		DumpRequestStop
		DumpResponse
		SshOpenChannel
		SshData
		SshCloseChannel
		AutoUpdateRequest
		DirtyShutdownReport
		KeyValue
		AgentEvent
		ConfigFile
		ConfigData
		StopAction
		PauseAction
		CaptureAction
		Action
		BaselineDetail
		ManualDetail
		FalcoRuleFilter
		FalcoDetail
		ScopePredicate
		Policy
		FalcoRulesContents
		Policies
		BaselineEventDetail
		ManualEventDetail
		FalcoEventDetail
		ActionResult
		PolicyEvent
		PolicyEvents
		ThrottledPolicyEvent
		ThrottledPolicyEvents
		ErrorMessage
		FalcoSubcategory
		FalcoSubcategoryContainer
		FalcoCategory
		FalcoProg
		FalcoContainer
		FalcoBaseline
*/
package draiosproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import github_com_golang_protobuf_proto "github.com/golang/protobuf/proto"
import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

//
// SQL statement information
//
type SqlStatementType int32

const (
	SqlStatementType_SOP_NONE    SqlStatementType = 0
	SqlStatementType_SOP_SELECT  SqlStatementType = 1
	SqlStatementType_SOP_INSERT  SqlStatementType = 2
	SqlStatementType_SOP_SET     SqlStatementType = 3
	SqlStatementType_SOP_CREATE  SqlStatementType = 4
	SqlStatementType_SOP_DELETE  SqlStatementType = 5
	SqlStatementType_SOP_DROP    SqlStatementType = 6
	SqlStatementType_SOP_REPLACE SqlStatementType = 7
	SqlStatementType_SOP_UPDATE  SqlStatementType = 8
	SqlStatementType_SOP_USE     SqlStatementType = 9
	SqlStatementType_SOP_SHOW    SqlStatementType = 10
	SqlStatementType_SOP_LOCK    SqlStatementType = 11
	SqlStatementType_SOP_UNLOCK  SqlStatementType = 12
	SqlStatementType_SOP_ALTER   SqlStatementType = 13
)

var SqlStatementType_name = map[int32]string{
	0:  "SOP_NONE",
	1:  "SOP_SELECT",
	2:  "SOP_INSERT",
	3:  "SOP_SET",
	4:  "SOP_CREATE",
	5:  "SOP_DELETE",
	6:  "SOP_DROP",
	7:  "SOP_REPLACE",
	8:  "SOP_UPDATE",
	9:  "SOP_USE",
	10: "SOP_SHOW",
	11: "SOP_LOCK",
	12: "SOP_UNLOCK",
	13: "SOP_ALTER",
}
var SqlStatementType_value = map[string]int32{
	"SOP_NONE":    0,
	"SOP_SELECT":  1,
	"SOP_INSERT":  2,
	"SOP_SET":     3,
	"SOP_CREATE":  4,
	"SOP_DELETE":  5,
	"SOP_DROP":    6,
	"SOP_REPLACE": 7,
	"SOP_UPDATE":  8,
	"SOP_USE":     9,
	"SOP_SHOW":    10,
	"SOP_LOCK":    11,
	"SOP_UNLOCK":  12,
	"SOP_ALTER":   13,
}

func (x SqlStatementType) Enum() *SqlStatementType {
	p := new(SqlStatementType)
	*p = x
	return p
}
func (x SqlStatementType) String() string {
	return proto.EnumName(SqlStatementType_name, int32(x))
}
func (x *SqlStatementType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SqlStatementType_value, data, "SqlStatementType")
	if err != nil {
		return err
	}
	*x = SqlStatementType(value)
	return nil
}
func (SqlStatementType) EnumDescriptor() ([]byte, []int) { return fileDescriptorDraios, []int{0} }

type MongodbOpType int32

const (
	MongodbOpType_MONGODB_OP_NONE            MongodbOpType = 0
	MongodbOpType_MONGODB_OP_INSERT          MongodbOpType = 1
	MongodbOpType_MONGODB_OP_UPDATE          MongodbOpType = 2
	MongodbOpType_MONGODB_OP_DELETE          MongodbOpType = 3
	MongodbOpType_MONGODB_OP_GET_MORE        MongodbOpType = 4
	MongodbOpType_MONGODB_OP_KILL_CURSORS    MongodbOpType = 5
	MongodbOpType_MONGODB_OP_FIND            MongodbOpType = 6
	MongodbOpType_MONGODB_OP_AGGREGATE       MongodbOpType = 7
	MongodbOpType_MONGODB_OP_COMMAND         MongodbOpType = 8
	MongodbOpType_MONGODB_OP_COUNT           MongodbOpType = 9
	MongodbOpType_MONGODB_OP_DISTINCT        MongodbOpType = 10
	MongodbOpType_MONGODB_OP_MAP_REDUCE      MongodbOpType = 11
	MongodbOpType_MONGODB_OP_GEO_NEAR        MongodbOpType = 12
	MongodbOpType_MONGODB_OP_GEO_SEARCH      MongodbOpType = 13
	MongodbOpType_MONGODB_OP_FIND_AND_MODIFY MongodbOpType = 14
)

var MongodbOpType_name = map[int32]string{
	0:  "MONGODB_OP_NONE",
	1:  "MONGODB_OP_INSERT",
	2:  "MONGODB_OP_UPDATE",
	3:  "MONGODB_OP_DELETE",
	4:  "MONGODB_OP_GET_MORE",
	5:  "MONGODB_OP_KILL_CURSORS",
	6:  "MONGODB_OP_FIND",
	7:  "MONGODB_OP_AGGREGATE",
	8:  "MONGODB_OP_COMMAND",
	9:  "MONGODB_OP_COUNT",
	10: "MONGODB_OP_DISTINCT",
	11: "MONGODB_OP_MAP_REDUCE",
	12: "MONGODB_OP_GEO_NEAR",
	13: "MONGODB_OP_GEO_SEARCH",
	14: "MONGODB_OP_FIND_AND_MODIFY",
}
var MongodbOpType_value = map[string]int32{
	"MONGODB_OP_NONE":            0,
	"MONGODB_OP_INSERT":          1,
	"MONGODB_OP_UPDATE":          2,
	"MONGODB_OP_DELETE":          3,
	"MONGODB_OP_GET_MORE":        4,
	"MONGODB_OP_KILL_CURSORS":    5,
	"MONGODB_OP_FIND":            6,
	"MONGODB_OP_AGGREGATE":       7,
	"MONGODB_OP_COMMAND":         8,
	"MONGODB_OP_COUNT":           9,
	"MONGODB_OP_DISTINCT":        10,
	"MONGODB_OP_MAP_REDUCE":      11,
	"MONGODB_OP_GEO_NEAR":        12,
	"MONGODB_OP_GEO_SEARCH":      13,
	"MONGODB_OP_FIND_AND_MODIFY": 14,
}

func (x MongodbOpType) Enum() *MongodbOpType {
	p := new(MongodbOpType)
	*p = x
	return p
}
func (x MongodbOpType) String() string {
	return proto.EnumName(MongodbOpType_name, int32(x))
}
func (x *MongodbOpType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MongodbOpType_value, data, "MongodbOpType")
	if err != nil {
		return err
	}
	*x = MongodbOpType(value)
	return nil
}
func (MongodbOpType) EnumDescriptor() ([]byte, []int) { return fileDescriptorDraios, []int{1} }

type Unit int32

const (
	Unit_UNIT_NONE    Unit = 0
	Unit_UNIT_SECOND  Unit = 1
	Unit_UNIT_BYTE    Unit = 2
	Unit_UNIT_PERCENT Unit = 3
)

var Unit_name = map[int32]string{
	0: "UNIT_NONE",
	1: "UNIT_SECOND",
	2: "UNIT_BYTE",
	3: "UNIT_PERCENT",
}
var Unit_value = map[string]int32{
	"UNIT_NONE":    0,
	"UNIT_SECOND":  1,
	"UNIT_BYTE":    2,
	"UNIT_PERCENT": 3,
}

func (x Unit) Enum() *Unit {
	p := new(Unit)
	*p = x
	return p
}
func (x Unit) String() string {
	return proto.EnumName(Unit_name, int32(x))
}
func (x *Unit) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Unit_value, data, "Unit")
	if err != nil {
		return err
	}
	*x = Unit(value)
	return nil
}
func (Unit) EnumDescriptor() ([]byte, []int) { return fileDescriptorDraios, []int{2} }

type Scale int32

const (
	Scale_SCALE_NONE        Scale = 0
	Scale_SCALE_MILLI       Scale = 1
	Scale_SCALE_MICRO       Scale = 2
	Scale_SCALE_NANO        Scale = 3
	Scale_SCALE_MINUTE      Scale = 4
	Scale_SCALE_HOUR        Scale = 5
	Scale_SCALE_DAY         Scale = 6
	Scale_SCALE_KILO        Scale = 7
	Scale_SCALE_MEGA        Scale = 8
	Scale_SCALE_GIGA        Scale = 9
	Scale_SCALE_TERA        Scale = 10
	Scale_SCALE_KIBI        Scale = 11
	Scale_SCALE_MEBI        Scale = 12
	Scale_SCALE_GIBI        Scale = 13
	Scale_SCALE_TEBI        Scale = 14
	Scale_SCALE_PERCENT_0_1 Scale = 15
)

var Scale_name = map[int32]string{
	0:  "SCALE_NONE",
	1:  "SCALE_MILLI",
	2:  "SCALE_MICRO",
	3:  "SCALE_NANO",
	4:  "SCALE_MINUTE",
	5:  "SCALE_HOUR",
	6:  "SCALE_DAY",
	7:  "SCALE_KILO",
	8:  "SCALE_MEGA",
	9:  "SCALE_GIGA",
	10: "SCALE_TERA",
	11: "SCALE_KIBI",
	12: "SCALE_MEBI",
	13: "SCALE_GIBI",
	14: "SCALE_TEBI",
	15: "SCALE_PERCENT_0_1",
}
var Scale_value = map[string]int32{
	"SCALE_NONE":        0,
	"SCALE_MILLI":       1,
	"SCALE_MICRO":       2,
	"SCALE_NANO":        3,
	"SCALE_MINUTE":      4,
	"SCALE_HOUR":        5,
	"SCALE_DAY":         6,
	"SCALE_KILO":        7,
	"SCALE_MEGA":        8,
	"SCALE_GIGA":        9,
	"SCALE_TERA":        10,
	"SCALE_KIBI":        11,
	"SCALE_MEBI":        12,
	"SCALE_GIBI":        13,
	"SCALE_TEBI":        14,
	"SCALE_PERCENT_0_1": 15,
}

func (x Scale) Enum() *Scale {
	p := new(Scale)
	*p = x
	return p
}
func (x Scale) String() string {
	return proto.EnumName(Scale_name, int32(x))
}
func (x *Scale) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Scale_value, data, "Scale")
	if err != nil {
		return err
	}
	*x = Scale(value)
	return nil
}
func (Scale) EnumDescriptor() ([]byte, []int) { return fileDescriptorDraios, []int{3} }

type JmxMetricType int32

const (
	JmxMetricType_JMX_METRIC_TYPE_COUNTER JmxMetricType = 1
	JmxMetricType_JMX_METRIC_TYPE_GAUGE   JmxMetricType = 2
)

var JmxMetricType_name = map[int32]string{
	1: "JMX_METRIC_TYPE_COUNTER",
	2: "JMX_METRIC_TYPE_GAUGE",
}
var JmxMetricType_value = map[string]int32{
	"JMX_METRIC_TYPE_COUNTER": 1,
	"JMX_METRIC_TYPE_GAUGE":   2,
}

func (x JmxMetricType) Enum() *JmxMetricType {
	p := new(JmxMetricType)
	*p = x
	return p
}
func (x JmxMetricType) String() string {
	return proto.EnumName(JmxMetricType_name, int32(x))
}
func (x *JmxMetricType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(JmxMetricType_value, data, "JmxMetricType")
	if err != nil {
		return err
	}
	*x = JmxMetricType(value)
	return nil
}
func (JmxMetricType) EnumDescriptor() ([]byte, []int) { return fileDescriptorDraios, []int{4} }

type StatsdMetricType int32

const (
	StatsdMetricType_STATSD_COUNT     StatsdMetricType = 1
	StatsdMetricType_STATSD_HISTOGRAM StatsdMetricType = 2
	StatsdMetricType_STATSD_GAUGE     StatsdMetricType = 3
	StatsdMetricType_STATSD_SET       StatsdMetricType = 4
)

var StatsdMetricType_name = map[int32]string{
	1: "STATSD_COUNT",
	2: "STATSD_HISTOGRAM",
	3: "STATSD_GAUGE",
	4: "STATSD_SET",
}
var StatsdMetricType_value = map[string]int32{
	"STATSD_COUNT":     1,
	"STATSD_HISTOGRAM": 2,
	"STATSD_GAUGE":     3,
	"STATSD_SET":       4,
}

func (x StatsdMetricType) Enum() *StatsdMetricType {
	p := new(StatsdMetricType)
	*p = x
	return p
}
func (x StatsdMetricType) String() string {
	return proto.EnumName(StatsdMetricType_name, int32(x))
}
func (x *StatsdMetricType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(StatsdMetricType_value, data, "StatsdMetricType")
	if err != nil {
		return err
	}
	*x = StatsdMetricType(value)
	return nil
}
func (StatsdMetricType) EnumDescriptor() ([]byte, []int) { return fileDescriptorDraios, []int{5} }

type AppMetricType int32

const (
	AppMetricType_APP_METRIC_TYPE_GAUGE AppMetricType = 1
	AppMetricType_APP_METRIC_TYPE_RATE  AppMetricType = 2
)

var AppMetricType_name = map[int32]string{
	1: "APP_METRIC_TYPE_GAUGE",
	2: "APP_METRIC_TYPE_RATE",
}
var AppMetricType_value = map[string]int32{
	"APP_METRIC_TYPE_GAUGE": 1,
	"APP_METRIC_TYPE_RATE":  2,
}

func (x AppMetricType) Enum() *AppMetricType {
	p := new(AppMetricType)
	*p = x
	return p
}
func (x AppMetricType) String() string {
	return proto.EnumName(AppMetricType_name, int32(x))
}
func (x *AppMetricType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AppMetricType_value, data, "AppMetricType")
	if err != nil {
		return err
	}
	*x = AppMetricType(value)
	return nil
}
func (AppMetricType) EnumDescriptor() ([]byte, []int) { return fileDescriptorDraios, []int{6} }

type AppCheckValue int32

const (
	AppCheckValue_APP_CHECK_VALUE_OK       AppCheckValue = 0
	AppCheckValue_APP_CHECK_VALUE_WARNING  AppCheckValue = 1
	AppCheckValue_APP_CHECK_VALUE_CRITICAL AppCheckValue = 2
	AppCheckValue_APP_CHECK_VALUE_UNKNOWN  AppCheckValue = 3
)

var AppCheckValue_name = map[int32]string{
	0: "APP_CHECK_VALUE_OK",
	1: "APP_CHECK_VALUE_WARNING",
	2: "APP_CHECK_VALUE_CRITICAL",
	3: "APP_CHECK_VALUE_UNKNOWN",
}
var AppCheckValue_value = map[string]int32{
	"APP_CHECK_VALUE_OK":       0,
	"APP_CHECK_VALUE_WARNING":  1,
	"APP_CHECK_VALUE_CRITICAL": 2,
	"APP_CHECK_VALUE_UNKNOWN":  3,
}

func (x AppCheckValue) Enum() *AppCheckValue {
	p := new(AppCheckValue)
	*p = x
	return p
}
func (x AppCheckValue) String() string {
	return proto.EnumName(AppCheckValue_name, int32(x))
}
func (x *AppCheckValue) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AppCheckValue_value, data, "AppCheckValue")
	if err != nil {
		return err
	}
	*x = AppCheckValue(value)
	return nil
}
func (AppCheckValue) EnumDescriptor() ([]byte, []int) { return fileDescriptorDraios, []int{7} }

//
// PROCESS
// info for a process, i.e. a collection of threads.
// NOTE: this is process info only, when emitting threads, the main thread of a process will have a
// separate thread message with tid=process pid.
//
type Networkrole int32

const (
	Networkrole_NONE                  Networkrole = 0
	Networkrole_IS_LOCAL_IPV4_SERVER  Networkrole = 1
	Networkrole_IS_REMOTE_IPV4_SERVER Networkrole = 2
	Networkrole_IS_UNIX_SERVER        Networkrole = 4
	Networkrole_IS_LOCAL_IPV4_CLIENT  Networkrole = 8
	Networkrole_IS_REMOTE_IPV4_CLIENT Networkrole = 16
	Networkrole_IS_UNIX_CLIENT        Networkrole = 32
)

var Networkrole_name = map[int32]string{
	0:  "NONE",
	1:  "IS_LOCAL_IPV4_SERVER",
	2:  "IS_REMOTE_IPV4_SERVER",
	4:  "IS_UNIX_SERVER",
	8:  "IS_LOCAL_IPV4_CLIENT",
	16: "IS_REMOTE_IPV4_CLIENT",
	32: "IS_UNIX_CLIENT",
}
var Networkrole_value = map[string]int32{
	"NONE":                  0,
	"IS_LOCAL_IPV4_SERVER":  1,
	"IS_REMOTE_IPV4_SERVER": 2,
	"IS_UNIX_SERVER":        4,
	"IS_LOCAL_IPV4_CLIENT":  8,
	"IS_REMOTE_IPV4_CLIENT": 16,
	"IS_UNIX_CLIENT":        32,
}

func (x Networkrole) Enum() *Networkrole {
	p := new(Networkrole)
	*p = x
	return p
}
func (x Networkrole) String() string {
	return proto.EnumName(Networkrole_name, int32(x))
}
func (x *Networkrole) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Networkrole_value, data, "Networkrole")
	if err != nil {
		return err
	}
	*x = Networkrole(value)
	return nil
}
func (Networkrole) EnumDescriptor() ([]byte, []int) { return fileDescriptorDraios, []int{8} }

//
// MESSAGE TYPES
//
type MessageType int32

const (
	MessageType_METRICS                 MessageType = 1
	MessageType_DUMP_REQUEST_START      MessageType = 2
	MessageType_DUMP_REQUEST_STOP       MessageType = 4
	MessageType_DUMP_RESPONSE           MessageType = 3
	MessageType_SSH_OPEN_CHANNEL        MessageType = 6
	MessageType_SSH_CLOSE_CHANNEL       MessageType = 7
	MessageType_SSH_DATA                MessageType = 8
	MessageType_AUTO_UPDATE_REQUEST     MessageType = 9
	MessageType_DIRTY_SHUTDOWN_REPORT   MessageType = 10
	MessageType_CONFIG_DATA             MessageType = 11
	MessageType_ERROR_MESSAGE           MessageType = 12
	MessageType_POLICIES                MessageType = 13
	MessageType_POLICY_EVENTS           MessageType = 14
	MessageType_THROTTLED_POLICY_EVENTS MessageType = 15
	MessageType_ORCHESTRATOR_EVENTS     MessageType = 16
)

var MessageType_name = map[int32]string{
	1:  "METRICS",
	2:  "DUMP_REQUEST_START",
	4:  "DUMP_REQUEST_STOP",
	3:  "DUMP_RESPONSE",
	6:  "SSH_OPEN_CHANNEL",
	7:  "SSH_CLOSE_CHANNEL",
	8:  "SSH_DATA",
	9:  "AUTO_UPDATE_REQUEST",
	10: "DIRTY_SHUTDOWN_REPORT",
	11: "CONFIG_DATA",
	12: "ERROR_MESSAGE",
	13: "POLICIES",
	14: "POLICY_EVENTS",
	15: "THROTTLED_POLICY_EVENTS",
	16: "ORCHESTRATOR_EVENTS",
}
var MessageType_value = map[string]int32{
	"METRICS":                 1,
	"DUMP_REQUEST_START":      2,
	"DUMP_REQUEST_STOP":       4,
	"DUMP_RESPONSE":           3,
	"SSH_OPEN_CHANNEL":        6,
	"SSH_CLOSE_CHANNEL":       7,
	"SSH_DATA":                8,
	"AUTO_UPDATE_REQUEST":     9,
	"DIRTY_SHUTDOWN_REPORT":   10,
	"CONFIG_DATA":             11,
	"ERROR_MESSAGE":           12,
	"POLICIES":                13,
	"POLICY_EVENTS":           14,
	"THROTTLED_POLICY_EVENTS": 15,
	"ORCHESTRATOR_EVENTS":     16,
}

func (x MessageType) Enum() *MessageType {
	p := new(MessageType)
	*p = x
	return p
}
func (x MessageType) String() string {
	return proto.EnumName(MessageType_name, int32(x))
}
func (x *MessageType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MessageType_value, data, "MessageType")
	if err != nil {
		return err
	}
	*x = MessageType(value)
	return nil
}
func (MessageType) EnumDescriptor() ([]byte, []int) { return fileDescriptorDraios, []int{9} }

type ContainerType int32

const (
	ContainerType_DOCKER      ContainerType = 1
	ContainerType_LXC         ContainerType = 2
	ContainerType_LIBVIRT_LXC ContainerType = 3
	ContainerType_MESOS       ContainerType = 4
	ContainerType_RKT         ContainerType = 5
)

var ContainerType_name = map[int32]string{
	1: "DOCKER",
	2: "LXC",
	3: "LIBVIRT_LXC",
	4: "MESOS",
	5: "RKT",
}
var ContainerType_value = map[string]int32{
	"DOCKER":      1,
	"LXC":         2,
	"LIBVIRT_LXC": 3,
	"MESOS":       4,
	"RKT":         5,
}

func (x ContainerType) Enum() *ContainerType {
	p := new(ContainerType)
	*p = x
	return p
}
func (x ContainerType) String() string {
	return proto.EnumName(ContainerType_name, int32(x))
}
func (x *ContainerType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ContainerType_value, data, "ContainerType")
	if err != nil {
		return err
	}
	*x = ContainerType(value)
	return nil
}
func (ContainerType) EnumDescriptor() ([]byte, []int) { return fileDescriptorDraios, []int{10} }

type CongroupEventType int32

const (
	CongroupEventType_ADDED   CongroupEventType = 1
	CongroupEventType_REMOVED CongroupEventType = 2
	CongroupEventType_UPDATED CongroupEventType = 3
)

var CongroupEventType_name = map[int32]string{
	1: "ADDED",
	2: "REMOVED",
	3: "UPDATED",
}
var CongroupEventType_value = map[string]int32{
	"ADDED":   1,
	"REMOVED": 2,
	"UPDATED": 3,
}

func (x CongroupEventType) Enum() *CongroupEventType {
	p := new(CongroupEventType)
	*p = x
	return p
}
func (x CongroupEventType) String() string {
	return proto.EnumName(CongroupEventType_name, int32(x))
}
func (x *CongroupEventType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CongroupEventType_value, data, "CongroupEventType")
	if err != nil {
		return err
	}
	*x = CongroupEventType(value)
	return nil
}
func (CongroupEventType) EnumDescriptor() ([]byte, []int) { return fileDescriptorDraios, []int{11} }

type SwarmServiceMode int32

const (
	SwarmServiceMode_REPLICATED SwarmServiceMode = 1
	SwarmServiceMode_GLOBAL     SwarmServiceMode = 2
)

var SwarmServiceMode_name = map[int32]string{
	1: "REPLICATED",
	2: "GLOBAL",
}
var SwarmServiceMode_value = map[string]int32{
	"REPLICATED": 1,
	"GLOBAL":     2,
}

func (x SwarmServiceMode) Enum() *SwarmServiceMode {
	p := new(SwarmServiceMode)
	*p = x
	return p
}
func (x SwarmServiceMode) String() string {
	return proto.EnumName(SwarmServiceMode_name, int32(x))
}
func (x *SwarmServiceMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SwarmServiceMode_value, data, "SwarmServiceMode")
	if err != nil {
		return err
	}
	*x = SwarmServiceMode(value)
	return nil
}
func (SwarmServiceMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorDraios, []int{12} }

type ActionType int32

const (
	ActionType_ACTION_STOP    ActionType = 1
	ActionType_ACTION_PAUSE   ActionType = 2
	ActionType_ACTION_CAPTURE ActionType = 3
)

var ActionType_name = map[int32]string{
	1: "ACTION_STOP",
	2: "ACTION_PAUSE",
	3: "ACTION_CAPTURE",
}
var ActionType_value = map[string]int32{
	"ACTION_STOP":    1,
	"ACTION_PAUSE":   2,
	"ACTION_CAPTURE": 3,
}

func (x ActionType) Enum() *ActionType {
	p := new(ActionType)
	*p = x
	return p
}
func (x ActionType) String() string {
	return proto.EnumName(ActionType_name, int32(x))
}
func (x *ActionType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ActionType_value, data, "ActionType")
	if err != nil {
		return err
	}
	*x = ActionType(value)
	return nil
}
func (ActionType) EnumDescriptor() ([]byte, []int) { return fileDescriptorDraios, []int{13} }

type PolicyType int32

const (
	PolicyType_POLICY_BASELINE PolicyType = 1
	PolicyType_POLICY_FALCO    PolicyType = 2
	PolicyType_POLICY_MANUAL   PolicyType = 3
)

var PolicyType_name = map[int32]string{
	1: "POLICY_BASELINE",
	2: "POLICY_FALCO",
	3: "POLICY_MANUAL",
}
var PolicyType_value = map[string]int32{
	"POLICY_BASELINE": 1,
	"POLICY_FALCO":    2,
	"POLICY_MANUAL":   3,
}

func (x PolicyType) Enum() *PolicyType {
	p := new(PolicyType)
	*p = x
	return p
}
func (x PolicyType) String() string {
	return proto.EnumName(PolicyType_name, int32(x))
}
func (x *PolicyType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PolicyType_value, data, "PolicyType")
	if err != nil {
		return err
	}
	*x = PolicyType(value)
	return nil
}
func (PolicyType) EnumDescriptor() ([]byte, []int) { return fileDescriptorDraios, []int{14} }

type ScopeOperator int32

const (
	ScopeOperator_EQ           ScopeOperator = 1
	ScopeOperator_NOT_EQ       ScopeOperator = 2
	ScopeOperator_IN_SET       ScopeOperator = 3
	ScopeOperator_NOT_IN_SET   ScopeOperator = 4
	ScopeOperator_CONTAINS     ScopeOperator = 5
	ScopeOperator_NOT_CONTAINS ScopeOperator = 6
	ScopeOperator_STARTS_WITH  ScopeOperator = 7
)

var ScopeOperator_name = map[int32]string{
	1: "EQ",
	2: "NOT_EQ",
	3: "IN_SET",
	4: "NOT_IN_SET",
	5: "CONTAINS",
	6: "NOT_CONTAINS",
	7: "STARTS_WITH",
}
var ScopeOperator_value = map[string]int32{
	"EQ":           1,
	"NOT_EQ":       2,
	"IN_SET":       3,
	"NOT_IN_SET":   4,
	"CONTAINS":     5,
	"NOT_CONTAINS": 6,
	"STARTS_WITH":  7,
}

func (x ScopeOperator) Enum() *ScopeOperator {
	p := new(ScopeOperator)
	*p = x
	return p
}
func (x ScopeOperator) String() string {
	return proto.EnumName(ScopeOperator_name, int32(x))
}
func (x *ScopeOperator) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ScopeOperator_value, data, "ScopeOperator")
	if err != nil {
		return err
	}
	*x = ScopeOperator(value)
	return nil
}
func (ScopeOperator) EnumDescriptor() ([]byte, []int) { return fileDescriptorDraios, []int{15} }

type ErrorType int32

const (
	ErrorType_ERR_CONN_LIMIT           ErrorType = 1
	ErrorType_ERR_INVALID_CUSTOMER_KEY ErrorType = 2
	ErrorType_ERR_DUPLICATE_AGENT      ErrorType = 3
	ErrorType_ERR_SERVER_BUSY          ErrorType = 4
	ErrorType_ERR_PROTO_MISMATCH       ErrorType = 5
)

var ErrorType_name = map[int32]string{
	1: "ERR_CONN_LIMIT",
	2: "ERR_INVALID_CUSTOMER_KEY",
	3: "ERR_DUPLICATE_AGENT",
	4: "ERR_SERVER_BUSY",
	5: "ERR_PROTO_MISMATCH",
}
var ErrorType_value = map[string]int32{
	"ERR_CONN_LIMIT":           1,
	"ERR_INVALID_CUSTOMER_KEY": 2,
	"ERR_DUPLICATE_AGENT":      3,
	"ERR_SERVER_BUSY":          4,
	"ERR_PROTO_MISMATCH":       5,
}

func (x ErrorType) Enum() *ErrorType {
	p := new(ErrorType)
	*p = x
	return p
}
func (x ErrorType) String() string {
	return proto.EnumName(ErrorType_name, int32(x))
}
func (x *ErrorType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ErrorType_value, data, "ErrorType")
	if err != nil {
		return err
	}
	*x = ErrorType(value)
	return nil
}
func (ErrorType) EnumDescriptor() ([]byte, []int) { return fileDescriptorDraios, []int{16} }

type CounterPercentileData struct {
	Min              *float64  `protobuf:"fixed64,1,req,name=min" json:"min,omitempty"`
	Max              *float64  `protobuf:"fixed64,2,req,name=max" json:"max,omitempty"`
	Compression      *uint32   `protobuf:"varint,3,req,name=compression" json:"compression,omitempty"`
	NumSamples       *uint32   `protobuf:"varint,4,req,name=num_samples,json=numSamples" json:"num_samples,omitempty"`
	Means            []float64 `protobuf:"fixed64,5,rep,packed,name=means" json:"means,omitempty"`
	Weights          []float64 `protobuf:"fixed64,6,rep,packed,name=weights" json:"weights,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *CounterPercentileData) Reset()                    { *m = CounterPercentileData{} }
func (m *CounterPercentileData) String() string            { return proto.CompactTextString(m) }
func (*CounterPercentileData) ProtoMessage()               {}
func (*CounterPercentileData) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{0} }

func (m *CounterPercentileData) GetMin() float64 {
	if m != nil && m.Min != nil {
		return *m.Min
	}
	return 0
}

func (m *CounterPercentileData) GetMax() float64 {
	if m != nil && m.Max != nil {
		return *m.Max
	}
	return 0
}

func (m *CounterPercentileData) GetCompression() uint32 {
	if m != nil && m.Compression != nil {
		return *m.Compression
	}
	return 0
}

func (m *CounterPercentileData) GetNumSamples() uint32 {
	if m != nil && m.NumSamples != nil {
		return *m.NumSamples
	}
	return 0
}

func (m *CounterPercentileData) GetMeans() []float64 {
	if m != nil {
		return m.Means
	}
	return nil
}

func (m *CounterPercentileData) GetWeights() []float64 {
	if m != nil {
		return m.Weights
	}
	return nil
}

type CounterPercentile struct {
	Percentile       *uint32 `protobuf:"varint,1,opt,name=percentile" json:"percentile,omitempty"`
	Value            *uint32 `protobuf:"varint,2,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *CounterPercentile) Reset()                    { *m = CounterPercentile{} }
func (m *CounterPercentile) String() string            { return proto.CompactTextString(m) }
func (*CounterPercentile) ProtoMessage()               {}
func (*CounterPercentile) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{1} }

func (m *CounterPercentile) GetPercentile() uint32 {
	if m != nil && m.Percentile != nil {
		return *m.Percentile
	}
	return 0
}

func (m *CounterPercentile) GetValue() uint32 {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return 0
}

type CounterTime struct {
	Count            *uint32                `protobuf:"varint,1,req,name=count" json:"count,omitempty"`
	TimeNs           *uint64                `protobuf:"varint,2,req,name=time_ns,json=timeNs" json:"time_ns,omitempty"`
	TimePercentage   *uint32                `protobuf:"varint,3,opt,name=time_percentage,json=timePercentage" json:"time_percentage,omitempty"`
	Percentile       []*CounterPercentile   `protobuf:"bytes,8,rep,name=percentile" json:"percentile,omitempty"`
	PercentileData   *CounterPercentileData `protobuf:"bytes,9,opt,name=percentile_data,json=percentileData" json:"percentile_data,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *CounterTime) Reset()                    { *m = CounterTime{} }
func (m *CounterTime) String() string            { return proto.CompactTextString(m) }
func (*CounterTime) ProtoMessage()               {}
func (*CounterTime) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{2} }

func (m *CounterTime) GetCount() uint32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

func (m *CounterTime) GetTimeNs() uint64 {
	if m != nil && m.TimeNs != nil {
		return *m.TimeNs
	}
	return 0
}

func (m *CounterTime) GetTimePercentage() uint32 {
	if m != nil && m.TimePercentage != nil {
		return *m.TimePercentage
	}
	return 0
}

func (m *CounterTime) GetPercentile() []*CounterPercentile {
	if m != nil {
		return m.Percentile
	}
	return nil
}

func (m *CounterTime) GetPercentileData() *CounterPercentileData {
	if m != nil {
		return m.PercentileData
	}
	return nil
}

type CounterTimeBidirectional struct {
	CountIn           *uint32                `protobuf:"varint,1,req,name=count_in,json=countIn" json:"count_in,omitempty"`
	CountOut          *uint32                `protobuf:"varint,2,req,name=count_out,json=countOut" json:"count_out,omitempty"`
	TimeNsIn          *uint64                `protobuf:"varint,3,req,name=time_ns_in,json=timeNsIn" json:"time_ns_in,omitempty"`
	TimeNsOut         *uint64                `protobuf:"varint,4,req,name=time_ns_out,json=timeNsOut" json:"time_ns_out,omitempty"`
	PercentileIn      []*CounterPercentile   `protobuf:"bytes,10,rep,name=percentile_in,json=percentileIn" json:"percentile_in,omitempty"`
	PercentileOut     []*CounterPercentile   `protobuf:"bytes,11,rep,name=percentile_out,json=percentileOut" json:"percentile_out,omitempty"`
	PercentileInData  *CounterPercentileData `protobuf:"bytes,12,opt,name=percentile_in_data,json=percentileInData" json:"percentile_in_data,omitempty"`
	PercentileOutData *CounterPercentileData `protobuf:"bytes,13,opt,name=percentile_out_data,json=percentileOutData" json:"percentile_out_data,omitempty"`
	XXX_unrecognized  []byte                 `json:"-"`
}

func (m *CounterTimeBidirectional) Reset()                    { *m = CounterTimeBidirectional{} }
func (m *CounterTimeBidirectional) String() string            { return proto.CompactTextString(m) }
func (*CounterTimeBidirectional) ProtoMessage()               {}
func (*CounterTimeBidirectional) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{3} }

func (m *CounterTimeBidirectional) GetCountIn() uint32 {
	if m != nil && m.CountIn != nil {
		return *m.CountIn
	}
	return 0
}

func (m *CounterTimeBidirectional) GetCountOut() uint32 {
	if m != nil && m.CountOut != nil {
		return *m.CountOut
	}
	return 0
}

func (m *CounterTimeBidirectional) GetTimeNsIn() uint64 {
	if m != nil && m.TimeNsIn != nil {
		return *m.TimeNsIn
	}
	return 0
}

func (m *CounterTimeBidirectional) GetTimeNsOut() uint64 {
	if m != nil && m.TimeNsOut != nil {
		return *m.TimeNsOut
	}
	return 0
}

func (m *CounterTimeBidirectional) GetPercentileIn() []*CounterPercentile {
	if m != nil {
		return m.PercentileIn
	}
	return nil
}

func (m *CounterTimeBidirectional) GetPercentileOut() []*CounterPercentile {
	if m != nil {
		return m.PercentileOut
	}
	return nil
}

func (m *CounterTimeBidirectional) GetPercentileInData() *CounterPercentileData {
	if m != nil {
		return m.PercentileInData
	}
	return nil
}

func (m *CounterTimeBidirectional) GetPercentileOutData() *CounterPercentileData {
	if m != nil {
		return m.PercentileOutData
	}
	return nil
}

type CounterBytes struct {
	CountIn          *uint32 `protobuf:"varint,1,req,name=count_in,json=countIn" json:"count_in,omitempty"`
	CountOut         *uint32 `protobuf:"varint,2,req,name=count_out,json=countOut" json:"count_out,omitempty"`
	BytesIn          *uint32 `protobuf:"varint,3,req,name=bytes_in,json=bytesIn" json:"bytes_in,omitempty"`
	BytesOut         *uint32 `protobuf:"varint,4,req,name=bytes_out,json=bytesOut" json:"bytes_out,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *CounterBytes) Reset()                    { *m = CounterBytes{} }
func (m *CounterBytes) String() string            { return proto.CompactTextString(m) }
func (*CounterBytes) ProtoMessage()               {}
func (*CounterBytes) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{4} }

func (m *CounterBytes) GetCountIn() uint32 {
	if m != nil && m.CountIn != nil {
		return *m.CountIn
	}
	return 0
}

func (m *CounterBytes) GetCountOut() uint32 {
	if m != nil && m.CountOut != nil {
		return *m.CountOut
	}
	return 0
}

func (m *CounterBytes) GetBytesIn() uint32 {
	if m != nil && m.BytesIn != nil {
		return *m.BytesIn
	}
	return 0
}

func (m *CounterBytes) GetBytesOut() uint32 {
	if m != nil && m.BytesOut != nil {
		return *m.BytesOut
	}
	return 0
}

type CounterTimeBytes struct {
	TimeNsIn            *uint64                `protobuf:"varint,1,req,name=time_ns_in,json=timeNsIn" json:"time_ns_in,omitempty"`
	TimeNsOut           *uint64                `protobuf:"varint,2,req,name=time_ns_out,json=timeNsOut" json:"time_ns_out,omitempty"`
	TimeNsOther         *uint64                `protobuf:"varint,3,req,name=time_ns_other,json=timeNsOther" json:"time_ns_other,omitempty"`
	CountIn             *uint32                `protobuf:"varint,4,req,name=count_in,json=countIn" json:"count_in,omitempty"`
	CountOut            *uint32                `protobuf:"varint,5,req,name=count_out,json=countOut" json:"count_out,omitempty"`
	CountOther          *uint32                `protobuf:"varint,6,req,name=count_other,json=countOther" json:"count_other,omitempty"`
	BytesIn             *uint32                `protobuf:"varint,7,req,name=bytes_in,json=bytesIn" json:"bytes_in,omitempty"`
	BytesOut            *uint32                `protobuf:"varint,8,req,name=bytes_out,json=bytesOut" json:"bytes_out,omitempty"`
	BytesOther          *uint32                `protobuf:"varint,9,req,name=bytes_other,json=bytesOther" json:"bytes_other,omitempty"`
	TimePercentageIn    *uint32                `protobuf:"varint,10,opt,name=time_percentage_in,json=timePercentageIn" json:"time_percentage_in,omitempty"`
	TimePercentageOut   *uint32                `protobuf:"varint,11,opt,name=time_percentage_out,json=timePercentageOut" json:"time_percentage_out,omitempty"`
	TimePercentageOther *uint32                `protobuf:"varint,12,opt,name=time_percentage_other,json=timePercentageOther" json:"time_percentage_other,omitempty"`
	PercentileIn        []*CounterPercentile   `protobuf:"bytes,26,rep,name=percentile_in,json=percentileIn" json:"percentile_in,omitempty"`
	PercentileOut       []*CounterPercentile   `protobuf:"bytes,27,rep,name=percentile_out,json=percentileOut" json:"percentile_out,omitempty"`
	PercentileInData    *CounterPercentileData `protobuf:"bytes,28,opt,name=percentile_in_data,json=percentileInData" json:"percentile_in_data,omitempty"`
	PercentileOutData   *CounterPercentileData `protobuf:"bytes,29,opt,name=percentile_out_data,json=percentileOutData" json:"percentile_out_data,omitempty"`
	XXX_unrecognized    []byte                 `json:"-"`
}

func (m *CounterTimeBytes) Reset()                    { *m = CounterTimeBytes{} }
func (m *CounterTimeBytes) String() string            { return proto.CompactTextString(m) }
func (*CounterTimeBytes) ProtoMessage()               {}
func (*CounterTimeBytes) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{5} }

func (m *CounterTimeBytes) GetTimeNsIn() uint64 {
	if m != nil && m.TimeNsIn != nil {
		return *m.TimeNsIn
	}
	return 0
}

func (m *CounterTimeBytes) GetTimeNsOut() uint64 {
	if m != nil && m.TimeNsOut != nil {
		return *m.TimeNsOut
	}
	return 0
}

func (m *CounterTimeBytes) GetTimeNsOther() uint64 {
	if m != nil && m.TimeNsOther != nil {
		return *m.TimeNsOther
	}
	return 0
}

func (m *CounterTimeBytes) GetCountIn() uint32 {
	if m != nil && m.CountIn != nil {
		return *m.CountIn
	}
	return 0
}

func (m *CounterTimeBytes) GetCountOut() uint32 {
	if m != nil && m.CountOut != nil {
		return *m.CountOut
	}
	return 0
}

func (m *CounterTimeBytes) GetCountOther() uint32 {
	if m != nil && m.CountOther != nil {
		return *m.CountOther
	}
	return 0
}

func (m *CounterTimeBytes) GetBytesIn() uint32 {
	if m != nil && m.BytesIn != nil {
		return *m.BytesIn
	}
	return 0
}

func (m *CounterTimeBytes) GetBytesOut() uint32 {
	if m != nil && m.BytesOut != nil {
		return *m.BytesOut
	}
	return 0
}

func (m *CounterTimeBytes) GetBytesOther() uint32 {
	if m != nil && m.BytesOther != nil {
		return *m.BytesOther
	}
	return 0
}

func (m *CounterTimeBytes) GetTimePercentageIn() uint32 {
	if m != nil && m.TimePercentageIn != nil {
		return *m.TimePercentageIn
	}
	return 0
}

func (m *CounterTimeBytes) GetTimePercentageOut() uint32 {
	if m != nil && m.TimePercentageOut != nil {
		return *m.TimePercentageOut
	}
	return 0
}

func (m *CounterTimeBytes) GetTimePercentageOther() uint32 {
	if m != nil && m.TimePercentageOther != nil {
		return *m.TimePercentageOther
	}
	return 0
}

func (m *CounterTimeBytes) GetPercentileIn() []*CounterPercentile {
	if m != nil {
		return m.PercentileIn
	}
	return nil
}

func (m *CounterTimeBytes) GetPercentileOut() []*CounterPercentile {
	if m != nil {
		return m.PercentileOut
	}
	return nil
}

func (m *CounterTimeBytes) GetPercentileInData() *CounterPercentileData {
	if m != nil {
		return m.PercentileInData
	}
	return nil
}

func (m *CounterTimeBytes) GetPercentileOutData() *CounterPercentileData {
	if m != nil {
		return m.PercentileOutData
	}
	return nil
}

type TimeCategories struct {
	Unknown          *CounterTime      `protobuf:"bytes,1,opt,name=unknown" json:"unknown,omitempty"`
	Other            *CounterTime      `protobuf:"bytes,2,opt,name=other" json:"other,omitempty"`
	File             *CounterTime      `protobuf:"bytes,3,opt,name=file" json:"file,omitempty"`
	Net              *CounterTime      `protobuf:"bytes,4,opt,name=net" json:"net,omitempty"`
	Ipc              *CounterTime      `protobuf:"bytes,5,opt,name=ipc" json:"ipc,omitempty"`
	Memory           *CounterTime      `protobuf:"bytes,6,opt,name=memory" json:"memory,omitempty"`
	Process          *CounterTime      `protobuf:"bytes,7,opt,name=process" json:"process,omitempty"`
	Sleep            *CounterTime      `protobuf:"bytes,8,opt,name=sleep" json:"sleep,omitempty"`
	System           *CounterTime      `protobuf:"bytes,9,opt,name=system" json:"system,omitempty"`
	Signal           *CounterTime      `protobuf:"bytes,10,opt,name=signal" json:"signal,omitempty"`
	User             *CounterTime      `protobuf:"bytes,11,opt,name=user" json:"user,omitempty"`
	Time             *CounterTime      `protobuf:"bytes,12,opt,name=time" json:"time,omitempty"`
	IoFile           *CounterTimeBytes `protobuf:"bytes,13,opt,name=io_file,json=ioFile" json:"io_file,omitempty"`
	IoNet            *CounterTimeBytes `protobuf:"bytes,14,opt,name=io_net,json=ioNet" json:"io_net,omitempty"`
	IoOther          *CounterTimeBytes `protobuf:"bytes,15,opt,name=io_other,json=ioOther" json:"io_other,omitempty"`
	Wait             *CounterTime      `protobuf:"bytes,16,opt,name=wait" json:"wait,omitempty"`
	Processing       *CounterTime      `protobuf:"bytes,17,opt,name=processing" json:"processing,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *TimeCategories) Reset()                    { *m = TimeCategories{} }
func (m *TimeCategories) String() string            { return proto.CompactTextString(m) }
func (*TimeCategories) ProtoMessage()               {}
func (*TimeCategories) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{6} }

func (m *TimeCategories) GetUnknown() *CounterTime {
	if m != nil {
		return m.Unknown
	}
	return nil
}

func (m *TimeCategories) GetOther() *CounterTime {
	if m != nil {
		return m.Other
	}
	return nil
}

func (m *TimeCategories) GetFile() *CounterTime {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *TimeCategories) GetNet() *CounterTime {
	if m != nil {
		return m.Net
	}
	return nil
}

func (m *TimeCategories) GetIpc() *CounterTime {
	if m != nil {
		return m.Ipc
	}
	return nil
}

func (m *TimeCategories) GetMemory() *CounterTime {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *TimeCategories) GetProcess() *CounterTime {
	if m != nil {
		return m.Process
	}
	return nil
}

func (m *TimeCategories) GetSleep() *CounterTime {
	if m != nil {
		return m.Sleep
	}
	return nil
}

func (m *TimeCategories) GetSystem() *CounterTime {
	if m != nil {
		return m.System
	}
	return nil
}

func (m *TimeCategories) GetSignal() *CounterTime {
	if m != nil {
		return m.Signal
	}
	return nil
}

func (m *TimeCategories) GetUser() *CounterTime {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *TimeCategories) GetTime() *CounterTime {
	if m != nil {
		return m.Time
	}
	return nil
}

func (m *TimeCategories) GetIoFile() *CounterTimeBytes {
	if m != nil {
		return m.IoFile
	}
	return nil
}

func (m *TimeCategories) GetIoNet() *CounterTimeBytes {
	if m != nil {
		return m.IoNet
	}
	return nil
}

func (m *TimeCategories) GetIoOther() *CounterTimeBytes {
	if m != nil {
		return m.IoOther
	}
	return nil
}

func (m *TimeCategories) GetWait() *CounterTime {
	if m != nil {
		return m.Wait
	}
	return nil
}

func (m *TimeCategories) GetProcessing() *CounterTime {
	if m != nil {
		return m.Processing
	}
	return nil
}

//
// Stores how time is spent serving requests by the host
//
type TransactionBreakdownCategories struct {
	Other            *CounterTime      `protobuf:"bytes,2,opt,name=other" json:"other,omitempty"`
	IoFile           *CounterTimeBytes `protobuf:"bytes,13,opt,name=io_file,json=ioFile" json:"io_file,omitempty"`
	IoNet            *CounterTimeBytes `protobuf:"bytes,14,opt,name=io_net,json=ioNet" json:"io_net,omitempty"`
	Processing       *CounterTime      `protobuf:"bytes,17,opt,name=processing" json:"processing,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *TransactionBreakdownCategories) Reset()         { *m = TransactionBreakdownCategories{} }
func (m *TransactionBreakdownCategories) String() string { return proto.CompactTextString(m) }
func (*TransactionBreakdownCategories) ProtoMessage()    {}
func (*TransactionBreakdownCategories) Descriptor() ([]byte, []int) {
	return fileDescriptorDraios, []int{7}
}

func (m *TransactionBreakdownCategories) GetOther() *CounterTime {
	if m != nil {
		return m.Other
	}
	return nil
}

func (m *TransactionBreakdownCategories) GetIoFile() *CounterTimeBytes {
	if m != nil {
		return m.IoFile
	}
	return nil
}

func (m *TransactionBreakdownCategories) GetIoNet() *CounterTimeBytes {
	if m != nil {
		return m.IoNet
	}
	return nil
}

func (m *TransactionBreakdownCategories) GetProcessing() *CounterTime {
	if m != nil {
		return m.Processing
	}
	return nil
}

type CounterSyscallErrors struct {
	Count            *uint32  `protobuf:"varint,1,req,name=count" json:"count,omitempty"`
	TopErrorCodes    []uint32 `protobuf:"varint,2,rep,name=top_error_codes,json=topErrorCodes" json:"top_error_codes,omitempty"`
	CountFile        *uint32  `protobuf:"varint,4,opt,name=count_file,json=countFile" json:"count_file,omitempty"`
	CountFileOpen    *uint32  `protobuf:"varint,5,opt,name=count_file_open,json=countFileOpen" json:"count_file_open,omitempty"`
	CountNet         *uint32  `protobuf:"varint,6,opt,name=count_net,json=countNet" json:"count_net,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *CounterSyscallErrors) Reset()                    { *m = CounterSyscallErrors{} }
func (m *CounterSyscallErrors) String() string            { return proto.CompactTextString(m) }
func (*CounterSyscallErrors) ProtoMessage()               {}
func (*CounterSyscallErrors) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{8} }

func (m *CounterSyscallErrors) GetCount() uint32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

func (m *CounterSyscallErrors) GetTopErrorCodes() []uint32 {
	if m != nil {
		return m.TopErrorCodes
	}
	return nil
}

func (m *CounterSyscallErrors) GetCountFile() uint32 {
	if m != nil && m.CountFile != nil {
		return *m.CountFile
	}
	return 0
}

func (m *CounterSyscallErrors) GetCountFileOpen() uint32 {
	if m != nil && m.CountFileOpen != nil {
		return *m.CountFileOpen
	}
	return 0
}

func (m *CounterSyscallErrors) GetCountNet() uint32 {
	if m != nil && m.CountNet != nil {
		return *m.CountNet
	}
	return 0
}

type ResourceCategories struct {
	CapacityScore           *uint32 `protobuf:"varint,1,opt,name=capacity_score,json=capacityScore" json:"capacity_score,omitempty"`
	StolenCapacityScore     *uint32 `protobuf:"varint,6,opt,name=stolen_capacity_score,json=stolenCapacityScore" json:"stolen_capacity_score,omitempty"`
	ConnectionQueueUsagePct *uint32 `protobuf:"varint,2,opt,name=connection_queue_usage_pct,json=connectionQueueUsagePct" json:"connection_queue_usage_pct,omitempty"`
	FdUsagePct              *uint32 `protobuf:"varint,3,opt,name=fd_usage_pct,json=fdUsagePct" json:"fd_usage_pct,omitempty"`
	CpuPct                  *uint32 `protobuf:"varint,4,opt,name=cpu_pct,json=cpuPct" json:"cpu_pct,omitempty"`
	ResidentMemoryUsageKb   *uint32 `protobuf:"varint,5,opt,name=resident_memory_usage_kb,json=residentMemoryUsageKb" json:"resident_memory_usage_kb,omitempty"`
	VirtualMemoryUsageKb    *uint32 `protobuf:"varint,13,opt,name=virtual_memory_usage_kb,json=virtualMemoryUsageKb" json:"virtual_memory_usage_kb,omitempty"`
	SwapMemoryUsageKb       *uint32 `protobuf:"varint,14,opt,name=swap_memory_usage_kb,json=swapMemoryUsageKb" json:"swap_memory_usage_kb,omitempty"`
	MajorPagefaults         *uint64 `protobuf:"varint,15,opt,name=major_pagefaults,json=majorPagefaults" json:"major_pagefaults,omitempty"`
	MinorPagefaults         *uint64 `protobuf:"varint,16,opt,name=minor_pagefaults,json=minorPagefaults" json:"minor_pagefaults,omitempty"`
	FdCount                 *uint32 `protobuf:"varint,21,opt,name=fd_count,json=fdCount" json:"fd_count,omitempty"`
	CpuShares               *uint32 `protobuf:"varint,24,opt,name=cpu_shares,json=cpuShares" json:"cpu_shares,omitempty"`
	CpuSharesUsagePct       *uint32 `protobuf:"varint,25,opt,name=cpu_shares_usage_pct,json=cpuSharesUsagePct" json:"cpu_shares_usage_pct,omitempty"`
	MemoryLimitKb           *uint32 `protobuf:"varint,26,opt,name=memory_limit_kb,json=memoryLimitKb" json:"memory_limit_kb,omitempty"`
	SwapLimitKb             *uint32 `protobuf:"varint,27,opt,name=swap_limit_kb,json=swapLimitKb" json:"swap_limit_kb,omitempty"`
	CpuQuotaUsedPct         *uint32 `protobuf:"varint,28,opt,name=cpu_quota_used_pct,json=cpuQuotaUsedPct" json:"cpu_quota_used_pct,omitempty"`
	SwapMemoryTotalKb       *uint32 `protobuf:"varint,29,opt,name=swap_memory_total_kb,json=swapMemoryTotalKb" json:"swap_memory_total_kb,omitempty"`
	SwapMemoryAvailableKb   *uint32 `protobuf:"varint,30,opt,name=swap_memory_available_kb,json=swapMemoryAvailableKb" json:"swap_memory_available_kb,omitempty"`
	CountProcesses          *uint64 `protobuf:"varint,31,opt,name=count_processes,json=countProcesses" json:"count_processes,omitempty"`
	ProcStartCount          *uint64 `protobuf:"varint,32,opt,name=proc_start_count,json=procStartCount" json:"proc_start_count,omitempty"`
	JmxSent                 *uint64 `protobuf:"varint,33,opt,name=jmx_sent,json=jmxSent" json:"jmx_sent,omitempty"`
	JmxTotal                *uint64 `protobuf:"varint,34,opt,name=jmx_total,json=jmxTotal" json:"jmx_total,omitempty"`
	StatsdSent              *uint64 `protobuf:"varint,35,opt,name=statsd_sent,json=statsdSent" json:"statsd_sent,omitempty"`
	StatsdTotal             *uint64 `protobuf:"varint,36,opt,name=statsd_total,json=statsdTotal" json:"statsd_total,omitempty"`
	AppChecksSent           *uint64 `protobuf:"varint,37,opt,name=app_checks_sent,json=appChecksSent" json:"app_checks_sent,omitempty"`
	AppChecksTotal          *uint64 `protobuf:"varint,38,opt,name=app_checks_total,json=appChecksTotal" json:"app_checks_total,omitempty"`
	ThreadsCount            *uint64 `protobuf:"varint,39,opt,name=threads_count,json=threadsCount" json:"threads_count,omitempty"`
	PrometheusSent          *uint64 `protobuf:"varint,40,opt,name=prometheus_sent,json=prometheusSent" json:"prometheus_sent,omitempty"`
	PrometheusTotal         *uint64 `protobuf:"varint,41,opt,name=prometheus_total,json=prometheusTotal" json:"prometheus_total,omitempty"`
	XXX_unrecognized        []byte  `json:"-"`
}

func (m *ResourceCategories) Reset()                    { *m = ResourceCategories{} }
func (m *ResourceCategories) String() string            { return proto.CompactTextString(m) }
func (*ResourceCategories) ProtoMessage()               {}
func (*ResourceCategories) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{9} }

func (m *ResourceCategories) GetCapacityScore() uint32 {
	if m != nil && m.CapacityScore != nil {
		return *m.CapacityScore
	}
	return 0
}

func (m *ResourceCategories) GetStolenCapacityScore() uint32 {
	if m != nil && m.StolenCapacityScore != nil {
		return *m.StolenCapacityScore
	}
	return 0
}

func (m *ResourceCategories) GetConnectionQueueUsagePct() uint32 {
	if m != nil && m.ConnectionQueueUsagePct != nil {
		return *m.ConnectionQueueUsagePct
	}
	return 0
}

func (m *ResourceCategories) GetFdUsagePct() uint32 {
	if m != nil && m.FdUsagePct != nil {
		return *m.FdUsagePct
	}
	return 0
}

func (m *ResourceCategories) GetCpuPct() uint32 {
	if m != nil && m.CpuPct != nil {
		return *m.CpuPct
	}
	return 0
}

func (m *ResourceCategories) GetResidentMemoryUsageKb() uint32 {
	if m != nil && m.ResidentMemoryUsageKb != nil {
		return *m.ResidentMemoryUsageKb
	}
	return 0
}

func (m *ResourceCategories) GetVirtualMemoryUsageKb() uint32 {
	if m != nil && m.VirtualMemoryUsageKb != nil {
		return *m.VirtualMemoryUsageKb
	}
	return 0
}

func (m *ResourceCategories) GetSwapMemoryUsageKb() uint32 {
	if m != nil && m.SwapMemoryUsageKb != nil {
		return *m.SwapMemoryUsageKb
	}
	return 0
}

func (m *ResourceCategories) GetMajorPagefaults() uint64 {
	if m != nil && m.MajorPagefaults != nil {
		return *m.MajorPagefaults
	}
	return 0
}

func (m *ResourceCategories) GetMinorPagefaults() uint64 {
	if m != nil && m.MinorPagefaults != nil {
		return *m.MinorPagefaults
	}
	return 0
}

func (m *ResourceCategories) GetFdCount() uint32 {
	if m != nil && m.FdCount != nil {
		return *m.FdCount
	}
	return 0
}

func (m *ResourceCategories) GetCpuShares() uint32 {
	if m != nil && m.CpuShares != nil {
		return *m.CpuShares
	}
	return 0
}

func (m *ResourceCategories) GetCpuSharesUsagePct() uint32 {
	if m != nil && m.CpuSharesUsagePct != nil {
		return *m.CpuSharesUsagePct
	}
	return 0
}

func (m *ResourceCategories) GetMemoryLimitKb() uint32 {
	if m != nil && m.MemoryLimitKb != nil {
		return *m.MemoryLimitKb
	}
	return 0
}

func (m *ResourceCategories) GetSwapLimitKb() uint32 {
	if m != nil && m.SwapLimitKb != nil {
		return *m.SwapLimitKb
	}
	return 0
}

func (m *ResourceCategories) GetCpuQuotaUsedPct() uint32 {
	if m != nil && m.CpuQuotaUsedPct != nil {
		return *m.CpuQuotaUsedPct
	}
	return 0
}

func (m *ResourceCategories) GetSwapMemoryTotalKb() uint32 {
	if m != nil && m.SwapMemoryTotalKb != nil {
		return *m.SwapMemoryTotalKb
	}
	return 0
}

func (m *ResourceCategories) GetSwapMemoryAvailableKb() uint32 {
	if m != nil && m.SwapMemoryAvailableKb != nil {
		return *m.SwapMemoryAvailableKb
	}
	return 0
}

func (m *ResourceCategories) GetCountProcesses() uint64 {
	if m != nil && m.CountProcesses != nil {
		return *m.CountProcesses
	}
	return 0
}

func (m *ResourceCategories) GetProcStartCount() uint64 {
	if m != nil && m.ProcStartCount != nil {
		return *m.ProcStartCount
	}
	return 0
}

func (m *ResourceCategories) GetJmxSent() uint64 {
	if m != nil && m.JmxSent != nil {
		return *m.JmxSent
	}
	return 0
}

func (m *ResourceCategories) GetJmxTotal() uint64 {
	if m != nil && m.JmxTotal != nil {
		return *m.JmxTotal
	}
	return 0
}

func (m *ResourceCategories) GetStatsdSent() uint64 {
	if m != nil && m.StatsdSent != nil {
		return *m.StatsdSent
	}
	return 0
}

func (m *ResourceCategories) GetStatsdTotal() uint64 {
	if m != nil && m.StatsdTotal != nil {
		return *m.StatsdTotal
	}
	return 0
}

func (m *ResourceCategories) GetAppChecksSent() uint64 {
	if m != nil && m.AppChecksSent != nil {
		return *m.AppChecksSent
	}
	return 0
}

func (m *ResourceCategories) GetAppChecksTotal() uint64 {
	if m != nil && m.AppChecksTotal != nil {
		return *m.AppChecksTotal
	}
	return 0
}

func (m *ResourceCategories) GetThreadsCount() uint64 {
	if m != nil && m.ThreadsCount != nil {
		return *m.ThreadsCount
	}
	return 0
}

func (m *ResourceCategories) GetPrometheusSent() uint64 {
	if m != nil && m.PrometheusSent != nil {
		return *m.PrometheusSent
	}
	return 0
}

func (m *ResourceCategories) GetPrometheusTotal() uint64 {
	if m != nil && m.PrometheusTotal != nil {
		return *m.PrometheusTotal
	}
	return 0
}

type ConnectionCategories struct {
	Server                 *CounterBytes             `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	Client                 *CounterBytes             `protobuf:"bytes,2,opt,name=client" json:"client,omitempty"`
	TransactionCounters    *CounterTimeBidirectional `protobuf:"bytes,3,opt,name=transaction_counters,json=transactionCounters" json:"transaction_counters,omitempty"`
	MaxTransactionCounters *CounterTimeBidirectional `protobuf:"bytes,19,opt,name=max_transaction_counters,json=maxTransactionCounters" json:"max_transaction_counters,omitempty"`
	NAggregatedConnections *uint32                   `protobuf:"varint,4,opt,name=n_aggregated_connections,json=nAggregatedConnections" json:"n_aggregated_connections,omitempty"`
	XXX_unrecognized       []byte                    `json:"-"`
}

func (m *ConnectionCategories) Reset()                    { *m = ConnectionCategories{} }
func (m *ConnectionCategories) String() string            { return proto.CompactTextString(m) }
func (*ConnectionCategories) ProtoMessage()               {}
func (*ConnectionCategories) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{10} }

func (m *ConnectionCategories) GetServer() *CounterBytes {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *ConnectionCategories) GetClient() *CounterBytes {
	if m != nil {
		return m.Client
	}
	return nil
}

func (m *ConnectionCategories) GetTransactionCounters() *CounterTimeBidirectional {
	if m != nil {
		return m.TransactionCounters
	}
	return nil
}

func (m *ConnectionCategories) GetMaxTransactionCounters() *CounterTimeBidirectional {
	if m != nil {
		return m.MaxTransactionCounters
	}
	return nil
}

func (m *ConnectionCategories) GetNAggregatedConnections() uint32 {
	if m != nil && m.NAggregatedConnections != nil {
		return *m.NAggregatedConnections
	}
	return 0
}

type ProcessDetails struct {
	Comm             *string  `protobuf:"bytes,1,req,name=comm" json:"comm,omitempty"`
	Exe              *string  `protobuf:"bytes,2,req,name=exe" json:"exe,omitempty"`
	Args             []string `protobuf:"bytes,3,rep,name=args" json:"args,omitempty"`
	ContainerId      *string  `protobuf:"bytes,4,opt,name=container_id,json=containerId" json:"container_id,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ProcessDetails) Reset()                    { *m = ProcessDetails{} }
func (m *ProcessDetails) String() string            { return proto.CompactTextString(m) }
func (*ProcessDetails) ProtoMessage()               {}
func (*ProcessDetails) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{11} }

func (m *ProcessDetails) GetComm() string {
	if m != nil && m.Comm != nil {
		return *m.Comm
	}
	return ""
}

func (m *ProcessDetails) GetExe() string {
	if m != nil && m.Exe != nil {
		return *m.Exe
	}
	return ""
}

func (m *ProcessDetails) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *ProcessDetails) GetContainerId() string {
	if m != nil && m.ContainerId != nil {
		return *m.ContainerId
	}
	return ""
}

//
// Description of a command executed on the machine
//
type CommandDetails struct {
	Timestamp          *uint64 `protobuf:"varint,1,req,name=timestamp" json:"timestamp,omitempty"`
	Count              *uint32 `protobuf:"varint,2,opt,name=count" json:"count,omitempty"`
	Cmdline            *string `protobuf:"bytes,3,req,name=cmdline" json:"cmdline,omitempty"`
	Comm               *string `protobuf:"bytes,4,req,name=comm" json:"comm,omitempty"`
	Pid                *uint64 `protobuf:"varint,5,req,name=pid" json:"pid,omitempty"`
	Ppid               *uint64 `protobuf:"varint,6,req,name=ppid" json:"ppid,omitempty"`
	Uid                *uint64 `protobuf:"varint,7,req,name=uid" json:"uid,omitempty"`
	Cwd                *string `protobuf:"bytes,8,opt,name=cwd" json:"cwd,omitempty"`
	LoginShellId       *uint64 `protobuf:"varint,9,opt,name=login_shell_id,json=loginShellId" json:"login_shell_id,omitempty"`
	LoginShellDistance *uint32 `protobuf:"varint,10,opt,name=login_shell_distance,json=loginShellDistance" json:"login_shell_distance,omitempty"`
	Tty                *uint32 `protobuf:"varint,11,opt,name=tty" json:"tty,omitempty"`
	XXX_unrecognized   []byte  `json:"-"`
}

func (m *CommandDetails) Reset()                    { *m = CommandDetails{} }
func (m *CommandDetails) String() string            { return proto.CompactTextString(m) }
func (*CommandDetails) ProtoMessage()               {}
func (*CommandDetails) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{12} }

func (m *CommandDetails) GetTimestamp() uint64 {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return 0
}

func (m *CommandDetails) GetCount() uint32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

func (m *CommandDetails) GetCmdline() string {
	if m != nil && m.Cmdline != nil {
		return *m.Cmdline
	}
	return ""
}

func (m *CommandDetails) GetComm() string {
	if m != nil && m.Comm != nil {
		return *m.Comm
	}
	return ""
}

func (m *CommandDetails) GetPid() uint64 {
	if m != nil && m.Pid != nil {
		return *m.Pid
	}
	return 0
}

func (m *CommandDetails) GetPpid() uint64 {
	if m != nil && m.Ppid != nil {
		return *m.Ppid
	}
	return 0
}

func (m *CommandDetails) GetUid() uint64 {
	if m != nil && m.Uid != nil {
		return *m.Uid
	}
	return 0
}

func (m *CommandDetails) GetCwd() string {
	if m != nil && m.Cwd != nil {
		return *m.Cwd
	}
	return ""
}

func (m *CommandDetails) GetLoginShellId() uint64 {
	if m != nil && m.LoginShellId != nil {
		return *m.LoginShellId
	}
	return 0
}

func (m *CommandDetails) GetLoginShellDistance() uint32 {
	if m != nil && m.LoginShellDistance != nil {
		return *m.LoginShellDistance
	}
	return 0
}

func (m *CommandDetails) GetTty() uint32 {
	if m != nil && m.Tty != nil {
		return *m.Tty
	}
	return 0
}

//
// Counters for a protocol-related dimension, like a URL or a query
//
type CounterProtoEntry struct {
	Ncalls           *uint32                `protobuf:"varint,1,req,name=ncalls" json:"ncalls,omitempty"`
	TimeTot          *uint64                `protobuf:"varint,2,req,name=time_tot,json=timeTot" json:"time_tot,omitempty"`
	TimeMax          *uint64                `protobuf:"varint,3,req,name=time_max,json=timeMax" json:"time_max,omitempty"`
	BytesIn          *uint64                `protobuf:"varint,4,req,name=bytes_in,json=bytesIn" json:"bytes_in,omitempty"`
	BytesOut         *uint64                `protobuf:"varint,5,req,name=bytes_out,json=bytesOut" json:"bytes_out,omitempty"`
	Nerrors          *uint32                `protobuf:"varint,6,req,name=nerrors" json:"nerrors,omitempty"`
	Percentile       []*CounterPercentile   `protobuf:"bytes,13,rep,name=percentile" json:"percentile,omitempty"`
	PercentileData   *CounterPercentileData `protobuf:"bytes,14,opt,name=percentile_data,json=percentileData" json:"percentile_data,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *CounterProtoEntry) Reset()                    { *m = CounterProtoEntry{} }
func (m *CounterProtoEntry) String() string            { return proto.CompactTextString(m) }
func (*CounterProtoEntry) ProtoMessage()               {}
func (*CounterProtoEntry) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{13} }

func (m *CounterProtoEntry) GetNcalls() uint32 {
	if m != nil && m.Ncalls != nil {
		return *m.Ncalls
	}
	return 0
}

func (m *CounterProtoEntry) GetTimeTot() uint64 {
	if m != nil && m.TimeTot != nil {
		return *m.TimeTot
	}
	return 0
}

func (m *CounterProtoEntry) GetTimeMax() uint64 {
	if m != nil && m.TimeMax != nil {
		return *m.TimeMax
	}
	return 0
}

func (m *CounterProtoEntry) GetBytesIn() uint64 {
	if m != nil && m.BytesIn != nil {
		return *m.BytesIn
	}
	return 0
}

func (m *CounterProtoEntry) GetBytesOut() uint64 {
	if m != nil && m.BytesOut != nil {
		return *m.BytesOut
	}
	return 0
}

func (m *CounterProtoEntry) GetNerrors() uint32 {
	if m != nil && m.Nerrors != nil {
		return *m.Nerrors
	}
	return 0
}

func (m *CounterProtoEntry) GetPercentile() []*CounterPercentile {
	if m != nil {
		return m.Percentile
	}
	return nil
}

func (m *CounterProtoEntry) GetPercentileData() *CounterPercentileData {
	if m != nil {
		return m.PercentileData
	}
	return nil
}

//
// URL information
//
type UrlDetails struct {
	//
	// The URL, in the following format "TYPEADDR<:PORT>/PATH", e.g. "p172.16.189.128:9000/api/data".
	// Note: possible values foy type are:
	//   n for NONE
	//   g for GET
	//   p for POST
	//   o for OPTIONS
	//   h for HEAD
	//   P for PUT
	//   d for DELETE
	//   t for TRACE
	//   c for CONNECT
	//
	Url              *string            `protobuf:"bytes,1,req,name=url" json:"url,omitempty"`
	Counters         *CounterProtoEntry `protobuf:"bytes,2,req,name=counters" json:"counters,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *UrlDetails) Reset()                    { *m = UrlDetails{} }
func (m *UrlDetails) String() string            { return proto.CompactTextString(m) }
func (*UrlDetails) ProtoMessage()               {}
func (*UrlDetails) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{14} }

func (m *UrlDetails) GetUrl() string {
	if m != nil && m.Url != nil {
		return *m.Url
	}
	return ""
}

func (m *UrlDetails) GetCounters() *CounterProtoEntry {
	if m != nil {
		return m.Counters
	}
	return nil
}

type StatusCodeDetails struct {
	StatusCode       *uint32 `protobuf:"varint,1,req,name=status_code,json=statusCode" json:"status_code,omitempty"`
	Ncalls           *uint32 `protobuf:"varint,2,req,name=ncalls" json:"ncalls,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *StatusCodeDetails) Reset()                    { *m = StatusCodeDetails{} }
func (m *StatusCodeDetails) String() string            { return proto.CompactTextString(m) }
func (*StatusCodeDetails) ProtoMessage()               {}
func (*StatusCodeDetails) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{15} }

func (m *StatusCodeDetails) GetStatusCode() uint32 {
	if m != nil && m.StatusCode != nil {
		return *m.StatusCode
	}
	return 0
}

func (m *StatusCodeDetails) GetNcalls() uint32 {
	if m != nil && m.Ncalls != nil {
		return *m.Ncalls
	}
	return 0
}

//
// HTTP protocol information
//
type HttpInfo struct {
	ServerUrls        []*UrlDetails        `protobuf:"bytes,1,rep,name=server_urls,json=serverUrls" json:"server_urls,omitempty"`
	ClientUrls        []*UrlDetails        `protobuf:"bytes,2,rep,name=client_urls,json=clientUrls" json:"client_urls,omitempty"`
	ClientStatusCodes []*StatusCodeDetails `protobuf:"bytes,3,rep,name=client_status_codes,json=clientStatusCodes" json:"client_status_codes,omitempty"`
	ServerStatusCodes []*StatusCodeDetails `protobuf:"bytes,4,rep,name=server_status_codes,json=serverStatusCodes" json:"server_status_codes,omitempty"`
	XXX_unrecognized  []byte               `json:"-"`
}

func (m *HttpInfo) Reset()                    { *m = HttpInfo{} }
func (m *HttpInfo) String() string            { return proto.CompactTextString(m) }
func (*HttpInfo) ProtoMessage()               {}
func (*HttpInfo) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{16} }

func (m *HttpInfo) GetServerUrls() []*UrlDetails {
	if m != nil {
		return m.ServerUrls
	}
	return nil
}

func (m *HttpInfo) GetClientUrls() []*UrlDetails {
	if m != nil {
		return m.ClientUrls
	}
	return nil
}

func (m *HttpInfo) GetClientStatusCodes() []*StatusCodeDetails {
	if m != nil {
		return m.ClientStatusCodes
	}
	return nil
}

func (m *HttpInfo) GetServerStatusCodes() []*StatusCodeDetails {
	if m != nil {
		return m.ServerStatusCodes
	}
	return nil
}

//
// SQL query information
//
type SqlEntryDetails struct {
	Name             *string            `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Counters         *CounterProtoEntry `protobuf:"bytes,2,req,name=counters" json:"counters,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *SqlEntryDetails) Reset()                    { *m = SqlEntryDetails{} }
func (m *SqlEntryDetails) String() string            { return proto.CompactTextString(m) }
func (*SqlEntryDetails) ProtoMessage()               {}
func (*SqlEntryDetails) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{17} }

func (m *SqlEntryDetails) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *SqlEntryDetails) GetCounters() *CounterProtoEntry {
	if m != nil {
		return m.Counters
	}
	return nil
}

type SqlQueryTypeDetails struct {
	Type             *SqlStatementType  `protobuf:"varint,1,req,name=type,enum=draiosproto.SqlStatementType" json:"type,omitempty"`
	Counters         *CounterProtoEntry `protobuf:"bytes,2,req,name=counters" json:"counters,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *SqlQueryTypeDetails) Reset()                    { *m = SqlQueryTypeDetails{} }
func (m *SqlQueryTypeDetails) String() string            { return proto.CompactTextString(m) }
func (*SqlQueryTypeDetails) ProtoMessage()               {}
func (*SqlQueryTypeDetails) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{18} }

func (m *SqlQueryTypeDetails) GetType() SqlStatementType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return SqlStatementType_SOP_NONE
}

func (m *SqlQueryTypeDetails) GetCounters() *CounterProtoEntry {
	if m != nil {
		return m.Counters
	}
	return nil
}

//
// SQL protocol information
//
type SqlInfo struct {
	ServerQueries    []*SqlEntryDetails     `protobuf:"bytes,1,rep,name=server_queries,json=serverQueries" json:"server_queries,omitempty"`
	ClientQueries    []*SqlEntryDetails     `protobuf:"bytes,2,rep,name=client_queries,json=clientQueries" json:"client_queries,omitempty"`
	ServerQueryTypes []*SqlQueryTypeDetails `protobuf:"bytes,3,rep,name=server_query_types,json=serverQueryTypes" json:"server_query_types,omitempty"`
	ClientQueryTypes []*SqlQueryTypeDetails `protobuf:"bytes,4,rep,name=client_query_types,json=clientQueryTypes" json:"client_query_types,omitempty"`
	ServerTables     []*SqlEntryDetails     `protobuf:"bytes,5,rep,name=server_tables,json=serverTables" json:"server_tables,omitempty"`
	ClientTables     []*SqlEntryDetails     `protobuf:"bytes,6,rep,name=client_tables,json=clientTables" json:"client_tables,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *SqlInfo) Reset()                    { *m = SqlInfo{} }
func (m *SqlInfo) String() string            { return proto.CompactTextString(m) }
func (*SqlInfo) ProtoMessage()               {}
func (*SqlInfo) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{19} }

func (m *SqlInfo) GetServerQueries() []*SqlEntryDetails {
	if m != nil {
		return m.ServerQueries
	}
	return nil
}

func (m *SqlInfo) GetClientQueries() []*SqlEntryDetails {
	if m != nil {
		return m.ClientQueries
	}
	return nil
}

func (m *SqlInfo) GetServerQueryTypes() []*SqlQueryTypeDetails {
	if m != nil {
		return m.ServerQueryTypes
	}
	return nil
}

func (m *SqlInfo) GetClientQueryTypes() []*SqlQueryTypeDetails {
	if m != nil {
		return m.ClientQueryTypes
	}
	return nil
}

func (m *SqlInfo) GetServerTables() []*SqlEntryDetails {
	if m != nil {
		return m.ServerTables
	}
	return nil
}

func (m *SqlInfo) GetClientTables() []*SqlEntryDetails {
	if m != nil {
		return m.ClientTables
	}
	return nil
}

type MongodbCollectionDetails struct {
	Name             *string            `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Counters         *CounterProtoEntry `protobuf:"bytes,2,req,name=counters" json:"counters,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *MongodbCollectionDetails) Reset()                    { *m = MongodbCollectionDetails{} }
func (m *MongodbCollectionDetails) String() string            { return proto.CompactTextString(m) }
func (*MongodbCollectionDetails) ProtoMessage()               {}
func (*MongodbCollectionDetails) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{20} }

func (m *MongodbCollectionDetails) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *MongodbCollectionDetails) GetCounters() *CounterProtoEntry {
	if m != nil {
		return m.Counters
	}
	return nil
}

type MongodbOpTypeDetails struct {
	Op               *MongodbOpType     `protobuf:"varint,1,req,name=op,enum=draiosproto.MongodbOpType" json:"op,omitempty"`
	Counters         *CounterProtoEntry `protobuf:"bytes,2,req,name=counters" json:"counters,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *MongodbOpTypeDetails) Reset()                    { *m = MongodbOpTypeDetails{} }
func (m *MongodbOpTypeDetails) String() string            { return proto.CompactTextString(m) }
func (*MongodbOpTypeDetails) ProtoMessage()               {}
func (*MongodbOpTypeDetails) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{21} }

func (m *MongodbOpTypeDetails) GetOp() MongodbOpType {
	if m != nil && m.Op != nil {
		return *m.Op
	}
	return MongodbOpType_MONGODB_OP_NONE
}

func (m *MongodbOpTypeDetails) GetCounters() *CounterProtoEntry {
	if m != nil {
		return m.Counters
	}
	return nil
}

type MongodbInfo struct {
	ServersOps        []*MongodbOpTypeDetails     `protobuf:"bytes,1,rep,name=servers_ops,json=serversOps" json:"servers_ops,omitempty"`
	ClientOps         []*MongodbOpTypeDetails     `protobuf:"bytes,2,rep,name=client_ops,json=clientOps" json:"client_ops,omitempty"`
	ServerCollections []*MongodbCollectionDetails `protobuf:"bytes,3,rep,name=server_collections,json=serverCollections" json:"server_collections,omitempty"`
	ClientCollections []*MongodbCollectionDetails `protobuf:"bytes,4,rep,name=client_collections,json=clientCollections" json:"client_collections,omitempty"`
	XXX_unrecognized  []byte                      `json:"-"`
}

func (m *MongodbInfo) Reset()                    { *m = MongodbInfo{} }
func (m *MongodbInfo) String() string            { return proto.CompactTextString(m) }
func (*MongodbInfo) ProtoMessage()               {}
func (*MongodbInfo) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{22} }

func (m *MongodbInfo) GetServersOps() []*MongodbOpTypeDetails {
	if m != nil {
		return m.ServersOps
	}
	return nil
}

func (m *MongodbInfo) GetClientOps() []*MongodbOpTypeDetails {
	if m != nil {
		return m.ClientOps
	}
	return nil
}

func (m *MongodbInfo) GetServerCollections() []*MongodbCollectionDetails {
	if m != nil {
		return m.ServerCollections
	}
	return nil
}

func (m *MongodbInfo) GetClientCollections() []*MongodbCollectionDetails {
	if m != nil {
		return m.ClientCollections
	}
	return nil
}

type JmxAttribute struct {
	Name             *string         `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Value            *float64        `protobuf:"fixed64,2,opt,name=value" json:"value,omitempty"`
	Alias            *string         `protobuf:"bytes,5,opt,name=alias" json:"alias,omitempty"`
	Type             *JmxMetricType  `protobuf:"varint,7,opt,name=type,enum=draiosproto.JmxMetricType" json:"type,omitempty"`
	Unit             *Unit           `protobuf:"varint,8,opt,name=unit,enum=draiosproto.Unit" json:"unit,omitempty"`
	Scale            *Scale          `protobuf:"varint,9,opt,name=scale,enum=draiosproto.Scale" json:"scale,omitempty"`
	Subattributes    []*JmxAttribute `protobuf:"bytes,3,rep,name=subattributes" json:"subattributes,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *JmxAttribute) Reset()                    { *m = JmxAttribute{} }
func (m *JmxAttribute) String() string            { return proto.CompactTextString(m) }
func (*JmxAttribute) ProtoMessage()               {}
func (*JmxAttribute) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{23} }

func (m *JmxAttribute) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *JmxAttribute) GetValue() float64 {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return 0
}

func (m *JmxAttribute) GetAlias() string {
	if m != nil && m.Alias != nil {
		return *m.Alias
	}
	return ""
}

func (m *JmxAttribute) GetType() JmxMetricType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return JmxMetricType_JMX_METRIC_TYPE_COUNTER
}

func (m *JmxAttribute) GetUnit() Unit {
	if m != nil && m.Unit != nil {
		return *m.Unit
	}
	return Unit_UNIT_NONE
}

func (m *JmxAttribute) GetScale() Scale {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return Scale_SCALE_NONE
}

func (m *JmxAttribute) GetSubattributes() []*JmxAttribute {
	if m != nil {
		return m.Subattributes
	}
	return nil
}

type JmxBean struct {
	Name             *string         `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Attributes       []*JmxAttribute `protobuf:"bytes,2,rep,name=attributes" json:"attributes,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *JmxBean) Reset()                    { *m = JmxBean{} }
func (m *JmxBean) String() string            { return proto.CompactTextString(m) }
func (*JmxBean) ProtoMessage()               {}
func (*JmxBean) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{24} }

func (m *JmxBean) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *JmxBean) GetAttributes() []*JmxAttribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type JavaInfo struct {
	ProcessName      *string    `protobuf:"bytes,1,opt,name=process_name,json=processName" json:"process_name,omitempty"`
	Beans            []*JmxBean `protobuf:"bytes,2,rep,name=beans" json:"beans,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *JavaInfo) Reset()                    { *m = JavaInfo{} }
func (m *JavaInfo) String() string            { return proto.CompactTextString(m) }
func (*JavaInfo) ProtoMessage()               {}
func (*JavaInfo) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{25} }

func (m *JavaInfo) GetProcessName() string {
	if m != nil && m.ProcessName != nil {
		return *m.ProcessName
	}
	return ""
}

func (m *JavaInfo) GetBeans() []*JmxBean {
	if m != nil {
		return m.Beans
	}
	return nil
}

type StatsdTag struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *StatsdTag) Reset()                    { *m = StatsdTag{} }
func (m *StatsdTag) String() string            { return proto.CompactTextString(m) }
func (*StatsdTag) ProtoMessage()               {}
func (*StatsdTag) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{26} }

func (m *StatsdTag) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *StatsdTag) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type StatsdMetric struct {
	Name *string           `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Tags []*StatsdTag      `protobuf:"bytes,2,rep,name=tags" json:"tags,omitempty"`
	Type *StatsdMetricType `protobuf:"varint,3,opt,name=type,enum=draiosproto.StatsdMetricType" json:"type,omitempty"`
	// Valid on COUNT, GAUGE and SET
	Value *float64 `protobuf:"fixed64,4,opt,name=value" json:"value,omitempty"`
	// Valid only on HISTOGRAM type
	Sum              *float64               `protobuf:"fixed64,5,opt,name=sum" json:"sum,omitempty"`
	Min              *float64               `protobuf:"fixed64,6,opt,name=min" json:"min,omitempty"`
	Max              *float64               `protobuf:"fixed64,7,opt,name=max" json:"max,omitempty"`
	Count            *float64               `protobuf:"fixed64,8,opt,name=count" json:"count,omitempty"`
	Percentile       []*CounterPercentile   `protobuf:"bytes,12,rep,name=percentile" json:"percentile,omitempty"`
	PercentileData   *CounterPercentileData `protobuf:"bytes,13,opt,name=percentile_data,json=percentileData" json:"percentile_data,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *StatsdMetric) Reset()                    { *m = StatsdMetric{} }
func (m *StatsdMetric) String() string            { return proto.CompactTextString(m) }
func (*StatsdMetric) ProtoMessage()               {}
func (*StatsdMetric) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{27} }

func (m *StatsdMetric) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *StatsdMetric) GetTags() []*StatsdTag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *StatsdMetric) GetType() StatsdMetricType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return StatsdMetricType_STATSD_COUNT
}

func (m *StatsdMetric) GetValue() float64 {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return 0
}

func (m *StatsdMetric) GetSum() float64 {
	if m != nil && m.Sum != nil {
		return *m.Sum
	}
	return 0
}

func (m *StatsdMetric) GetMin() float64 {
	if m != nil && m.Min != nil {
		return *m.Min
	}
	return 0
}

func (m *StatsdMetric) GetMax() float64 {
	if m != nil && m.Max != nil {
		return *m.Max
	}
	return 0
}

func (m *StatsdMetric) GetCount() float64 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

func (m *StatsdMetric) GetPercentile() []*CounterPercentile {
	if m != nil {
		return m.Percentile
	}
	return nil
}

func (m *StatsdMetric) GetPercentileData() *CounterPercentileData {
	if m != nil {
		return m.PercentileData
	}
	return nil
}

type StatsdInfo struct {
	// May be used in the future to add metadata
	StatsdMetrics    []*StatsdMetric `protobuf:"bytes,1,rep,name=statsd_metrics,json=statsdMetrics" json:"statsd_metrics,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *StatsdInfo) Reset()                    { *m = StatsdInfo{} }
func (m *StatsdInfo) String() string            { return proto.CompactTextString(m) }
func (*StatsdInfo) ProtoMessage()               {}
func (*StatsdInfo) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{28} }

func (m *StatsdInfo) GetStatsdMetrics() []*StatsdMetric {
	if m != nil {
		return m.StatsdMetrics
	}
	return nil
}

type AppTag struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *AppTag) Reset()                    { *m = AppTag{} }
func (m *AppTag) String() string            { return proto.CompactTextString(m) }
func (*AppTag) ProtoMessage()               {}
func (*AppTag) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{29} }

func (m *AppTag) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *AppTag) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type AppMetric struct {
	Name *string        `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Type *AppMetricType `protobuf:"varint,2,opt,name=type,enum=draiosproto.AppMetricType" json:"type,omitempty"`
	// Valid on GAUGE and RATE
	Value            *float64  `protobuf:"fixed64,3,opt,name=value" json:"value,omitempty"`
	Tags             []*AppTag `protobuf:"bytes,4,rep,name=tags" json:"tags,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *AppMetric) Reset()                    { *m = AppMetric{} }
func (m *AppMetric) String() string            { return proto.CompactTextString(m) }
func (*AppMetric) ProtoMessage()               {}
func (*AppMetric) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{30} }

func (m *AppMetric) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *AppMetric) GetType() AppMetricType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return AppMetricType_APP_METRIC_TYPE_GAUGE
}

func (m *AppMetric) GetValue() float64 {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return 0
}

func (m *AppMetric) GetTags() []*AppTag {
	if m != nil {
		return m.Tags
	}
	return nil
}

type AppCheck struct {
	Name             *string        `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Value            *AppCheckValue `protobuf:"varint,2,opt,name=value,enum=draiosproto.AppCheckValue" json:"value,omitempty"`
	Tags             []*AppTag      `protobuf:"bytes,3,rep,name=tags" json:"tags,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *AppCheck) Reset()                    { *m = AppCheck{} }
func (m *AppCheck) String() string            { return proto.CompactTextString(m) }
func (*AppCheck) ProtoMessage()               {}
func (*AppCheck) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{31} }

func (m *AppCheck) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *AppCheck) GetValue() AppCheckValue {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return AppCheckValue_APP_CHECK_VALUE_OK
}

func (m *AppCheck) GetTags() []*AppTag {
	if m != nil {
		return m.Tags
	}
	return nil
}

type AppInfo struct {
	ProcessName      *string      `protobuf:"bytes,1,opt,name=process_name,json=processName" json:"process_name,omitempty"`
	Metrics          []*AppMetric `protobuf:"bytes,2,rep,name=metrics" json:"metrics,omitempty"`
	Checks           []*AppCheck  `protobuf:"bytes,3,rep,name=checks" json:"checks,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *AppInfo) Reset()                    { *m = AppInfo{} }
func (m *AppInfo) String() string            { return proto.CompactTextString(m) }
func (*AppInfo) ProtoMessage()               {}
func (*AppInfo) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{32} }

func (m *AppInfo) GetProcessName() string {
	if m != nil && m.ProcessName != nil {
		return *m.ProcessName
	}
	return ""
}

func (m *AppInfo) GetMetrics() []*AppMetric {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *AppInfo) GetChecks() []*AppCheck {
	if m != nil {
		return m.Checks
	}
	return nil
}

//
// General protocol information
//
type ProtoInfo struct {
	Http             *HttpInfo    `protobuf:"bytes,1,opt,name=http" json:"http,omitempty"`
	Mysql            *SqlInfo     `protobuf:"bytes,2,opt,name=mysql" json:"mysql,omitempty"`
	Postgres         *SqlInfo     `protobuf:"bytes,3,opt,name=postgres" json:"postgres,omitempty"`
	Mongodb          *MongodbInfo `protobuf:"bytes,4,opt,name=mongodb" json:"mongodb,omitempty"`
	Java             *JavaInfo    `protobuf:"bytes,5,opt,name=java" json:"java,omitempty"`
	Statsd           *StatsdInfo  `protobuf:"bytes,6,opt,name=statsd" json:"statsd,omitempty"`
	App              *AppInfo     `protobuf:"bytes,7,opt,name=app" json:"app,omitempty"`
	Prometheus       *AppInfo     `protobuf:"bytes,9,opt,name=prometheus" json:"prometheus,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *ProtoInfo) Reset()                    { *m = ProtoInfo{} }
func (m *ProtoInfo) String() string            { return proto.CompactTextString(m) }
func (*ProtoInfo) ProtoMessage()               {}
func (*ProtoInfo) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{33} }

func (m *ProtoInfo) GetHttp() *HttpInfo {
	if m != nil {
		return m.Http
	}
	return nil
}

func (m *ProtoInfo) GetMysql() *SqlInfo {
	if m != nil {
		return m.Mysql
	}
	return nil
}

func (m *ProtoInfo) GetPostgres() *SqlInfo {
	if m != nil {
		return m.Postgres
	}
	return nil
}

func (m *ProtoInfo) GetMongodb() *MongodbInfo {
	if m != nil {
		return m.Mongodb
	}
	return nil
}

func (m *ProtoInfo) GetJava() *JavaInfo {
	if m != nil {
		return m.Java
	}
	return nil
}

func (m *ProtoInfo) GetStatsd() *StatsdInfo {
	if m != nil {
		return m.Statsd
	}
	return nil
}

func (m *ProtoInfo) GetApp() *AppInfo {
	if m != nil {
		return m.App
	}
	return nil
}

func (m *ProtoInfo) GetPrometheus() *AppInfo {
	if m != nil {
		return m.Prometheus
	}
	return nil
}

type NetworkByPort struct {
	Port             *uint32               `protobuf:"varint,1,req,name=port" json:"port,omitempty"`
	Counters         *ConnectionCategories `protobuf:"bytes,2,req,name=counters" json:"counters,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *NetworkByPort) Reset()                    { *m = NetworkByPort{} }
func (m *NetworkByPort) String() string            { return proto.CompactTextString(m) }
func (*NetworkByPort) ProtoMessage()               {}
func (*NetworkByPort) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{34} }

func (m *NetworkByPort) GetPort() uint32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *NetworkByPort) GetCounters() *ConnectionCategories {
	if m != nil {
		return m.Counters
	}
	return nil
}

//
// HOST
// global host info.
//
type Host struct {
	Hostname                   *string                         `protobuf:"bytes,1,opt,name=hostname" json:"hostname,omitempty"`
	NumCpus                    *uint32                         `protobuf:"varint,2,opt,name=num_cpus,json=numCpus" json:"num_cpus,omitempty"`
	CpuLoads                   []uint32                        `protobuf:"varint,3,rep,name=cpu_loads,json=cpuLoads" json:"cpu_loads,omitempty"`
	CpuSteal                   []uint32                        `protobuf:"varint,11,rep,name=cpu_steal,json=cpuSteal" json:"cpu_steal,omitempty"`
	PhysicalMemorySizeBytes    *uint64                         `protobuf:"varint,4,req,name=physical_memory_size_bytes,json=physicalMemorySizeBytes" json:"physical_memory_size_bytes,omitempty"`
	Tcounters                  *TimeCategories                 `protobuf:"bytes,5,opt,name=tcounters" json:"tcounters,omitempty"`
	Reqcounters                *TransactionBreakdownCategories `protobuf:"bytes,12,opt,name=reqcounters" json:"reqcounters,omitempty"`
	TransactionCounters        *CounterTimeBidirectional       `protobuf:"bytes,6,opt,name=transaction_counters,json=transactionCounters" json:"transaction_counters,omitempty"`
	MaxTransactionCounters     *CounterTimeBidirectional       `protobuf:"bytes,23,opt,name=max_transaction_counters,json=maxTransactionCounters" json:"max_transaction_counters,omitempty"`
	TransactionProcessingDelay *uint64                         `protobuf:"varint,7,opt,name=transaction_processing_delay,json=transactionProcessingDelay" json:"transaction_processing_delay,omitempty"`
	// It's calculated by subtracting outgoing connection time from incoming connection time.
	// NEVER USED optional uint64 merged_server_delay = 14; // the total merged time of all the incoming requests.
	NextTiersDelay         *uint64               `protobuf:"varint,13,opt,name=next_tiers_delay,json=nextTiersDelay" json:"next_tiers_delay,omitempty"`
	ResourceCounters       *ResourceCategories   `protobuf:"bytes,8,opt,name=resource_counters,json=resourceCounters" json:"resource_counters,omitempty"`
	SyscallErrors          *CounterSyscallErrors `protobuf:"bytes,9,opt,name=syscall_errors,json=syscallErrors" json:"syscall_errors,omitempty"`
	ExternalIoNet          *CounterTimeBytes     `protobuf:"bytes,10,opt,name=external_io_net,json=externalIoNet" json:"external_io_net,omitempty"`
	NetworkByServerports   []*NetworkByPort      `protobuf:"bytes,24,rep,name=network_by_serverports,json=networkByServerports" json:"network_by_serverports,omitempty"`
	CpuIdle                []uint32              `protobuf:"varint,25,rep,name=cpu_idle,json=cpuIdle" json:"cpu_idle,omitempty"`
	Uptime                 *uint64               `protobuf:"varint,33,opt,name=uptime" json:"uptime,omitempty"`
	SystemCpu              []uint32              `protobuf:"varint,34,rep,name=system_cpu,json=systemCpu" json:"system_cpu,omitempty"`
	UserCpu                []uint32              `protobuf:"varint,35,rep,name=user_cpu,json=userCpu" json:"user_cpu,omitempty"`
	MemoryBytesAvailableKb *uint64               `protobuf:"varint,36,opt,name=memory_bytes_available_kb,json=memoryBytesAvailableKb" json:"memory_bytes_available_kb,omitempty"`
	IowaitCpu              []uint32              `protobuf:"varint,37,rep,name=iowait_cpu,json=iowaitCpu" json:"iowait_cpu,omitempty"`
	NiceCpu                []uint32              `protobuf:"varint,38,rep,name=nice_cpu,json=niceCpu" json:"nice_cpu,omitempty"`
	SystemLoad_1           *uint32               `protobuf:"varint,41,opt,name=system_load_1,json=systemLoad1" json:"system_load_1,omitempty"`
	SystemLoad_5           *uint32               `protobuf:"varint,42,opt,name=system_load_5,json=systemLoad5" json:"system_load_5,omitempty"`
	SystemLoad_15          *uint32               `protobuf:"varint,43,opt,name=system_load_15,json=systemLoad15" json:"system_load_15,omitempty"`
	XXX_unrecognized       []byte                `json:"-"`
}

func (m *Host) Reset()                    { *m = Host{} }
func (m *Host) String() string            { return proto.CompactTextString(m) }
func (*Host) ProtoMessage()               {}
func (*Host) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{35} }

func (m *Host) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *Host) GetNumCpus() uint32 {
	if m != nil && m.NumCpus != nil {
		return *m.NumCpus
	}
	return 0
}

func (m *Host) GetCpuLoads() []uint32 {
	if m != nil {
		return m.CpuLoads
	}
	return nil
}

func (m *Host) GetCpuSteal() []uint32 {
	if m != nil {
		return m.CpuSteal
	}
	return nil
}

func (m *Host) GetPhysicalMemorySizeBytes() uint64 {
	if m != nil && m.PhysicalMemorySizeBytes != nil {
		return *m.PhysicalMemorySizeBytes
	}
	return 0
}

func (m *Host) GetTcounters() *TimeCategories {
	if m != nil {
		return m.Tcounters
	}
	return nil
}

func (m *Host) GetReqcounters() *TransactionBreakdownCategories {
	if m != nil {
		return m.Reqcounters
	}
	return nil
}

func (m *Host) GetTransactionCounters() *CounterTimeBidirectional {
	if m != nil {
		return m.TransactionCounters
	}
	return nil
}

func (m *Host) GetMaxTransactionCounters() *CounterTimeBidirectional {
	if m != nil {
		return m.MaxTransactionCounters
	}
	return nil
}

func (m *Host) GetTransactionProcessingDelay() uint64 {
	if m != nil && m.TransactionProcessingDelay != nil {
		return *m.TransactionProcessingDelay
	}
	return 0
}

func (m *Host) GetNextTiersDelay() uint64 {
	if m != nil && m.NextTiersDelay != nil {
		return *m.NextTiersDelay
	}
	return 0
}

func (m *Host) GetResourceCounters() *ResourceCategories {
	if m != nil {
		return m.ResourceCounters
	}
	return nil
}

func (m *Host) GetSyscallErrors() *CounterSyscallErrors {
	if m != nil {
		return m.SyscallErrors
	}
	return nil
}

func (m *Host) GetExternalIoNet() *CounterTimeBytes {
	if m != nil {
		return m.ExternalIoNet
	}
	return nil
}

func (m *Host) GetNetworkByServerports() []*NetworkByPort {
	if m != nil {
		return m.NetworkByServerports
	}
	return nil
}

func (m *Host) GetCpuIdle() []uint32 {
	if m != nil {
		return m.CpuIdle
	}
	return nil
}

func (m *Host) GetUptime() uint64 {
	if m != nil && m.Uptime != nil {
		return *m.Uptime
	}
	return 0
}

func (m *Host) GetSystemCpu() []uint32 {
	if m != nil {
		return m.SystemCpu
	}
	return nil
}

func (m *Host) GetUserCpu() []uint32 {
	if m != nil {
		return m.UserCpu
	}
	return nil
}

func (m *Host) GetMemoryBytesAvailableKb() uint64 {
	if m != nil && m.MemoryBytesAvailableKb != nil {
		return *m.MemoryBytesAvailableKb
	}
	return 0
}

func (m *Host) GetIowaitCpu() []uint32 {
	if m != nil {
		return m.IowaitCpu
	}
	return nil
}

func (m *Host) GetNiceCpu() []uint32 {
	if m != nil {
		return m.NiceCpu
	}
	return nil
}

func (m *Host) GetSystemLoad_1() uint32 {
	if m != nil && m.SystemLoad_1 != nil {
		return *m.SystemLoad_1
	}
	return 0
}

func (m *Host) GetSystemLoad_5() uint32 {
	if m != nil && m.SystemLoad_5 != nil {
		return *m.SystemLoad_5
	}
	return 0
}

func (m *Host) GetSystemLoad_15() uint32 {
	if m != nil && m.SystemLoad_15 != nil {
		return *m.SystemLoad_15
	}
	return 0
}

type Process struct {
	Details                    *ProcessDetails           `protobuf:"bytes,2,opt,name=details" json:"details,omitempty"`
	IsIpv4TransactionServer    *bool                     `protobuf:"varint,3,opt,name=is_ipv4_transaction_server,json=isIpv4TransactionServer" json:"is_ipv4_transaction_server,omitempty"`
	IsUnixTransactionServer    *bool                     `protobuf:"varint,4,opt,name=is_unix_transaction_server,json=isUnixTransactionServer" json:"is_unix_transaction_server,omitempty"`
	IsIpv4TransactionClient    *bool                     `protobuf:"varint,10,opt,name=is_ipv4_transaction_client,json=isIpv4TransactionClient" json:"is_ipv4_transaction_client,omitempty"`
	IsUnixTransactionClient    *bool                     `protobuf:"varint,11,opt,name=is_unix_transaction_client,json=isUnixTransactionClient" json:"is_unix_transaction_client,omitempty"`
	Netrole                    *uint32                   `protobuf:"varint,13,opt,name=netrole" json:"netrole,omitempty"`
	Tcounters                  *TimeCategories           `protobuf:"bytes,5,opt,name=tcounters" json:"tcounters,omitempty"`
	TransactionCounters        *CounterTimeBidirectional `protobuf:"bytes,6,opt,name=transaction_counters,json=transactionCounters" json:"transaction_counters,omitempty"`
	MaxTransactionCounters     *CounterTimeBidirectional `protobuf:"bytes,19,opt,name=max_transaction_counters,json=maxTransactionCounters" json:"max_transaction_counters,omitempty"`
	TransactionProcessingDelay *uint64                   `protobuf:"varint,7,opt,name=transaction_processing_delay,json=transactionProcessingDelay" json:"transaction_processing_delay,omitempty"`
	// It's calculated by subtracting outgoing connection time from incoming connection time.
	// NEVER USED optional uint64 merged_server_delay = 14; // the total merged time of all the incoming requests.
	NextTiersDelay   *uint64               `protobuf:"varint,12,opt,name=next_tiers_delay,json=nextTiersDelay" json:"next_tiers_delay,omitempty"`
	ResourceCounters *ResourceCategories   `protobuf:"bytes,8,opt,name=resource_counters,json=resourceCounters" json:"resource_counters,omitempty"`
	SyscallErrors    *CounterSyscallErrors `protobuf:"bytes,9,opt,name=syscall_errors,json=syscallErrors" json:"syscall_errors,omitempty"`
	Protos           *ProtoInfo            `protobuf:"bytes,20,opt,name=protos" json:"protos,omitempty"`
	StartCount       *uint64               `protobuf:"varint,21,opt,name=start_count,json=startCount" json:"start_count,omitempty"`
	CountProcesses   *uint64               `protobuf:"varint,23,opt,name=count_processes,json=countProcesses" json:"count_processes,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *Process) Reset()                    { *m = Process{} }
func (m *Process) String() string            { return proto.CompactTextString(m) }
func (*Process) ProtoMessage()               {}
func (*Process) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{36} }

func (m *Process) GetDetails() *ProcessDetails {
	if m != nil {
		return m.Details
	}
	return nil
}

func (m *Process) GetIsIpv4TransactionServer() bool {
	if m != nil && m.IsIpv4TransactionServer != nil {
		return *m.IsIpv4TransactionServer
	}
	return false
}

func (m *Process) GetIsUnixTransactionServer() bool {
	if m != nil && m.IsUnixTransactionServer != nil {
		return *m.IsUnixTransactionServer
	}
	return false
}

func (m *Process) GetIsIpv4TransactionClient() bool {
	if m != nil && m.IsIpv4TransactionClient != nil {
		return *m.IsIpv4TransactionClient
	}
	return false
}

func (m *Process) GetIsUnixTransactionClient() bool {
	if m != nil && m.IsUnixTransactionClient != nil {
		return *m.IsUnixTransactionClient
	}
	return false
}

func (m *Process) GetNetrole() uint32 {
	if m != nil && m.Netrole != nil {
		return *m.Netrole
	}
	return 0
}

func (m *Process) GetTcounters() *TimeCategories {
	if m != nil {
		return m.Tcounters
	}
	return nil
}

func (m *Process) GetTransactionCounters() *CounterTimeBidirectional {
	if m != nil {
		return m.TransactionCounters
	}
	return nil
}

func (m *Process) GetMaxTransactionCounters() *CounterTimeBidirectional {
	if m != nil {
		return m.MaxTransactionCounters
	}
	return nil
}

func (m *Process) GetTransactionProcessingDelay() uint64 {
	if m != nil && m.TransactionProcessingDelay != nil {
		return *m.TransactionProcessingDelay
	}
	return 0
}

func (m *Process) GetNextTiersDelay() uint64 {
	if m != nil && m.NextTiersDelay != nil {
		return *m.NextTiersDelay
	}
	return 0
}

func (m *Process) GetResourceCounters() *ResourceCategories {
	if m != nil {
		return m.ResourceCounters
	}
	return nil
}

func (m *Process) GetSyscallErrors() *CounterSyscallErrors {
	if m != nil {
		return m.SyscallErrors
	}
	return nil
}

func (m *Process) GetProtos() *ProtoInfo {
	if m != nil {
		return m.Protos
	}
	return nil
}

func (m *Process) GetStartCount() uint64 {
	if m != nil && m.StartCount != nil {
		return *m.StartCount
	}
	return 0
}

func (m *Process) GetCountProcesses() uint64 {
	if m != nil && m.CountProcesses != nil {
		return *m.CountProcesses
	}
	return 0
}

//
// PROGRAM
// info for a program, i.e. a collection of processes with the same name and the same creator.
//
type Program struct {
	Procinfo         *Process `protobuf:"bytes,1,req,name=procinfo" json:"procinfo,omitempty"`
	Pids             []uint64 `protobuf:"varint,2,rep,name=pids" json:"pids,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Program) Reset()                    { *m = Program{} }
func (m *Program) String() string            { return proto.CompactTextString(m) }
func (*Program) ProtoMessage()               {}
func (*Program) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{37} }

func (m *Program) GetProcinfo() *Process {
	if m != nil {
		return m.Procinfo
	}
	return nil
}

func (m *Program) GetPids() []uint64 {
	if m != nil {
		return m.Pids
	}
	return nil
}

//
// IPv4 CONNECTION
//
type Ipv4Tuple struct {
	Sip              *uint32 `protobuf:"varint,1,req,name=sip" json:"sip,omitempty"`
	Dip              *uint32 `protobuf:"varint,2,req,name=dip" json:"dip,omitempty"`
	Sport            *uint32 `protobuf:"varint,3,req,name=sport" json:"sport,omitempty"`
	Dport            *uint32 `protobuf:"varint,4,req,name=dport" json:"dport,omitempty"`
	L4Proto          *uint32 `protobuf:"varint,5,req,name=l4proto" json:"l4proto,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Ipv4Tuple) Reset()                    { *m = Ipv4Tuple{} }
func (m *Ipv4Tuple) String() string            { return proto.CompactTextString(m) }
func (*Ipv4Tuple) ProtoMessage()               {}
func (*Ipv4Tuple) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{38} }

func (m *Ipv4Tuple) GetSip() uint32 {
	if m != nil && m.Sip != nil {
		return *m.Sip
	}
	return 0
}

func (m *Ipv4Tuple) GetDip() uint32 {
	if m != nil && m.Dip != nil {
		return *m.Dip
	}
	return 0
}

func (m *Ipv4Tuple) GetSport() uint32 {
	if m != nil && m.Sport != nil {
		return *m.Sport
	}
	return 0
}

func (m *Ipv4Tuple) GetDport() uint32 {
	if m != nil && m.Dport != nil {
		return *m.Dport
	}
	return 0
}

func (m *Ipv4Tuple) GetL4Proto() uint32 {
	if m != nil && m.L4Proto != nil {
		return *m.L4Proto
	}
	return 0
}

type Ipv4Connection struct {
	Tuple            *Ipv4Tuple            `protobuf:"bytes,1,req,name=tuple" json:"tuple,omitempty"`
	Spid             *uint64               `protobuf:"varint,2,opt,name=spid" json:"spid,omitempty"`
	Dpid             *uint64               `protobuf:"varint,5,opt,name=dpid" json:"dpid,omitempty"`
	Counters         *ConnectionCategories `protobuf:"bytes,8,req,name=counters" json:"counters,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *Ipv4Connection) Reset()                    { *m = Ipv4Connection{} }
func (m *Ipv4Connection) String() string            { return proto.CompactTextString(m) }
func (*Ipv4Connection) ProtoMessage()               {}
func (*Ipv4Connection) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{39} }

func (m *Ipv4Connection) GetTuple() *Ipv4Tuple {
	if m != nil {
		return m.Tuple
	}
	return nil
}

func (m *Ipv4Connection) GetSpid() uint64 {
	if m != nil && m.Spid != nil {
		return *m.Spid
	}
	return 0
}

func (m *Ipv4Connection) GetDpid() uint64 {
	if m != nil && m.Dpid != nil {
		return *m.Dpid
	}
	return 0
}

func (m *Ipv4Connection) GetCounters() *ConnectionCategories {
	if m != nil {
		return m.Counters
	}
	return nil
}

//
// NETWORK INTERFACE
//
type Ipv4NetworkInterface struct {
	Name             *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Addr             *uint32 `protobuf:"varint,2,req,name=addr" json:"addr,omitempty"`
	Netmask          *uint32 `protobuf:"varint,3,req,name=netmask" json:"netmask,omitempty"`
	Bcast            *uint32 `protobuf:"varint,4,opt,name=bcast" json:"bcast,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Ipv4NetworkInterface) Reset()                    { *m = Ipv4NetworkInterface{} }
func (m *Ipv4NetworkInterface) String() string            { return proto.CompactTextString(m) }
func (*Ipv4NetworkInterface) ProtoMessage()               {}
func (*Ipv4NetworkInterface) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{40} }

func (m *Ipv4NetworkInterface) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Ipv4NetworkInterface) GetAddr() uint32 {
	if m != nil && m.Addr != nil {
		return *m.Addr
	}
	return 0
}

func (m *Ipv4NetworkInterface) GetNetmask() uint32 {
	if m != nil && m.Netmask != nil {
		return *m.Netmask
	}
	return 0
}

func (m *Ipv4NetworkInterface) GetBcast() uint32 {
	if m != nil && m.Bcast != nil {
		return *m.Bcast
	}
	return 0
}

//
// MOUNTED FILE SYSTEM
//
type MountedFs struct {
	Device           *string `protobuf:"bytes,1,req,name=device" json:"device,omitempty"`
	MountDir         *string `protobuf:"bytes,2,req,name=mount_dir,json=mountDir" json:"mount_dir,omitempty"`
	Type             *string `protobuf:"bytes,3,req,name=type" json:"type,omitempty"`
	SizeBytes        *uint64 `protobuf:"varint,4,req,name=size_bytes,json=sizeBytes" json:"size_bytes,omitempty"`
	UsedBytes        *uint64 `protobuf:"varint,5,req,name=used_bytes,json=usedBytes" json:"used_bytes,omitempty"`
	AvailableBytes   *uint64 `protobuf:"varint,6,req,name=available_bytes,json=availableBytes" json:"available_bytes,omitempty"`
	TotalInodes      *uint64 `protobuf:"varint,10,opt,name=total_inodes,json=totalInodes" json:"total_inodes,omitempty"`
	UsedInodes       *uint64 `protobuf:"varint,11,opt,name=used_inodes,json=usedInodes" json:"used_inodes,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *MountedFs) Reset()                    { *m = MountedFs{} }
func (m *MountedFs) String() string            { return proto.CompactTextString(m) }
func (*MountedFs) ProtoMessage()               {}
func (*MountedFs) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{41} }

func (m *MountedFs) GetDevice() string {
	if m != nil && m.Device != nil {
		return *m.Device
	}
	return ""
}

func (m *MountedFs) GetMountDir() string {
	if m != nil && m.MountDir != nil {
		return *m.MountDir
	}
	return ""
}

func (m *MountedFs) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

func (m *MountedFs) GetSizeBytes() uint64 {
	if m != nil && m.SizeBytes != nil {
		return *m.SizeBytes
	}
	return 0
}

func (m *MountedFs) GetUsedBytes() uint64 {
	if m != nil && m.UsedBytes != nil {
		return *m.UsedBytes
	}
	return 0
}

func (m *MountedFs) GetAvailableBytes() uint64 {
	if m != nil && m.AvailableBytes != nil {
		return *m.AvailableBytes
	}
	return 0
}

func (m *MountedFs) GetTotalInodes() uint64 {
	if m != nil && m.TotalInodes != nil {
		return *m.TotalInodes
	}
	return 0
}

func (m *MountedFs) GetUsedInodes() uint64 {
	if m != nil && m.UsedInodes != nil {
		return *m.UsedInodes
	}
	return 0
}

//
// TOP FILE STATISTICS
//
type FileStat struct {
	Name             *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Bytes            *uint32 `protobuf:"varint,2,req,name=bytes" json:"bytes,omitempty"`
	TimeNs           *uint64 `protobuf:"varint,3,req,name=time_ns,json=timeNs" json:"time_ns,omitempty"`
	OpenCount        *uint32 `protobuf:"varint,4,req,name=open_count,json=openCount" json:"open_count,omitempty"`
	Errors           *uint32 `protobuf:"varint,5,req,name=errors" json:"errors,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *FileStat) Reset()                    { *m = FileStat{} }
func (m *FileStat) String() string            { return proto.CompactTextString(m) }
func (*FileStat) ProtoMessage()               {}
func (*FileStat) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{42} }

func (m *FileStat) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *FileStat) GetBytes() uint32 {
	if m != nil && m.Bytes != nil {
		return *m.Bytes
	}
	return 0
}

func (m *FileStat) GetTimeNs() uint64 {
	if m != nil && m.TimeNs != nil {
		return *m.TimeNs
	}
	return 0
}

func (m *FileStat) GetOpenCount() uint32 {
	if m != nil && m.OpenCount != nil {
		return *m.OpenCount
	}
	return 0
}

func (m *FileStat) GetErrors() uint32 {
	if m != nil && m.Errors != nil {
		return *m.Errors
	}
	return 0
}

type ContainerPortMapping struct {
	HostIp           *uint32 `protobuf:"varint,1,opt,name=host_ip,json=hostIp" json:"host_ip,omitempty"`
	HostPort         *uint32 `protobuf:"varint,2,opt,name=host_port,json=hostPort" json:"host_port,omitempty"`
	ContainerIp      *uint32 `protobuf:"varint,3,opt,name=container_ip,json=containerIp" json:"container_ip,omitempty"`
	ContainerPort    *uint32 `protobuf:"varint,4,opt,name=container_port,json=containerPort" json:"container_port,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ContainerPortMapping) Reset()                    { *m = ContainerPortMapping{} }
func (m *ContainerPortMapping) String() string            { return proto.CompactTextString(m) }
func (*ContainerPortMapping) ProtoMessage()               {}
func (*ContainerPortMapping) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{43} }

func (m *ContainerPortMapping) GetHostIp() uint32 {
	if m != nil && m.HostIp != nil {
		return *m.HostIp
	}
	return 0
}

func (m *ContainerPortMapping) GetHostPort() uint32 {
	if m != nil && m.HostPort != nil {
		return *m.HostPort
	}
	return 0
}

func (m *ContainerPortMapping) GetContainerIp() uint32 {
	if m != nil && m.ContainerIp != nil {
		return *m.ContainerIp
	}
	return 0
}

func (m *ContainerPortMapping) GetContainerPort() uint32 {
	if m != nil && m.ContainerPort != nil {
		return *m.ContainerPort
	}
	return 0
}

type ContainerLabel struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ContainerLabel) Reset()                    { *m = ContainerLabel{} }
func (m *ContainerLabel) String() string            { return proto.CompactTextString(m) }
func (*ContainerLabel) ProtoMessage()               {}
func (*ContainerLabel) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{44} }

func (m *ContainerLabel) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *ContainerLabel) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type Container struct {
	Id                         *string                         `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	Type                       *ContainerType                  `protobuf:"varint,2,opt,name=type,enum=draiosproto.ContainerType" json:"type,omitempty"`
	Name                       *string                         `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	Image                      *string                         `protobuf:"bytes,4,opt,name=image" json:"image,omitempty"`
	Tcounters                  *TimeCategories                 `protobuf:"bytes,5,opt,name=tcounters" json:"tcounters,omitempty"`
	Reqcounters                *TransactionBreakdownCategories `protobuf:"bytes,6,opt,name=reqcounters" json:"reqcounters,omitempty"`
	TransactionCounters        *CounterTimeBidirectional       `protobuf:"bytes,7,opt,name=transaction_counters,json=transactionCounters" json:"transaction_counters,omitempty"`
	MaxTransactionCounters     *CounterTimeBidirectional       `protobuf:"bytes,9,opt,name=max_transaction_counters,json=maxTransactionCounters" json:"max_transaction_counters,omitempty"`
	TransactionProcessingDelay *uint64                         `protobuf:"varint,10,opt,name=transaction_processing_delay,json=transactionProcessingDelay" json:"transaction_processing_delay,omitempty"`
	// It's calculated by subtracting outgoing connection time from incoming connection time.
	// NEVER USED optional uint64 merged_server_delay = 11; // the total merged time of all the incoming requests.
	NextTiersDelay       *uint64                 `protobuf:"varint,12,opt,name=next_tiers_delay,json=nextTiersDelay" json:"next_tiers_delay,omitempty"`
	ResourceCounters     *ResourceCategories     `protobuf:"bytes,13,opt,name=resource_counters,json=resourceCounters" json:"resource_counters,omitempty"`
	SyscallErrors        *CounterSyscallErrors   `protobuf:"bytes,14,opt,name=syscall_errors,json=syscallErrors" json:"syscall_errors,omitempty"`
	PortMappings         []*ContainerPortMapping `protobuf:"bytes,18,rep,name=port_mappings,json=portMappings" json:"port_mappings,omitempty"`
	Protos               *ProtoInfo              `protobuf:"bytes,19,opt,name=protos" json:"protos,omitempty"`
	Labels               []*ContainerLabel       `protobuf:"bytes,20,rep,name=labels" json:"labels,omitempty"`
	Mounts               []*MountedFs            `protobuf:"bytes,21,rep,name=mounts" json:"mounts,omitempty"`
	NetworkByServerports []*NetworkByPort        `protobuf:"bytes,22,rep,name=network_by_serverports,json=networkByServerports" json:"network_by_serverports,omitempty"`
	MesosTaskId          *string                 `protobuf:"bytes,23,opt,name=mesos_task_id,json=mesosTaskId" json:"mesos_task_id,omitempty"`
	ImageId              *string                 `protobuf:"bytes,24,opt,name=image_id,json=imageId" json:"image_id,omitempty"`
	Commands             []*CommandDetails       `protobuf:"bytes,25,rep,name=commands" json:"commands,omitempty"`
	XXX_unrecognized     []byte                  `json:"-"`
}

func (m *Container) Reset()                    { *m = Container{} }
func (m *Container) String() string            { return proto.CompactTextString(m) }
func (*Container) ProtoMessage()               {}
func (*Container) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{45} }

func (m *Container) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *Container) GetType() ContainerType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ContainerType_DOCKER
}

func (m *Container) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Container) GetImage() string {
	if m != nil && m.Image != nil {
		return *m.Image
	}
	return ""
}

func (m *Container) GetTcounters() *TimeCategories {
	if m != nil {
		return m.Tcounters
	}
	return nil
}

func (m *Container) GetReqcounters() *TransactionBreakdownCategories {
	if m != nil {
		return m.Reqcounters
	}
	return nil
}

func (m *Container) GetTransactionCounters() *CounterTimeBidirectional {
	if m != nil {
		return m.TransactionCounters
	}
	return nil
}

func (m *Container) GetMaxTransactionCounters() *CounterTimeBidirectional {
	if m != nil {
		return m.MaxTransactionCounters
	}
	return nil
}

func (m *Container) GetTransactionProcessingDelay() uint64 {
	if m != nil && m.TransactionProcessingDelay != nil {
		return *m.TransactionProcessingDelay
	}
	return 0
}

func (m *Container) GetNextTiersDelay() uint64 {
	if m != nil && m.NextTiersDelay != nil {
		return *m.NextTiersDelay
	}
	return 0
}

func (m *Container) GetResourceCounters() *ResourceCategories {
	if m != nil {
		return m.ResourceCounters
	}
	return nil
}

func (m *Container) GetSyscallErrors() *CounterSyscallErrors {
	if m != nil {
		return m.SyscallErrors
	}
	return nil
}

func (m *Container) GetPortMappings() []*ContainerPortMapping {
	if m != nil {
		return m.PortMappings
	}
	return nil
}

func (m *Container) GetProtos() *ProtoInfo {
	if m != nil {
		return m.Protos
	}
	return nil
}

func (m *Container) GetLabels() []*ContainerLabel {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Container) GetMounts() []*MountedFs {
	if m != nil {
		return m.Mounts
	}
	return nil
}

func (m *Container) GetNetworkByServerports() []*NetworkByPort {
	if m != nil {
		return m.NetworkByServerports
	}
	return nil
}

func (m *Container) GetMesosTaskId() string {
	if m != nil && m.MesosTaskId != nil {
		return *m.MesosTaskId
	}
	return ""
}

func (m *Container) GetImageId() string {
	if m != nil && m.ImageId != nil {
		return *m.ImageId
	}
	return ""
}

func (m *Container) GetCommands() []*CommandDetails {
	if m != nil {
		return m.Commands
	}
	return nil
}

//
// ORCHESTRATOR METADATA
//
type CongroupUid struct {
	Kind             *string `protobuf:"bytes,1,opt,name=kind" json:"kind,omitempty"`
	Id               *string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *CongroupUid) Reset()                    { *m = CongroupUid{} }
func (m *CongroupUid) String() string            { return proto.CompactTextString(m) }
func (*CongroupUid) ProtoMessage()               {}
func (*CongroupUid) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{46} }

func (m *CongroupUid) GetKind() string {
	if m != nil && m.Kind != nil {
		return *m.Kind
	}
	return ""
}

func (m *CongroupUid) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

type CongroupNetPort struct {
	Port             *uint32 `protobuf:"varint,1,req,name=port" json:"port,omitempty"`
	TargetPort       *uint32 `protobuf:"varint,2,req,name=target_port,json=targetPort" json:"target_port,omitempty"`
	Protocol         *string `protobuf:"bytes,3,opt,name=protocol" json:"protocol,omitempty"`
	NodePort         *uint32 `protobuf:"varint,4,opt,name=node_port,json=nodePort" json:"node_port,omitempty"`
	PublishedPort    *uint32 `protobuf:"varint,5,opt,name=published_port,json=publishedPort" json:"published_port,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *CongroupNetPort) Reset()                    { *m = CongroupNetPort{} }
func (m *CongroupNetPort) String() string            { return proto.CompactTextString(m) }
func (*CongroupNetPort) ProtoMessage()               {}
func (*CongroupNetPort) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{47} }

func (m *CongroupNetPort) GetPort() uint32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *CongroupNetPort) GetTargetPort() uint32 {
	if m != nil && m.TargetPort != nil {
		return *m.TargetPort
	}
	return 0
}

func (m *CongroupNetPort) GetProtocol() string {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return ""
}

func (m *CongroupNetPort) GetNodePort() uint32 {
	if m != nil && m.NodePort != nil {
		return *m.NodePort
	}
	return 0
}

func (m *CongroupNetPort) GetPublishedPort() uint32 {
	if m != nil && m.PublishedPort != nil {
		return *m.PublishedPort
	}
	return 0
}

type ContainerGroup struct {
	Uid              *CongroupUid       `protobuf:"bytes,1,opt,name=uid" json:"uid,omitempty"`
	Tags             map[string]string  `protobuf:"bytes,3,rep,name=tags" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	InternalTags     map[string]string  `protobuf:"bytes,10,rep,name=internal_tags,json=internalTags" json:"internal_tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	IpAddresses      []string           `protobuf:"bytes,5,rep,name=ip_addresses,json=ipAddresses" json:"ip_addresses,omitempty"`
	Ports            []*CongroupNetPort `protobuf:"bytes,6,rep,name=ports" json:"ports,omitempty"`
	Metrics          []*AppMetric       `protobuf:"bytes,7,rep,name=metrics" json:"metrics,omitempty"`
	Children         []*CongroupUid     `protobuf:"bytes,8,rep,name=children" json:"children,omitempty"`
	Parents          []*CongroupUid     `protobuf:"bytes,9,rep,name=parents" json:"parents,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *ContainerGroup) Reset()                    { *m = ContainerGroup{} }
func (m *ContainerGroup) String() string            { return proto.CompactTextString(m) }
func (*ContainerGroup) ProtoMessage()               {}
func (*ContainerGroup) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{48} }

func (m *ContainerGroup) GetUid() *CongroupUid {
	if m != nil {
		return m.Uid
	}
	return nil
}

func (m *ContainerGroup) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *ContainerGroup) GetInternalTags() map[string]string {
	if m != nil {
		return m.InternalTags
	}
	return nil
}

func (m *ContainerGroup) GetIpAddresses() []string {
	if m != nil {
		return m.IpAddresses
	}
	return nil
}

func (m *ContainerGroup) GetPorts() []*CongroupNetPort {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *ContainerGroup) GetMetrics() []*AppMetric {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *ContainerGroup) GetChildren() []*CongroupUid {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *ContainerGroup) GetParents() []*CongroupUid {
	if m != nil {
		return m.Parents
	}
	return nil
}

type CongroupUpdateEvent struct {
	Type             *CongroupEventType `protobuf:"varint,1,req,name=type,enum=draiosproto.CongroupEventType" json:"type,omitempty"`
	Object           *ContainerGroup    `protobuf:"bytes,3,req,name=object" json:"object,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *CongroupUpdateEvent) Reset()                    { *m = CongroupUpdateEvent{} }
func (m *CongroupUpdateEvent) String() string            { return proto.CompactTextString(m) }
func (*CongroupUpdateEvent) ProtoMessage()               {}
func (*CongroupUpdateEvent) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{49} }

func (m *CongroupUpdateEvent) GetType() CongroupEventType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return CongroupEventType_ADDED
}

func (m *CongroupUpdateEvent) GetObject() *ContainerGroup {
	if m != nil {
		return m.Object
	}
	return nil
}

type OrchestratorEvents struct {
	Events           []*CongroupUpdateEvent `protobuf:"bytes,1,rep,name=events" json:"events,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *OrchestratorEvents) Reset()                    { *m = OrchestratorEvents{} }
func (m *OrchestratorEvents) String() string            { return proto.CompactTextString(m) }
func (*OrchestratorEvents) ProtoMessage()               {}
func (*OrchestratorEvents) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{50} }

func (m *OrchestratorEvents) GetEvents() []*CongroupUpdateEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

//
// KUBERNETES
//
type K8SPair struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *K8SPair) Reset()                    { *m = K8SPair{} }
func (m *K8SPair) String() string            { return proto.CompactTextString(m) }
func (*K8SPair) ProtoMessage()               {}
func (*K8SPair) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{51} }

func (m *K8SPair) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *K8SPair) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type K8SCommon struct {
	Name             *string    `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Uid              *string    `protobuf:"bytes,2,req,name=uid" json:"uid,omitempty"`
	Namespace        *string    `protobuf:"bytes,3,opt,name=namespace" json:"namespace,omitempty"`
	Labels           []*K8SPair `protobuf:"bytes,4,rep,name=labels" json:"labels,omitempty"`
	Selectors        []*K8SPair `protobuf:"bytes,5,rep,name=selectors" json:"selectors,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *K8SCommon) Reset()                    { *m = K8SCommon{} }
func (m *K8SCommon) String() string            { return proto.CompactTextString(m) }
func (*K8SCommon) ProtoMessage()               {}
func (*K8SCommon) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{52} }

func (m *K8SCommon) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *K8SCommon) GetUid() string {
	if m != nil && m.Uid != nil {
		return *m.Uid
	}
	return ""
}

func (m *K8SCommon) GetNamespace() string {
	if m != nil && m.Namespace != nil {
		return *m.Namespace
	}
	return ""
}

func (m *K8SCommon) GetLabels() []*K8SPair {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *K8SCommon) GetSelectors() []*K8SPair {
	if m != nil {
		return m.Selectors
	}
	return nil
}

type K8SNamespace struct {
	Common           *K8SCommon `protobuf:"bytes,1,req,name=common" json:"common,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *K8SNamespace) Reset()                    { *m = K8SNamespace{} }
func (m *K8SNamespace) String() string            { return proto.CompactTextString(m) }
func (*K8SNamespace) ProtoMessage()               {}
func (*K8SNamespace) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{53} }

func (m *K8SNamespace) GetCommon() *K8SCommon {
	if m != nil {
		return m.Common
	}
	return nil
}

type K8SNode struct {
	Common           *K8SCommon `protobuf:"bytes,1,req,name=common" json:"common,omitempty"`
	HostIps          []string   `protobuf:"bytes,2,rep,name=host_ips,json=hostIps" json:"host_ips,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *K8SNode) Reset()                    { *m = K8SNode{} }
func (m *K8SNode) String() string            { return proto.CompactTextString(m) }
func (*K8SNode) ProtoMessage()               {}
func (*K8SNode) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{54} }

func (m *K8SNode) GetCommon() *K8SCommon {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *K8SNode) GetHostIps() []string {
	if m != nil {
		return m.HostIps
	}
	return nil
}

type K8SPod struct {
	Common           *K8SCommon `protobuf:"bytes,1,req,name=common" json:"common,omitempty"`
	ContainerIds     []string   `protobuf:"bytes,2,rep,name=container_ids,json=containerIds" json:"container_ids,omitempty"`
	NodeName         *string    `protobuf:"bytes,3,opt,name=node_name,json=nodeName" json:"node_name,omitempty"`
	HostIp           *string    `protobuf:"bytes,4,opt,name=host_ip,json=hostIp" json:"host_ip,omitempty"`
	InternalIp       *string    `protobuf:"bytes,5,opt,name=internal_ip,json=internalIp" json:"internal_ip,omitempty"`
	RestartCount     *uint32    `protobuf:"varint,6,opt,name=restart_count,json=restartCount" json:"restart_count,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *K8SPod) Reset()                    { *m = K8SPod{} }
func (m *K8SPod) String() string            { return proto.CompactTextString(m) }
func (*K8SPod) ProtoMessage()               {}
func (*K8SPod) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{55} }

func (m *K8SPod) GetCommon() *K8SCommon {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *K8SPod) GetContainerIds() []string {
	if m != nil {
		return m.ContainerIds
	}
	return nil
}

func (m *K8SPod) GetNodeName() string {
	if m != nil && m.NodeName != nil {
		return *m.NodeName
	}
	return ""
}

func (m *K8SPod) GetHostIp() string {
	if m != nil && m.HostIp != nil {
		return *m.HostIp
	}
	return ""
}

func (m *K8SPod) GetInternalIp() string {
	if m != nil && m.InternalIp != nil {
		return *m.InternalIp
	}
	return ""
}

func (m *K8SPod) GetRestartCount() uint32 {
	if m != nil && m.RestartCount != nil {
		return *m.RestartCount
	}
	return 0
}

type K8SReplicationController struct {
	Common           *K8SCommon `protobuf:"bytes,1,req,name=common" json:"common,omitempty"`
	ReplicasDesired  *uint32    `protobuf:"varint,2,opt,name=replicas_desired,json=replicasDesired" json:"replicas_desired,omitempty"`
	ReplicasRunning  *uint32    `protobuf:"varint,3,opt,name=replicas_running,json=replicasRunning" json:"replicas_running,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *K8SReplicationController) Reset()                    { *m = K8SReplicationController{} }
func (m *K8SReplicationController) String() string            { return proto.CompactTextString(m) }
func (*K8SReplicationController) ProtoMessage()               {}
func (*K8SReplicationController) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{56} }

func (m *K8SReplicationController) GetCommon() *K8SCommon {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *K8SReplicationController) GetReplicasDesired() uint32 {
	if m != nil && m.ReplicasDesired != nil {
		return *m.ReplicasDesired
	}
	return 0
}

func (m *K8SReplicationController) GetReplicasRunning() uint32 {
	if m != nil && m.ReplicasRunning != nil {
		return *m.ReplicasRunning
	}
	return 0
}

type K8SReplicaSet struct {
	Common           *K8SCommon `protobuf:"bytes,1,req,name=common" json:"common,omitempty"`
	ReplicasDesired  *uint32    `protobuf:"varint,2,opt,name=replicas_desired,json=replicasDesired" json:"replicas_desired,omitempty"`
	ReplicasRunning  *uint32    `protobuf:"varint,3,opt,name=replicas_running,json=replicasRunning" json:"replicas_running,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *K8SReplicaSet) Reset()                    { *m = K8SReplicaSet{} }
func (m *K8SReplicaSet) String() string            { return proto.CompactTextString(m) }
func (*K8SReplicaSet) ProtoMessage()               {}
func (*K8SReplicaSet) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{57} }

func (m *K8SReplicaSet) GetCommon() *K8SCommon {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *K8SReplicaSet) GetReplicasDesired() uint32 {
	if m != nil && m.ReplicasDesired != nil {
		return *m.ReplicasDesired
	}
	return 0
}

func (m *K8SReplicaSet) GetReplicasRunning() uint32 {
	if m != nil && m.ReplicasRunning != nil {
		return *m.ReplicasRunning
	}
	return 0
}

type K8SService struct {
	Common           *K8SCommon           `protobuf:"bytes,1,req,name=common" json:"common,omitempty"`
	ClusterIp        *string              `protobuf:"bytes,2,opt,name=cluster_ip,json=clusterIp" json:"cluster_ip,omitempty"`
	Ports            []*K8SServiceNetPort `protobuf:"bytes,3,rep,name=ports" json:"ports,omitempty"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *K8SService) Reset()                    { *m = K8SService{} }
func (m *K8SService) String() string            { return proto.CompactTextString(m) }
func (*K8SService) ProtoMessage()               {}
func (*K8SService) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{58} }

func (m *K8SService) GetCommon() *K8SCommon {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *K8SService) GetClusterIp() string {
	if m != nil && m.ClusterIp != nil {
		return *m.ClusterIp
	}
	return ""
}

func (m *K8SService) GetPorts() []*K8SServiceNetPort {
	if m != nil {
		return m.Ports
	}
	return nil
}

type K8SServiceNetPort struct {
	Port             *uint32 `protobuf:"varint,1,req,name=port" json:"port,omitempty"`
	TargetPort       *uint32 `protobuf:"varint,2,req,name=target_port,json=targetPort" json:"target_port,omitempty"`
	Protocol         *string `protobuf:"bytes,3,opt,name=protocol" json:"protocol,omitempty"`
	NodePort         *uint32 `protobuf:"varint,4,opt,name=node_port,json=nodePort" json:"node_port,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *K8SServiceNetPort) Reset()                    { *m = K8SServiceNetPort{} }
func (m *K8SServiceNetPort) String() string            { return proto.CompactTextString(m) }
func (*K8SServiceNetPort) ProtoMessage()               {}
func (*K8SServiceNetPort) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{58, 0} }

func (m *K8SServiceNetPort) GetPort() uint32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *K8SServiceNetPort) GetTargetPort() uint32 {
	if m != nil && m.TargetPort != nil {
		return *m.TargetPort
	}
	return 0
}

func (m *K8SServiceNetPort) GetProtocol() string {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return ""
}

func (m *K8SServiceNetPort) GetNodePort() uint32 {
	if m != nil && m.NodePort != nil {
		return *m.NodePort
	}
	return 0
}

type K8SDeployment struct {
	Common           *K8SCommon `protobuf:"bytes,1,req,name=common" json:"common,omitempty"`
	ReplicasDesired  *uint32    `protobuf:"varint,2,opt,name=replicas_desired,json=replicasDesired" json:"replicas_desired,omitempty"`
	ReplicasRunning  *uint32    `protobuf:"varint,3,opt,name=replicas_running,json=replicasRunning" json:"replicas_running,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *K8SDeployment) Reset()                    { *m = K8SDeployment{} }
func (m *K8SDeployment) String() string            { return proto.CompactTextString(m) }
func (*K8SDeployment) ProtoMessage()               {}
func (*K8SDeployment) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{59} }

func (m *K8SDeployment) GetCommon() *K8SCommon {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *K8SDeployment) GetReplicasDesired() uint32 {
	if m != nil && m.ReplicasDesired != nil {
		return *m.ReplicasDesired
	}
	return 0
}

func (m *K8SDeployment) GetReplicasRunning() uint32 {
	if m != nil && m.ReplicasRunning != nil {
		return *m.ReplicasRunning
	}
	return 0
}

type K8SDaemonset struct {
	Common           *K8SCommon `protobuf:"bytes,1,req,name=common" json:"common,omitempty"`
	CurrentScheduled *uint32    `protobuf:"varint,2,opt,name=current_scheduled,json=currentScheduled" json:"current_scheduled,omitempty"`
	DesiredScheduled *uint32    `protobuf:"varint,3,opt,name=desired_scheduled,json=desiredScheduled" json:"desired_scheduled,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *K8SDaemonset) Reset()                    { *m = K8SDaemonset{} }
func (m *K8SDaemonset) String() string            { return proto.CompactTextString(m) }
func (*K8SDaemonset) ProtoMessage()               {}
func (*K8SDaemonset) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{60} }

func (m *K8SDaemonset) GetCommon() *K8SCommon {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *K8SDaemonset) GetCurrentScheduled() uint32 {
	if m != nil && m.CurrentScheduled != nil {
		return *m.CurrentScheduled
	}
	return 0
}

func (m *K8SDaemonset) GetDesiredScheduled() uint32 {
	if m != nil && m.DesiredScheduled != nil {
		return *m.DesiredScheduled
	}
	return 0
}

type K8SState struct {
	Namespaces       []*K8SNamespace             `protobuf:"bytes,1,rep,name=namespaces" json:"namespaces,omitempty"`
	Nodes            []*K8SNode                  `protobuf:"bytes,2,rep,name=nodes" json:"nodes,omitempty"`
	Pods             []*K8SPod                   `protobuf:"bytes,3,rep,name=pods" json:"pods,omitempty"`
	Controllers      []*K8SReplicationController `protobuf:"bytes,4,rep,name=controllers" json:"controllers,omitempty"`
	Services         []*K8SService               `protobuf:"bytes,5,rep,name=services" json:"services,omitempty"`
	ReplicaSets      []*K8SReplicaSet            `protobuf:"bytes,6,rep,name=replica_sets,json=replicaSets" json:"replica_sets,omitempty"`
	Deployments      []*K8SDeployment            `protobuf:"bytes,7,rep,name=deployments" json:"deployments,omitempty"`
	Daemonsets       []*K8SDaemonset             `protobuf:"bytes,8,rep,name=daemonsets" json:"daemonsets,omitempty"`
	XXX_unrecognized []byte                      `json:"-"`
}

func (m *K8SState) Reset()                    { *m = K8SState{} }
func (m *K8SState) String() string            { return proto.CompactTextString(m) }
func (*K8SState) ProtoMessage()               {}
func (*K8SState) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{61} }

func (m *K8SState) GetNamespaces() []*K8SNamespace {
	if m != nil {
		return m.Namespaces
	}
	return nil
}

func (m *K8SState) GetNodes() []*K8SNode {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *K8SState) GetPods() []*K8SPod {
	if m != nil {
		return m.Pods
	}
	return nil
}

func (m *K8SState) GetControllers() []*K8SReplicationController {
	if m != nil {
		return m.Controllers
	}
	return nil
}

func (m *K8SState) GetServices() []*K8SService {
	if m != nil {
		return m.Services
	}
	return nil
}

func (m *K8SState) GetReplicaSets() []*K8SReplicaSet {
	if m != nil {
		return m.ReplicaSets
	}
	return nil
}

func (m *K8SState) GetDeployments() []*K8SDeployment {
	if m != nil {
		return m.Deployments
	}
	return nil
}

func (m *K8SState) GetDaemonsets() []*K8SDaemonset {
	if m != nil {
		return m.Daemonsets
	}
	return nil
}

type MesosPair struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *MesosPair) Reset()                    { *m = MesosPair{} }
func (m *MesosPair) String() string            { return proto.CompactTextString(m) }
func (*MesosPair) ProtoMessage()               {}
func (*MesosPair) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{62} }

func (m *MesosPair) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *MesosPair) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type MesosCommon struct {
	Uid              *string      `protobuf:"bytes,1,req,name=uid" json:"uid,omitempty"`
	Name             *string      `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Labels           []*MesosPair `protobuf:"bytes,3,rep,name=labels" json:"labels,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *MesosCommon) Reset()                    { *m = MesosCommon{} }
func (m *MesosCommon) String() string            { return proto.CompactTextString(m) }
func (*MesosCommon) ProtoMessage()               {}
func (*MesosCommon) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{63} }

func (m *MesosCommon) GetUid() string {
	if m != nil && m.Uid != nil {
		return *m.Uid
	}
	return ""
}

func (m *MesosCommon) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *MesosCommon) GetLabels() []*MesosPair {
	if m != nil {
		return m.Labels
	}
	return nil
}

type MesosTask struct {
	Common           *MesosCommon `protobuf:"bytes,1,req,name=common" json:"common,omitempty"`
	SlaveId          *string      `protobuf:"bytes,2,req,name=slave_id,json=slaveId" json:"slave_id,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *MesosTask) Reset()                    { *m = MesosTask{} }
func (m *MesosTask) String() string            { return proto.CompactTextString(m) }
func (*MesosTask) ProtoMessage()               {}
func (*MesosTask) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{64} }

func (m *MesosTask) GetCommon() *MesosCommon {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *MesosTask) GetSlaveId() string {
	if m != nil && m.SlaveId != nil {
		return *m.SlaveId
	}
	return ""
}

type MarathonApp struct {
	Id               *string  `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	TaskIds          []string `protobuf:"bytes,2,rep,name=task_ids,json=taskIds" json:"task_ids,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *MarathonApp) Reset()                    { *m = MarathonApp{} }
func (m *MarathonApp) String() string            { return proto.CompactTextString(m) }
func (*MarathonApp) ProtoMessage()               {}
func (*MarathonApp) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{65} }

func (m *MarathonApp) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *MarathonApp) GetTaskIds() []string {
	if m != nil {
		return m.TaskIds
	}
	return nil
}

type MarathonGroup struct {
	Id               *string          `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	Apps             []*MarathonApp   `protobuf:"bytes,2,rep,name=apps" json:"apps,omitempty"`
	Groups           []*MarathonGroup `protobuf:"bytes,3,rep,name=groups" json:"groups,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *MarathonGroup) Reset()                    { *m = MarathonGroup{} }
func (m *MarathonGroup) String() string            { return proto.CompactTextString(m) }
func (*MarathonGroup) ProtoMessage()               {}
func (*MarathonGroup) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{66} }

func (m *MarathonGroup) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *MarathonGroup) GetApps() []*MarathonApp {
	if m != nil {
		return m.Apps
	}
	return nil
}

func (m *MarathonGroup) GetGroups() []*MarathonGroup {
	if m != nil {
		return m.Groups
	}
	return nil
}

type MesosFramework struct {
	Common           *MesosCommon `protobuf:"bytes,1,req,name=common" json:"common,omitempty"`
	Tasks            []*MesosTask `protobuf:"bytes,2,rep,name=tasks" json:"tasks,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *MesosFramework) Reset()                    { *m = MesosFramework{} }
func (m *MesosFramework) String() string            { return proto.CompactTextString(m) }
func (*MesosFramework) ProtoMessage()               {}
func (*MesosFramework) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{67} }

func (m *MesosFramework) GetCommon() *MesosCommon {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *MesosFramework) GetTasks() []*MesosTask {
	if m != nil {
		return m.Tasks
	}
	return nil
}

type MesosSlave struct {
	Common           *MesosCommon `protobuf:"bytes,1,req,name=common" json:"common,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *MesosSlave) Reset()                    { *m = MesosSlave{} }
func (m *MesosSlave) String() string            { return proto.CompactTextString(m) }
func (*MesosSlave) ProtoMessage()               {}
func (*MesosSlave) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{68} }

func (m *MesosSlave) GetCommon() *MesosCommon {
	if m != nil {
		return m.Common
	}
	return nil
}

type MesosState struct {
	Frameworks       []*MesosFramework `protobuf:"bytes,1,rep,name=frameworks" json:"frameworks,omitempty"`
	Groups           []*MarathonGroup  `protobuf:"bytes,2,rep,name=groups" json:"groups,omitempty"`
	Slaves           []*MesosSlave     `protobuf:"bytes,3,rep,name=slaves" json:"slaves,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *MesosState) Reset()                    { *m = MesosState{} }
func (m *MesosState) String() string            { return proto.CompactTextString(m) }
func (*MesosState) ProtoMessage()               {}
func (*MesosState) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{69} }

func (m *MesosState) GetFrameworks() []*MesosFramework {
	if m != nil {
		return m.Frameworks
	}
	return nil
}

func (m *MesosState) GetGroups() []*MarathonGroup {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *MesosState) GetSlaves() []*MesosSlave {
	if m != nil {
		return m.Slaves
	}
	return nil
}

type SwarmPair struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SwarmPair) Reset()                    { *m = SwarmPair{} }
func (m *SwarmPair) String() string            { return proto.CompactTextString(m) }
func (*SwarmPair) ProtoMessage()               {}
func (*SwarmPair) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{70} }

func (m *SwarmPair) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *SwarmPair) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type SwarmPort struct {
	Port             *uint32 `protobuf:"varint,1,opt,name=port" json:"port,omitempty"`
	PublishedPort    *uint32 `protobuf:"varint,2,opt,name=published_port,json=publishedPort" json:"published_port,omitempty"`
	Protocol         *string `protobuf:"bytes,3,opt,name=protocol" json:"protocol,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SwarmPort) Reset()                    { *m = SwarmPort{} }
func (m *SwarmPort) String() string            { return proto.CompactTextString(m) }
func (*SwarmPort) ProtoMessage()               {}
func (*SwarmPort) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{71} }

func (m *SwarmPort) GetPort() uint32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *SwarmPort) GetPublishedPort() uint32 {
	if m != nil && m.PublishedPort != nil {
		return *m.PublishedPort
	}
	return 0
}

func (m *SwarmPort) GetProtocol() string {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return ""
}

type SwarmCommon struct {
	Id               *string      `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Name             *string      `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Labels           []*SwarmPair `protobuf:"bytes,3,rep,name=labels" json:"labels,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *SwarmCommon) Reset()                    { *m = SwarmCommon{} }
func (m *SwarmCommon) String() string            { return proto.CompactTextString(m) }
func (*SwarmCommon) ProtoMessage()               {}
func (*SwarmCommon) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{72} }

func (m *SwarmCommon) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *SwarmCommon) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *SwarmCommon) GetLabels() []*SwarmPair {
	if m != nil {
		return m.Labels
	}
	return nil
}

type SwarmService struct {
	Common     *SwarmCommon `protobuf:"bytes,1,opt,name=common" json:"common,omitempty"`
	VirtualIps []string     `protobuf:"bytes,2,rep,name=virtual_ips,json=virtualIps" json:"virtual_ips,omitempty"`
	// Ports will be available only for published services
	// internal service don't need it, even if they load
	// balance traffic as well
	Ports            []*SwarmPort      `protobuf:"bytes,3,rep,name=ports" json:"ports,omitempty"`
	Mode             *SwarmServiceMode `protobuf:"varint,4,opt,name=mode,enum=draiosproto.SwarmServiceMode" json:"mode,omitempty"`
	SpecReplicas     *uint64           `protobuf:"varint,5,opt,name=spec_replicas,json=specReplicas" json:"spec_replicas,omitempty"`
	Tasks            *uint64           `protobuf:"varint,6,opt,name=tasks" json:"tasks,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *SwarmService) Reset()                    { *m = SwarmService{} }
func (m *SwarmService) String() string            { return proto.CompactTextString(m) }
func (*SwarmService) ProtoMessage()               {}
func (*SwarmService) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{73} }

func (m *SwarmService) GetCommon() *SwarmCommon {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *SwarmService) GetVirtualIps() []string {
	if m != nil {
		return m.VirtualIps
	}
	return nil
}

func (m *SwarmService) GetPorts() []*SwarmPort {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *SwarmService) GetMode() SwarmServiceMode {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return SwarmServiceMode_REPLICATED
}

func (m *SwarmService) GetSpecReplicas() uint64 {
	if m != nil && m.SpecReplicas != nil {
		return *m.SpecReplicas
	}
	return 0
}

func (m *SwarmService) GetTasks() uint64 {
	if m != nil && m.Tasks != nil {
		return *m.Tasks
	}
	return 0
}

type SwarmTask struct {
	Common           *SwarmCommon `protobuf:"bytes,1,opt,name=common" json:"common,omitempty"`
	ServiceId        *string      `protobuf:"bytes,2,opt,name=service_id,json=serviceId" json:"service_id,omitempty"`
	NodeId           *string      `protobuf:"bytes,3,opt,name=node_id,json=nodeId" json:"node_id,omitempty"`
	ContainerId      *string      `protobuf:"bytes,4,opt,name=container_id,json=containerId" json:"container_id,omitempty"`
	State            *string      `protobuf:"bytes,5,opt,name=state" json:"state,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *SwarmTask) Reset()                    { *m = SwarmTask{} }
func (m *SwarmTask) String() string            { return proto.CompactTextString(m) }
func (*SwarmTask) ProtoMessage()               {}
func (*SwarmTask) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{74} }

func (m *SwarmTask) GetCommon() *SwarmCommon {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *SwarmTask) GetServiceId() string {
	if m != nil && m.ServiceId != nil {
		return *m.ServiceId
	}
	return ""
}

func (m *SwarmTask) GetNodeId() string {
	if m != nil && m.NodeId != nil {
		return *m.NodeId
	}
	return ""
}

func (m *SwarmTask) GetContainerId() string {
	if m != nil && m.ContainerId != nil {
		return *m.ContainerId
	}
	return ""
}

func (m *SwarmTask) GetState() string {
	if m != nil && m.State != nil {
		return *m.State
	}
	return ""
}

type SwarmManager struct {
	Leader           *bool   `protobuf:"varint,1,opt,name=leader" json:"leader,omitempty"`
	Reachability     *string `protobuf:"bytes,2,opt,name=reachability" json:"reachability,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SwarmManager) Reset()                    { *m = SwarmManager{} }
func (m *SwarmManager) String() string            { return proto.CompactTextString(m) }
func (*SwarmManager) ProtoMessage()               {}
func (*SwarmManager) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{75} }

func (m *SwarmManager) GetLeader() bool {
	if m != nil && m.Leader != nil {
		return *m.Leader
	}
	return false
}

func (m *SwarmManager) GetReachability() string {
	if m != nil && m.Reachability != nil {
		return *m.Reachability
	}
	return ""
}

type SwarmNode struct {
	// hostname of the node is inside common.name
	Common           *SwarmCommon  `protobuf:"bytes,1,opt,name=common" json:"common,omitempty"`
	Role             *string       `protobuf:"bytes,2,opt,name=role" json:"role,omitempty"`
	IpAddress        *string       `protobuf:"bytes,3,opt,name=ip_address,json=ipAddress" json:"ip_address,omitempty"`
	Version          *string       `protobuf:"bytes,4,opt,name=version" json:"version,omitempty"`
	Availability     *string       `protobuf:"bytes,5,opt,name=availability" json:"availability,omitempty"`
	State            *string       `protobuf:"bytes,6,opt,name=state" json:"state,omitempty"`
	Manager          *SwarmManager `protobuf:"bytes,7,opt,name=manager" json:"manager,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *SwarmNode) Reset()                    { *m = SwarmNode{} }
func (m *SwarmNode) String() string            { return proto.CompactTextString(m) }
func (*SwarmNode) ProtoMessage()               {}
func (*SwarmNode) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{76} }

func (m *SwarmNode) GetCommon() *SwarmCommon {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *SwarmNode) GetRole() string {
	if m != nil && m.Role != nil {
		return *m.Role
	}
	return ""
}

func (m *SwarmNode) GetIpAddress() string {
	if m != nil && m.IpAddress != nil {
		return *m.IpAddress
	}
	return ""
}

func (m *SwarmNode) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

func (m *SwarmNode) GetAvailability() string {
	if m != nil && m.Availability != nil {
		return *m.Availability
	}
	return ""
}

func (m *SwarmNode) GetState() string {
	if m != nil && m.State != nil {
		return *m.State
	}
	return ""
}

func (m *SwarmNode) GetManager() *SwarmManager {
	if m != nil {
		return m.Manager
	}
	return nil
}

type SwarmState struct {
	// This values will be filled only
	// by swarm manager nodes
	Services []*SwarmService `protobuf:"bytes,2,rep,name=services" json:"services,omitempty"`
	Nodes    []*SwarmNode    `protobuf:"bytes,3,rep,name=nodes" json:"nodes,omitempty"`
	Tasks    []*SwarmTask    `protobuf:"bytes,4,rep,name=tasks" json:"tasks,omitempty"`
	Quorum   *bool           `protobuf:"varint,5,opt,name=quorum" json:"quorum,omitempty"`
	// Every node in the cluster will send its node_id
	// it can be used if we'll hit duplicate ip addresses
	NodeId           *string `protobuf:"bytes,7,opt,name=node_id,json=nodeId" json:"node_id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SwarmState) Reset()                    { *m = SwarmState{} }
func (m *SwarmState) String() string            { return proto.CompactTextString(m) }
func (*SwarmState) ProtoMessage()               {}
func (*SwarmState) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{77} }

func (m *SwarmState) GetServices() []*SwarmService {
	if m != nil {
		return m.Services
	}
	return nil
}

func (m *SwarmState) GetNodes() []*SwarmNode {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *SwarmState) GetTasks() []*SwarmTask {
	if m != nil {
		return m.Tasks
	}
	return nil
}

func (m *SwarmState) GetQuorum() bool {
	if m != nil && m.Quorum != nil {
		return *m.Quorum
	}
	return false
}

func (m *SwarmState) GetNodeId() string {
	if m != nil && m.NodeId != nil {
		return *m.NodeId
	}
	return ""
}

type OrchestratorStateT struct {
	Groups []*ContainerGroup `protobuf:"bytes,1,rep,name=groups" json:"groups,omitempty"`
	// This is the UID of default namespace
	ClusterId *string `protobuf:"bytes,2,opt,name=cluster_id,json=clusterId" json:"cluster_id,omitempty"`
	// This is a *likely* unique identifier set by customer or automatically
	// scraped by AWS, GCP and so on
	ClusterName      *string `protobuf:"bytes,3,opt,name=cluster_name,json=clusterName" json:"cluster_name,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *OrchestratorStateT) Reset()                    { *m = OrchestratorStateT{} }
func (m *OrchestratorStateT) String() string            { return proto.CompactTextString(m) }
func (*OrchestratorStateT) ProtoMessage()               {}
func (*OrchestratorStateT) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{78} }

func (m *OrchestratorStateT) GetGroups() []*ContainerGroup {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *OrchestratorStateT) GetClusterId() string {
	if m != nil && m.ClusterId != nil {
		return *m.ClusterId
	}
	return ""
}

func (m *OrchestratorStateT) GetClusterName() string {
	if m != nil && m.ClusterName != nil {
		return *m.ClusterName
	}
	return ""
}

// ENTRY POINT MESSAGE
//
type Metrics struct {
	TimestampNs    *uint64 `protobuf:"varint,1,req,name=timestamp_ns,json=timestampNs" json:"timestamp_ns,omitempty"`
	MachineId      *string `protobuf:"bytes,2,req,name=machine_id,json=machineId" json:"machine_id,omitempty"`
	CustomerId     *string `protobuf:"bytes,3,opt,name=customer_id,json=customerId" json:"customer_id,omitempty"`
	SamplingRatio  *uint32 `protobuf:"varint,10,opt,name=sampling_ratio,json=samplingRatio" json:"sampling_ratio,omitempty"`
	HostCustomName *string `protobuf:"bytes,11,opt,name=host_custom_name,json=hostCustomName" json:"host_custom_name,omitempty"`
	HostTags       *string `protobuf:"bytes,12,opt,name=host_tags,json=hostTags" json:"host_tags,omitempty"`
	// NEVER USED optional string host_custom_map = 13; // This machines's user-set custom map for the draios UI.
	IsHostHidden    *bool      `protobuf:"varint,14,opt,name=is_host_hidden,json=isHostHidden" json:"is_host_hidden,omitempty"`
	HiddenProcesses *string    `protobuf:"bytes,15,opt,name=hidden_processes,json=hiddenProcesses" json:"hidden_processes,omitempty"`
	Version         *string    `protobuf:"bytes,16,opt,name=version" json:"version,omitempty"`
	InstanceId      *string    `protobuf:"bytes,21,opt,name=instance_id,json=instanceId" json:"instance_id,omitempty"`
	Hostinfo        *Host      `protobuf:"bytes,4,opt,name=hostinfo" json:"hostinfo,omitempty"`
	Programs        []*Program `protobuf:"bytes,9,rep,name=programs" json:"programs,omitempty"`
	// NEVER USED repeated process processes = 5; // The list of processes
	Ipv4Connections       []*Ipv4Connection       `protobuf:"bytes,7,rep,name=ipv4_connections,json=ipv4Connections" json:"ipv4_connections,omitempty"`
	Ipv4NetworkInterfaces []*Ipv4NetworkInterface `protobuf:"bytes,8,rep,name=ipv4_network_interfaces,json=ipv4NetworkInterfaces" json:"ipv4_network_interfaces,omitempty"`
	Commands              []*CommandDetails       `protobuf:"bytes,28,rep,name=commands" json:"commands,omitempty"`
	Mounts                []*MountedFs            `protobuf:"bytes,18,rep,name=mounts" json:"mounts,omitempty"`
	TopFiles              []*FileStat             `protobuf:"bytes,19,rep,name=top_files,json=topFiles" json:"top_files,omitempty"`
	Protos                *ProtoInfo              `protobuf:"bytes,20,opt,name=protos" json:"protos,omitempty"`
	Containers            []*Container            `protobuf:"bytes,22,rep,name=containers" json:"containers,omitempty"`
	// NEVER USED (used by back-end) repeated string machine_ids = 23; //machine IDs aggregated for this group
	OrchestratorState       *OrchestratorStateT `protobuf:"bytes,34,opt,name=orchestrator_state,json=orchestratorState" json:"orchestrator_state,omitempty"`
	GlobalOrchestratorState *OrchestratorStateT `protobuf:"bytes,32,opt,name=global_orchestrator_state,json=globalOrchestratorState" json:"global_orchestrator_state,omitempty"`
	Kubernetes              *K8SState           `protobuf:"bytes,24,opt,name=kubernetes" json:"kubernetes,omitempty"`
	Mesos                   *MesosState         `protobuf:"bytes,25,opt,name=mesos" json:"mesos,omitempty"`
	Events                  []*AgentEvent       `protobuf:"bytes,26,rep,name=events" json:"events,omitempty"`
	Falcobl                 *FalcoBaseline      `protobuf:"bytes,27,opt,name=falcobl" json:"falcobl,omitempty"`
	Swarm                   *SwarmState         `protobuf:"bytes,29,opt,name=swarm" json:"swarm,omitempty"`
	ConfigPercentiles       []uint32            `protobuf:"varint,30,rep,name=config_percentiles,json=configPercentiles" json:"config_percentiles,omitempty"`
	InternalMetrics         *StatsdInfo         `protobuf:"bytes,31,opt,name=internal_metrics,json=internalMetrics" json:"internal_metrics,omitempty"`
	XXX_unrecognized        []byte              `json:"-"`
}

func (m *Metrics) Reset()                    { *m = Metrics{} }
func (m *Metrics) String() string            { return proto.CompactTextString(m) }
func (*Metrics) ProtoMessage()               {}
func (*Metrics) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{79} }

func (m *Metrics) GetTimestampNs() uint64 {
	if m != nil && m.TimestampNs != nil {
		return *m.TimestampNs
	}
	return 0
}

func (m *Metrics) GetMachineId() string {
	if m != nil && m.MachineId != nil {
		return *m.MachineId
	}
	return ""
}

func (m *Metrics) GetCustomerId() string {
	if m != nil && m.CustomerId != nil {
		return *m.CustomerId
	}
	return ""
}

func (m *Metrics) GetSamplingRatio() uint32 {
	if m != nil && m.SamplingRatio != nil {
		return *m.SamplingRatio
	}
	return 0
}

func (m *Metrics) GetHostCustomName() string {
	if m != nil && m.HostCustomName != nil {
		return *m.HostCustomName
	}
	return ""
}

func (m *Metrics) GetHostTags() string {
	if m != nil && m.HostTags != nil {
		return *m.HostTags
	}
	return ""
}

func (m *Metrics) GetIsHostHidden() bool {
	if m != nil && m.IsHostHidden != nil {
		return *m.IsHostHidden
	}
	return false
}

func (m *Metrics) GetHiddenProcesses() string {
	if m != nil && m.HiddenProcesses != nil {
		return *m.HiddenProcesses
	}
	return ""
}

func (m *Metrics) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

func (m *Metrics) GetInstanceId() string {
	if m != nil && m.InstanceId != nil {
		return *m.InstanceId
	}
	return ""
}

func (m *Metrics) GetHostinfo() *Host {
	if m != nil {
		return m.Hostinfo
	}
	return nil
}

func (m *Metrics) GetPrograms() []*Program {
	if m != nil {
		return m.Programs
	}
	return nil
}

func (m *Metrics) GetIpv4Connections() []*Ipv4Connection {
	if m != nil {
		return m.Ipv4Connections
	}
	return nil
}

func (m *Metrics) GetIpv4NetworkInterfaces() []*Ipv4NetworkInterface {
	if m != nil {
		return m.Ipv4NetworkInterfaces
	}
	return nil
}

func (m *Metrics) GetCommands() []*CommandDetails {
	if m != nil {
		return m.Commands
	}
	return nil
}

func (m *Metrics) GetMounts() []*MountedFs {
	if m != nil {
		return m.Mounts
	}
	return nil
}

func (m *Metrics) GetTopFiles() []*FileStat {
	if m != nil {
		return m.TopFiles
	}
	return nil
}

func (m *Metrics) GetProtos() *ProtoInfo {
	if m != nil {
		return m.Protos
	}
	return nil
}

func (m *Metrics) GetContainers() []*Container {
	if m != nil {
		return m.Containers
	}
	return nil
}

func (m *Metrics) GetOrchestratorState() *OrchestratorStateT {
	if m != nil {
		return m.OrchestratorState
	}
	return nil
}

func (m *Metrics) GetGlobalOrchestratorState() *OrchestratorStateT {
	if m != nil {
		return m.GlobalOrchestratorState
	}
	return nil
}

func (m *Metrics) GetKubernetes() *K8SState {
	if m != nil {
		return m.Kubernetes
	}
	return nil
}

func (m *Metrics) GetMesos() *MesosState {
	if m != nil {
		return m.Mesos
	}
	return nil
}

func (m *Metrics) GetEvents() []*AgentEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *Metrics) GetFalcobl() *FalcoBaseline {
	if m != nil {
		return m.Falcobl
	}
	return nil
}

func (m *Metrics) GetSwarm() *SwarmState {
	if m != nil {
		return m.Swarm
	}
	return nil
}

func (m *Metrics) GetConfigPercentiles() []uint32 {
	if m != nil {
		return m.ConfigPercentiles
	}
	return nil
}

func (m *Metrics) GetInternalMetrics() *StatsdInfo {
	if m != nil {
		return m.InternalMetrics
	}
	return nil
}

type DumpRequestStart struct {
	TimestampNs    *uint64 `protobuf:"varint,1,req,name=timestamp_ns,json=timestampNs" json:"timestamp_ns,omitempty"`
	MachineId      *string `protobuf:"bytes,2,req,name=machine_id,json=machineId" json:"machine_id,omitempty"`
	CustomerId     *string `protobuf:"bytes,3,opt,name=customer_id,json=customerId" json:"customer_id,omitempty"`
	DurationNs     *uint64 `protobuf:"varint,4,opt,name=duration_ns,json=durationNs" json:"duration_ns,omitempty"`
	Filters        *string `protobuf:"bytes,5,opt,name=filters" json:"filters,omitempty"`
	MaxSize        *uint64 `protobuf:"varint,7,opt,name=max_size,json=maxSize" json:"max_size,omitempty"`
	Token          *string `protobuf:"bytes,6,req,name=token" json:"token,omitempty"`
	PastDurationNs *uint64 `protobuf:"varint,8,opt,name=past_duration_ns,json=pastDurationNs" json:"past_duration_ns,omitempty"`
	// This works only if the agent has been configured with rotational capture
	PastSize         *uint64 `protobuf:"varint,9,opt,name=past_size,json=pastSize" json:"past_size,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DumpRequestStart) Reset()                    { *m = DumpRequestStart{} }
func (m *DumpRequestStart) String() string            { return proto.CompactTextString(m) }
func (*DumpRequestStart) ProtoMessage()               {}
func (*DumpRequestStart) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{80} }

func (m *DumpRequestStart) GetTimestampNs() uint64 {
	if m != nil && m.TimestampNs != nil {
		return *m.TimestampNs
	}
	return 0
}

func (m *DumpRequestStart) GetMachineId() string {
	if m != nil && m.MachineId != nil {
		return *m.MachineId
	}
	return ""
}

func (m *DumpRequestStart) GetCustomerId() string {
	if m != nil && m.CustomerId != nil {
		return *m.CustomerId
	}
	return ""
}

func (m *DumpRequestStart) GetDurationNs() uint64 {
	if m != nil && m.DurationNs != nil {
		return *m.DurationNs
	}
	return 0
}

func (m *DumpRequestStart) GetFilters() string {
	if m != nil && m.Filters != nil {
		return *m.Filters
	}
	return ""
}

func (m *DumpRequestStart) GetMaxSize() uint64 {
	if m != nil && m.MaxSize != nil {
		return *m.MaxSize
	}
	return 0
}

func (m *DumpRequestStart) GetToken() string {
	if m != nil && m.Token != nil {
		return *m.Token
	}
	return ""
}

func (m *DumpRequestStart) GetPastDurationNs() uint64 {
	if m != nil && m.PastDurationNs != nil {
		return *m.PastDurationNs
	}
	return 0
}

func (m *DumpRequestStart) GetPastSize() uint64 {
	if m != nil && m.PastSize != nil {
		return *m.PastSize
	}
	return 0
}

type DumpRequestStop struct {
	TimestampNs      *uint64 `protobuf:"varint,1,req,name=timestamp_ns,json=timestampNs" json:"timestamp_ns,omitempty"`
	MachineId        *string `protobuf:"bytes,2,req,name=machine_id,json=machineId" json:"machine_id,omitempty"`
	CustomerId       *string `protobuf:"bytes,3,opt,name=customer_id,json=customerId" json:"customer_id,omitempty"`
	Token            *string `protobuf:"bytes,4,req,name=token" json:"token,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DumpRequestStop) Reset()                    { *m = DumpRequestStop{} }
func (m *DumpRequestStop) String() string            { return proto.CompactTextString(m) }
func (*DumpRequestStop) ProtoMessage()               {}
func (*DumpRequestStop) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{81} }

func (m *DumpRequestStop) GetTimestampNs() uint64 {
	if m != nil && m.TimestampNs != nil {
		return *m.TimestampNs
	}
	return 0
}

func (m *DumpRequestStop) GetMachineId() string {
	if m != nil && m.MachineId != nil {
		return *m.MachineId
	}
	return ""
}

func (m *DumpRequestStop) GetCustomerId() string {
	if m != nil && m.CustomerId != nil {
		return *m.CustomerId
	}
	return ""
}

func (m *DumpRequestStop) GetToken() string {
	if m != nil && m.Token != nil {
		return *m.Token
	}
	return ""
}

type DumpResponse struct {
	TimestampNs      *uint64 `protobuf:"varint,1,req,name=timestamp_ns,json=timestampNs" json:"timestamp_ns,omitempty"`
	MachineId        *string `protobuf:"bytes,2,req,name=machine_id,json=machineId" json:"machine_id,omitempty"`
	CustomerId       *string `protobuf:"bytes,3,opt,name=customer_id,json=customerId" json:"customer_id,omitempty"`
	ChunkNo          *uint32 `protobuf:"varint,7,opt,name=chunk_no,json=chunkNo" json:"chunk_no,omitempty"`
	FinalChunk       *bool   `protobuf:"varint,8,opt,name=final_chunk,json=finalChunk" json:"final_chunk,omitempty"`
	KeepAlive        *bool   `protobuf:"varint,9,opt,name=keep_alive,json=keepAlive" json:"keep_alive,omitempty"`
	Content          []byte  `protobuf:"bytes,4,opt,name=content" json:"content,omitempty"`
	FinalSizeBytes   *uint64 `protobuf:"varint,10,opt,name=final_size_bytes,json=finalSizeBytes" json:"final_size_bytes,omitempty"`
	Error            *string `protobuf:"bytes,5,opt,name=error" json:"error,omitempty"`
	Token            *string `protobuf:"bytes,6,req,name=token" json:"token,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DumpResponse) Reset()                    { *m = DumpResponse{} }
func (m *DumpResponse) String() string            { return proto.CompactTextString(m) }
func (*DumpResponse) ProtoMessage()               {}
func (*DumpResponse) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{82} }

func (m *DumpResponse) GetTimestampNs() uint64 {
	if m != nil && m.TimestampNs != nil {
		return *m.TimestampNs
	}
	return 0
}

func (m *DumpResponse) GetMachineId() string {
	if m != nil && m.MachineId != nil {
		return *m.MachineId
	}
	return ""
}

func (m *DumpResponse) GetCustomerId() string {
	if m != nil && m.CustomerId != nil {
		return *m.CustomerId
	}
	return ""
}

func (m *DumpResponse) GetChunkNo() uint32 {
	if m != nil && m.ChunkNo != nil {
		return *m.ChunkNo
	}
	return 0
}

func (m *DumpResponse) GetFinalChunk() bool {
	if m != nil && m.FinalChunk != nil {
		return *m.FinalChunk
	}
	return false
}

func (m *DumpResponse) GetKeepAlive() bool {
	if m != nil && m.KeepAlive != nil {
		return *m.KeepAlive
	}
	return false
}

func (m *DumpResponse) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *DumpResponse) GetFinalSizeBytes() uint64 {
	if m != nil && m.FinalSizeBytes != nil {
		return *m.FinalSizeBytes
	}
	return 0
}

func (m *DumpResponse) GetError() string {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return ""
}

func (m *DumpResponse) GetToken() string {
	if m != nil && m.Token != nil {
		return *m.Token
	}
	return ""
}

type SshOpenChannel struct {
	TimestampNs      *uint64 `protobuf:"varint,1,req,name=timestamp_ns,json=timestampNs" json:"timestamp_ns,omitempty"`
	MachineId        *string `protobuf:"bytes,2,req,name=machine_id,json=machineId" json:"machine_id,omitempty"`
	CustomerId       *string `protobuf:"bytes,3,opt,name=customer_id,json=customerId" json:"customer_id,omitempty"`
	Token            *string `protobuf:"bytes,4,req,name=token" json:"token,omitempty"`
	User             *string `protobuf:"bytes,5,req,name=user" json:"user,omitempty"`
	Password         *string `protobuf:"bytes,6,opt,name=password" json:"password,omitempty"`
	Key              *string `protobuf:"bytes,7,opt,name=key" json:"key,omitempty"`
	Passphrase       *string `protobuf:"bytes,8,opt,name=passphrase" json:"passphrase,omitempty"`
	Port             *uint32 `protobuf:"varint,9,opt,name=port" json:"port,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SshOpenChannel) Reset()                    { *m = SshOpenChannel{} }
func (m *SshOpenChannel) String() string            { return proto.CompactTextString(m) }
func (*SshOpenChannel) ProtoMessage()               {}
func (*SshOpenChannel) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{83} }

func (m *SshOpenChannel) GetTimestampNs() uint64 {
	if m != nil && m.TimestampNs != nil {
		return *m.TimestampNs
	}
	return 0
}

func (m *SshOpenChannel) GetMachineId() string {
	if m != nil && m.MachineId != nil {
		return *m.MachineId
	}
	return ""
}

func (m *SshOpenChannel) GetCustomerId() string {
	if m != nil && m.CustomerId != nil {
		return *m.CustomerId
	}
	return ""
}

func (m *SshOpenChannel) GetToken() string {
	if m != nil && m.Token != nil {
		return *m.Token
	}
	return ""
}

func (m *SshOpenChannel) GetUser() string {
	if m != nil && m.User != nil {
		return *m.User
	}
	return ""
}

func (m *SshOpenChannel) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

func (m *SshOpenChannel) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *SshOpenChannel) GetPassphrase() string {
	if m != nil && m.Passphrase != nil {
		return *m.Passphrase
	}
	return ""
}

func (m *SshOpenChannel) GetPort() uint32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

type SshData struct {
	TimestampNs      *uint64 `protobuf:"varint,1,req,name=timestamp_ns,json=timestampNs" json:"timestamp_ns,omitempty"`
	MachineId        *string `protobuf:"bytes,2,req,name=machine_id,json=machineId" json:"machine_id,omitempty"`
	CustomerId       *string `protobuf:"bytes,3,opt,name=customer_id,json=customerId" json:"customer_id,omitempty"`
	Token            *string `protobuf:"bytes,4,req,name=token" json:"token,omitempty"`
	Data             []byte  `protobuf:"bytes,5,opt,name=data" json:"data,omitempty"`
	Error            *string `protobuf:"bytes,6,opt,name=error" json:"error,omitempty"`
	ExitStatus       *int32  `protobuf:"varint,7,opt,name=exit_status,json=exitStatus" json:"exit_status,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SshData) Reset()                    { *m = SshData{} }
func (m *SshData) String() string            { return proto.CompactTextString(m) }
func (*SshData) ProtoMessage()               {}
func (*SshData) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{84} }

func (m *SshData) GetTimestampNs() uint64 {
	if m != nil && m.TimestampNs != nil {
		return *m.TimestampNs
	}
	return 0
}

func (m *SshData) GetMachineId() string {
	if m != nil && m.MachineId != nil {
		return *m.MachineId
	}
	return ""
}

func (m *SshData) GetCustomerId() string {
	if m != nil && m.CustomerId != nil {
		return *m.CustomerId
	}
	return ""
}

func (m *SshData) GetToken() string {
	if m != nil && m.Token != nil {
		return *m.Token
	}
	return ""
}

func (m *SshData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *SshData) GetError() string {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return ""
}

func (m *SshData) GetExitStatus() int32 {
	if m != nil && m.ExitStatus != nil {
		return *m.ExitStatus
	}
	return 0
}

type SshCloseChannel struct {
	TimestampNs      *uint64 `protobuf:"varint,1,req,name=timestamp_ns,json=timestampNs" json:"timestamp_ns,omitempty"`
	MachineId        *string `protobuf:"bytes,2,req,name=machine_id,json=machineId" json:"machine_id,omitempty"`
	CustomerId       *string `protobuf:"bytes,3,opt,name=customer_id,json=customerId" json:"customer_id,omitempty"`
	Token            *string `protobuf:"bytes,4,req,name=token" json:"token,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SshCloseChannel) Reset()                    { *m = SshCloseChannel{} }
func (m *SshCloseChannel) String() string            { return proto.CompactTextString(m) }
func (*SshCloseChannel) ProtoMessage()               {}
func (*SshCloseChannel) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{85} }

func (m *SshCloseChannel) GetTimestampNs() uint64 {
	if m != nil && m.TimestampNs != nil {
		return *m.TimestampNs
	}
	return 0
}

func (m *SshCloseChannel) GetMachineId() string {
	if m != nil && m.MachineId != nil {
		return *m.MachineId
	}
	return ""
}

func (m *SshCloseChannel) GetCustomerId() string {
	if m != nil && m.CustomerId != nil {
		return *m.CustomerId
	}
	return ""
}

func (m *SshCloseChannel) GetToken() string {
	if m != nil && m.Token != nil {
		return *m.Token
	}
	return ""
}

type AutoUpdateRequest struct {
	TimestampNs      *uint64 `protobuf:"varint,1,req,name=timestamp_ns,json=timestampNs" json:"timestamp_ns,omitempty"`
	MachineId        *string `protobuf:"bytes,2,req,name=machine_id,json=machineId" json:"machine_id,omitempty"`
	CustomerId       *string `protobuf:"bytes,3,opt,name=customer_id,json=customerId" json:"customer_id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *AutoUpdateRequest) Reset()                    { *m = AutoUpdateRequest{} }
func (m *AutoUpdateRequest) String() string            { return proto.CompactTextString(m) }
func (*AutoUpdateRequest) ProtoMessage()               {}
func (*AutoUpdateRequest) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{86} }

func (m *AutoUpdateRequest) GetTimestampNs() uint64 {
	if m != nil && m.TimestampNs != nil {
		return *m.TimestampNs
	}
	return 0
}

func (m *AutoUpdateRequest) GetMachineId() string {
	if m != nil && m.MachineId != nil {
		return *m.MachineId
	}
	return ""
}

func (m *AutoUpdateRequest) GetCustomerId() string {
	if m != nil && m.CustomerId != nil {
		return *m.CustomerId
	}
	return ""
}

type DirtyShutdownReport struct {
	TimestampNs      *uint64 `protobuf:"varint,1,req,name=timestamp_ns,json=timestampNs" json:"timestamp_ns,omitempty"`
	MachineId        *string `protobuf:"bytes,2,req,name=machine_id,json=machineId" json:"machine_id,omitempty"`
	CustomerId       *string `protobuf:"bytes,3,opt,name=customer_id,json=customerId" json:"customer_id,omitempty"`
	Log              *string `protobuf:"bytes,4,req,name=log" json:"log,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DirtyShutdownReport) Reset()                    { *m = DirtyShutdownReport{} }
func (m *DirtyShutdownReport) String() string            { return proto.CompactTextString(m) }
func (*DirtyShutdownReport) ProtoMessage()               {}
func (*DirtyShutdownReport) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{87} }

func (m *DirtyShutdownReport) GetTimestampNs() uint64 {
	if m != nil && m.TimestampNs != nil {
		return *m.TimestampNs
	}
	return 0
}

func (m *DirtyShutdownReport) GetMachineId() string {
	if m != nil && m.MachineId != nil {
		return *m.MachineId
	}
	return ""
}

func (m *DirtyShutdownReport) GetCustomerId() string {
	if m != nil && m.CustomerId != nil {
		return *m.CustomerId
	}
	return ""
}

func (m *DirtyShutdownReport) GetLog() string {
	if m != nil && m.Log != nil {
		return *m.Log
	}
	return ""
}

type KeyValue struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *KeyValue) Reset()                    { *m = KeyValue{} }
func (m *KeyValue) String() string            { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()               {}
func (*KeyValue) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{88} }

func (m *KeyValue) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *KeyValue) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type AgentEvent struct {
	TimestampSec     *uint64     `protobuf:"varint,1,opt,name=timestamp_sec,json=timestampSec" json:"timestamp_sec,omitempty"`
	Scope            *string     `protobuf:"bytes,2,opt,name=scope" json:"scope,omitempty"`
	Title            *string     `protobuf:"bytes,3,opt,name=title" json:"title,omitempty"`
	Description      *string     `protobuf:"bytes,4,opt,name=description" json:"description,omitempty"`
	Severity         *uint32     `protobuf:"varint,5,opt,name=severity" json:"severity,omitempty"`
	Tags             []*KeyValue `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *AgentEvent) Reset()                    { *m = AgentEvent{} }
func (m *AgentEvent) String() string            { return proto.CompactTextString(m) }
func (*AgentEvent) ProtoMessage()               {}
func (*AgentEvent) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{89} }

func (m *AgentEvent) GetTimestampSec() uint64 {
	if m != nil && m.TimestampSec != nil {
		return *m.TimestampSec
	}
	return 0
}

func (m *AgentEvent) GetScope() string {
	if m != nil && m.Scope != nil {
		return *m.Scope
	}
	return ""
}

func (m *AgentEvent) GetTitle() string {
	if m != nil && m.Title != nil {
		return *m.Title
	}
	return ""
}

func (m *AgentEvent) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *AgentEvent) GetSeverity() uint32 {
	if m != nil && m.Severity != nil {
		return *m.Severity
	}
	return 0
}

func (m *AgentEvent) GetTags() []*KeyValue {
	if m != nil {
		return m.Tags
	}
	return nil
}

type ConfigFile struct {
	Name             *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Content          *string `protobuf:"bytes,2,opt,name=content" json:"content,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ConfigFile) Reset()                    { *m = ConfigFile{} }
func (m *ConfigFile) String() string            { return proto.CompactTextString(m) }
func (*ConfigFile) ProtoMessage()               {}
func (*ConfigFile) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{90} }

func (m *ConfigFile) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ConfigFile) GetContent() string {
	if m != nil && m.Content != nil {
		return *m.Content
	}
	return ""
}

type ConfigData struct {
	ConfigFiles      []*ConfigFile `protobuf:"bytes,1,rep,name=config_files,json=configFiles" json:"config_files,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *ConfigData) Reset()                    { *m = ConfigData{} }
func (m *ConfigData) String() string            { return proto.CompactTextString(m) }
func (*ConfigData) ProtoMessage()               {}
func (*ConfigData) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{91} }

func (m *ConfigData) GetConfigFiles() []*ConfigFile {
	if m != nil {
		return m.ConfigFiles
	}
	return nil
}

type StopAction struct {
	// This is the message to send to the thing being stopped.
	Msg              *string `protobuf:"bytes,1,opt,name=msg" json:"msg,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *StopAction) Reset()                    { *m = StopAction{} }
func (m *StopAction) String() string            { return proto.CompactTextString(m) }
func (*StopAction) ProtoMessage()               {}
func (*StopAction) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{92} }

func (m *StopAction) GetMsg() string {
	if m != nil && m.Msg != nil {
		return *m.Msg
	}
	return ""
}

type PauseAction struct {
	// This is the message to send to the thing being paused.
	Msg              *string `protobuf:"bytes,1,opt,name=msg" json:"msg,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PauseAction) Reset()                    { *m = PauseAction{} }
func (m *PauseAction) String() string            { return proto.CompactTextString(m) }
func (*PauseAction) ProtoMessage()               {}
func (*PauseAction) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{93} }

func (m *PauseAction) GetMsg() string {
	if m != nil && m.Msg != nil {
		return *m.Msg
	}
	return ""
}

type CaptureAction struct {
	BeforeEventNs        *uint64 `protobuf:"varint,1,req,name=before_event_ns,json=beforeEventNs" json:"before_event_ns,omitempty"`
	AfterEventNs         *uint64 `protobuf:"varint,2,req,name=after_event_ns,json=afterEventNs" json:"after_event_ns,omitempty"`
	Filter               *string `protobuf:"bytes,3,opt,name=filter" json:"filter,omitempty"`
	IsLimitedToContainer *bool   `protobuf:"varint,4,opt,name=is_limited_to_container,json=isLimitedToContainer" json:"is_limited_to_container,omitempty"`
	XXX_unrecognized     []byte  `json:"-"`
}

func (m *CaptureAction) Reset()                    { *m = CaptureAction{} }
func (m *CaptureAction) String() string            { return proto.CompactTextString(m) }
func (*CaptureAction) ProtoMessage()               {}
func (*CaptureAction) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{94} }

func (m *CaptureAction) GetBeforeEventNs() uint64 {
	if m != nil && m.BeforeEventNs != nil {
		return *m.BeforeEventNs
	}
	return 0
}

func (m *CaptureAction) GetAfterEventNs() uint64 {
	if m != nil && m.AfterEventNs != nil {
		return *m.AfterEventNs
	}
	return 0
}

func (m *CaptureAction) GetFilter() string {
	if m != nil && m.Filter != nil {
		return *m.Filter
	}
	return ""
}

func (m *CaptureAction) GetIsLimitedToContainer() bool {
	if m != nil && m.IsLimitedToContainer != nil {
		return *m.IsLimitedToContainer
	}
	return false
}

// If we were using gproto >= 2.6, we could use oneof
type Action struct {
	Type *ActionType `protobuf:"varint,1,req,name=type,enum=draiosproto.ActionType" json:"type,omitempty"`
	// when type=ACTION_STOP
	Stop *StopAction `protobuf:"bytes,2,opt,name=stop" json:"stop,omitempty"`
	// when type=ACTION_PAUSE
	Pause *PauseAction `protobuf:"bytes,3,opt,name=pause" json:"pause,omitempty"`
	// when type=ACTION_CAPTURE
	Capture          *CaptureAction `protobuf:"bytes,4,opt,name=capture" json:"capture,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *Action) Reset()                    { *m = Action{} }
func (m *Action) String() string            { return proto.CompactTextString(m) }
func (*Action) ProtoMessage()               {}
func (*Action) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{95} }

func (m *Action) GetType() ActionType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ActionType_ACTION_STOP
}

func (m *Action) GetStop() *StopAction {
	if m != nil {
		return m.Stop
	}
	return nil
}

func (m *Action) GetPause() *PauseAction {
	if m != nil {
		return m.Pause
	}
	return nil
}

func (m *Action) GetCapture() *CaptureAction {
	if m != nil {
		return m.Capture
	}
	return nil
}

// XXX/mstemm fill these in
type BaselineDetail struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *BaselineDetail) Reset()                    { *m = BaselineDetail{} }
func (m *BaselineDetail) String() string            { return proto.CompactTextString(m) }
func (*BaselineDetail) ProtoMessage()               {}
func (*BaselineDetail) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{96} }

type ManualDetail struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *ManualDetail) Reset()                    { *m = ManualDetail{} }
func (m *ManualDetail) String() string            { return proto.CompactTextString(m) }
func (*ManualDetail) ProtoMessage()               {}
func (*ManualDetail) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{97} }

type FalcoRuleFilter struct {
	Tags             []string `protobuf:"bytes,1,rep,name=tags" json:"tags,omitempty"`
	Name             *string  `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *FalcoRuleFilter) Reset()                    { *m = FalcoRuleFilter{} }
func (m *FalcoRuleFilter) String() string            { return proto.CompactTextString(m) }
func (*FalcoRuleFilter) ProtoMessage()               {}
func (*FalcoRuleFilter) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{98} }

func (m *FalcoRuleFilter) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *FalcoRuleFilter) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

type FalcoDetail struct {
	RuleFilter       *FalcoRuleFilter `protobuf:"bytes,1,req,name=rule_filter,json=ruleFilter" json:"rule_filter,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *FalcoDetail) Reset()                    { *m = FalcoDetail{} }
func (m *FalcoDetail) String() string            { return proto.CompactTextString(m) }
func (*FalcoDetail) ProtoMessage()               {}
func (*FalcoDetail) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{99} }

func (m *FalcoDetail) GetRuleFilter() *FalcoRuleFilter {
	if m != nil {
		return m.RuleFilter
	}
	return nil
}

type ScopePredicate struct {
	Key *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	// multiple values when using IN/NOT_IN, otherwise single
	Values           []string       `protobuf:"bytes,2,rep,name=values" json:"values,omitempty"`
	Op               *ScopeOperator `protobuf:"varint,3,req,name=op,enum=draiosproto.ScopeOperator" json:"op,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *ScopePredicate) Reset()                    { *m = ScopePredicate{} }
func (m *ScopePredicate) String() string            { return proto.CompactTextString(m) }
func (*ScopePredicate) ProtoMessage()               {}
func (*ScopePredicate) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{100} }

func (m *ScopePredicate) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *ScopePredicate) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *ScopePredicate) GetOp() ScopeOperator {
	if m != nil && m.Op != nil {
		return *m.Op
	}
	return ScopeOperator_EQ
}

type Policy struct {
	Id             *uint64     `protobuf:"varint,1,req,name=id" json:"id,omitempty"`
	Name           *string     `protobuf:"bytes,2,req,name=name" json:"name,omitempty"`
	Type           *PolicyType `protobuf:"varint,3,req,name=type,enum=draiosproto.PolicyType" json:"type,omitempty"`
	HostScope      *bool       `protobuf:"varint,9,req,name=host_scope,json=hostScope" json:"host_scope,omitempty"`
	ContainerScope *bool       `protobuf:"varint,10,req,name=container_scope,json=containerScope" json:"container_scope,omitempty"`
	// all scope_predicates must match against the entity
	ScopePredicates []*ScopePredicate `protobuf:"bytes,11,rep,name=scope_predicates,json=scopePredicates" json:"scope_predicates,omitempty"`
	// when type=POLICY_BASELINE
	BaselineDetails *BaselineDetail `protobuf:"bytes,4,opt,name=baseline_details,json=baselineDetails" json:"baseline_details,omitempty"`
	// when type=POLICY_FALCO
	FalcoDetails *FalcoDetail `protobuf:"bytes,5,opt,name=falco_details,json=falcoDetails" json:"falco_details,omitempty"`
	// when type=POLICY_MANUAL
	ManualDetails    *ManualDetail `protobuf:"bytes,6,opt,name=manual_details,json=manualDetails" json:"manual_details,omitempty"`
	Actions          []*Action     `protobuf:"bytes,7,rep,name=actions" json:"actions,omitempty"`
	Enabled          *bool         `protobuf:"varint,8,req,name=enabled" json:"enabled,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Policy) Reset()                    { *m = Policy{} }
func (m *Policy) String() string            { return proto.CompactTextString(m) }
func (*Policy) ProtoMessage()               {}
func (*Policy) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{101} }

func (m *Policy) GetId() uint64 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Policy) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Policy) GetType() PolicyType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return PolicyType_POLICY_BASELINE
}

func (m *Policy) GetHostScope() bool {
	if m != nil && m.HostScope != nil {
		return *m.HostScope
	}
	return false
}

func (m *Policy) GetContainerScope() bool {
	if m != nil && m.ContainerScope != nil {
		return *m.ContainerScope
	}
	return false
}

func (m *Policy) GetScopePredicates() []*ScopePredicate {
	if m != nil {
		return m.ScopePredicates
	}
	return nil
}

func (m *Policy) GetBaselineDetails() *BaselineDetail {
	if m != nil {
		return m.BaselineDetails
	}
	return nil
}

func (m *Policy) GetFalcoDetails() *FalcoDetail {
	if m != nil {
		return m.FalcoDetails
	}
	return nil
}

func (m *Policy) GetManualDetails() *ManualDetail {
	if m != nil {
		return m.ManualDetails
	}
	return nil
}

func (m *Policy) GetActions() []*Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *Policy) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return false
}

// It's repeated to allow for pushing multiple rule files from the
// backend (think a rules.d with many files below it). The rule files
// will be loaded in message order.
type FalcoRulesContents struct {
	Contents         []string `protobuf:"bytes,1,rep,name=contents" json:"contents,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *FalcoRulesContents) Reset()                    { *m = FalcoRulesContents{} }
func (m *FalcoRulesContents) String() string            { return proto.CompactTextString(m) }
func (*FalcoRulesContents) ProtoMessage()               {}
func (*FalcoRulesContents) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{102} }

func (m *FalcoRulesContents) GetContents() []string {
	if m != nil {
		return m.Contents
	}
	return nil
}

type Policies struct {
	PolicyList       []*Policy           `protobuf:"bytes,1,rep,name=policy_list,json=policyList" json:"policy_list,omitempty"`
	FalcoRules       *FalcoRulesContents `protobuf:"bytes,2,opt,name=falco_rules,json=falcoRules" json:"falco_rules,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *Policies) Reset()                    { *m = Policies{} }
func (m *Policies) String() string            { return proto.CompactTextString(m) }
func (*Policies) ProtoMessage()               {}
func (*Policies) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{103} }

func (m *Policies) GetPolicyList() []*Policy {
	if m != nil {
		return m.PolicyList
	}
	return nil
}

func (m *Policies) GetFalcoRules() *FalcoRulesContents {
	if m != nil {
		return m.FalcoRules
	}
	return nil
}

// XXX/mstemm fill these in
type BaselineEventDetail struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *BaselineEventDetail) Reset()                    { *m = BaselineEventDetail{} }
func (m *BaselineEventDetail) String() string            { return proto.CompactTextString(m) }
func (*BaselineEventDetail) ProtoMessage()               {}
func (*BaselineEventDetail) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{104} }

type ManualEventDetail struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *ManualEventDetail) Reset()                    { *m = ManualEventDetail{} }
func (m *ManualEventDetail) String() string            { return proto.CompactTextString(m) }
func (*ManualEventDetail) ProtoMessage()               {}
func (*ManualEventDetail) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{105} }

type FalcoEventDetail struct {
	Rule             *string `protobuf:"bytes,1,req,name=rule" json:"rule,omitempty"`
	Output           *string `protobuf:"bytes,2,req,name=output" json:"output,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *FalcoEventDetail) Reset()                    { *m = FalcoEventDetail{} }
func (m *FalcoEventDetail) String() string            { return proto.CompactTextString(m) }
func (*FalcoEventDetail) ProtoMessage()               {}
func (*FalcoEventDetail) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{106} }

func (m *FalcoEventDetail) GetRule() string {
	if m != nil && m.Rule != nil {
		return *m.Rule
	}
	return ""
}

func (m *FalcoEventDetail) GetOutput() string {
	if m != nil && m.Output != nil {
		return *m.Output
	}
	return ""
}

type ActionResult struct {
	Type *ActionType `protobuf:"varint,1,req,name=type,enum=draiosproto.ActionType" json:"type,omitempty"`
	// Whether or not the action was completed successfully
	Successful *bool `protobuf:"varint,2,req,name=successful" json:"successful,omitempty"`
	// When successful == false, details on why the action failed
	Errmsg *string `protobuf:"bytes,3,opt,name=errmsg" json:"errmsg,omitempty"`
	// An optional token that can be related to later messages. For
	// example, when the type is ACTION_CAPTURE, A series of
	// dump_response messages will follow. Each will have a token
	// field == this token.
	Token            *string `protobuf:"bytes,4,opt,name=token" json:"token,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ActionResult) Reset()                    { *m = ActionResult{} }
func (m *ActionResult) String() string            { return proto.CompactTextString(m) }
func (*ActionResult) ProtoMessage()               {}
func (*ActionResult) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{107} }

func (m *ActionResult) GetType() ActionType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ActionType_ACTION_STOP
}

func (m *ActionResult) GetSuccessful() bool {
	if m != nil && m.Successful != nil {
		return *m.Successful
	}
	return false
}

func (m *ActionResult) GetErrmsg() string {
	if m != nil && m.Errmsg != nil {
		return *m.Errmsg
	}
	return ""
}

func (m *ActionResult) GetToken() string {
	if m != nil && m.Token != nil {
		return *m.Token
	}
	return ""
}

// Once we add a scope, we'll want to also include the scope of the
// event as well.
type PolicyEvent struct {
	TimestampNs *uint64 `protobuf:"varint,1,req,name=timestamp_ns,json=timestampNs" json:"timestamp_ns,omitempty"`
	PolicyId    *uint64 `protobuf:"varint,2,req,name=policy_id,json=policyId" json:"policy_id,omitempty"`
	ContainerId *string `protobuf:"bytes,3,opt,name=container_id,json=containerId" json:"container_id,omitempty"`
	// Which of these are present depends on the type of the policy
	// referred to by policy_id.
	BaselineDetails *BaselineEventDetail `protobuf:"bytes,4,opt,name=baseline_details,json=baselineDetails" json:"baseline_details,omitempty"`
	FalcoDetails    *FalcoEventDetail    `protobuf:"bytes,5,opt,name=falco_details,json=falcoDetails" json:"falco_details,omitempty"`
	ManualDetails   *ManualEventDetail   `protobuf:"bytes,6,opt,name=manual_details,json=manualDetails" json:"manual_details,omitempty"`
	ActionResults   []*ActionResult      `protobuf:"bytes,7,rep,name=action_results,json=actionResults" json:"action_results,omitempty"`
	// If true, there were inspector events dropped recently, which
	// might have affected the details in this policy event.
	SinspEventsDropped *bool  `protobuf:"varint,8,opt,name=sinsp_events_dropped,json=sinspEventsDropped" json:"sinsp_events_dropped,omitempty"`
	XXX_unrecognized   []byte `json:"-"`
}

func (m *PolicyEvent) Reset()                    { *m = PolicyEvent{} }
func (m *PolicyEvent) String() string            { return proto.CompactTextString(m) }
func (*PolicyEvent) ProtoMessage()               {}
func (*PolicyEvent) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{108} }

func (m *PolicyEvent) GetTimestampNs() uint64 {
	if m != nil && m.TimestampNs != nil {
		return *m.TimestampNs
	}
	return 0
}

func (m *PolicyEvent) GetPolicyId() uint64 {
	if m != nil && m.PolicyId != nil {
		return *m.PolicyId
	}
	return 0
}

func (m *PolicyEvent) GetContainerId() string {
	if m != nil && m.ContainerId != nil {
		return *m.ContainerId
	}
	return ""
}

func (m *PolicyEvent) GetBaselineDetails() *BaselineEventDetail {
	if m != nil {
		return m.BaselineDetails
	}
	return nil
}

func (m *PolicyEvent) GetFalcoDetails() *FalcoEventDetail {
	if m != nil {
		return m.FalcoDetails
	}
	return nil
}

func (m *PolicyEvent) GetManualDetails() *ManualEventDetail {
	if m != nil {
		return m.ManualDetails
	}
	return nil
}

func (m *PolicyEvent) GetActionResults() []*ActionResult {
	if m != nil {
		return m.ActionResults
	}
	return nil
}

func (m *PolicyEvent) GetSinspEventsDropped() bool {
	if m != nil && m.SinspEventsDropped != nil {
		return *m.SinspEventsDropped
	}
	return false
}

type PolicyEvents struct {
	MachineId        *string        `protobuf:"bytes,1,req,name=machine_id,json=machineId" json:"machine_id,omitempty"`
	CustomerId       *string        `protobuf:"bytes,2,opt,name=customer_id,json=customerId" json:"customer_id,omitempty"`
	Events           []*PolicyEvent `protobuf:"bytes,3,rep,name=events" json:"events,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *PolicyEvents) Reset()                    { *m = PolicyEvents{} }
func (m *PolicyEvents) String() string            { return proto.CompactTextString(m) }
func (*PolicyEvents) ProtoMessage()               {}
func (*PolicyEvents) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{109} }

func (m *PolicyEvents) GetMachineId() string {
	if m != nil && m.MachineId != nil {
		return *m.MachineId
	}
	return ""
}

func (m *PolicyEvents) GetCustomerId() string {
	if m != nil && m.CustomerId != nil {
		return *m.CustomerId
	}
	return ""
}

func (m *PolicyEvents) GetEvents() []*PolicyEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

type ThrottledPolicyEvent struct {
	TimestampNs      *uint64 `protobuf:"varint,1,req,name=timestamp_ns,json=timestampNs" json:"timestamp_ns,omitempty"`
	PolicyId         *uint64 `protobuf:"varint,2,req,name=policy_id,json=policyId" json:"policy_id,omitempty"`
	ContainerId      *string `protobuf:"bytes,3,opt,name=container_id,json=containerId" json:"container_id,omitempty"`
	Count            *uint64 `protobuf:"varint,4,req,name=count" json:"count,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ThrottledPolicyEvent) Reset()                    { *m = ThrottledPolicyEvent{} }
func (m *ThrottledPolicyEvent) String() string            { return proto.CompactTextString(m) }
func (*ThrottledPolicyEvent) ProtoMessage()               {}
func (*ThrottledPolicyEvent) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{110} }

func (m *ThrottledPolicyEvent) GetTimestampNs() uint64 {
	if m != nil && m.TimestampNs != nil {
		return *m.TimestampNs
	}
	return 0
}

func (m *ThrottledPolicyEvent) GetPolicyId() uint64 {
	if m != nil && m.PolicyId != nil {
		return *m.PolicyId
	}
	return 0
}

func (m *ThrottledPolicyEvent) GetContainerId() string {
	if m != nil && m.ContainerId != nil {
		return *m.ContainerId
	}
	return ""
}

func (m *ThrottledPolicyEvent) GetCount() uint64 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

type ThrottledPolicyEvents struct {
	MachineId        *string                 `protobuf:"bytes,1,req,name=machine_id,json=machineId" json:"machine_id,omitempty"`
	CustomerId       *string                 `protobuf:"bytes,2,opt,name=customer_id,json=customerId" json:"customer_id,omitempty"`
	Events           []*ThrottledPolicyEvent `protobuf:"bytes,3,rep,name=events" json:"events,omitempty"`
	XXX_unrecognized []byte                  `json:"-"`
}

func (m *ThrottledPolicyEvents) Reset()                    { *m = ThrottledPolicyEvents{} }
func (m *ThrottledPolicyEvents) String() string            { return proto.CompactTextString(m) }
func (*ThrottledPolicyEvents) ProtoMessage()               {}
func (*ThrottledPolicyEvents) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{111} }

func (m *ThrottledPolicyEvents) GetMachineId() string {
	if m != nil && m.MachineId != nil {
		return *m.MachineId
	}
	return ""
}

func (m *ThrottledPolicyEvents) GetCustomerId() string {
	if m != nil && m.CustomerId != nil {
		return *m.CustomerId
	}
	return ""
}

func (m *ThrottledPolicyEvents) GetEvents() []*ThrottledPolicyEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

type ErrorMessage struct {
	Type             *ErrorType `protobuf:"varint,1,opt,name=type,enum=draiosproto.ErrorType" json:"type,omitempty"`
	Description      *string    `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *ErrorMessage) Reset()                    { *m = ErrorMessage{} }
func (m *ErrorMessage) String() string            { return proto.CompactTextString(m) }
func (*ErrorMessage) ProtoMessage()               {}
func (*ErrorMessage) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{112} }

func (m *ErrorMessage) GetType() ErrorType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ErrorType_ERR_CONN_LIMIT
}

func (m *ErrorMessage) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

//
// FALCO BASELINE
//
type FalcoSubcategory struct {
	Name             *string  `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	D                []string `protobuf:"bytes,2,rep,name=d" json:"d,omitempty"`
	Full             *bool    `protobuf:"varint,3,opt,name=full" json:"full,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *FalcoSubcategory) Reset()                    { *m = FalcoSubcategory{} }
func (m *FalcoSubcategory) String() string            { return proto.CompactTextString(m) }
func (*FalcoSubcategory) ProtoMessage()               {}
func (*FalcoSubcategory) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{113} }

func (m *FalcoSubcategory) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *FalcoSubcategory) GetD() []string {
	if m != nil {
		return m.D
	}
	return nil
}

func (m *FalcoSubcategory) GetFull() bool {
	if m != nil && m.Full != nil {
		return *m.Full
	}
	return false
}

type FalcoSubcategoryContainer struct {
	Subcats          []*FalcoSubcategory `protobuf:"bytes,1,rep,name=subcats" json:"subcats,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *FalcoSubcategoryContainer) Reset()         { *m = FalcoSubcategoryContainer{} }
func (m *FalcoSubcategoryContainer) String() string { return proto.CompactTextString(m) }
func (*FalcoSubcategoryContainer) ProtoMessage()    {}
func (*FalcoSubcategoryContainer) Descriptor() ([]byte, []int) {
	return fileDescriptorDraios, []int{114}
}

func (m *FalcoSubcategoryContainer) GetSubcats() []*FalcoSubcategory {
	if m != nil {
		return m.Subcats
	}
	return nil
}

type FalcoCategory struct {
	Name             *string                      `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	StartupSubcats   []*FalcoSubcategoryContainer `protobuf:"bytes,2,rep,name=startup_subcats,json=startupSubcats" json:"startup_subcats,omitempty"`
	RegularSubcats   []*FalcoSubcategoryContainer `protobuf:"bytes,3,rep,name=regular_subcats,json=regularSubcats" json:"regular_subcats,omitempty"`
	XXX_unrecognized []byte                       `json:"-"`
}

func (m *FalcoCategory) Reset()                    { *m = FalcoCategory{} }
func (m *FalcoCategory) String() string            { return proto.CompactTextString(m) }
func (*FalcoCategory) ProtoMessage()               {}
func (*FalcoCategory) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{115} }

func (m *FalcoCategory) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *FalcoCategory) GetStartupSubcats() []*FalcoSubcategoryContainer {
	if m != nil {
		return m.StartupSubcats
	}
	return nil
}

func (m *FalcoCategory) GetRegularSubcats() []*FalcoSubcategoryContainer {
	if m != nil {
		return m.RegularSubcats
	}
	return nil
}

type FalcoProg struct {
	Comm             *string          `protobuf:"bytes,1,req,name=comm" json:"comm,omitempty"`
	Exe              *string          `protobuf:"bytes,2,req,name=exe" json:"exe,omitempty"`
	Args             []string         `protobuf:"bytes,3,rep,name=args" json:"args,omitempty"`
	UserId           *uint64          `protobuf:"varint,4,req,name=user_id,json=userId" json:"user_id,omitempty"`
	ContainerId      *string          `protobuf:"bytes,5,opt,name=container_id,json=containerId" json:"container_id,omitempty"`
	Cats             []*FalcoCategory `protobuf:"bytes,6,rep,name=cats" json:"cats,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *FalcoProg) Reset()                    { *m = FalcoProg{} }
func (m *FalcoProg) String() string            { return proto.CompactTextString(m) }
func (*FalcoProg) ProtoMessage()               {}
func (*FalcoProg) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{116} }

func (m *FalcoProg) GetComm() string {
	if m != nil && m.Comm != nil {
		return *m.Comm
	}
	return ""
}

func (m *FalcoProg) GetExe() string {
	if m != nil && m.Exe != nil {
		return *m.Exe
	}
	return ""
}

func (m *FalcoProg) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *FalcoProg) GetUserId() uint64 {
	if m != nil && m.UserId != nil {
		return *m.UserId
	}
	return 0
}

func (m *FalcoProg) GetContainerId() string {
	if m != nil && m.ContainerId != nil {
		return *m.ContainerId
	}
	return ""
}

func (m *FalcoProg) GetCats() []*FalcoCategory {
	if m != nil {
		return m.Cats
	}
	return nil
}

type FalcoContainer struct {
	Id               *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	Name             *string `protobuf:"bytes,2,req,name=name" json:"name,omitempty"`
	ImageName        *string `protobuf:"bytes,3,opt,name=image_name,json=imageName" json:"image_name,omitempty"`
	ImageId          *string `protobuf:"bytes,4,opt,name=image_id,json=imageId" json:"image_id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *FalcoContainer) Reset()                    { *m = FalcoContainer{} }
func (m *FalcoContainer) String() string            { return proto.CompactTextString(m) }
func (*FalcoContainer) ProtoMessage()               {}
func (*FalcoContainer) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{117} }

func (m *FalcoContainer) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *FalcoContainer) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *FalcoContainer) GetImageName() string {
	if m != nil && m.ImageName != nil {
		return *m.ImageName
	}
	return ""
}

func (m *FalcoContainer) GetImageId() string {
	if m != nil && m.ImageId != nil {
		return *m.ImageId
	}
	return ""
}

type FalcoBaseline struct {
	Progs            []*FalcoProg      `protobuf:"bytes,1,rep,name=progs" json:"progs,omitempty"`
	Containers       []*FalcoContainer `protobuf:"bytes,2,rep,name=containers" json:"containers,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *FalcoBaseline) Reset()                    { *m = FalcoBaseline{} }
func (m *FalcoBaseline) String() string            { return proto.CompactTextString(m) }
func (*FalcoBaseline) ProtoMessage()               {}
func (*FalcoBaseline) Descriptor() ([]byte, []int) { return fileDescriptorDraios, []int{118} }

func (m *FalcoBaseline) GetProgs() []*FalcoProg {
	if m != nil {
		return m.Progs
	}
	return nil
}

func (m *FalcoBaseline) GetContainers() []*FalcoContainer {
	if m != nil {
		return m.Containers
	}
	return nil
}

func init() {
	proto.RegisterType((*CounterPercentileData)(nil), "draiosproto.counter_percentile_data")
	proto.RegisterType((*CounterPercentile)(nil), "draiosproto.counter_percentile")
	proto.RegisterType((*CounterTime)(nil), "draiosproto.counter_time")
	proto.RegisterType((*CounterTimeBidirectional)(nil), "draiosproto.counter_time_bidirectional")
	proto.RegisterType((*CounterBytes)(nil), "draiosproto.counter_bytes")
	proto.RegisterType((*CounterTimeBytes)(nil), "draiosproto.counter_time_bytes")
	proto.RegisterType((*TimeCategories)(nil), "draiosproto.time_categories")
	proto.RegisterType((*TransactionBreakdownCategories)(nil), "draiosproto.transaction_breakdown_categories")
	proto.RegisterType((*CounterSyscallErrors)(nil), "draiosproto.counter_syscall_errors")
	proto.RegisterType((*ResourceCategories)(nil), "draiosproto.resource_categories")
	proto.RegisterType((*ConnectionCategories)(nil), "draiosproto.connection_categories")
	proto.RegisterType((*ProcessDetails)(nil), "draiosproto.process_details")
	proto.RegisterType((*CommandDetails)(nil), "draiosproto.command_details")
	proto.RegisterType((*CounterProtoEntry)(nil), "draiosproto.counter_proto_entry")
	proto.RegisterType((*UrlDetails)(nil), "draiosproto.url_details")
	proto.RegisterType((*StatusCodeDetails)(nil), "draiosproto.status_code_details")
	proto.RegisterType((*HttpInfo)(nil), "draiosproto.http_info")
	proto.RegisterType((*SqlEntryDetails)(nil), "draiosproto.sql_entry_details")
	proto.RegisterType((*SqlQueryTypeDetails)(nil), "draiosproto.sql_query_type_details")
	proto.RegisterType((*SqlInfo)(nil), "draiosproto.sql_info")
	proto.RegisterType((*MongodbCollectionDetails)(nil), "draiosproto.mongodb_collection_details")
	proto.RegisterType((*MongodbOpTypeDetails)(nil), "draiosproto.mongodb_op_type_details")
	proto.RegisterType((*MongodbInfo)(nil), "draiosproto.mongodb_info")
	proto.RegisterType((*JmxAttribute)(nil), "draiosproto.jmx_attribute")
	proto.RegisterType((*JmxBean)(nil), "draiosproto.jmx_bean")
	proto.RegisterType((*JavaInfo)(nil), "draiosproto.java_info")
	proto.RegisterType((*StatsdTag)(nil), "draiosproto.statsd_tag")
	proto.RegisterType((*StatsdMetric)(nil), "draiosproto.statsd_metric")
	proto.RegisterType((*StatsdInfo)(nil), "draiosproto.statsd_info")
	proto.RegisterType((*AppTag)(nil), "draiosproto.app_tag")
	proto.RegisterType((*AppMetric)(nil), "draiosproto.app_metric")
	proto.RegisterType((*AppCheck)(nil), "draiosproto.app_check")
	proto.RegisterType((*AppInfo)(nil), "draiosproto.app_info")
	proto.RegisterType((*ProtoInfo)(nil), "draiosproto.proto_info")
	proto.RegisterType((*NetworkByPort)(nil), "draiosproto.network_by_port")
	proto.RegisterType((*Host)(nil), "draiosproto.host")
	proto.RegisterType((*Process)(nil), "draiosproto.process")
	proto.RegisterType((*Program)(nil), "draiosproto.program")
	proto.RegisterType((*Ipv4Tuple)(nil), "draiosproto.ipv4tuple")
	proto.RegisterType((*Ipv4Connection)(nil), "draiosproto.ipv4_connection")
	proto.RegisterType((*Ipv4NetworkInterface)(nil), "draiosproto.ipv4_network_interface")
	proto.RegisterType((*MountedFs)(nil), "draiosproto.mounted_fs")
	proto.RegisterType((*FileStat)(nil), "draiosproto.file_stat")
	proto.RegisterType((*ContainerPortMapping)(nil), "draiosproto.container_port_mapping")
	proto.RegisterType((*ContainerLabel)(nil), "draiosproto.container_label")
	proto.RegisterType((*Container)(nil), "draiosproto.container")
	proto.RegisterType((*CongroupUid)(nil), "draiosproto.congroup_uid")
	proto.RegisterType((*CongroupNetPort)(nil), "draiosproto.congroup_net_port")
	proto.RegisterType((*ContainerGroup)(nil), "draiosproto.container_group")
	proto.RegisterType((*CongroupUpdateEvent)(nil), "draiosproto.congroup_update_event")
	proto.RegisterType((*OrchestratorEvents)(nil), "draiosproto.orchestrator_events")
	proto.RegisterType((*K8SPair)(nil), "draiosproto.k8s_pair")
	proto.RegisterType((*K8SCommon)(nil), "draiosproto.k8s_common")
	proto.RegisterType((*K8SNamespace)(nil), "draiosproto.k8s_namespace")
	proto.RegisterType((*K8SNode)(nil), "draiosproto.k8s_node")
	proto.RegisterType((*K8SPod)(nil), "draiosproto.k8s_pod")
	proto.RegisterType((*K8SReplicationController)(nil), "draiosproto.k8s_replication_controller")
	proto.RegisterType((*K8SReplicaSet)(nil), "draiosproto.k8s_replica_set")
	proto.RegisterType((*K8SService)(nil), "draiosproto.k8s_service")
	proto.RegisterType((*K8SServiceNetPort)(nil), "draiosproto.k8s_service.net_port")
	proto.RegisterType((*K8SDeployment)(nil), "draiosproto.k8s_deployment")
	proto.RegisterType((*K8SDaemonset)(nil), "draiosproto.k8s_daemonset")
	proto.RegisterType((*K8SState)(nil), "draiosproto.k8s_state")
	proto.RegisterType((*MesosPair)(nil), "draiosproto.mesos_pair")
	proto.RegisterType((*MesosCommon)(nil), "draiosproto.mesos_common")
	proto.RegisterType((*MesosTask)(nil), "draiosproto.mesos_task")
	proto.RegisterType((*MarathonApp)(nil), "draiosproto.marathon_app")
	proto.RegisterType((*MarathonGroup)(nil), "draiosproto.marathon_group")
	proto.RegisterType((*MesosFramework)(nil), "draiosproto.mesos_framework")
	proto.RegisterType((*MesosSlave)(nil), "draiosproto.mesos_slave")
	proto.RegisterType((*MesosState)(nil), "draiosproto.mesos_state")
	proto.RegisterType((*SwarmPair)(nil), "draiosproto.swarm_pair")
	proto.RegisterType((*SwarmPort)(nil), "draiosproto.swarm_port")
	proto.RegisterType((*SwarmCommon)(nil), "draiosproto.swarm_common")
	proto.RegisterType((*SwarmService)(nil), "draiosproto.swarm_service")
	proto.RegisterType((*SwarmTask)(nil), "draiosproto.swarm_task")
	proto.RegisterType((*SwarmManager)(nil), "draiosproto.swarm_manager")
	proto.RegisterType((*SwarmNode)(nil), "draiosproto.swarm_node")
	proto.RegisterType((*SwarmState)(nil), "draiosproto.swarm_state")
	proto.RegisterType((*OrchestratorStateT)(nil), "draiosproto.orchestrator_state_t")
	proto.RegisterType((*Metrics)(nil), "draiosproto.metrics")
	proto.RegisterType((*DumpRequestStart)(nil), "draiosproto.dump_request_start")
	proto.RegisterType((*DumpRequestStop)(nil), "draiosproto.dump_request_stop")
	proto.RegisterType((*DumpResponse)(nil), "draiosproto.dump_response")
	proto.RegisterType((*SshOpenChannel)(nil), "draiosproto.ssh_open_channel")
	proto.RegisterType((*SshData)(nil), "draiosproto.ssh_data")
	proto.RegisterType((*SshCloseChannel)(nil), "draiosproto.ssh_close_channel")
	proto.RegisterType((*AutoUpdateRequest)(nil), "draiosproto.auto_update_request")
	proto.RegisterType((*DirtyShutdownReport)(nil), "draiosproto.dirty_shutdown_report")
	proto.RegisterType((*KeyValue)(nil), "draiosproto.key_value")
	proto.RegisterType((*AgentEvent)(nil), "draiosproto.agent_event")
	proto.RegisterType((*ConfigFile)(nil), "draiosproto.config_file")
	proto.RegisterType((*ConfigData)(nil), "draiosproto.config_data")
	proto.RegisterType((*StopAction)(nil), "draiosproto.stop_action")
	proto.RegisterType((*PauseAction)(nil), "draiosproto.pause_action")
	proto.RegisterType((*CaptureAction)(nil), "draiosproto.capture_action")
	proto.RegisterType((*Action)(nil), "draiosproto.action")
	proto.RegisterType((*BaselineDetail)(nil), "draiosproto.baseline_detail")
	proto.RegisterType((*ManualDetail)(nil), "draiosproto.manual_detail")
	proto.RegisterType((*FalcoRuleFilter)(nil), "draiosproto.falco_rule_filter")
	proto.RegisterType((*FalcoDetail)(nil), "draiosproto.falco_detail")
	proto.RegisterType((*ScopePredicate)(nil), "draiosproto.scope_predicate")
	proto.RegisterType((*Policy)(nil), "draiosproto.policy")
	proto.RegisterType((*FalcoRulesContents)(nil), "draiosproto.falco_rules_contents")
	proto.RegisterType((*Policies)(nil), "draiosproto.policies")
	proto.RegisterType((*BaselineEventDetail)(nil), "draiosproto.baseline_event_detail")
	proto.RegisterType((*ManualEventDetail)(nil), "draiosproto.manual_event_detail")
	proto.RegisterType((*FalcoEventDetail)(nil), "draiosproto.falco_event_detail")
	proto.RegisterType((*ActionResult)(nil), "draiosproto.action_result")
	proto.RegisterType((*PolicyEvent)(nil), "draiosproto.policy_event")
	proto.RegisterType((*PolicyEvents)(nil), "draiosproto.policy_events")
	proto.RegisterType((*ThrottledPolicyEvent)(nil), "draiosproto.throttled_policy_event")
	proto.RegisterType((*ThrottledPolicyEvents)(nil), "draiosproto.throttled_policy_events")
	proto.RegisterType((*ErrorMessage)(nil), "draiosproto.error_message")
	proto.RegisterType((*FalcoSubcategory)(nil), "draiosproto.falco_subcategory")
	proto.RegisterType((*FalcoSubcategoryContainer)(nil), "draiosproto.falco_subcategory_container")
	proto.RegisterType((*FalcoCategory)(nil), "draiosproto.falco_category")
	proto.RegisterType((*FalcoProg)(nil), "draiosproto.falco_prog")
	proto.RegisterType((*FalcoContainer)(nil), "draiosproto.falco_container")
	proto.RegisterType((*FalcoBaseline)(nil), "draiosproto.falco_baseline")
	proto.RegisterEnum("draiosproto.SqlStatementType", SqlStatementType_name, SqlStatementType_value)
	proto.RegisterEnum("draiosproto.MongodbOpType", MongodbOpType_name, MongodbOpType_value)
	proto.RegisterEnum("draiosproto.Unit", Unit_name, Unit_value)
	proto.RegisterEnum("draiosproto.Scale", Scale_name, Scale_value)
	proto.RegisterEnum("draiosproto.JmxMetricType", JmxMetricType_name, JmxMetricType_value)
	proto.RegisterEnum("draiosproto.StatsdMetricType", StatsdMetricType_name, StatsdMetricType_value)
	proto.RegisterEnum("draiosproto.AppMetricType", AppMetricType_name, AppMetricType_value)
	proto.RegisterEnum("draiosproto.AppCheckValue", AppCheckValue_name, AppCheckValue_value)
	proto.RegisterEnum("draiosproto.Networkrole", Networkrole_name, Networkrole_value)
	proto.RegisterEnum("draiosproto.MessageType", MessageType_name, MessageType_value)
	proto.RegisterEnum("draiosproto.ContainerType", ContainerType_name, ContainerType_value)
	proto.RegisterEnum("draiosproto.CongroupEventType", CongroupEventType_name, CongroupEventType_value)
	proto.RegisterEnum("draiosproto.SwarmServiceMode", SwarmServiceMode_name, SwarmServiceMode_value)
	proto.RegisterEnum("draiosproto.ActionType", ActionType_name, ActionType_value)
	proto.RegisterEnum("draiosproto.PolicyType", PolicyType_name, PolicyType_value)
	proto.RegisterEnum("draiosproto.ScopeOperator", ScopeOperator_name, ScopeOperator_value)
	proto.RegisterEnum("draiosproto.ErrorType", ErrorType_name, ErrorType_value)
}
func (m *CounterPercentileData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CounterPercentileData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Min == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Min))))
		i += 8
	}
	if m.Max == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Max))))
		i += 8
	}
	if m.Compression == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Compression))
	}
	if m.NumSamples == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.NumSamples))
	}
	if len(m.Means) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(m.Means)*8))
		for _, num := range m.Means {
			f1 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f1))
			i += 8
		}
	}
	if len(m.Weights) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(m.Weights)*8))
		for _, num := range m.Weights {
			f2 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f2))
			i += 8
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CounterPercentile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CounterPercentile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Percentile != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Percentile))
	}
	if m.Value != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Value))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CounterTime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CounterTime) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Count == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Count))
	}
	if m.TimeNs == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TimeNs))
	}
	if m.TimePercentage != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TimePercentage))
	}
	if len(m.Percentile) > 0 {
		for _, msg := range m.Percentile {
			dAtA[i] = 0x42
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PercentileData != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.PercentileData.Size()))
		n3, err := m.PercentileData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CounterTimeBidirectional) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CounterTimeBidirectional) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CountIn == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.CountIn))
	}
	if m.CountOut == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.CountOut))
	}
	if m.TimeNsIn == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TimeNsIn))
	}
	if m.TimeNsOut == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TimeNsOut))
	}
	if len(m.PercentileIn) > 0 {
		for _, msg := range m.PercentileIn {
			dAtA[i] = 0x52
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PercentileOut) > 0 {
		for _, msg := range m.PercentileOut {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PercentileInData != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.PercentileInData.Size()))
		n4, err := m.PercentileInData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.PercentileOutData != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.PercentileOutData.Size()))
		n5, err := m.PercentileOutData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CounterBytes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CounterBytes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CountIn == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.CountIn))
	}
	if m.CountOut == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.CountOut))
	}
	if m.BytesIn == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.BytesIn))
	}
	if m.BytesOut == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.BytesOut))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CounterTimeBytes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CounterTimeBytes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TimeNsIn == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TimeNsIn))
	}
	if m.TimeNsOut == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TimeNsOut))
	}
	if m.TimeNsOther == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TimeNsOther))
	}
	if m.CountIn == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.CountIn))
	}
	if m.CountOut == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.CountOut))
	}
	if m.CountOther == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x30
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.CountOther))
	}
	if m.BytesIn == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x38
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.BytesIn))
	}
	if m.BytesOut == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x40
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.BytesOut))
	}
	if m.BytesOther == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x48
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.BytesOther))
	}
	if m.TimePercentageIn != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TimePercentageIn))
	}
	if m.TimePercentageOut != nil {
		dAtA[i] = 0x58
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TimePercentageOut))
	}
	if m.TimePercentageOther != nil {
		dAtA[i] = 0x60
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TimePercentageOther))
	}
	if len(m.PercentileIn) > 0 {
		for _, msg := range m.PercentileIn {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PercentileOut) > 0 {
		for _, msg := range m.PercentileOut {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PercentileInData != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.PercentileInData.Size()))
		n6, err := m.PercentileInData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.PercentileOutData != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.PercentileOutData.Size()))
		n7, err := m.PercentileOutData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TimeCategories) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeCategories) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Unknown != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Unknown.Size()))
		n8, err := m.Unknown.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Other != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Other.Size()))
		n9, err := m.Other.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.File != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.File.Size()))
		n10, err := m.File.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Net != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Net.Size()))
		n11, err := m.Net.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Ipc != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Ipc.Size()))
		n12, err := m.Ipc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Memory != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Memory.Size()))
		n13, err := m.Memory.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Process != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Process.Size()))
		n14, err := m.Process.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Sleep != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Sleep.Size()))
		n15, err := m.Sleep.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.System != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.System.Size()))
		n16, err := m.System.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Signal != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Signal.Size()))
		n17, err := m.Signal.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.User != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.User.Size()))
		n18, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Time != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Time.Size()))
		n19, err := m.Time.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.IoFile != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.IoFile.Size()))
		n20, err := m.IoFile.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.IoNet != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.IoNet.Size()))
		n21, err := m.IoNet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.IoOther != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.IoOther.Size()))
		n22, err := m.IoOther.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.Wait != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Wait.Size()))
		n23, err := m.Wait.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.Processing != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Processing.Size()))
		n24, err := m.Processing.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransactionBreakdownCategories) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionBreakdownCategories) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Other != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Other.Size()))
		n25, err := m.Other.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.IoFile != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.IoFile.Size()))
		n26, err := m.IoFile.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.IoNet != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.IoNet.Size()))
		n27, err := m.IoNet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.Processing != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Processing.Size()))
		n28, err := m.Processing.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CounterSyscallErrors) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CounterSyscallErrors) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Count == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Count))
	}
	if len(m.TopErrorCodes) > 0 {
		for _, num := range m.TopErrorCodes {
			dAtA[i] = 0x10
			i++
			i = encodeVarintDraios(dAtA, i, uint64(num))
		}
	}
	if m.CountFile != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.CountFile))
	}
	if m.CountFileOpen != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.CountFileOpen))
	}
	if m.CountNet != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.CountNet))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResourceCategories) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceCategories) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CapacityScore != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.CapacityScore))
	}
	if m.ConnectionQueueUsagePct != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.ConnectionQueueUsagePct))
	}
	if m.FdUsagePct != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.FdUsagePct))
	}
	if m.CpuPct != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.CpuPct))
	}
	if m.ResidentMemoryUsageKb != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.ResidentMemoryUsageKb))
	}
	if m.StolenCapacityScore != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.StolenCapacityScore))
	}
	if m.VirtualMemoryUsageKb != nil {
		dAtA[i] = 0x68
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.VirtualMemoryUsageKb))
	}
	if m.SwapMemoryUsageKb != nil {
		dAtA[i] = 0x70
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.SwapMemoryUsageKb))
	}
	if m.MajorPagefaults != nil {
		dAtA[i] = 0x78
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.MajorPagefaults))
	}
	if m.MinorPagefaults != nil {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.MinorPagefaults))
	}
	if m.FdCount != nil {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.FdCount))
	}
	if m.CpuShares != nil {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.CpuShares))
	}
	if m.CpuSharesUsagePct != nil {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.CpuSharesUsagePct))
	}
	if m.MemoryLimitKb != nil {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.MemoryLimitKb))
	}
	if m.SwapLimitKb != nil {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.SwapLimitKb))
	}
	if m.CpuQuotaUsedPct != nil {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.CpuQuotaUsedPct))
	}
	if m.SwapMemoryTotalKb != nil {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.SwapMemoryTotalKb))
	}
	if m.SwapMemoryAvailableKb != nil {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.SwapMemoryAvailableKb))
	}
	if m.CountProcesses != nil {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.CountProcesses))
	}
	if m.ProcStartCount != nil {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.ProcStartCount))
	}
	if m.JmxSent != nil {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.JmxSent))
	}
	if m.JmxTotal != nil {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.JmxTotal))
	}
	if m.StatsdSent != nil {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.StatsdSent))
	}
	if m.StatsdTotal != nil {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.StatsdTotal))
	}
	if m.AppChecksSent != nil {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.AppChecksSent))
	}
	if m.AppChecksTotal != nil {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.AppChecksTotal))
	}
	if m.ThreadsCount != nil {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.ThreadsCount))
	}
	if m.PrometheusSent != nil {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.PrometheusSent))
	}
	if m.PrometheusTotal != nil {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.PrometheusTotal))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConnectionCategories) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectionCategories) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Server != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Server.Size()))
		n29, err := m.Server.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.Client != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Client.Size()))
		n30, err := m.Client.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.TransactionCounters != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.TransactionCounters.Size()))
		n31, err := m.TransactionCounters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.NAggregatedConnections != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.NAggregatedConnections))
	}
	if m.MaxTransactionCounters != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.MaxTransactionCounters.Size()))
		n32, err := m.MaxTransactionCounters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProcessDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Comm == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Comm)))
		i += copy(dAtA[i:], *m.Comm)
	}
	if m.Exe == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Exe)))
		i += copy(dAtA[i:], *m.Exe)
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.ContainerId != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.ContainerId)))
		i += copy(dAtA[i:], *m.ContainerId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Timestamp))
	}
	if m.Count != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Count))
	}
	if m.Cmdline == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Cmdline)))
		i += copy(dAtA[i:], *m.Cmdline)
	}
	if m.Comm == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Comm)))
		i += copy(dAtA[i:], *m.Comm)
	}
	if m.Pid == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Pid))
	}
	if m.Ppid == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x30
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Ppid))
	}
	if m.Uid == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x38
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Uid))
	}
	if m.Cwd != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Cwd)))
		i += copy(dAtA[i:], *m.Cwd)
	}
	if m.LoginShellId != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.LoginShellId))
	}
	if m.LoginShellDistance != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.LoginShellDistance))
	}
	if m.Tty != nil {
		dAtA[i] = 0x58
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Tty))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CounterProtoEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CounterProtoEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ncalls == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Ncalls))
	}
	if m.TimeTot == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TimeTot))
	}
	if m.TimeMax == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TimeMax))
	}
	if m.BytesIn == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.BytesIn))
	}
	if m.BytesOut == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.BytesOut))
	}
	if m.Nerrors == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x30
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Nerrors))
	}
	if len(m.Percentile) > 0 {
		for _, msg := range m.Percentile {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PercentileData != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.PercentileData.Size()))
		n33, err := m.PercentileData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UrlDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UrlDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Url == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Url)))
		i += copy(dAtA[i:], *m.Url)
	}
	if m.Counters == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Counters.Size()))
		n34, err := m.Counters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StatusCodeDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusCodeDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StatusCode == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.StatusCode))
	}
	if m.Ncalls == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Ncalls))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HttpInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServerUrls) > 0 {
		for _, msg := range m.ServerUrls {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ClientUrls) > 0 {
		for _, msg := range m.ClientUrls {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ClientStatusCodes) > 0 {
		for _, msg := range m.ClientStatusCodes {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ServerStatusCodes) > 0 {
		for _, msg := range m.ServerStatusCodes {
			dAtA[i] = 0x22
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SqlEntryDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SqlEntryDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.Counters == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Counters.Size()))
		n35, err := m.Counters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SqlQueryTypeDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SqlQueryTypeDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Type))
	}
	if m.Counters == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Counters.Size()))
		n36, err := m.Counters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SqlInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SqlInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServerQueries) > 0 {
		for _, msg := range m.ServerQueries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ClientQueries) > 0 {
		for _, msg := range m.ClientQueries {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ServerQueryTypes) > 0 {
		for _, msg := range m.ServerQueryTypes {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ClientQueryTypes) > 0 {
		for _, msg := range m.ClientQueryTypes {
			dAtA[i] = 0x22
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ServerTables) > 0 {
		for _, msg := range m.ServerTables {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ClientTables) > 0 {
		for _, msg := range m.ClientTables {
			dAtA[i] = 0x32
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MongodbCollectionDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MongodbCollectionDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.Counters == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Counters.Size()))
		n37, err := m.Counters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MongodbOpTypeDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MongodbOpTypeDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Op))
	}
	if m.Counters == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Counters.Size()))
		n38, err := m.Counters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MongodbInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MongodbInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServersOps) > 0 {
		for _, msg := range m.ServersOps {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ClientOps) > 0 {
		for _, msg := range m.ClientOps {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ServerCollections) > 0 {
		for _, msg := range m.ServerCollections {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ClientCollections) > 0 {
		for _, msg := range m.ClientCollections {
			dAtA[i] = 0x22
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *JmxAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JmxAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.Value != nil {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Value))))
		i += 8
	}
	if len(m.Subattributes) > 0 {
		for _, msg := range m.Subattributes {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Alias != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Alias)))
		i += copy(dAtA[i:], *m.Alias)
	}
	if m.Type != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Type))
	}
	if m.Unit != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Unit))
	}
	if m.Scale != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Scale))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *JmxBean) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JmxBean) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if len(m.Attributes) > 0 {
		for _, msg := range m.Attributes {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *JavaInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JavaInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProcessName != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.ProcessName)))
		i += copy(dAtA[i:], *m.ProcessName)
	}
	if len(m.Beans) > 0 {
		for _, msg := range m.Beans {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StatsdTag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatsdTag) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Key)))
		i += copy(dAtA[i:], *m.Key)
	}
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Value)))
		i += copy(dAtA[i:], *m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StatsdMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatsdMetric) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Type != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Type))
	}
	if m.Value != nil {
		dAtA[i] = 0x21
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Value))))
		i += 8
	}
	if m.Sum != nil {
		dAtA[i] = 0x29
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Sum))))
		i += 8
	}
	if m.Min != nil {
		dAtA[i] = 0x31
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Min))))
		i += 8
	}
	if m.Max != nil {
		dAtA[i] = 0x39
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Max))))
		i += 8
	}
	if m.Count != nil {
		dAtA[i] = 0x41
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Count))))
		i += 8
	}
	if len(m.Percentile) > 0 {
		for _, msg := range m.Percentile {
			dAtA[i] = 0x62
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PercentileData != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.PercentileData.Size()))
		n39, err := m.PercentileData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StatsdInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatsdInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StatsdMetrics) > 0 {
		for _, msg := range m.StatsdMetrics {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AppTag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppTag) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Key)))
		i += copy(dAtA[i:], *m.Key)
	}
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Value)))
		i += copy(dAtA[i:], *m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AppMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppMetric) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.Type != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Type))
	}
	if m.Value != nil {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Value))))
		i += 8
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x22
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AppCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppCheck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.Value != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Value))
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AppInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProcessName != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.ProcessName)))
		i += copy(dAtA[i:], *m.ProcessName)
	}
	if len(m.Metrics) > 0 {
		for _, msg := range m.Metrics {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Checks) > 0 {
		for _, msg := range m.Checks {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProtoInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtoInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Http != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Http.Size()))
		n40, err := m.Http.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.Mysql != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Mysql.Size()))
		n41, err := m.Mysql.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.Postgres != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Postgres.Size()))
		n42, err := m.Postgres.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.Mongodb != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Mongodb.Size()))
		n43, err := m.Mongodb.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.Java != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Java.Size()))
		n44, err := m.Java.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.Statsd != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Statsd.Size()))
		n45, err := m.Statsd.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.App != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.App.Size()))
		n46, err := m.App.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if m.Prometheus != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Prometheus.Size()))
		n47, err := m.Prometheus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NetworkByPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkByPort) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Port == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Port))
	}
	if m.Counters == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Counters.Size()))
		n48, err := m.Counters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Host) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Host) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Hostname != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Hostname)))
		i += copy(dAtA[i:], *m.Hostname)
	}
	if m.NumCpus != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.NumCpus))
	}
	if len(m.CpuLoads) > 0 {
		for _, num := range m.CpuLoads {
			dAtA[i] = 0x18
			i++
			i = encodeVarintDraios(dAtA, i, uint64(num))
		}
	}
	if m.PhysicalMemorySizeBytes == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.PhysicalMemorySizeBytes))
	}
	if m.Tcounters != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Tcounters.Size()))
		n49, err := m.Tcounters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.TransactionCounters != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.TransactionCounters.Size()))
		n50, err := m.TransactionCounters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.TransactionProcessingDelay != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TransactionProcessingDelay))
	}
	if m.ResourceCounters != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.ResourceCounters.Size()))
		n51, err := m.ResourceCounters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if m.SyscallErrors != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.SyscallErrors.Size()))
		n52, err := m.SyscallErrors.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if m.ExternalIoNet != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.ExternalIoNet.Size()))
		n53, err := m.ExternalIoNet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if len(m.CpuSteal) > 0 {
		for _, num := range m.CpuSteal {
			dAtA[i] = 0x58
			i++
			i = encodeVarintDraios(dAtA, i, uint64(num))
		}
	}
	if m.Reqcounters != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Reqcounters.Size()))
		n54, err := m.Reqcounters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if m.NextTiersDelay != nil {
		dAtA[i] = 0x68
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.NextTiersDelay))
	}
	if m.MaxTransactionCounters != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.MaxTransactionCounters.Size()))
		n55, err := m.MaxTransactionCounters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	if len(m.NetworkByServerports) > 0 {
		for _, msg := range m.NetworkByServerports {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CpuIdle) > 0 {
		for _, num := range m.CpuIdle {
			dAtA[i] = 0xc8
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDraios(dAtA, i, uint64(num))
		}
	}
	if m.Uptime != nil {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Uptime))
	}
	if len(m.SystemCpu) > 0 {
		for _, num := range m.SystemCpu {
			dAtA[i] = 0x90
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintDraios(dAtA, i, uint64(num))
		}
	}
	if len(m.UserCpu) > 0 {
		for _, num := range m.UserCpu {
			dAtA[i] = 0x98
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintDraios(dAtA, i, uint64(num))
		}
	}
	if m.MemoryBytesAvailableKb != nil {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.MemoryBytesAvailableKb))
	}
	if len(m.IowaitCpu) > 0 {
		for _, num := range m.IowaitCpu {
			dAtA[i] = 0xa8
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintDraios(dAtA, i, uint64(num))
		}
	}
	if len(m.NiceCpu) > 0 {
		for _, num := range m.NiceCpu {
			dAtA[i] = 0xb0
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintDraios(dAtA, i, uint64(num))
		}
	}
	if m.SystemLoad_1 != nil {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.SystemLoad_1))
	}
	if m.SystemLoad_5 != nil {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.SystemLoad_5))
	}
	if m.SystemLoad_15 != nil {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.SystemLoad_15))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Process) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Process) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Details != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Details.Size()))
		n56, err := m.Details.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if m.IsIpv4TransactionServer != nil {
		dAtA[i] = 0x18
		i++
		if *m.IsIpv4TransactionServer {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsUnixTransactionServer != nil {
		dAtA[i] = 0x20
		i++
		if *m.IsUnixTransactionServer {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Tcounters != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Tcounters.Size()))
		n57, err := m.Tcounters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	if m.TransactionCounters != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.TransactionCounters.Size()))
		n58, err := m.TransactionCounters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	if m.TransactionProcessingDelay != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TransactionProcessingDelay))
	}
	if m.ResourceCounters != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.ResourceCounters.Size()))
		n59, err := m.ResourceCounters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	if m.SyscallErrors != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.SyscallErrors.Size()))
		n60, err := m.SyscallErrors.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	if m.IsIpv4TransactionClient != nil {
		dAtA[i] = 0x50
		i++
		if *m.IsIpv4TransactionClient {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsUnixTransactionClient != nil {
		dAtA[i] = 0x58
		i++
		if *m.IsUnixTransactionClient {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NextTiersDelay != nil {
		dAtA[i] = 0x60
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.NextTiersDelay))
	}
	if m.Netrole != nil {
		dAtA[i] = 0x68
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Netrole))
	}
	if m.MaxTransactionCounters != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.MaxTransactionCounters.Size()))
		n61, err := m.MaxTransactionCounters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	if m.Protos != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Protos.Size()))
		n62, err := m.Protos.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	if m.StartCount != nil {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.StartCount))
	}
	if m.CountProcesses != nil {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.CountProcesses))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Program) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Program) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Procinfo == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Procinfo.Size()))
		n63, err := m.Procinfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	if len(m.Pids) > 0 {
		for _, num := range m.Pids {
			dAtA[i] = 0x10
			i++
			i = encodeVarintDraios(dAtA, i, uint64(num))
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Ipv4Tuple) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ipv4Tuple) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sip == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Sip))
	}
	if m.Dip == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Dip))
	}
	if m.Sport == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Sport))
	}
	if m.Dport == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Dport))
	}
	if m.L4Proto == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.L4Proto))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Ipv4Connection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ipv4Connection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tuple == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Tuple.Size()))
		n64, err := m.Tuple.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	if m.Spid != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Spid))
	}
	if m.Dpid != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Dpid))
	}
	if m.Counters == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x42
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Counters.Size()))
		n65, err := m.Counters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Ipv4NetworkInterface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ipv4NetworkInterface) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.Addr == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Addr))
	}
	if m.Netmask == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Netmask))
	}
	if m.Bcast != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Bcast))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MountedFs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MountedFs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Device == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Device)))
		i += copy(dAtA[i:], *m.Device)
	}
	if m.MountDir == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.MountDir)))
		i += copy(dAtA[i:], *m.MountDir)
	}
	if m.Type == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Type)))
		i += copy(dAtA[i:], *m.Type)
	}
	if m.SizeBytes == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.SizeBytes))
	}
	if m.UsedBytes == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.UsedBytes))
	}
	if m.AvailableBytes == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x30
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.AvailableBytes))
	}
	if m.TotalInodes != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TotalInodes))
	}
	if m.UsedInodes != nil {
		dAtA[i] = 0x58
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.UsedInodes))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FileStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileStat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.Bytes == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Bytes))
	}
	if m.TimeNs == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TimeNs))
	}
	if m.OpenCount == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.OpenCount))
	}
	if m.Errors == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Errors))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ContainerPortMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerPortMapping) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HostIp != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.HostIp))
	}
	if m.HostPort != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.HostPort))
	}
	if m.ContainerIp != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.ContainerIp))
	}
	if m.ContainerPort != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.ContainerPort))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ContainerLabel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerLabel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Key)))
		i += copy(dAtA[i:], *m.Key)
	}
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Value)))
		i += copy(dAtA[i:], *m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Container) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Container) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Id)))
		i += copy(dAtA[i:], *m.Id)
	}
	if m.Type != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Type))
	}
	if m.Name != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.Image != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Image)))
		i += copy(dAtA[i:], *m.Image)
	}
	if m.Tcounters != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Tcounters.Size()))
		n66, err := m.Tcounters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	if m.Reqcounters != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Reqcounters.Size()))
		n67, err := m.Reqcounters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	if m.TransactionCounters != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.TransactionCounters.Size()))
		n68, err := m.TransactionCounters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	if m.MaxTransactionCounters != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.MaxTransactionCounters.Size()))
		n69, err := m.MaxTransactionCounters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	if m.TransactionProcessingDelay != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TransactionProcessingDelay))
	}
	if m.NextTiersDelay != nil {
		dAtA[i] = 0x60
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.NextTiersDelay))
	}
	if m.ResourceCounters != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.ResourceCounters.Size()))
		n70, err := m.ResourceCounters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	if m.SyscallErrors != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.SyscallErrors.Size()))
		n71, err := m.SyscallErrors.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	if len(m.PortMappings) > 0 {
		for _, msg := range m.PortMappings {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Protos != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Protos.Size()))
		n72, err := m.Protos.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	if len(m.Labels) > 0 {
		for _, msg := range m.Labels {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Mounts) > 0 {
		for _, msg := range m.Mounts {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NetworkByServerports) > 0 {
		for _, msg := range m.NetworkByServerports {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MesosTaskId != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.MesosTaskId)))
		i += copy(dAtA[i:], *m.MesosTaskId)
	}
	if m.ImageId != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.ImageId)))
		i += copy(dAtA[i:], *m.ImageId)
	}
	if len(m.Commands) > 0 {
		for _, msg := range m.Commands {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CongroupUid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CongroupUid) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kind != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Kind)))
		i += copy(dAtA[i:], *m.Kind)
	}
	if m.Id != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Id)))
		i += copy(dAtA[i:], *m.Id)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CongroupNetPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CongroupNetPort) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Port == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Port))
	}
	if m.TargetPort == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TargetPort))
	}
	if m.Protocol != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Protocol)))
		i += copy(dAtA[i:], *m.Protocol)
	}
	if m.NodePort != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.NodePort))
	}
	if m.PublishedPort != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.PublishedPort))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ContainerGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Uid.Size()))
		n73, err := m.Uid.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n73
	}
	if len(m.Tags) > 0 {
		for k, _ := range m.Tags {
			dAtA[i] = 0x1a
			i++
			v := m.Tags[k]
			mapSize := 1 + len(k) + sovDraios(uint64(len(k))) + 1 + len(v) + sovDraios(uint64(len(v)))
			i = encodeVarintDraios(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintDraios(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintDraios(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.IpAddresses) > 0 {
		for _, s := range m.IpAddresses {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x32
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Metrics) > 0 {
		for _, msg := range m.Metrics {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Children) > 0 {
		for _, msg := range m.Children {
			dAtA[i] = 0x42
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Parents) > 0 {
		for _, msg := range m.Parents {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.InternalTags) > 0 {
		for k, _ := range m.InternalTags {
			dAtA[i] = 0x52
			i++
			v := m.InternalTags[k]
			mapSize := 1 + len(k) + sovDraios(uint64(len(k))) + 1 + len(v) + sovDraios(uint64(len(v)))
			i = encodeVarintDraios(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintDraios(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintDraios(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CongroupUpdateEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CongroupUpdateEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Type))
	}
	if m.Object == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Object.Size()))
		n74, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OrchestratorEvents) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrchestratorEvents) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *K8SPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SPair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Key)))
		i += copy(dAtA[i:], *m.Key)
	}
	if m.Value == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Value)))
		i += copy(dAtA[i:], *m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *K8SCommon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SCommon) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.Uid == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Uid)))
		i += copy(dAtA[i:], *m.Uid)
	}
	if m.Namespace != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Namespace)))
		i += copy(dAtA[i:], *m.Namespace)
	}
	if len(m.Labels) > 0 {
		for _, msg := range m.Labels {
			dAtA[i] = 0x22
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Selectors) > 0 {
		for _, msg := range m.Selectors {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *K8SNamespace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SNamespace) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Common.Size()))
		n75, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *K8SNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Common.Size()))
		n76, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n76
	}
	if len(m.HostIps) > 0 {
		for _, s := range m.HostIps {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *K8SPod) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SPod) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Common.Size()))
		n77, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n77
	}
	if len(m.ContainerIds) > 0 {
		for _, s := range m.ContainerIds {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.NodeName != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.NodeName)))
		i += copy(dAtA[i:], *m.NodeName)
	}
	if m.HostIp != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.HostIp)))
		i += copy(dAtA[i:], *m.HostIp)
	}
	if m.InternalIp != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.InternalIp)))
		i += copy(dAtA[i:], *m.InternalIp)
	}
	if m.RestartCount != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.RestartCount))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *K8SReplicationController) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SReplicationController) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Common.Size()))
		n78, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n78
	}
	if m.ReplicasDesired != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.ReplicasDesired))
	}
	if m.ReplicasRunning != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.ReplicasRunning))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *K8SReplicaSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SReplicaSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Common.Size()))
		n79, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n79
	}
	if m.ReplicasDesired != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.ReplicasDesired))
	}
	if m.ReplicasRunning != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.ReplicasRunning))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *K8SService) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SService) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Common.Size()))
		n80, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n80
	}
	if m.ClusterIp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.ClusterIp)))
		i += copy(dAtA[i:], *m.ClusterIp)
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *K8SServiceNetPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SServiceNetPort) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Port == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Port))
	}
	if m.TargetPort == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TargetPort))
	}
	if m.Protocol != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Protocol)))
		i += copy(dAtA[i:], *m.Protocol)
	}
	if m.NodePort != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.NodePort))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *K8SDeployment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SDeployment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Common.Size()))
		n81, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n81
	}
	if m.ReplicasDesired != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.ReplicasDesired))
	}
	if m.ReplicasRunning != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.ReplicasRunning))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *K8SDaemonset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SDaemonset) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Common.Size()))
		n82, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n82
	}
	if m.CurrentScheduled != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.CurrentScheduled))
	}
	if m.DesiredScheduled != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.DesiredScheduled))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *K8SState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespaces) > 0 {
		for _, msg := range m.Namespaces {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Nodes) > 0 {
		for _, msg := range m.Nodes {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Pods) > 0 {
		for _, msg := range m.Pods {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Controllers) > 0 {
		for _, msg := range m.Controllers {
			dAtA[i] = 0x22
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Services) > 0 {
		for _, msg := range m.Services {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ReplicaSets) > 0 {
		for _, msg := range m.ReplicaSets {
			dAtA[i] = 0x32
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Deployments) > 0 {
		for _, msg := range m.Deployments {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Daemonsets) > 0 {
		for _, msg := range m.Daemonsets {
			dAtA[i] = 0x42
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MesosPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MesosPair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Key)))
		i += copy(dAtA[i:], *m.Key)
	}
	if m.Value == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Value)))
		i += copy(dAtA[i:], *m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MesosCommon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MesosCommon) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Uid)))
		i += copy(dAtA[i:], *m.Uid)
	}
	if m.Name != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if len(m.Labels) > 0 {
		for _, msg := range m.Labels {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MesosTask) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MesosTask) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Common.Size()))
		n83, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n83
	}
	if m.SlaveId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.SlaveId)))
		i += copy(dAtA[i:], *m.SlaveId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MarathonApp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarathonApp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Id)))
		i += copy(dAtA[i:], *m.Id)
	}
	if len(m.TaskIds) > 0 {
		for _, s := range m.TaskIds {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MarathonGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarathonGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Id)))
		i += copy(dAtA[i:], *m.Id)
	}
	if len(m.Apps) > 0 {
		for _, msg := range m.Apps {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Groups) > 0 {
		for _, msg := range m.Groups {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MesosFramework) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MesosFramework) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Common.Size()))
		n84, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n84
	}
	if len(m.Tasks) > 0 {
		for _, msg := range m.Tasks {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MesosSlave) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MesosSlave) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Common.Size()))
		n85, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n85
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MesosState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MesosState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Frameworks) > 0 {
		for _, msg := range m.Frameworks {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Groups) > 0 {
		for _, msg := range m.Groups {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Slaves) > 0 {
		for _, msg := range m.Slaves {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SwarmPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwarmPair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Key)))
		i += copy(dAtA[i:], *m.Key)
	}
	if m.Value == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Value)))
		i += copy(dAtA[i:], *m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SwarmPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwarmPort) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Port != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Port))
	}
	if m.PublishedPort != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.PublishedPort))
	}
	if m.Protocol != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Protocol)))
		i += copy(dAtA[i:], *m.Protocol)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SwarmCommon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwarmCommon) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Id)))
		i += copy(dAtA[i:], *m.Id)
	}
	if m.Name != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if len(m.Labels) > 0 {
		for _, msg := range m.Labels {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SwarmService) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwarmService) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Common.Size()))
		n86, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n86
	}
	if len(m.VirtualIps) > 0 {
		for _, s := range m.VirtualIps {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Mode != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Mode))
	}
	if m.SpecReplicas != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.SpecReplicas))
	}
	if m.Tasks != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Tasks))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SwarmTask) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwarmTask) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Common.Size()))
		n87, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n87
	}
	if m.ServiceId != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.ServiceId)))
		i += copy(dAtA[i:], *m.ServiceId)
	}
	if m.NodeId != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.NodeId)))
		i += copy(dAtA[i:], *m.NodeId)
	}
	if m.ContainerId != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.ContainerId)))
		i += copy(dAtA[i:], *m.ContainerId)
	}
	if m.State != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.State)))
		i += copy(dAtA[i:], *m.State)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SwarmManager) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwarmManager) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Leader != nil {
		dAtA[i] = 0x8
		i++
		if *m.Leader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Reachability != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Reachability)))
		i += copy(dAtA[i:], *m.Reachability)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SwarmNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwarmNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Common.Size()))
		n88, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n88
	}
	if m.Role != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Role)))
		i += copy(dAtA[i:], *m.Role)
	}
	if m.IpAddress != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.IpAddress)))
		i += copy(dAtA[i:], *m.IpAddress)
	}
	if m.Version != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Version)))
		i += copy(dAtA[i:], *m.Version)
	}
	if m.Availability != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Availability)))
		i += copy(dAtA[i:], *m.Availability)
	}
	if m.State != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.State)))
		i += copy(dAtA[i:], *m.State)
	}
	if m.Manager != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Manager.Size()))
		n89, err := m.Manager.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n89
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SwarmState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwarmState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Services) > 0 {
		for _, msg := range m.Services {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Nodes) > 0 {
		for _, msg := range m.Nodes {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tasks) > 0 {
		for _, msg := range m.Tasks {
			dAtA[i] = 0x22
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Quorum != nil {
		dAtA[i] = 0x28
		i++
		if *m.Quorum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NodeId != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.NodeId)))
		i += copy(dAtA[i:], *m.NodeId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OrchestratorStateT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrchestratorStateT) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for _, msg := range m.Groups {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ClusterId != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.ClusterId)))
		i += copy(dAtA[i:], *m.ClusterId)
	}
	if m.ClusterName != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.ClusterName)))
		i += copy(dAtA[i:], *m.ClusterName)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Metrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metrics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TimestampNs == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TimestampNs))
	}
	if m.MachineId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.MachineId)))
		i += copy(dAtA[i:], *m.MachineId)
	}
	if m.CustomerId != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.CustomerId)))
		i += copy(dAtA[i:], *m.CustomerId)
	}
	if m.Hostinfo != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Hostinfo.Size()))
		n90, err := m.Hostinfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n90
	}
	if len(m.Ipv4Connections) > 0 {
		for _, msg := range m.Ipv4Connections {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Ipv4NetworkInterfaces) > 0 {
		for _, msg := range m.Ipv4NetworkInterfaces {
			dAtA[i] = 0x42
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Programs) > 0 {
		for _, msg := range m.Programs {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SamplingRatio != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.SamplingRatio))
	}
	if m.HostCustomName != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.HostCustomName)))
		i += copy(dAtA[i:], *m.HostCustomName)
	}
	if m.HostTags != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.HostTags)))
		i += copy(dAtA[i:], *m.HostTags)
	}
	if m.IsHostHidden != nil {
		dAtA[i] = 0x70
		i++
		if *m.IsHostHidden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HiddenProcesses != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.HiddenProcesses)))
		i += copy(dAtA[i:], *m.HiddenProcesses)
	}
	if m.Version != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Version)))
		i += copy(dAtA[i:], *m.Version)
	}
	if len(m.Mounts) > 0 {
		for _, msg := range m.Mounts {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TopFiles) > 0 {
		for _, msg := range m.TopFiles {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Protos != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Protos.Size()))
		n91, err := m.Protos.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n91
	}
	if m.InstanceId != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.InstanceId)))
		i += copy(dAtA[i:], *m.InstanceId)
	}
	if len(m.Containers) > 0 {
		for _, msg := range m.Containers {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Kubernetes != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Kubernetes.Size()))
		n92, err := m.Kubernetes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n92
	}
	if m.Mesos != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Mesos.Size()))
		n93, err := m.Mesos.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n93
	}
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Falcobl != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Falcobl.Size()))
		n94, err := m.Falcobl.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n94
	}
	if len(m.Commands) > 0 {
		for _, msg := range m.Commands {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Swarm != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Swarm.Size()))
		n95, err := m.Swarm.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n95
	}
	if len(m.ConfigPercentiles) > 0 {
		for _, num := range m.ConfigPercentiles {
			dAtA[i] = 0xf0
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDraios(dAtA, i, uint64(num))
		}
	}
	if m.InternalMetrics != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.InternalMetrics.Size()))
		n96, err := m.InternalMetrics.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n96
	}
	if m.GlobalOrchestratorState != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.GlobalOrchestratorState.Size()))
		n97, err := m.GlobalOrchestratorState.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n97
	}
	if m.OrchestratorState != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.OrchestratorState.Size()))
		n98, err := m.OrchestratorState.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n98
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DumpRequestStart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DumpRequestStart) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TimestampNs == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TimestampNs))
	}
	if m.MachineId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.MachineId)))
		i += copy(dAtA[i:], *m.MachineId)
	}
	if m.CustomerId != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.CustomerId)))
		i += copy(dAtA[i:], *m.CustomerId)
	}
	if m.DurationNs != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.DurationNs))
	}
	if m.Filters != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Filters)))
		i += copy(dAtA[i:], *m.Filters)
	}
	if m.Token == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Token)))
		i += copy(dAtA[i:], *m.Token)
	}
	if m.MaxSize != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.MaxSize))
	}
	if m.PastDurationNs != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.PastDurationNs))
	}
	if m.PastSize != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.PastSize))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DumpRequestStop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DumpRequestStop) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TimestampNs == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TimestampNs))
	}
	if m.MachineId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.MachineId)))
		i += copy(dAtA[i:], *m.MachineId)
	}
	if m.CustomerId != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.CustomerId)))
		i += copy(dAtA[i:], *m.CustomerId)
	}
	if m.Token == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Token)))
		i += copy(dAtA[i:], *m.Token)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DumpResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DumpResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TimestampNs == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TimestampNs))
	}
	if m.MachineId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.MachineId)))
		i += copy(dAtA[i:], *m.MachineId)
	}
	if m.CustomerId != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.CustomerId)))
		i += copy(dAtA[i:], *m.CustomerId)
	}
	if m.Content != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if m.Error != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Error)))
		i += copy(dAtA[i:], *m.Error)
	}
	if m.Token == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Token)))
		i += copy(dAtA[i:], *m.Token)
	}
	if m.ChunkNo != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.ChunkNo))
	}
	if m.FinalChunk != nil {
		dAtA[i] = 0x40
		i++
		if *m.FinalChunk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.KeepAlive != nil {
		dAtA[i] = 0x48
		i++
		if *m.KeepAlive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FinalSizeBytes != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.FinalSizeBytes))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SshOpenChannel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SshOpenChannel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TimestampNs == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TimestampNs))
	}
	if m.MachineId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.MachineId)))
		i += copy(dAtA[i:], *m.MachineId)
	}
	if m.CustomerId != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.CustomerId)))
		i += copy(dAtA[i:], *m.CustomerId)
	}
	if m.Token == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Token)))
		i += copy(dAtA[i:], *m.Token)
	}
	if m.User == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.User)))
		i += copy(dAtA[i:], *m.User)
	}
	if m.Password != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Password)))
		i += copy(dAtA[i:], *m.Password)
	}
	if m.Key != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Key)))
		i += copy(dAtA[i:], *m.Key)
	}
	if m.Passphrase != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Passphrase)))
		i += copy(dAtA[i:], *m.Passphrase)
	}
	if m.Port != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Port))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SshData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SshData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TimestampNs == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TimestampNs))
	}
	if m.MachineId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.MachineId)))
		i += copy(dAtA[i:], *m.MachineId)
	}
	if m.CustomerId != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.CustomerId)))
		i += copy(dAtA[i:], *m.CustomerId)
	}
	if m.Token == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Token)))
		i += copy(dAtA[i:], *m.Token)
	}
	if m.Data != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Error != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Error)))
		i += copy(dAtA[i:], *m.Error)
	}
	if m.ExitStatus != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.ExitStatus))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SshCloseChannel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SshCloseChannel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TimestampNs == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TimestampNs))
	}
	if m.MachineId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.MachineId)))
		i += copy(dAtA[i:], *m.MachineId)
	}
	if m.CustomerId != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.CustomerId)))
		i += copy(dAtA[i:], *m.CustomerId)
	}
	if m.Token == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Token)))
		i += copy(dAtA[i:], *m.Token)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AutoUpdateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoUpdateRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TimestampNs == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TimestampNs))
	}
	if m.MachineId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.MachineId)))
		i += copy(dAtA[i:], *m.MachineId)
	}
	if m.CustomerId != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.CustomerId)))
		i += copy(dAtA[i:], *m.CustomerId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DirtyShutdownReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirtyShutdownReport) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TimestampNs == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TimestampNs))
	}
	if m.MachineId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.MachineId)))
		i += copy(dAtA[i:], *m.MachineId)
	}
	if m.CustomerId != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.CustomerId)))
		i += copy(dAtA[i:], *m.CustomerId)
	}
	if m.Log == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Log)))
		i += copy(dAtA[i:], *m.Log)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Key)))
		i += copy(dAtA[i:], *m.Key)
	}
	if m.Value == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Value)))
		i += copy(dAtA[i:], *m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AgentEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AgentEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TimestampSec != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TimestampSec))
	}
	if m.Scope != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Scope)))
		i += copy(dAtA[i:], *m.Scope)
	}
	if m.Title != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Title)))
		i += copy(dAtA[i:], *m.Title)
	}
	if m.Description != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Description)))
		i += copy(dAtA[i:], *m.Description)
	}
	if m.Severity != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Severity))
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x32
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConfigFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigFile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.Content != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Content)))
		i += copy(dAtA[i:], *m.Content)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConfigData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ConfigFiles) > 0 {
		for _, msg := range m.ConfigFiles {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StopAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Msg != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Msg)))
		i += copy(dAtA[i:], *m.Msg)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PauseAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PauseAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Msg != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Msg)))
		i += copy(dAtA[i:], *m.Msg)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CaptureAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptureAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BeforeEventNs == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.BeforeEventNs))
	}
	if m.AfterEventNs == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.AfterEventNs))
	}
	if m.Filter != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Filter)))
		i += copy(dAtA[i:], *m.Filter)
	}
	if m.IsLimitedToContainer != nil {
		dAtA[i] = 0x20
		i++
		if *m.IsLimitedToContainer {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Action) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Action) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Type))
	}
	if m.Stop != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Stop.Size()))
		n99, err := m.Stop.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n99
	}
	if m.Pause != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Pause.Size()))
		n100, err := m.Pause.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n100
	}
	if m.Capture != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.Capture.Size()))
		n101, err := m.Capture.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n101
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BaselineDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaselineDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ManualDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ManualDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FalcoRuleFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FalcoRuleFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Name != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FalcoDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FalcoDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RuleFilter == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.RuleFilter.Size()))
		n102, err := m.RuleFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n102
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ScopePredicate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScopePredicate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Key)))
		i += copy(dAtA[i:], *m.Key)
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Op == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Op))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Policy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Policy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Id))
	}
	if m.Name == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.Type == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Type))
	}
	if m.BaselineDetails != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.BaselineDetails.Size()))
		n103, err := m.BaselineDetails.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n103
	}
	if m.FalcoDetails != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.FalcoDetails.Size()))
		n104, err := m.FalcoDetails.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n104
	}
	if m.ManualDetails != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.ManualDetails.Size()))
		n105, err := m.ManualDetails.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n105
	}
	if len(m.Actions) > 0 {
		for _, msg := range m.Actions {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Enabled == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x40
		i++
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HostScope == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x48
		i++
		if *m.HostScope {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ContainerScope == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x50
		i++
		if *m.ContainerScope {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ScopePredicates) > 0 {
		for _, msg := range m.ScopePredicates {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FalcoRulesContents) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FalcoRulesContents) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Contents) > 0 {
		for _, s := range m.Contents {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Policies) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Policies) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PolicyList) > 0 {
		for _, msg := range m.PolicyList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.FalcoRules != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.FalcoRules.Size()))
		n106, err := m.FalcoRules.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n106
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BaselineEventDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaselineEventDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ManualEventDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ManualEventDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FalcoEventDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FalcoEventDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rule == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Rule)))
		i += copy(dAtA[i:], *m.Rule)
	}
	if m.Output == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Output)))
		i += copy(dAtA[i:], *m.Output)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ActionResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Type))
	}
	if m.Successful == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		if *m.Successful {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Errmsg != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Errmsg)))
		i += copy(dAtA[i:], *m.Errmsg)
	}
	if m.Token != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Token)))
		i += copy(dAtA[i:], *m.Token)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PolicyEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TimestampNs == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TimestampNs))
	}
	if m.PolicyId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.PolicyId))
	}
	if m.ContainerId != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.ContainerId)))
		i += copy(dAtA[i:], *m.ContainerId)
	}
	if m.BaselineDetails != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.BaselineDetails.Size()))
		n107, err := m.BaselineDetails.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n107
	}
	if m.FalcoDetails != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.FalcoDetails.Size()))
		n108, err := m.FalcoDetails.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n108
	}
	if m.ManualDetails != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDraios(dAtA, i, uint64(m.ManualDetails.Size()))
		n109, err := m.ManualDetails.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n109
	}
	if len(m.ActionResults) > 0 {
		for _, msg := range m.ActionResults {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SinspEventsDropped != nil {
		dAtA[i] = 0x40
		i++
		if *m.SinspEventsDropped {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PolicyEvents) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyEvents) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MachineId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.MachineId)))
		i += copy(dAtA[i:], *m.MachineId)
	}
	if m.CustomerId != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.CustomerId)))
		i += copy(dAtA[i:], *m.CustomerId)
	}
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ThrottledPolicyEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThrottledPolicyEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TimestampNs == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.TimestampNs))
	}
	if m.PolicyId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.PolicyId))
	}
	if m.ContainerId != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.ContainerId)))
		i += copy(dAtA[i:], *m.ContainerId)
	}
	if m.Count == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Count))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ThrottledPolicyEvents) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThrottledPolicyEvents) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MachineId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.MachineId)))
		i += copy(dAtA[i:], *m.MachineId)
	}
	if m.CustomerId != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.CustomerId)))
		i += copy(dAtA[i:], *m.CustomerId)
	}
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ErrorMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrorMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.Type))
	}
	if m.Description != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Description)))
		i += copy(dAtA[i:], *m.Description)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FalcoSubcategory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FalcoSubcategory) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if len(m.D) > 0 {
		for _, s := range m.D {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Full != nil {
		dAtA[i] = 0x18
		i++
		if *m.Full {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FalcoSubcategoryContainer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FalcoSubcategoryContainer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Subcats) > 0 {
		for _, msg := range m.Subcats {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FalcoCategory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FalcoCategory) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if len(m.StartupSubcats) > 0 {
		for _, msg := range m.StartupSubcats {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RegularSubcats) > 0 {
		for _, msg := range m.RegularSubcats {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FalcoProg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FalcoProg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Comm == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Comm)))
		i += copy(dAtA[i:], *m.Comm)
	}
	if m.Exe == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Exe)))
		i += copy(dAtA[i:], *m.Exe)
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.UserId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDraios(dAtA, i, uint64(*m.UserId))
	}
	if m.ContainerId != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.ContainerId)))
		i += copy(dAtA[i:], *m.ContainerId)
	}
	if len(m.Cats) > 0 {
		for _, msg := range m.Cats {
			dAtA[i] = 0x32
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FalcoContainer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FalcoContainer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Id)))
		i += copy(dAtA[i:], *m.Id)
	}
	if m.Name == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.ImageName != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.ImageName)))
		i += copy(dAtA[i:], *m.ImageName)
	}
	if m.ImageId != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDraios(dAtA, i, uint64(len(*m.ImageId)))
		i += copy(dAtA[i:], *m.ImageId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FalcoBaseline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FalcoBaseline) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Progs) > 0 {
		for _, msg := range m.Progs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Containers) > 0 {
		for _, msg := range m.Containers {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDraios(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintDraios(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CounterPercentileData) Size() (n int) {
	var l int
	_ = l
	if m.Min != nil {
		n += 9
	}
	if m.Max != nil {
		n += 9
	}
	if m.Compression != nil {
		n += 1 + sovDraios(uint64(*m.Compression))
	}
	if m.NumSamples != nil {
		n += 1 + sovDraios(uint64(*m.NumSamples))
	}
	if len(m.Means) > 0 {
		n += 1 + sovDraios(uint64(len(m.Means)*8)) + len(m.Means)*8
	}
	if len(m.Weights) > 0 {
		n += 1 + sovDraios(uint64(len(m.Weights)*8)) + len(m.Weights)*8
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CounterPercentile) Size() (n int) {
	var l int
	_ = l
	if m.Percentile != nil {
		n += 1 + sovDraios(uint64(*m.Percentile))
	}
	if m.Value != nil {
		n += 1 + sovDraios(uint64(*m.Value))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CounterTime) Size() (n int) {
	var l int
	_ = l
	if m.Count != nil {
		n += 1 + sovDraios(uint64(*m.Count))
	}
	if m.TimeNs != nil {
		n += 1 + sovDraios(uint64(*m.TimeNs))
	}
	if m.TimePercentage != nil {
		n += 1 + sovDraios(uint64(*m.TimePercentage))
	}
	if len(m.Percentile) > 0 {
		for _, e := range m.Percentile {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.PercentileData != nil {
		l = m.PercentileData.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CounterTimeBidirectional) Size() (n int) {
	var l int
	_ = l
	if m.CountIn != nil {
		n += 1 + sovDraios(uint64(*m.CountIn))
	}
	if m.CountOut != nil {
		n += 1 + sovDraios(uint64(*m.CountOut))
	}
	if m.TimeNsIn != nil {
		n += 1 + sovDraios(uint64(*m.TimeNsIn))
	}
	if m.TimeNsOut != nil {
		n += 1 + sovDraios(uint64(*m.TimeNsOut))
	}
	if len(m.PercentileIn) > 0 {
		for _, e := range m.PercentileIn {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.PercentileOut) > 0 {
		for _, e := range m.PercentileOut {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.PercentileInData != nil {
		l = m.PercentileInData.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.PercentileOutData != nil {
		l = m.PercentileOutData.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CounterBytes) Size() (n int) {
	var l int
	_ = l
	if m.CountIn != nil {
		n += 1 + sovDraios(uint64(*m.CountIn))
	}
	if m.CountOut != nil {
		n += 1 + sovDraios(uint64(*m.CountOut))
	}
	if m.BytesIn != nil {
		n += 1 + sovDraios(uint64(*m.BytesIn))
	}
	if m.BytesOut != nil {
		n += 1 + sovDraios(uint64(*m.BytesOut))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CounterTimeBytes) Size() (n int) {
	var l int
	_ = l
	if m.TimeNsIn != nil {
		n += 1 + sovDraios(uint64(*m.TimeNsIn))
	}
	if m.TimeNsOut != nil {
		n += 1 + sovDraios(uint64(*m.TimeNsOut))
	}
	if m.TimeNsOther != nil {
		n += 1 + sovDraios(uint64(*m.TimeNsOther))
	}
	if m.CountIn != nil {
		n += 1 + sovDraios(uint64(*m.CountIn))
	}
	if m.CountOut != nil {
		n += 1 + sovDraios(uint64(*m.CountOut))
	}
	if m.CountOther != nil {
		n += 1 + sovDraios(uint64(*m.CountOther))
	}
	if m.BytesIn != nil {
		n += 1 + sovDraios(uint64(*m.BytesIn))
	}
	if m.BytesOut != nil {
		n += 1 + sovDraios(uint64(*m.BytesOut))
	}
	if m.BytesOther != nil {
		n += 1 + sovDraios(uint64(*m.BytesOther))
	}
	if m.TimePercentageIn != nil {
		n += 1 + sovDraios(uint64(*m.TimePercentageIn))
	}
	if m.TimePercentageOut != nil {
		n += 1 + sovDraios(uint64(*m.TimePercentageOut))
	}
	if m.TimePercentageOther != nil {
		n += 1 + sovDraios(uint64(*m.TimePercentageOther))
	}
	if len(m.PercentileIn) > 0 {
		for _, e := range m.PercentileIn {
			l = e.Size()
			n += 2 + l + sovDraios(uint64(l))
		}
	}
	if len(m.PercentileOut) > 0 {
		for _, e := range m.PercentileOut {
			l = e.Size()
			n += 2 + l + sovDraios(uint64(l))
		}
	}
	if m.PercentileInData != nil {
		l = m.PercentileInData.Size()
		n += 2 + l + sovDraios(uint64(l))
	}
	if m.PercentileOutData != nil {
		l = m.PercentileOutData.Size()
		n += 2 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TimeCategories) Size() (n int) {
	var l int
	_ = l
	if m.Unknown != nil {
		l = m.Unknown.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Other != nil {
		l = m.Other.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Net != nil {
		l = m.Net.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Ipc != nil {
		l = m.Ipc.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Memory != nil {
		l = m.Memory.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Process != nil {
		l = m.Process.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Sleep != nil {
		l = m.Sleep.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.System != nil {
		l = m.System.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Signal != nil {
		l = m.Signal.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.IoFile != nil {
		l = m.IoFile.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.IoNet != nil {
		l = m.IoNet.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.IoOther != nil {
		l = m.IoOther.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Wait != nil {
		l = m.Wait.Size()
		n += 2 + l + sovDraios(uint64(l))
	}
	if m.Processing != nil {
		l = m.Processing.Size()
		n += 2 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransactionBreakdownCategories) Size() (n int) {
	var l int
	_ = l
	if m.Other != nil {
		l = m.Other.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.IoFile != nil {
		l = m.IoFile.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.IoNet != nil {
		l = m.IoNet.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Processing != nil {
		l = m.Processing.Size()
		n += 2 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CounterSyscallErrors) Size() (n int) {
	var l int
	_ = l
	if m.Count != nil {
		n += 1 + sovDraios(uint64(*m.Count))
	}
	if len(m.TopErrorCodes) > 0 {
		for _, e := range m.TopErrorCodes {
			n += 1 + sovDraios(uint64(e))
		}
	}
	if m.CountFile != nil {
		n += 1 + sovDraios(uint64(*m.CountFile))
	}
	if m.CountFileOpen != nil {
		n += 1 + sovDraios(uint64(*m.CountFileOpen))
	}
	if m.CountNet != nil {
		n += 1 + sovDraios(uint64(*m.CountNet))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourceCategories) Size() (n int) {
	var l int
	_ = l
	if m.CapacityScore != nil {
		n += 1 + sovDraios(uint64(*m.CapacityScore))
	}
	if m.ConnectionQueueUsagePct != nil {
		n += 1 + sovDraios(uint64(*m.ConnectionQueueUsagePct))
	}
	if m.FdUsagePct != nil {
		n += 1 + sovDraios(uint64(*m.FdUsagePct))
	}
	if m.CpuPct != nil {
		n += 1 + sovDraios(uint64(*m.CpuPct))
	}
	if m.ResidentMemoryUsageKb != nil {
		n += 1 + sovDraios(uint64(*m.ResidentMemoryUsageKb))
	}
	if m.StolenCapacityScore != nil {
		n += 1 + sovDraios(uint64(*m.StolenCapacityScore))
	}
	if m.VirtualMemoryUsageKb != nil {
		n += 1 + sovDraios(uint64(*m.VirtualMemoryUsageKb))
	}
	if m.SwapMemoryUsageKb != nil {
		n += 1 + sovDraios(uint64(*m.SwapMemoryUsageKb))
	}
	if m.MajorPagefaults != nil {
		n += 1 + sovDraios(uint64(*m.MajorPagefaults))
	}
	if m.MinorPagefaults != nil {
		n += 2 + sovDraios(uint64(*m.MinorPagefaults))
	}
	if m.FdCount != nil {
		n += 2 + sovDraios(uint64(*m.FdCount))
	}
	if m.CpuShares != nil {
		n += 2 + sovDraios(uint64(*m.CpuShares))
	}
	if m.CpuSharesUsagePct != nil {
		n += 2 + sovDraios(uint64(*m.CpuSharesUsagePct))
	}
	if m.MemoryLimitKb != nil {
		n += 2 + sovDraios(uint64(*m.MemoryLimitKb))
	}
	if m.SwapLimitKb != nil {
		n += 2 + sovDraios(uint64(*m.SwapLimitKb))
	}
	if m.CpuQuotaUsedPct != nil {
		n += 2 + sovDraios(uint64(*m.CpuQuotaUsedPct))
	}
	if m.SwapMemoryTotalKb != nil {
		n += 2 + sovDraios(uint64(*m.SwapMemoryTotalKb))
	}
	if m.SwapMemoryAvailableKb != nil {
		n += 2 + sovDraios(uint64(*m.SwapMemoryAvailableKb))
	}
	if m.CountProcesses != nil {
		n += 2 + sovDraios(uint64(*m.CountProcesses))
	}
	if m.ProcStartCount != nil {
		n += 2 + sovDraios(uint64(*m.ProcStartCount))
	}
	if m.JmxSent != nil {
		n += 2 + sovDraios(uint64(*m.JmxSent))
	}
	if m.JmxTotal != nil {
		n += 2 + sovDraios(uint64(*m.JmxTotal))
	}
	if m.StatsdSent != nil {
		n += 2 + sovDraios(uint64(*m.StatsdSent))
	}
	if m.StatsdTotal != nil {
		n += 2 + sovDraios(uint64(*m.StatsdTotal))
	}
	if m.AppChecksSent != nil {
		n += 2 + sovDraios(uint64(*m.AppChecksSent))
	}
	if m.AppChecksTotal != nil {
		n += 2 + sovDraios(uint64(*m.AppChecksTotal))
	}
	if m.ThreadsCount != nil {
		n += 2 + sovDraios(uint64(*m.ThreadsCount))
	}
	if m.PrometheusSent != nil {
		n += 2 + sovDraios(uint64(*m.PrometheusSent))
	}
	if m.PrometheusTotal != nil {
		n += 2 + sovDraios(uint64(*m.PrometheusTotal))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectionCategories) Size() (n int) {
	var l int
	_ = l
	if m.Server != nil {
		l = m.Server.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Client != nil {
		l = m.Client.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.TransactionCounters != nil {
		l = m.TransactionCounters.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.NAggregatedConnections != nil {
		n += 1 + sovDraios(uint64(*m.NAggregatedConnections))
	}
	if m.MaxTransactionCounters != nil {
		l = m.MaxTransactionCounters.Size()
		n += 2 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProcessDetails) Size() (n int) {
	var l int
	_ = l
	if m.Comm != nil {
		l = len(*m.Comm)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Exe != nil {
		l = len(*m.Exe)
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.ContainerId != nil {
		l = len(*m.ContainerId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandDetails) Size() (n int) {
	var l int
	_ = l
	if m.Timestamp != nil {
		n += 1 + sovDraios(uint64(*m.Timestamp))
	}
	if m.Count != nil {
		n += 1 + sovDraios(uint64(*m.Count))
	}
	if m.Cmdline != nil {
		l = len(*m.Cmdline)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Comm != nil {
		l = len(*m.Comm)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Pid != nil {
		n += 1 + sovDraios(uint64(*m.Pid))
	}
	if m.Ppid != nil {
		n += 1 + sovDraios(uint64(*m.Ppid))
	}
	if m.Uid != nil {
		n += 1 + sovDraios(uint64(*m.Uid))
	}
	if m.Cwd != nil {
		l = len(*m.Cwd)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.LoginShellId != nil {
		n += 1 + sovDraios(uint64(*m.LoginShellId))
	}
	if m.LoginShellDistance != nil {
		n += 1 + sovDraios(uint64(*m.LoginShellDistance))
	}
	if m.Tty != nil {
		n += 1 + sovDraios(uint64(*m.Tty))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CounterProtoEntry) Size() (n int) {
	var l int
	_ = l
	if m.Ncalls != nil {
		n += 1 + sovDraios(uint64(*m.Ncalls))
	}
	if m.TimeTot != nil {
		n += 1 + sovDraios(uint64(*m.TimeTot))
	}
	if m.TimeMax != nil {
		n += 1 + sovDraios(uint64(*m.TimeMax))
	}
	if m.BytesIn != nil {
		n += 1 + sovDraios(uint64(*m.BytesIn))
	}
	if m.BytesOut != nil {
		n += 1 + sovDraios(uint64(*m.BytesOut))
	}
	if m.Nerrors != nil {
		n += 1 + sovDraios(uint64(*m.Nerrors))
	}
	if len(m.Percentile) > 0 {
		for _, e := range m.Percentile {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.PercentileData != nil {
		l = m.PercentileData.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UrlDetails) Size() (n int) {
	var l int
	_ = l
	if m.Url != nil {
		l = len(*m.Url)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Counters != nil {
		l = m.Counters.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StatusCodeDetails) Size() (n int) {
	var l int
	_ = l
	if m.StatusCode != nil {
		n += 1 + sovDraios(uint64(*m.StatusCode))
	}
	if m.Ncalls != nil {
		n += 1 + sovDraios(uint64(*m.Ncalls))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.ServerUrls) > 0 {
		for _, e := range m.ServerUrls {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.ClientUrls) > 0 {
		for _, e := range m.ClientUrls {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.ClientStatusCodes) > 0 {
		for _, e := range m.ClientStatusCodes {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.ServerStatusCodes) > 0 {
		for _, e := range m.ServerStatusCodes {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SqlEntryDetails) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Counters != nil {
		l = m.Counters.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SqlQueryTypeDetails) Size() (n int) {
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovDraios(uint64(*m.Type))
	}
	if m.Counters != nil {
		l = m.Counters.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SqlInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.ServerQueries) > 0 {
		for _, e := range m.ServerQueries {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.ClientQueries) > 0 {
		for _, e := range m.ClientQueries {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.ServerQueryTypes) > 0 {
		for _, e := range m.ServerQueryTypes {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.ClientQueryTypes) > 0 {
		for _, e := range m.ClientQueryTypes {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.ServerTables) > 0 {
		for _, e := range m.ServerTables {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.ClientTables) > 0 {
		for _, e := range m.ClientTables {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MongodbCollectionDetails) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Counters != nil {
		l = m.Counters.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MongodbOpTypeDetails) Size() (n int) {
	var l int
	_ = l
	if m.Op != nil {
		n += 1 + sovDraios(uint64(*m.Op))
	}
	if m.Counters != nil {
		l = m.Counters.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MongodbInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.ServersOps) > 0 {
		for _, e := range m.ServersOps {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.ClientOps) > 0 {
		for _, e := range m.ClientOps {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.ServerCollections) > 0 {
		for _, e := range m.ServerCollections {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.ClientCollections) > 0 {
		for _, e := range m.ClientCollections {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JmxAttribute) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Value != nil {
		n += 9
	}
	if len(m.Subattributes) > 0 {
		for _, e := range m.Subattributes {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.Alias != nil {
		l = len(*m.Alias)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sovDraios(uint64(*m.Type))
	}
	if m.Unit != nil {
		n += 1 + sovDraios(uint64(*m.Unit))
	}
	if m.Scale != nil {
		n += 1 + sovDraios(uint64(*m.Scale))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JmxBean) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JavaInfo) Size() (n int) {
	var l int
	_ = l
	if m.ProcessName != nil {
		l = len(*m.ProcessName)
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.Beans) > 0 {
		for _, e := range m.Beans {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StatsdTag) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StatsdMetric) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.Type != nil {
		n += 1 + sovDraios(uint64(*m.Type))
	}
	if m.Value != nil {
		n += 9
	}
	if m.Sum != nil {
		n += 9
	}
	if m.Min != nil {
		n += 9
	}
	if m.Max != nil {
		n += 9
	}
	if m.Count != nil {
		n += 9
	}
	if len(m.Percentile) > 0 {
		for _, e := range m.Percentile {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.PercentileData != nil {
		l = m.PercentileData.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StatsdInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.StatsdMetrics) > 0 {
		for _, e := range m.StatsdMetrics {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppTag) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppMetric) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sovDraios(uint64(*m.Type))
	}
	if m.Value != nil {
		n += 9
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppCheck) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Value != nil {
		n += 1 + sovDraios(uint64(*m.Value))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppInfo) Size() (n int) {
	var l int
	_ = l
	if m.ProcessName != nil {
		l = len(*m.ProcessName)
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.Metrics) > 0 {
		for _, e := range m.Metrics {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.Checks) > 0 {
		for _, e := range m.Checks {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProtoInfo) Size() (n int) {
	var l int
	_ = l
	if m.Http != nil {
		l = m.Http.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Mysql != nil {
		l = m.Mysql.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Postgres != nil {
		l = m.Postgres.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Mongodb != nil {
		l = m.Mongodb.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Java != nil {
		l = m.Java.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Statsd != nil {
		l = m.Statsd.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.App != nil {
		l = m.App.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Prometheus != nil {
		l = m.Prometheus.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkByPort) Size() (n int) {
	var l int
	_ = l
	if m.Port != nil {
		n += 1 + sovDraios(uint64(*m.Port))
	}
	if m.Counters != nil {
		l = m.Counters.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Host) Size() (n int) {
	var l int
	_ = l
	if m.Hostname != nil {
		l = len(*m.Hostname)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.NumCpus != nil {
		n += 1 + sovDraios(uint64(*m.NumCpus))
	}
	if len(m.CpuLoads) > 0 {
		for _, e := range m.CpuLoads {
			n += 1 + sovDraios(uint64(e))
		}
	}
	if m.PhysicalMemorySizeBytes != nil {
		n += 1 + sovDraios(uint64(*m.PhysicalMemorySizeBytes))
	}
	if m.Tcounters != nil {
		l = m.Tcounters.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.TransactionCounters != nil {
		l = m.TransactionCounters.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.TransactionProcessingDelay != nil {
		n += 1 + sovDraios(uint64(*m.TransactionProcessingDelay))
	}
	if m.ResourceCounters != nil {
		l = m.ResourceCounters.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.SyscallErrors != nil {
		l = m.SyscallErrors.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.ExternalIoNet != nil {
		l = m.ExternalIoNet.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.CpuSteal) > 0 {
		for _, e := range m.CpuSteal {
			n += 1 + sovDraios(uint64(e))
		}
	}
	if m.Reqcounters != nil {
		l = m.Reqcounters.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.NextTiersDelay != nil {
		n += 1 + sovDraios(uint64(*m.NextTiersDelay))
	}
	if m.MaxTransactionCounters != nil {
		l = m.MaxTransactionCounters.Size()
		n += 2 + l + sovDraios(uint64(l))
	}
	if len(m.NetworkByServerports) > 0 {
		for _, e := range m.NetworkByServerports {
			l = e.Size()
			n += 2 + l + sovDraios(uint64(l))
		}
	}
	if len(m.CpuIdle) > 0 {
		for _, e := range m.CpuIdle {
			n += 2 + sovDraios(uint64(e))
		}
	}
	if m.Uptime != nil {
		n += 2 + sovDraios(uint64(*m.Uptime))
	}
	if len(m.SystemCpu) > 0 {
		for _, e := range m.SystemCpu {
			n += 2 + sovDraios(uint64(e))
		}
	}
	if len(m.UserCpu) > 0 {
		for _, e := range m.UserCpu {
			n += 2 + sovDraios(uint64(e))
		}
	}
	if m.MemoryBytesAvailableKb != nil {
		n += 2 + sovDraios(uint64(*m.MemoryBytesAvailableKb))
	}
	if len(m.IowaitCpu) > 0 {
		for _, e := range m.IowaitCpu {
			n += 2 + sovDraios(uint64(e))
		}
	}
	if len(m.NiceCpu) > 0 {
		for _, e := range m.NiceCpu {
			n += 2 + sovDraios(uint64(e))
		}
	}
	if m.SystemLoad_1 != nil {
		n += 2 + sovDraios(uint64(*m.SystemLoad_1))
	}
	if m.SystemLoad_5 != nil {
		n += 2 + sovDraios(uint64(*m.SystemLoad_5))
	}
	if m.SystemLoad_15 != nil {
		n += 2 + sovDraios(uint64(*m.SystemLoad_15))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Process) Size() (n int) {
	var l int
	_ = l
	if m.Details != nil {
		l = m.Details.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.IsIpv4TransactionServer != nil {
		n += 2
	}
	if m.IsUnixTransactionServer != nil {
		n += 2
	}
	if m.Tcounters != nil {
		l = m.Tcounters.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.TransactionCounters != nil {
		l = m.TransactionCounters.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.TransactionProcessingDelay != nil {
		n += 1 + sovDraios(uint64(*m.TransactionProcessingDelay))
	}
	if m.ResourceCounters != nil {
		l = m.ResourceCounters.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.SyscallErrors != nil {
		l = m.SyscallErrors.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.IsIpv4TransactionClient != nil {
		n += 2
	}
	if m.IsUnixTransactionClient != nil {
		n += 2
	}
	if m.NextTiersDelay != nil {
		n += 1 + sovDraios(uint64(*m.NextTiersDelay))
	}
	if m.Netrole != nil {
		n += 1 + sovDraios(uint64(*m.Netrole))
	}
	if m.MaxTransactionCounters != nil {
		l = m.MaxTransactionCounters.Size()
		n += 2 + l + sovDraios(uint64(l))
	}
	if m.Protos != nil {
		l = m.Protos.Size()
		n += 2 + l + sovDraios(uint64(l))
	}
	if m.StartCount != nil {
		n += 2 + sovDraios(uint64(*m.StartCount))
	}
	if m.CountProcesses != nil {
		n += 2 + sovDraios(uint64(*m.CountProcesses))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Program) Size() (n int) {
	var l int
	_ = l
	if m.Procinfo != nil {
		l = m.Procinfo.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.Pids) > 0 {
		for _, e := range m.Pids {
			n += 1 + sovDraios(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Ipv4Tuple) Size() (n int) {
	var l int
	_ = l
	if m.Sip != nil {
		n += 1 + sovDraios(uint64(*m.Sip))
	}
	if m.Dip != nil {
		n += 1 + sovDraios(uint64(*m.Dip))
	}
	if m.Sport != nil {
		n += 1 + sovDraios(uint64(*m.Sport))
	}
	if m.Dport != nil {
		n += 1 + sovDraios(uint64(*m.Dport))
	}
	if m.L4Proto != nil {
		n += 1 + sovDraios(uint64(*m.L4Proto))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Ipv4Connection) Size() (n int) {
	var l int
	_ = l
	if m.Tuple != nil {
		l = m.Tuple.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Spid != nil {
		n += 1 + sovDraios(uint64(*m.Spid))
	}
	if m.Dpid != nil {
		n += 1 + sovDraios(uint64(*m.Dpid))
	}
	if m.Counters != nil {
		l = m.Counters.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Ipv4NetworkInterface) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Addr != nil {
		n += 1 + sovDraios(uint64(*m.Addr))
	}
	if m.Netmask != nil {
		n += 1 + sovDraios(uint64(*m.Netmask))
	}
	if m.Bcast != nil {
		n += 1 + sovDraios(uint64(*m.Bcast))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MountedFs) Size() (n int) {
	var l int
	_ = l
	if m.Device != nil {
		l = len(*m.Device)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.MountDir != nil {
		l = len(*m.MountDir)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Type != nil {
		l = len(*m.Type)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.SizeBytes != nil {
		n += 1 + sovDraios(uint64(*m.SizeBytes))
	}
	if m.UsedBytes != nil {
		n += 1 + sovDraios(uint64(*m.UsedBytes))
	}
	if m.AvailableBytes != nil {
		n += 1 + sovDraios(uint64(*m.AvailableBytes))
	}
	if m.TotalInodes != nil {
		n += 1 + sovDraios(uint64(*m.TotalInodes))
	}
	if m.UsedInodes != nil {
		n += 1 + sovDraios(uint64(*m.UsedInodes))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileStat) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Bytes != nil {
		n += 1 + sovDraios(uint64(*m.Bytes))
	}
	if m.TimeNs != nil {
		n += 1 + sovDraios(uint64(*m.TimeNs))
	}
	if m.OpenCount != nil {
		n += 1 + sovDraios(uint64(*m.OpenCount))
	}
	if m.Errors != nil {
		n += 1 + sovDraios(uint64(*m.Errors))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContainerPortMapping) Size() (n int) {
	var l int
	_ = l
	if m.HostIp != nil {
		n += 1 + sovDraios(uint64(*m.HostIp))
	}
	if m.HostPort != nil {
		n += 1 + sovDraios(uint64(*m.HostPort))
	}
	if m.ContainerIp != nil {
		n += 1 + sovDraios(uint64(*m.ContainerIp))
	}
	if m.ContainerPort != nil {
		n += 1 + sovDraios(uint64(*m.ContainerPort))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContainerLabel) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Container) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sovDraios(uint64(*m.Type))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Image != nil {
		l = len(*m.Image)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Tcounters != nil {
		l = m.Tcounters.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Reqcounters != nil {
		l = m.Reqcounters.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.TransactionCounters != nil {
		l = m.TransactionCounters.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.MaxTransactionCounters != nil {
		l = m.MaxTransactionCounters.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.TransactionProcessingDelay != nil {
		n += 1 + sovDraios(uint64(*m.TransactionProcessingDelay))
	}
	if m.NextTiersDelay != nil {
		n += 1 + sovDraios(uint64(*m.NextTiersDelay))
	}
	if m.ResourceCounters != nil {
		l = m.ResourceCounters.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.SyscallErrors != nil {
		l = m.SyscallErrors.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.PortMappings) > 0 {
		for _, e := range m.PortMappings {
			l = e.Size()
			n += 2 + l + sovDraios(uint64(l))
		}
	}
	if m.Protos != nil {
		l = m.Protos.Size()
		n += 2 + l + sovDraios(uint64(l))
	}
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 2 + l + sovDraios(uint64(l))
		}
	}
	if len(m.Mounts) > 0 {
		for _, e := range m.Mounts {
			l = e.Size()
			n += 2 + l + sovDraios(uint64(l))
		}
	}
	if len(m.NetworkByServerports) > 0 {
		for _, e := range m.NetworkByServerports {
			l = e.Size()
			n += 2 + l + sovDraios(uint64(l))
		}
	}
	if m.MesosTaskId != nil {
		l = len(*m.MesosTaskId)
		n += 2 + l + sovDraios(uint64(l))
	}
	if m.ImageId != nil {
		l = len(*m.ImageId)
		n += 2 + l + sovDraios(uint64(l))
	}
	if len(m.Commands) > 0 {
		for _, e := range m.Commands {
			l = e.Size()
			n += 2 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CongroupUid) Size() (n int) {
	var l int
	_ = l
	if m.Kind != nil {
		l = len(*m.Kind)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CongroupNetPort) Size() (n int) {
	var l int
	_ = l
	if m.Port != nil {
		n += 1 + sovDraios(uint64(*m.Port))
	}
	if m.TargetPort != nil {
		n += 1 + sovDraios(uint64(*m.TargetPort))
	}
	if m.Protocol != nil {
		l = len(*m.Protocol)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.NodePort != nil {
		n += 1 + sovDraios(uint64(*m.NodePort))
	}
	if m.PublishedPort != nil {
		n += 1 + sovDraios(uint64(*m.PublishedPort))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContainerGroup) Size() (n int) {
	var l int
	_ = l
	if m.Uid != nil {
		l = m.Uid.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovDraios(uint64(len(k))) + 1 + len(v) + sovDraios(uint64(len(v)))
			n += mapEntrySize + 1 + sovDraios(uint64(mapEntrySize))
		}
	}
	if len(m.IpAddresses) > 0 {
		for _, s := range m.IpAddresses {
			l = len(s)
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.Metrics) > 0 {
		for _, e := range m.Metrics {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.Parents) > 0 {
		for _, e := range m.Parents {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.InternalTags) > 0 {
		for k, v := range m.InternalTags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovDraios(uint64(len(k))) + 1 + len(v) + sovDraios(uint64(len(v)))
			n += mapEntrySize + 1 + sovDraios(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CongroupUpdateEvent) Size() (n int) {
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovDraios(uint64(*m.Type))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OrchestratorEvents) Size() (n int) {
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *K8SPair) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *K8SCommon) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Uid != nil {
		l = len(*m.Uid)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Namespace != nil {
		l = len(*m.Namespace)
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.Selectors) > 0 {
		for _, e := range m.Selectors {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *K8SNamespace) Size() (n int) {
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *K8SNode) Size() (n int) {
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.HostIps) > 0 {
		for _, s := range m.HostIps {
			l = len(s)
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *K8SPod) Size() (n int) {
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.ContainerIds) > 0 {
		for _, s := range m.ContainerIds {
			l = len(s)
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.NodeName != nil {
		l = len(*m.NodeName)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.HostIp != nil {
		l = len(*m.HostIp)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.InternalIp != nil {
		l = len(*m.InternalIp)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.RestartCount != nil {
		n += 1 + sovDraios(uint64(*m.RestartCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *K8SReplicationController) Size() (n int) {
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.ReplicasDesired != nil {
		n += 1 + sovDraios(uint64(*m.ReplicasDesired))
	}
	if m.ReplicasRunning != nil {
		n += 1 + sovDraios(uint64(*m.ReplicasRunning))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *K8SReplicaSet) Size() (n int) {
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.ReplicasDesired != nil {
		n += 1 + sovDraios(uint64(*m.ReplicasDesired))
	}
	if m.ReplicasRunning != nil {
		n += 1 + sovDraios(uint64(*m.ReplicasRunning))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *K8SService) Size() (n int) {
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.ClusterIp != nil {
		l = len(*m.ClusterIp)
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *K8SServiceNetPort) Size() (n int) {
	var l int
	_ = l
	if m.Port != nil {
		n += 1 + sovDraios(uint64(*m.Port))
	}
	if m.TargetPort != nil {
		n += 1 + sovDraios(uint64(*m.TargetPort))
	}
	if m.Protocol != nil {
		l = len(*m.Protocol)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.NodePort != nil {
		n += 1 + sovDraios(uint64(*m.NodePort))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *K8SDeployment) Size() (n int) {
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.ReplicasDesired != nil {
		n += 1 + sovDraios(uint64(*m.ReplicasDesired))
	}
	if m.ReplicasRunning != nil {
		n += 1 + sovDraios(uint64(*m.ReplicasRunning))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *K8SDaemonset) Size() (n int) {
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.CurrentScheduled != nil {
		n += 1 + sovDraios(uint64(*m.CurrentScheduled))
	}
	if m.DesiredScheduled != nil {
		n += 1 + sovDraios(uint64(*m.DesiredScheduled))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *K8SState) Size() (n int) {
	var l int
	_ = l
	if len(m.Namespaces) > 0 {
		for _, e := range m.Namespaces {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.Pods) > 0 {
		for _, e := range m.Pods {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.Controllers) > 0 {
		for _, e := range m.Controllers {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.Services) > 0 {
		for _, e := range m.Services {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.ReplicaSets) > 0 {
		for _, e := range m.ReplicaSets {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.Deployments) > 0 {
		for _, e := range m.Deployments {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.Daemonsets) > 0 {
		for _, e := range m.Daemonsets {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MesosPair) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MesosCommon) Size() (n int) {
	var l int
	_ = l
	if m.Uid != nil {
		l = len(*m.Uid)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MesosTask) Size() (n int) {
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.SlaveId != nil {
		l = len(*m.SlaveId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MarathonApp) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.TaskIds) > 0 {
		for _, s := range m.TaskIds {
			l = len(s)
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MarathonGroup) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.Apps) > 0 {
		for _, e := range m.Apps {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MesosFramework) Size() (n int) {
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.Tasks) > 0 {
		for _, e := range m.Tasks {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MesosSlave) Size() (n int) {
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MesosState) Size() (n int) {
	var l int
	_ = l
	if len(m.Frameworks) > 0 {
		for _, e := range m.Frameworks {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.Slaves) > 0 {
		for _, e := range m.Slaves {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SwarmPair) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SwarmPort) Size() (n int) {
	var l int
	_ = l
	if m.Port != nil {
		n += 1 + sovDraios(uint64(*m.Port))
	}
	if m.PublishedPort != nil {
		n += 1 + sovDraios(uint64(*m.PublishedPort))
	}
	if m.Protocol != nil {
		l = len(*m.Protocol)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SwarmCommon) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SwarmService) Size() (n int) {
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.VirtualIps) > 0 {
		for _, s := range m.VirtualIps {
			l = len(s)
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.Mode != nil {
		n += 1 + sovDraios(uint64(*m.Mode))
	}
	if m.SpecReplicas != nil {
		n += 1 + sovDraios(uint64(*m.SpecReplicas))
	}
	if m.Tasks != nil {
		n += 1 + sovDraios(uint64(*m.Tasks))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SwarmTask) Size() (n int) {
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.ServiceId != nil {
		l = len(*m.ServiceId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.NodeId != nil {
		l = len(*m.NodeId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.ContainerId != nil {
		l = len(*m.ContainerId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.State != nil {
		l = len(*m.State)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SwarmManager) Size() (n int) {
	var l int
	_ = l
	if m.Leader != nil {
		n += 2
	}
	if m.Reachability != nil {
		l = len(*m.Reachability)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SwarmNode) Size() (n int) {
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Role != nil {
		l = len(*m.Role)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.IpAddress != nil {
		l = len(*m.IpAddress)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Version != nil {
		l = len(*m.Version)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Availability != nil {
		l = len(*m.Availability)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.State != nil {
		l = len(*m.State)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Manager != nil {
		l = m.Manager.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SwarmState) Size() (n int) {
	var l int
	_ = l
	if len(m.Services) > 0 {
		for _, e := range m.Services {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.Tasks) > 0 {
		for _, e := range m.Tasks {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.Quorum != nil {
		n += 2
	}
	if m.NodeId != nil {
		l = len(*m.NodeId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OrchestratorStateT) Size() (n int) {
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.ClusterId != nil {
		l = len(*m.ClusterId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.ClusterName != nil {
		l = len(*m.ClusterName)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Metrics) Size() (n int) {
	var l int
	_ = l
	if m.TimestampNs != nil {
		n += 1 + sovDraios(uint64(*m.TimestampNs))
	}
	if m.MachineId != nil {
		l = len(*m.MachineId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.CustomerId != nil {
		l = len(*m.CustomerId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Hostinfo != nil {
		l = m.Hostinfo.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.Ipv4Connections) > 0 {
		for _, e := range m.Ipv4Connections {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.Ipv4NetworkInterfaces) > 0 {
		for _, e := range m.Ipv4NetworkInterfaces {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.Programs) > 0 {
		for _, e := range m.Programs {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.SamplingRatio != nil {
		n += 1 + sovDraios(uint64(*m.SamplingRatio))
	}
	if m.HostCustomName != nil {
		l = len(*m.HostCustomName)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.HostTags != nil {
		l = len(*m.HostTags)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.IsHostHidden != nil {
		n += 2
	}
	if m.HiddenProcesses != nil {
		l = len(*m.HiddenProcesses)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Version != nil {
		l = len(*m.Version)
		n += 2 + l + sovDraios(uint64(l))
	}
	if len(m.Mounts) > 0 {
		for _, e := range m.Mounts {
			l = e.Size()
			n += 2 + l + sovDraios(uint64(l))
		}
	}
	if len(m.TopFiles) > 0 {
		for _, e := range m.TopFiles {
			l = e.Size()
			n += 2 + l + sovDraios(uint64(l))
		}
	}
	if m.Protos != nil {
		l = m.Protos.Size()
		n += 2 + l + sovDraios(uint64(l))
	}
	if m.InstanceId != nil {
		l = len(*m.InstanceId)
		n += 2 + l + sovDraios(uint64(l))
	}
	if len(m.Containers) > 0 {
		for _, e := range m.Containers {
			l = e.Size()
			n += 2 + l + sovDraios(uint64(l))
		}
	}
	if m.Kubernetes != nil {
		l = m.Kubernetes.Size()
		n += 2 + l + sovDraios(uint64(l))
	}
	if m.Mesos != nil {
		l = m.Mesos.Size()
		n += 2 + l + sovDraios(uint64(l))
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 2 + l + sovDraios(uint64(l))
		}
	}
	if m.Falcobl != nil {
		l = m.Falcobl.Size()
		n += 2 + l + sovDraios(uint64(l))
	}
	if len(m.Commands) > 0 {
		for _, e := range m.Commands {
			l = e.Size()
			n += 2 + l + sovDraios(uint64(l))
		}
	}
	if m.Swarm != nil {
		l = m.Swarm.Size()
		n += 2 + l + sovDraios(uint64(l))
	}
	if len(m.ConfigPercentiles) > 0 {
		for _, e := range m.ConfigPercentiles {
			n += 2 + sovDraios(uint64(e))
		}
	}
	if m.InternalMetrics != nil {
		l = m.InternalMetrics.Size()
		n += 2 + l + sovDraios(uint64(l))
	}
	if m.GlobalOrchestratorState != nil {
		l = m.GlobalOrchestratorState.Size()
		n += 2 + l + sovDraios(uint64(l))
	}
	if m.OrchestratorState != nil {
		l = m.OrchestratorState.Size()
		n += 2 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DumpRequestStart) Size() (n int) {
	var l int
	_ = l
	if m.TimestampNs != nil {
		n += 1 + sovDraios(uint64(*m.TimestampNs))
	}
	if m.MachineId != nil {
		l = len(*m.MachineId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.CustomerId != nil {
		l = len(*m.CustomerId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.DurationNs != nil {
		n += 1 + sovDraios(uint64(*m.DurationNs))
	}
	if m.Filters != nil {
		l = len(*m.Filters)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Token != nil {
		l = len(*m.Token)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.MaxSize != nil {
		n += 1 + sovDraios(uint64(*m.MaxSize))
	}
	if m.PastDurationNs != nil {
		n += 1 + sovDraios(uint64(*m.PastDurationNs))
	}
	if m.PastSize != nil {
		n += 1 + sovDraios(uint64(*m.PastSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DumpRequestStop) Size() (n int) {
	var l int
	_ = l
	if m.TimestampNs != nil {
		n += 1 + sovDraios(uint64(*m.TimestampNs))
	}
	if m.MachineId != nil {
		l = len(*m.MachineId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.CustomerId != nil {
		l = len(*m.CustomerId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Token != nil {
		l = len(*m.Token)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DumpResponse) Size() (n int) {
	var l int
	_ = l
	if m.TimestampNs != nil {
		n += 1 + sovDraios(uint64(*m.TimestampNs))
	}
	if m.MachineId != nil {
		l = len(*m.MachineId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.CustomerId != nil {
		l = len(*m.CustomerId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Content != nil {
		l = len(m.Content)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Error != nil {
		l = len(*m.Error)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Token != nil {
		l = len(*m.Token)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.ChunkNo != nil {
		n += 1 + sovDraios(uint64(*m.ChunkNo))
	}
	if m.FinalChunk != nil {
		n += 2
	}
	if m.KeepAlive != nil {
		n += 2
	}
	if m.FinalSizeBytes != nil {
		n += 1 + sovDraios(uint64(*m.FinalSizeBytes))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SshOpenChannel) Size() (n int) {
	var l int
	_ = l
	if m.TimestampNs != nil {
		n += 1 + sovDraios(uint64(*m.TimestampNs))
	}
	if m.MachineId != nil {
		l = len(*m.MachineId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.CustomerId != nil {
		l = len(*m.CustomerId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Token != nil {
		l = len(*m.Token)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.User != nil {
		l = len(*m.User)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Password != nil {
		l = len(*m.Password)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Passphrase != nil {
		l = len(*m.Passphrase)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Port != nil {
		n += 1 + sovDraios(uint64(*m.Port))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SshData) Size() (n int) {
	var l int
	_ = l
	if m.TimestampNs != nil {
		n += 1 + sovDraios(uint64(*m.TimestampNs))
	}
	if m.MachineId != nil {
		l = len(*m.MachineId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.CustomerId != nil {
		l = len(*m.CustomerId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Token != nil {
		l = len(*m.Token)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Error != nil {
		l = len(*m.Error)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.ExitStatus != nil {
		n += 1 + sovDraios(uint64(*m.ExitStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SshCloseChannel) Size() (n int) {
	var l int
	_ = l
	if m.TimestampNs != nil {
		n += 1 + sovDraios(uint64(*m.TimestampNs))
	}
	if m.MachineId != nil {
		l = len(*m.MachineId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.CustomerId != nil {
		l = len(*m.CustomerId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Token != nil {
		l = len(*m.Token)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AutoUpdateRequest) Size() (n int) {
	var l int
	_ = l
	if m.TimestampNs != nil {
		n += 1 + sovDraios(uint64(*m.TimestampNs))
	}
	if m.MachineId != nil {
		l = len(*m.MachineId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.CustomerId != nil {
		l = len(*m.CustomerId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DirtyShutdownReport) Size() (n int) {
	var l int
	_ = l
	if m.TimestampNs != nil {
		n += 1 + sovDraios(uint64(*m.TimestampNs))
	}
	if m.MachineId != nil {
		l = len(*m.MachineId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.CustomerId != nil {
		l = len(*m.CustomerId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Log != nil {
		l = len(*m.Log)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeyValue) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AgentEvent) Size() (n int) {
	var l int
	_ = l
	if m.TimestampSec != nil {
		n += 1 + sovDraios(uint64(*m.TimestampSec))
	}
	if m.Scope != nil {
		l = len(*m.Scope)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Title != nil {
		l = len(*m.Title)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Description != nil {
		l = len(*m.Description)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Severity != nil {
		n += 1 + sovDraios(uint64(*m.Severity))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigFile) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Content != nil {
		l = len(*m.Content)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigData) Size() (n int) {
	var l int
	_ = l
	if len(m.ConfigFiles) > 0 {
		for _, e := range m.ConfigFiles {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StopAction) Size() (n int) {
	var l int
	_ = l
	if m.Msg != nil {
		l = len(*m.Msg)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PauseAction) Size() (n int) {
	var l int
	_ = l
	if m.Msg != nil {
		l = len(*m.Msg)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CaptureAction) Size() (n int) {
	var l int
	_ = l
	if m.BeforeEventNs != nil {
		n += 1 + sovDraios(uint64(*m.BeforeEventNs))
	}
	if m.AfterEventNs != nil {
		n += 1 + sovDraios(uint64(*m.AfterEventNs))
	}
	if m.Filter != nil {
		l = len(*m.Filter)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.IsLimitedToContainer != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Action) Size() (n int) {
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovDraios(uint64(*m.Type))
	}
	if m.Stop != nil {
		l = m.Stop.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Pause != nil {
		l = m.Pause.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Capture != nil {
		l = m.Capture.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BaselineDetail) Size() (n int) {
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ManualDetail) Size() (n int) {
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FalcoRuleFilter) Size() (n int) {
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FalcoDetail) Size() (n int) {
	var l int
	_ = l
	if m.RuleFilter != nil {
		l = m.RuleFilter.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScopePredicate) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.Op != nil {
		n += 1 + sovDraios(uint64(*m.Op))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Policy) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sovDraios(uint64(*m.Id))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sovDraios(uint64(*m.Type))
	}
	if m.BaselineDetails != nil {
		l = m.BaselineDetails.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.FalcoDetails != nil {
		l = m.FalcoDetails.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.ManualDetails != nil {
		l = m.ManualDetails.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.Enabled != nil {
		n += 2
	}
	if m.HostScope != nil {
		n += 2
	}
	if m.ContainerScope != nil {
		n += 2
	}
	if len(m.ScopePredicates) > 0 {
		for _, e := range m.ScopePredicates {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FalcoRulesContents) Size() (n int) {
	var l int
	_ = l
	if len(m.Contents) > 0 {
		for _, s := range m.Contents {
			l = len(s)
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Policies) Size() (n int) {
	var l int
	_ = l
	if len(m.PolicyList) > 0 {
		for _, e := range m.PolicyList {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.FalcoRules != nil {
		l = m.FalcoRules.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BaselineEventDetail) Size() (n int) {
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ManualEventDetail) Size() (n int) {
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FalcoEventDetail) Size() (n int) {
	var l int
	_ = l
	if m.Rule != nil {
		l = len(*m.Rule)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Output != nil {
		l = len(*m.Output)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActionResult) Size() (n int) {
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovDraios(uint64(*m.Type))
	}
	if m.Successful != nil {
		n += 2
	}
	if m.Errmsg != nil {
		l = len(*m.Errmsg)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Token != nil {
		l = len(*m.Token)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PolicyEvent) Size() (n int) {
	var l int
	_ = l
	if m.TimestampNs != nil {
		n += 1 + sovDraios(uint64(*m.TimestampNs))
	}
	if m.PolicyId != nil {
		n += 1 + sovDraios(uint64(*m.PolicyId))
	}
	if m.ContainerId != nil {
		l = len(*m.ContainerId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.BaselineDetails != nil {
		l = m.BaselineDetails.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.FalcoDetails != nil {
		l = m.FalcoDetails.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.ManualDetails != nil {
		l = m.ManualDetails.Size()
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.ActionResults) > 0 {
		for _, e := range m.ActionResults {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.SinspEventsDropped != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PolicyEvents) Size() (n int) {
	var l int
	_ = l
	if m.MachineId != nil {
		l = len(*m.MachineId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.CustomerId != nil {
		l = len(*m.CustomerId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ThrottledPolicyEvent) Size() (n int) {
	var l int
	_ = l
	if m.TimestampNs != nil {
		n += 1 + sovDraios(uint64(*m.TimestampNs))
	}
	if m.PolicyId != nil {
		n += 1 + sovDraios(uint64(*m.PolicyId))
	}
	if m.ContainerId != nil {
		l = len(*m.ContainerId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Count != nil {
		n += 1 + sovDraios(uint64(*m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ThrottledPolicyEvents) Size() (n int) {
	var l int
	_ = l
	if m.MachineId != nil {
		l = len(*m.MachineId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.CustomerId != nil {
		l = len(*m.CustomerId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ErrorMessage) Size() (n int) {
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovDraios(uint64(*m.Type))
	}
	if m.Description != nil {
		l = len(*m.Description)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FalcoSubcategory) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.D) > 0 {
		for _, s := range m.D {
			l = len(s)
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.Full != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FalcoSubcategoryContainer) Size() (n int) {
	var l int
	_ = l
	if len(m.Subcats) > 0 {
		for _, e := range m.Subcats {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FalcoCategory) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.StartupSubcats) > 0 {
		for _, e := range m.StartupSubcats {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.RegularSubcats) > 0 {
		for _, e := range m.RegularSubcats {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FalcoProg) Size() (n int) {
	var l int
	_ = l
	if m.Comm != nil {
		l = len(*m.Comm)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Exe != nil {
		l = len(*m.Exe)
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.UserId != nil {
		n += 1 + sovDraios(uint64(*m.UserId))
	}
	if m.ContainerId != nil {
		l = len(*m.ContainerId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if len(m.Cats) > 0 {
		for _, e := range m.Cats {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FalcoContainer) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.ImageName != nil {
		l = len(*m.ImageName)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.ImageId != nil {
		l = len(*m.ImageId)
		n += 1 + l + sovDraios(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FalcoBaseline) Size() (n int) {
	var l int
	_ = l
	if len(m.Progs) > 0 {
		for _, e := range m.Progs {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if len(m.Containers) > 0 {
		for _, e := range m.Containers {
			l = e.Size()
			n += 1 + l + sovDraios(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDraios(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDraios(x uint64) (n int) {
	return sovDraios(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CounterPercentileData) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: counter_percentile_data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: counter_percentile_data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Min = &v2
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Max = &v2
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compression", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Compression = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSamples", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NumSamples = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Means = append(m.Means, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDraios
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDraios
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Means = append(m.Means, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Means", wireType)
			}
		case 6:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Weights = append(m.Weights, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDraios
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDraios
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Weights = append(m.Weights, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Weights", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CounterPercentile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: counter_percentile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: counter_percentile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percentile", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Percentile = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CounterTime) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: counter_time: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: counter_time: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Count = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeNs = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimePercentage", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimePercentage = &v
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percentile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Percentile = append(m.Percentile, &CounterPercentile{})
			if err := m.Percentile[len(m.Percentile)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PercentileData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PercentileData == nil {
				m.PercentileData = &CounterPercentileData{}
			}
			if err := m.PercentileData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CounterTimeBidirectional) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: counter_time_bidirectional: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: counter_time_bidirectional: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountIn", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CountIn = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountOut", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CountOut = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeNsIn", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeNsIn = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeNsOut", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeNsOut = &v
			hasFields[0] |= uint64(0x00000008)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PercentileIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PercentileIn = append(m.PercentileIn, &CounterPercentile{})
			if err := m.PercentileIn[len(m.PercentileIn)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PercentileOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PercentileOut = append(m.PercentileOut, &CounterPercentile{})
			if err := m.PercentileOut[len(m.PercentileOut)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PercentileInData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PercentileInData == nil {
				m.PercentileInData = &CounterPercentileData{}
			}
			if err := m.PercentileInData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PercentileOutData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PercentileOutData == nil {
				m.PercentileOutData = &CounterPercentileData{}
			}
			if err := m.PercentileOutData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CounterBytes) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: counter_bytes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: counter_bytes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountIn", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CountIn = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountOut", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CountOut = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesIn", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BytesIn = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesOut", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BytesOut = &v
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CounterTimeBytes) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: counter_time_bytes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: counter_time_bytes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeNsIn", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeNsIn = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeNsOut", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeNsOut = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeNsOther", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeNsOther = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountIn", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CountIn = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountOut", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CountOut = &v
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountOther", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CountOther = &v
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesIn", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BytesIn = &v
			hasFields[0] |= uint64(0x00000040)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesOut", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BytesOut = &v
			hasFields[0] |= uint64(0x00000080)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesOther", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BytesOther = &v
			hasFields[0] |= uint64(0x00000100)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimePercentageIn", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimePercentageIn = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimePercentageOut", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimePercentageOut = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimePercentageOther", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimePercentageOther = &v
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PercentileIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PercentileIn = append(m.PercentileIn, &CounterPercentile{})
			if err := m.PercentileIn[len(m.PercentileIn)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PercentileOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PercentileOut = append(m.PercentileOut, &CounterPercentile{})
			if err := m.PercentileOut[len(m.PercentileOut)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PercentileInData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PercentileInData == nil {
				m.PercentileInData = &CounterPercentileData{}
			}
			if err := m.PercentileInData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PercentileOutData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PercentileOutData == nil {
				m.PercentileOutData = &CounterPercentileData{}
			}
			if err := m.PercentileOutData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000080) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000100) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeCategories) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: time_categories: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: time_categories: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unknown", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Unknown == nil {
				m.Unknown = &CounterTime{}
			}
			if err := m.Unknown.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Other", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Other == nil {
				m.Other = &CounterTime{}
			}
			if err := m.Other.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &CounterTime{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Net", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Net == nil {
				m.Net = &CounterTime{}
			}
			if err := m.Net.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ipc == nil {
				m.Ipc = &CounterTime{}
			}
			if err := m.Ipc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Memory == nil {
				m.Memory = &CounterTime{}
			}
			if err := m.Memory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Process", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Process == nil {
				m.Process = &CounterTime{}
			}
			if err := m.Process.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sleep", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sleep == nil {
				m.Sleep = &CounterTime{}
			}
			if err := m.Sleep.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field System", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.System == nil {
				m.System = &CounterTime{}
			}
			if err := m.System.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signal == nil {
				m.Signal = &CounterTime{}
			}
			if err := m.Signal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &CounterTime{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &CounterTime{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IoFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IoFile == nil {
				m.IoFile = &CounterTimeBytes{}
			}
			if err := m.IoFile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IoNet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IoNet == nil {
				m.IoNet = &CounterTimeBytes{}
			}
			if err := m.IoNet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IoOther", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IoOther == nil {
				m.IoOther = &CounterTimeBytes{}
			}
			if err := m.IoOther.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wait", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Wait == nil {
				m.Wait = &CounterTime{}
			}
			if err := m.Wait.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Processing == nil {
				m.Processing = &CounterTime{}
			}
			if err := m.Processing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionBreakdownCategories) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: transaction_breakdown_categories: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: transaction_breakdown_categories: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Other", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Other == nil {
				m.Other = &CounterTime{}
			}
			if err := m.Other.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IoFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IoFile == nil {
				m.IoFile = &CounterTimeBytes{}
			}
			if err := m.IoFile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IoNet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IoNet == nil {
				m.IoNet = &CounterTimeBytes{}
			}
			if err := m.IoNet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Processing == nil {
				m.Processing = &CounterTime{}
			}
			if err := m.Processing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CounterSyscallErrors) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: counter_syscall_errors: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: counter_syscall_errors: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Count = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDraios
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TopErrorCodes = append(m.TopErrorCodes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDraios
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDraios
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDraios
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TopErrorCodes = append(m.TopErrorCodes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TopErrorCodes", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountFile", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CountFile = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountFileOpen", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CountFileOpen = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountNet", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CountNet = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceCategories) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: resource_categories: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: resource_categories: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapacityScore", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CapacityScore = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionQueueUsagePct", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConnectionQueueUsagePct = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FdUsagePct", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FdUsagePct = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuPct", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CpuPct = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResidentMemoryUsageKb", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ResidentMemoryUsageKb = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StolenCapacityScore", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StolenCapacityScore = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualMemoryUsageKb", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VirtualMemoryUsageKb = &v
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapMemoryUsageKb", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SwapMemoryUsageKb = &v
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MajorPagefaults", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MajorPagefaults = &v
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinorPagefaults", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinorPagefaults = &v
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FdCount", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FdCount = &v
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuShares", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CpuShares = &v
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSharesUsagePct", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CpuSharesUsagePct = &v
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryLimitKb", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MemoryLimitKb = &v
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapLimitKb", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SwapLimitKb = &v
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuQuotaUsedPct", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CpuQuotaUsedPct = &v
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapMemoryTotalKb", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SwapMemoryTotalKb = &v
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapMemoryAvailableKb", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SwapMemoryAvailableKb = &v
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountProcesses", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CountProcesses = &v
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcStartCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ProcStartCount = &v
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JmxSent", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.JmxSent = &v
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JmxTotal", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.JmxTotal = &v
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsdSent", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StatsdSent = &v
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsdTotal", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StatsdTotal = &v
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppChecksSent", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AppChecksSent = &v
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppChecksTotal", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AppChecksTotal = &v
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThreadsCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ThreadsCount = &v
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrometheusSent", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrometheusSent = &v
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrometheusTotal", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrometheusTotal = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionCategories) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: connection_categories: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: connection_categories: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Server == nil {
				m.Server = &CounterBytes{}
			}
			if err := m.Server.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Client", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Client == nil {
				m.Client = &CounterBytes{}
			}
			if err := m.Client.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionCounters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionCounters == nil {
				m.TransactionCounters = &CounterTimeBidirectional{}
			}
			if err := m.TransactionCounters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NAggregatedConnections", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NAggregatedConnections = &v
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTransactionCounters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxTransactionCounters == nil {
				m.MaxTransactionCounters = &CounterTimeBidirectional{}
			}
			if err := m.MaxTransactionCounters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessDetails) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: process_details: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: process_details: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Comm = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exe", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Exe = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ContainerId = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandDetails) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: command_details: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: command_details: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Timestamp = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Count = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmdline", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Cmdline = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Comm = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pid = &v
			hasFields[0] |= uint64(0x00000008)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ppid", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ppid = &v
			hasFields[0] |= uint64(0x00000010)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Uid = &v
			hasFields[0] |= uint64(0x00000020)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cwd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Cwd = &s
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginShellId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LoginShellId = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginShellDistance", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LoginShellDistance = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tty", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tty = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CounterProtoEntry) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: counter_proto_entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: counter_proto_entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ncalls", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ncalls = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeTot", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeTot = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeMax", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeMax = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesIn", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BytesIn = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesOut", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BytesOut = &v
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nerrors", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nerrors = &v
			hasFields[0] |= uint64(0x00000020)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percentile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Percentile = append(m.Percentile, &CounterPercentile{})
			if err := m.Percentile[len(m.Percentile)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PercentileData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PercentileData == nil {
				m.PercentileData = &CounterPercentileData{}
			}
			if err := m.PercentileData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UrlDetails) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: url_details: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: url_details: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Url = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Counters == nil {
				m.Counters = &CounterProtoEntry{}
			}
			if err := m.Counters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusCodeDetails) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: status_code_details: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: status_code_details: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StatusCode = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ncalls", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ncalls = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: http_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: http_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerUrls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerUrls = append(m.ServerUrls, &UrlDetails{})
			if err := m.ServerUrls[len(m.ServerUrls)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientUrls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientUrls = append(m.ClientUrls, &UrlDetails{})
			if err := m.ClientUrls[len(m.ClientUrls)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientStatusCodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientStatusCodes = append(m.ClientStatusCodes, &StatusCodeDetails{})
			if err := m.ClientStatusCodes[len(m.ClientStatusCodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerStatusCodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerStatusCodes = append(m.ServerStatusCodes, &StatusCodeDetails{})
			if err := m.ServerStatusCodes[len(m.ServerStatusCodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SqlEntryDetails) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sql_entry_details: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sql_entry_details: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Counters == nil {
				m.Counters = &CounterProtoEntry{}
			}
			if err := m.Counters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SqlQueryTypeDetails) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sql_query_type_details: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sql_query_type_details: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v SqlStatementType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (SqlStatementType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Counters == nil {
				m.Counters = &CounterProtoEntry{}
			}
			if err := m.Counters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SqlInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sql_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sql_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerQueries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerQueries = append(m.ServerQueries, &SqlEntryDetails{})
			if err := m.ServerQueries[len(m.ServerQueries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientQueries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientQueries = append(m.ClientQueries, &SqlEntryDetails{})
			if err := m.ClientQueries[len(m.ClientQueries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerQueryTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerQueryTypes = append(m.ServerQueryTypes, &SqlQueryTypeDetails{})
			if err := m.ServerQueryTypes[len(m.ServerQueryTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientQueryTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientQueryTypes = append(m.ClientQueryTypes, &SqlQueryTypeDetails{})
			if err := m.ClientQueryTypes[len(m.ClientQueryTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerTables = append(m.ServerTables, &SqlEntryDetails{})
			if err := m.ServerTables[len(m.ServerTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientTables = append(m.ClientTables, &SqlEntryDetails{})
			if err := m.ClientTables[len(m.ClientTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MongodbCollectionDetails) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: mongodb_collection_details: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: mongodb_collection_details: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Counters == nil {
				m.Counters = &CounterProtoEntry{}
			}
			if err := m.Counters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MongodbOpTypeDetails) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: mongodb_op_type_details: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: mongodb_op_type_details: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var v MongodbOpType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (MongodbOpType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Op = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Counters == nil {
				m.Counters = &CounterProtoEntry{}
			}
			if err := m.Counters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MongodbInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: mongodb_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: mongodb_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServersOps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServersOps = append(m.ServersOps, &MongodbOpTypeDetails{})
			if err := m.ServersOps[len(m.ServersOps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientOps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientOps = append(m.ClientOps, &MongodbOpTypeDetails{})
			if err := m.ClientOps[len(m.ClientOps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerCollections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerCollections = append(m.ServerCollections, &MongodbCollectionDetails{})
			if err := m.ServerCollections[len(m.ServerCollections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientCollections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientCollections = append(m.ClientCollections, &MongodbCollectionDetails{})
			if err := m.ClientCollections[len(m.ClientCollections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JmxAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: jmx_attribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: jmx_attribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Value = &v2
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subattributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subattributes = append(m.Subattributes, &JmxAttribute{})
			if err := m.Subattributes[len(m.Subattributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Alias = &s
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v JmxMetricType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (JmxMetricType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var v Unit
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Unit(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unit = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			var v Scale
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Scale(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Scale = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JmxBean) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: jmx_bean: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: jmx_bean: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &JmxAttribute{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JavaInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: java_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: java_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ProcessName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Beans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Beans = append(m.Beans, &JmxBean{})
			if err := m.Beans[len(m.Beans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatsdTag) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: statsd_tag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: statsd_tag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatsdMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: statsd_metric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: statsd_metric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &StatsdTag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v StatsdMetricType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (StatsdMetricType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Value = &v2
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Sum = &v2
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Min = &v2
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Max = &v2
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Count = &v2
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percentile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Percentile = append(m.Percentile, &CounterPercentile{})
			if err := m.Percentile[len(m.Percentile)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PercentileData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PercentileData == nil {
				m.PercentileData = &CounterPercentileData{}
			}
			if err := m.PercentileData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatsdInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: statsd_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: statsd_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsdMetrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatsdMetrics = append(m.StatsdMetrics, &StatsdMetric{})
			if err := m.StatsdMetrics[len(m.StatsdMetrics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppTag) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: app_tag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: app_tag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: app_metric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: app_metric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v AppMetricType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (AppMetricType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Value = &v2
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &AppTag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: app_check: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: app_check: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v AppCheckValue
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (AppCheckValue(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &AppTag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: app_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: app_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ProcessName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metrics = append(m.Metrics, &AppMetric{})
			if err := m.Metrics[len(m.Metrics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checks = append(m.Checks, &AppCheck{})
			if err := m.Checks[len(m.Checks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtoInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: proto_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: proto_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Http == nil {
				m.Http = &HttpInfo{}
			}
			if err := m.Http.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mysql", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mysql == nil {
				m.Mysql = &SqlInfo{}
			}
			if err := m.Mysql.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Postgres", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Postgres == nil {
				m.Postgres = &SqlInfo{}
			}
			if err := m.Postgres.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mongodb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mongodb == nil {
				m.Mongodb = &MongodbInfo{}
			}
			if err := m.Mongodb.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Java", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Java == nil {
				m.Java = &JavaInfo{}
			}
			if err := m.Java.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statsd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Statsd == nil {
				m.Statsd = &StatsdInfo{}
			}
			if err := m.Statsd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.App == nil {
				m.App = &AppInfo{}
			}
			if err := m.App.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prometheus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prometheus == nil {
				m.Prometheus = &AppInfo{}
			}
			if err := m.Prometheus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkByPort) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: network_by_port: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: network_by_port: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Port = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Counters == nil {
				m.Counters = &ConnectionCategories{}
			}
			if err := m.Counters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Host) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: host: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: host: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Hostname = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCpus", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NumCpus = &v
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDraios
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CpuLoads = append(m.CpuLoads, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDraios
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDraios
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDraios
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CpuLoads = append(m.CpuLoads, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuLoads", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalMemorySizeBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PhysicalMemorySizeBytes = &v
			hasFields[0] |= uint64(0x00000001)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tcounters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tcounters == nil {
				m.Tcounters = &TimeCategories{}
			}
			if err := m.Tcounters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionCounters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionCounters == nil {
				m.TransactionCounters = &CounterTimeBidirectional{}
			}
			if err := m.TransactionCounters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionProcessingDelay", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TransactionProcessingDelay = &v
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceCounters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceCounters == nil {
				m.ResourceCounters = &ResourceCategories{}
			}
			if err := m.ResourceCounters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyscallErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SyscallErrors == nil {
				m.SyscallErrors = &CounterSyscallErrors{}
			}
			if err := m.SyscallErrors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalIoNet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExternalIoNet == nil {
				m.ExternalIoNet = &CounterTimeBytes{}
			}
			if err := m.ExternalIoNet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDraios
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CpuSteal = append(m.CpuSteal, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDraios
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDraios
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDraios
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CpuSteal = append(m.CpuSteal, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSteal", wireType)
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reqcounters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reqcounters == nil {
				m.Reqcounters = &TransactionBreakdownCategories{}
			}
			if err := m.Reqcounters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextTiersDelay", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NextTiersDelay = &v
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTransactionCounters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxTransactionCounters == nil {
				m.MaxTransactionCounters = &CounterTimeBidirectional{}
			}
			if err := m.MaxTransactionCounters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkByServerports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkByServerports = append(m.NetworkByServerports, &NetworkByPort{})
			if err := m.NetworkByServerports[len(m.NetworkByServerports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDraios
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CpuIdle = append(m.CpuIdle, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDraios
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDraios
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDraios
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CpuIdle = append(m.CpuIdle, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuIdle", wireType)
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uptime", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Uptime = &v
		case 34:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDraios
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SystemCpu = append(m.SystemCpu, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDraios
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDraios
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDraios
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SystemCpu = append(m.SystemCpu, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemCpu", wireType)
			}
		case 35:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDraios
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserCpu = append(m.UserCpu, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDraios
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDraios
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDraios
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserCpu = append(m.UserCpu, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserCpu", wireType)
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryBytesAvailableKb", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MemoryBytesAvailableKb = &v
		case 37:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDraios
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IowaitCpu = append(m.IowaitCpu, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDraios
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDraios
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDraios
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IowaitCpu = append(m.IowaitCpu, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IowaitCpu", wireType)
			}
		case 38:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDraios
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NiceCpu = append(m.NiceCpu, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDraios
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDraios
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDraios
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NiceCpu = append(m.NiceCpu, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NiceCpu", wireType)
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemLoad_1", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SystemLoad_1 = &v
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemLoad_5", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SystemLoad_5 = &v
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemLoad_15", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SystemLoad_15 = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Process) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: process: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: process: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Details == nil {
				m.Details = &ProcessDetails{}
			}
			if err := m.Details.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsIpv4TransactionServer", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsIpv4TransactionServer = &b
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUnixTransactionServer", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsUnixTransactionServer = &b
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tcounters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tcounters == nil {
				m.Tcounters = &TimeCategories{}
			}
			if err := m.Tcounters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionCounters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionCounters == nil {
				m.TransactionCounters = &CounterTimeBidirectional{}
			}
			if err := m.TransactionCounters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionProcessingDelay", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TransactionProcessingDelay = &v
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceCounters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceCounters == nil {
				m.ResourceCounters = &ResourceCategories{}
			}
			if err := m.ResourceCounters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyscallErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SyscallErrors == nil {
				m.SyscallErrors = &CounterSyscallErrors{}
			}
			if err := m.SyscallErrors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsIpv4TransactionClient", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsIpv4TransactionClient = &b
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUnixTransactionClient", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsUnixTransactionClient = &b
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextTiersDelay", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NextTiersDelay = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Netrole", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Netrole = &v
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTransactionCounters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxTransactionCounters == nil {
				m.MaxTransactionCounters = &CounterTimeBidirectional{}
			}
			if err := m.MaxTransactionCounters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Protos == nil {
				m.Protos = &ProtoInfo{}
			}
			if err := m.Protos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StartCount = &v
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountProcesses", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CountProcesses = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Program) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: program: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: program: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Procinfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Procinfo == nil {
				m.Procinfo = &Process{}
			}
			if err := m.Procinfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDraios
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Pids = append(m.Pids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDraios
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDraios
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDraios
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Pids = append(m.Pids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ipv4Tuple) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ipv4tuple: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ipv4tuple: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sip", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sip = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dip", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dip = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sport", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sport = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dport", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dport = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4Proto", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L4Proto = &v
			hasFields[0] |= uint64(0x00000010)
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ipv4Connection) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ipv4_connection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ipv4_connection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tuple", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tuple == nil {
				m.Tuple = &Ipv4Tuple{}
			}
			if err := m.Tuple.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spid", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Spid = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dpid", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dpid = &v
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Counters == nil {
				m.Counters = &ConnectionCategories{}
			}
			if err := m.Counters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ipv4NetworkInterface) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ipv4_network_interface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ipv4_network_interface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Addr = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Netmask", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Netmask = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bcast", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bcast = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MountedFs) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: mounted_fs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: mounted_fs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Device = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.MountDir = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Type = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SizeBytes = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsedBytes = &v
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AvailableBytes = &v
			hasFields[0] |= uint64(0x00000020)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalInodes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalInodes = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedInodes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsedInodes = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileStat) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: file_stat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: file_stat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bytes = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeNs = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenCount", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OpenCount = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Errors = &v
			hasFields[0] |= uint64(0x00000010)
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerPortMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: container_port_mapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: container_port_mapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIp", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostIp = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostPort = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerIp", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContainerIp = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContainerPort = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerLabel) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: container_label: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: container_label: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Container) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: container: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: container: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v ContainerType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ContainerType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Image = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tcounters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tcounters == nil {
				m.Tcounters = &TimeCategories{}
			}
			if err := m.Tcounters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reqcounters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reqcounters == nil {
				m.Reqcounters = &TransactionBreakdownCategories{}
			}
			if err := m.Reqcounters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionCounters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionCounters == nil {
				m.TransactionCounters = &CounterTimeBidirectional{}
			}
			if err := m.TransactionCounters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTransactionCounters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxTransactionCounters == nil {
				m.MaxTransactionCounters = &CounterTimeBidirectional{}
			}
			if err := m.MaxTransactionCounters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionProcessingDelay", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TransactionProcessingDelay = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextTiersDelay", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NextTiersDelay = &v
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceCounters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceCounters == nil {
				m.ResourceCounters = &ResourceCategories{}
			}
			if err := m.ResourceCounters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyscallErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SyscallErrors == nil {
				m.SyscallErrors = &CounterSyscallErrors{}
			}
			if err := m.SyscallErrors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMappings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortMappings = append(m.PortMappings, &ContainerPortMapping{})
			if err := m.PortMappings[len(m.PortMappings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Protos == nil {
				m.Protos = &ProtoInfo{}
			}
			if err := m.Protos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, &ContainerLabel{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mounts = append(m.Mounts, &MountedFs{})
			if err := m.Mounts[len(m.Mounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkByServerports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkByServerports = append(m.NetworkByServerports, &NetworkByPort{})
			if err := m.NetworkByServerports[len(m.NetworkByServerports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MesosTaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.MesosTaskId = &s
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ImageId = &s
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commands", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commands = append(m.Commands, &CommandDetails{})
			if err := m.Commands[len(m.Commands)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CongroupUid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: congroup_uid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: congroup_uid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Kind = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CongroupNetPort) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: congroup_net_port: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: congroup_net_port: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Port = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TargetPort = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Protocol = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodePort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NodePort = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishedPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PublishedPort = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: container_group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: container_group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uid == nil {
				m.Uid = &CongroupUid{}
			}
			if err := m.Uid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDraios
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDraios
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDraios
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDraios
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthDraios
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDraios(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthDraios
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddresses = append(m.IpAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &CongroupNetPort{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metrics = append(m.Metrics, &AppMetric{})
			if err := m.Metrics[len(m.Metrics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &CongroupUid{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parents = append(m.Parents, &CongroupUid{})
			if err := m.Parents[len(m.Parents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalTags == nil {
				m.InternalTags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDraios
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDraios
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDraios
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDraios
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthDraios
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDraios(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthDraios
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InternalTags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CongroupUpdateEvent) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: congroup_update_event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: congroup_update_event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v CongroupEventType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (CongroupEventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
			hasFields[0] |= uint64(0x00000001)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &ContainerGroup{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrchestratorEvents) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: orchestrator_events: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: orchestrator_events: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &CongroupUpdateEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SPair) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: k8s_pair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: k8s_pair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SCommon) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: k8s_common: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: k8s_common: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Uid = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Namespace = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, &K8SPair{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Selectors = append(m.Selectors, &K8SPair{})
			if err := m.Selectors[len(m.Selectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SNamespace) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: k8s_namespace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: k8s_namespace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &K8SCommon{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SNode) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: k8s_node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: k8s_node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &K8SCommon{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIps", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostIps = append(m.HostIps, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SPod) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: k8s_pod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: k8s_pod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &K8SCommon{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerIds = append(m.ContainerIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NodeName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HostIp = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.InternalIp = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestartCount", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RestartCount = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SReplicationController) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: k8s_replication_controller: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: k8s_replication_controller: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &K8SCommon{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicasDesired", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReplicasDesired = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicasRunning", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReplicasRunning = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SReplicaSet) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: k8s_replica_set: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: k8s_replica_set: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &K8SCommon{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicasDesired", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReplicasDesired = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicasRunning", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReplicasRunning = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SService) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: k8s_service: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: k8s_service: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &K8SCommon{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ClusterIp = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &K8SServiceNetPort{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SServiceNetPort) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: net_port: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: net_port: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Port = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TargetPort = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Protocol = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodePort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NodePort = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SDeployment) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: k8s_deployment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: k8s_deployment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &K8SCommon{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicasDesired", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReplicasDesired = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicasRunning", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReplicasRunning = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SDaemonset) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: k8s_daemonset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: k8s_daemonset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &K8SCommon{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentScheduled", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CurrentScheduled = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredScheduled", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DesiredScheduled = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: k8s_state: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: k8s_state: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespaces = append(m.Namespaces, &K8SNamespace{})
			if err := m.Namespaces[len(m.Namespaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &K8SNode{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pods = append(m.Pods, &K8SPod{})
			if err := m.Pods[len(m.Pods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controllers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controllers = append(m.Controllers, &K8SReplicationController{})
			if err := m.Controllers[len(m.Controllers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Services = append(m.Services, &K8SService{})
			if err := m.Services[len(m.Services)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplicaSets = append(m.ReplicaSets, &K8SReplicaSet{})
			if err := m.ReplicaSets[len(m.ReplicaSets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deployments = append(m.Deployments, &K8SDeployment{})
			if err := m.Deployments[len(m.Deployments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Daemonsets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Daemonsets = append(m.Daemonsets, &K8SDaemonset{})
			if err := m.Daemonsets[len(m.Daemonsets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MesosPair) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: mesos_pair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: mesos_pair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MesosCommon) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: mesos_common: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: mesos_common: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Uid = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, &MesosPair{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MesosTask) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: mesos_task: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: mesos_task: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &MesosCommon{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlaveId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SlaveId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarathonApp) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: marathon_app: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: marathon_app: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskIds = append(m.TaskIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarathonGroup) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: marathon_group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: marathon_group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Apps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Apps = append(m.Apps, &MarathonApp{})
			if err := m.Apps[len(m.Apps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &MarathonGroup{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MesosFramework) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: mesos_framework: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: mesos_framework: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &MesosCommon{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tasks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tasks = append(m.Tasks, &MesosTask{})
			if err := m.Tasks[len(m.Tasks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MesosSlave) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: mesos_slave: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: mesos_slave: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &MesosCommon{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MesosState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: mesos_state: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: mesos_state: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frameworks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Frameworks = append(m.Frameworks, &MesosFramework{})
			if err := m.Frameworks[len(m.Frameworks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &MarathonGroup{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slaves", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Slaves = append(m.Slaves, &MesosSlave{})
			if err := m.Slaves[len(m.Slaves)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwarmPair) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: swarm_pair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: swarm_pair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwarmPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: swarm_port: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: swarm_port: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Port = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishedPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PublishedPort = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Protocol = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwarmCommon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: swarm_common: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: swarm_common: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, &SwarmPair{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwarmService) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: swarm_service: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: swarm_service: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &SwarmCommon{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualIps", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualIps = append(m.VirtualIps, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &SwarmPort{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var v SwarmServiceMode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (SwarmServiceMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mode = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecReplicas", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SpecReplicas = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tasks", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tasks = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwarmTask) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: swarm_task: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: swarm_task: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &SwarmCommon{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ServiceId = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NodeId = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ContainerId = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.State = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwarmManager) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: swarm_manager: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: swarm_manager: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Leader = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reachability", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Reachability = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwarmNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: swarm_node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: swarm_node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &SwarmCommon{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Role = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.IpAddress = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Version = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Availability", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Availability = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.State = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manager", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Manager == nil {
				m.Manager = &SwarmManager{}
			}
			if err := m.Manager.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwarmState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: swarm_state: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: swarm_state: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Services = append(m.Services, &SwarmService{})
			if err := m.Services[len(m.Services)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &SwarmNode{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tasks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tasks = append(m.Tasks, &SwarmTask{})
			if err := m.Tasks[len(m.Tasks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quorum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Quorum = &b
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NodeId = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrchestratorStateT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: orchestrator_state_t: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: orchestrator_state_t: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &ContainerGroup{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ClusterId = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ClusterName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metrics) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: metrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: metrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimestampNs = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MachineId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.MachineId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CustomerId = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostinfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hostinfo == nil {
				m.Hostinfo = &Host{}
			}
			if err := m.Hostinfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Connections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4Connections = append(m.Ipv4Connections, &Ipv4Connection{})
			if err := m.Ipv4Connections[len(m.Ipv4Connections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4NetworkInterfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4NetworkInterfaces = append(m.Ipv4NetworkInterfaces, &Ipv4NetworkInterface{})
			if err := m.Ipv4NetworkInterfaces[len(m.Ipv4NetworkInterfaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Programs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Programs = append(m.Programs, &Program{})
			if err := m.Programs[len(m.Programs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SamplingRatio", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SamplingRatio = &v
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostCustomName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HostCustomName = &s
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HostTags = &s
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHostHidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsHostHidden = &b
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HiddenProcesses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HiddenProcesses = &s
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Version = &s
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mounts = append(m.Mounts, &MountedFs{})
			if err := m.Mounts[len(m.Mounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopFiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopFiles = append(m.TopFiles, &FileStat{})
			if err := m.TopFiles[len(m.TopFiles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Protos == nil {
				m.Protos = &ProtoInfo{}
			}
			if err := m.Protos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.InstanceId = &s
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Containers = append(m.Containers, &Container{})
			if err := m.Containers[len(m.Containers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kubernetes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kubernetes == nil {
				m.Kubernetes = &K8SState{}
			}
			if err := m.Kubernetes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mesos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mesos == nil {
				m.Mesos = &MesosState{}
			}
			if err := m.Mesos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &AgentEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Falcobl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Falcobl == nil {
				m.Falcobl = &FalcoBaseline{}
			}
			if err := m.Falcobl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commands", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commands = append(m.Commands, &CommandDetails{})
			if err := m.Commands[len(m.Commands)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swarm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Swarm == nil {
				m.Swarm = &SwarmState{}
			}
			if err := m.Swarm.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDraios
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ConfigPercentiles = append(m.ConfigPercentiles, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDraios
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDraios
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDraios
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ConfigPercentiles = append(m.ConfigPercentiles, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigPercentiles", wireType)
			}
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalMetrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalMetrics == nil {
				m.InternalMetrics = &StatsdInfo{}
			}
			if err := m.InternalMetrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalOrchestratorState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GlobalOrchestratorState == nil {
				m.GlobalOrchestratorState = &OrchestratorStateT{}
			}
			if err := m.GlobalOrchestratorState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrchestratorState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OrchestratorState == nil {
				m.OrchestratorState = &OrchestratorStateT{}
			}
			if err := m.OrchestratorState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DumpRequestStart) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: dump_request_start: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: dump_request_start: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimestampNs = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MachineId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.MachineId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CustomerId = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DurationNs = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Filters = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Token = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSize", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxSize = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PastDurationNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PastDurationNs = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PastSize", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PastSize = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DumpRequestStop) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: dump_request_stop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: dump_request_stop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimestampNs = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MachineId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.MachineId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CustomerId = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Token = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DumpResponse) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: dump_response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: dump_response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimestampNs = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MachineId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.MachineId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CustomerId = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Error = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Token = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkNo", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChunkNo = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalChunk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.FinalChunk = &b
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepAlive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.KeepAlive = &b
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalSizeBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FinalSizeBytes = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SshOpenChannel) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ssh_open_channel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ssh_open_channel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimestampNs = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MachineId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.MachineId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CustomerId = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Token = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.User = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Password = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passphrase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Passphrase = &s
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Port = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SshData) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ssh_data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ssh_data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimestampNs = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MachineId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.MachineId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CustomerId = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Token = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Error = &s
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitStatus", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExitStatus = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SshCloseChannel) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ssh_close_channel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ssh_close_channel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimestampNs = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MachineId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.MachineId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CustomerId = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Token = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoUpdateRequest) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: auto_update_request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: auto_update_request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimestampNs = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MachineId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.MachineId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CustomerId = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DirtyShutdownReport) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: dirty_shutdown_report: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: dirty_shutdown_report: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimestampNs = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MachineId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.MachineId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CustomerId = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Log = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyValue) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: key_value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: key_value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AgentEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: agent_event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: agent_event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampSec", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimestampSec = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Scope = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Title = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Description = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Severity = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &KeyValue{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: config_file: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: config_file: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Content = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: config_data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: config_data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigFiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigFiles = append(m.ConfigFiles, &ConfigFile{})
			if err := m.ConfigFiles[len(m.ConfigFiles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: stop_action: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: stop_action: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Msg = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PauseAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: pause_action: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: pause_action: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Msg = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptureAction) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: capture_action: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: capture_action: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeforeEventNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BeforeEventNs = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterEventNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AfterEventNs = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Filter = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLimitedToContainer", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsLimitedToContainer = &b
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Action) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: action: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: action: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v ActionType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ActionType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stop == nil {
				m.Stop = &StopAction{}
			}
			if err := m.Stop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pause", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pause == nil {
				m.Pause = &PauseAction{}
			}
			if err := m.Pause.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capture", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Capture == nil {
				m.Capture = &CaptureAction{}
			}
			if err := m.Capture.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaselineDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: baseline_detail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: baseline_detail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ManualDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: manual_detail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: manual_detail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FalcoRuleFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: falco_rule_filter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: falco_rule_filter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FalcoDetail) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: falco_detail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: falco_detail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RuleFilter == nil {
				m.RuleFilter = &FalcoRuleFilter{}
			}
			if err := m.RuleFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScopePredicate) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: scope_predicate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: scope_predicate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var v ScopeOperator
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ScopeOperator(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Op = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Policy) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: policy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: policy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Id = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v PolicyType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (PolicyType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaselineDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BaselineDetails == nil {
				m.BaselineDetails = &BaselineDetail{}
			}
			if err := m.BaselineDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FalcoDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FalcoDetails == nil {
				m.FalcoDetails = &FalcoDetail{}
			}
			if err := m.FalcoDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ManualDetails == nil {
				m.ManualDetails = &ManualDetail{}
			}
			if err := m.ManualDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &Action{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
			hasFields[0] |= uint64(0x00000008)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostScope", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.HostScope = &b
			hasFields[0] |= uint64(0x00000010)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerScope", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ContainerScope = &b
			hasFields[0] |= uint64(0x00000020)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopePredicates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopePredicates = append(m.ScopePredicates, &ScopePredicate{})
			if err := m.ScopePredicates[len(m.ScopePredicates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FalcoRulesContents) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: falco_rules_contents: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: falco_rules_contents: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contents", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contents = append(m.Contents, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Policies) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: policies: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: policies: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PolicyList = append(m.PolicyList, &Policy{})
			if err := m.PolicyList[len(m.PolicyList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FalcoRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FalcoRules == nil {
				m.FalcoRules = &FalcoRulesContents{}
			}
			if err := m.FalcoRules.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaselineEventDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: baseline_event_detail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: baseline_event_detail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ManualEventDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: manual_event_detail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: manual_event_detail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FalcoEventDetail) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: falco_event_detail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: falco_event_detail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Rule = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Output = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionResult) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: action_result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: action_result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v ActionType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ActionType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Successful", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Successful = &b
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errmsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Errmsg = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Token = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyEvent) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: policy_event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: policy_event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimestampNs = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PolicyId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ContainerId = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaselineDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BaselineDetails == nil {
				m.BaselineDetails = &BaselineEventDetail{}
			}
			if err := m.BaselineDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FalcoDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FalcoDetails == nil {
				m.FalcoDetails = &FalcoEventDetail{}
			}
			if err := m.FalcoDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ManualDetails == nil {
				m.ManualDetails = &ManualEventDetail{}
			}
			if err := m.ManualDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionResults = append(m.ActionResults, &ActionResult{})
			if err := m.ActionResults[len(m.ActionResults)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SinspEventsDropped", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.SinspEventsDropped = &b
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyEvents) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: policy_events: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: policy_events: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MachineId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.MachineId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CustomerId = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &PolicyEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThrottledPolicyEvent) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: throttled_policy_event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: throttled_policy_event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimestampNs = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PolicyId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ContainerId = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Count = &v
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThrottledPolicyEvents) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: throttled_policy_events: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: throttled_policy_events: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MachineId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.MachineId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CustomerId = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &ThrottledPolicyEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ErrorMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: error_message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: error_message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v ErrorType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ErrorType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Description = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FalcoSubcategory) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: falco_subcategory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: falco_subcategory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field D", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.D = append(m.D, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Full", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Full = &b
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FalcoSubcategoryContainer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: falco_subcategory_container: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: falco_subcategory_container: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subcats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subcats = append(m.Subcats, &FalcoSubcategory{})
			if err := m.Subcats[len(m.Subcats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FalcoCategory) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: falco_category: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: falco_category: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartupSubcats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartupSubcats = append(m.StartupSubcats, &FalcoSubcategoryContainer{})
			if err := m.StartupSubcats[len(m.StartupSubcats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegularSubcats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegularSubcats = append(m.RegularSubcats, &FalcoSubcategoryContainer{})
			if err := m.RegularSubcats[len(m.RegularSubcats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FalcoProg) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: falco_prog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: falco_prog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Comm = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exe", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Exe = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UserId = &v
			hasFields[0] |= uint64(0x00000004)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ContainerId = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cats = append(m.Cats, &FalcoCategory{})
			if err := m.Cats[len(m.Cats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FalcoContainer) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: falco_container: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: falco_container: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ImageName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ImageId = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FalcoBaseline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: falco_baseline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: falco_baseline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Progs = append(m.Progs, &FalcoProg{})
			if err := m.Progs[len(m.Progs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDraios
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Containers = append(m.Containers, &FalcoContainer{})
			if err := m.Containers[len(m.Containers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDraios(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDraios
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDraios(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDraios
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDraios
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDraios
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDraios
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDraios(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDraios = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDraios   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("draios.proto", fileDescriptorDraios) }

var fileDescriptorDraios = []byte{
	// 8747 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x7c, 0x5d, 0x8f, 0x23, 0x47,
	0x92, 0xd8, 0xf1, 0xa3, 0xf9, 0x11, 0x24, 0xbb, 0x6b, 0xaa, 0x67, 0xa6, 0x39, 0xdf, 0xa3, 0x92,
	0x56, 0x9a, 0x6d, 0xad, 0x46, 0xd2, 0x68, 0xb4, 0xab, 0x8f, 0xf5, 0xad, 0x38, 0x6c, 0xaa, 0x87,
	0x9a, 0x6e, 0xb2, 0x95, 0x64, 0x4b, 0xab, 0x3d, 0xdc, 0x15, 0xaa, 0x59, 0xd5, 0xdd, 0xa5, 0x29,
	0x56, 0x95, 0xea, 0x63, 0xa6, 0x7b, 0x81, 0x83, 0xf7, 0xce, 0x7b, 0x7e, 0x59, 0xc3, 0xb8, 0x33,
	0x0c, 0xfb, 0x60, 0xf8, 0xcd, 0x30, 0xce, 0x36, 0x60, 0xc0, 0xb0, 0xfd, 0x60, 0x18, 0xf0, 0x83,
	0x01, 0x1b, 0xb7, 0x58, 0x1c, 0x0c, 0x3f, 0xf8, 0xed, 0x5e, 0x8c, 0x35, 0xe0, 0x1f, 0x60, 0xf8,
	0xe3, 0x1e, 0xfc, 0x60, 0x44, 0x64, 0x66, 0xb1, 0x8a, 0xac, 0xfe, 0x98, 0x19, 0x9d, 0x74, 0x0f,
	0x7e, 0x22, 0x33, 0x32, 0x22, 0x32, 0x33, 0x22, 0x32, 0x32, 0x32, 0x23, 0xb3, 0xa0, 0x69, 0x06,
	0x86, 0xed, 0x85, 0x77, 0xfd, 0xc0, 0x8b, 0x3c, 0xb5, 0xc1, 0x4b, 0x54, 0xd0, 0xfe, 0x4d, 0x01,
	0xd6, 0x26, 0x5e, 0xec, 0x46, 0x56, 0xa0, 0xfb, 0x56, 0x30, 0xb1, 0xdc, 0xc8, 0x76, 0x2c, 0xdd,
	0x34, 0x22, 0x43, 0x55, 0xa0, 0x34, 0xb5, 0xdd, 0x76, 0xe1, 0x76, 0xf1, 0x4e, 0x81, 0xe1, 0x5f,
	0x82, 0x18, 0x47, 0xed, 0xa2, 0x80, 0x18, 0x47, 0xea, 0x6d, 0x68, 0x4c, 0xbc, 0xa9, 0x1f, 0x58,
	0x61, 0x68, 0x7b, 0x6e, 0xbb, 0x74, 0xbb, 0x78, 0xa7, 0xc5, 0xd2, 0x20, 0xf5, 0x16, 0x34, 0xdc,
	0x78, 0xaa, 0x87, 0xc6, 0xd4, 0x77, 0xac, 0xb0, 0x5d, 0x26, 0x0c, 0x70, 0xe3, 0xe9, 0x88, 0x43,
	0xd4, 0x36, 0x2c, 0x4d, 0x2d, 0xc3, 0x0d, 0xdb, 0x4b, 0xb7, 0x4b, 0x77, 0x0a, 0x0f, 0x8a, 0x4a,
	0x81, 0x71, 0x80, 0x7a, 0x1d, 0xaa, 0x4f, 0x2d, 0xfb, 0xe0, 0x30, 0x0a, 0xdb, 0x95, 0xa4, 0x4e,
	0x82, 0xb4, 0x4f, 0x40, 0x5d, 0xec, 0xb9, 0x7a, 0x13, 0x60, 0x56, 0x6a, 0x17, 0x6e, 0x17, 0xb0,
	0xb5, 0x54, 0xfd, 0x45, 0x58, 0x7a, 0x62, 0x38, 0xb1, 0xd5, 0x2e, 0x52, 0x15, 0x2f, 0x68, 0xff,
	0xbb, 0x00, 0x4d, 0xc9, 0x2c, 0xb2, 0xa7, 0x84, 0x46, 0x65, 0x1a, 0x7d, 0x8b, 0xf1, 0x82, 0xba,
	0x06, 0x55, 0xac, 0xd5, 0xdd, 0x90, 0x64, 0x50, 0x66, 0x15, 0x2c, 0x0e, 0x42, 0xf5, 0x35, 0x58,
	0xa1, 0x0a, 0xd1, 0x90, 0x71, 0x60, 0xb5, 0x4b, 0xc4, 0x7f, 0x19, 0xc1, 0x3b, 0x09, 0x54, 0xfd,
	0x51, 0xa6, 0x7b, 0xb5, 0xdb, 0xa5, 0x3b, 0x8d, 0x7b, 0xb7, 0xee, 0xa6, 0x34, 0x72, 0x77, 0x71,
	0x4c, 0x99, 0xfe, 0x6f, 0xc3, 0xca, 0x9c, 0x9e, 0xda, 0xf5, 0xdb, 0x85, 0x3b, 0x8d, 0x7b, 0xaf,
	0x9c, 0xc1, 0x85, 0x70, 0xd9, 0xf2, 0x0c, 0xb0, 0x61, 0x44, 0x86, 0xf6, 0xab, 0x12, 0x5c, 0x4d,
	0x0f, 0x5c, 0xdf, 0xb3, 0x4d, 0x3b, 0xb0, 0x26, 0x91, 0xed, 0xb9, 0x86, 0xa3, 0x5e, 0x81, 0x1a,
	0xd5, 0xea, 0xc2, 0x0e, 0x5a, 0xac, 0x4a, 0xe5, 0xbe, 0xab, 0x5e, 0x83, 0x3a, 0xaf, 0xf2, 0xe2,
	0x88, 0xa4, 0xd1, 0x62, 0x1c, 0x77, 0x18, 0x47, 0xea, 0x75, 0x00, 0x21, 0x28, 0xa4, 0x2c, 0x91,
	0xac, 0x6a, 0x5c, 0x56, 0x7d, 0x57, 0xbd, 0x09, 0x0d, 0x59, 0x8b, 0xc4, 0x65, 0xaa, 0xae, 0xf3,
	0x6a, 0xa4, 0xde, 0x80, 0x56, 0xaa, 0xdf, 0xb6, 0xdb, 0x86, 0xf3, 0xc9, 0xa9, 0x39, 0xfb, 0xdf,
	0x77, 0xd5, 0x8f, 0x21, 0x35, 0x58, 0x6a, 0xa8, 0x71, 0x3e, 0x36, 0xa9, 0xc6, 0xb1, 0x37, 0x0c,
	0xd4, 0x4c, 0x6f, 0xb8, 0xd0, 0x9b, 0xcf, 0x20, 0x74, 0x25, 0xdd, 0x2f, 0x14, 0xbb, 0x3a, 0x86,
	0xd5, 0x6c, 0xdf, 0x38, 0xd3, 0xd6, 0x33, 0x30, 0xbd, 0x90, 0xe9, 0x25, 0x29, 0xf3, 0xaf, 0x43,
	0x4b, 0x62, 0xef, 0x1d, 0x47, 0x56, 0xf8, 0xdc, 0xea, 0xbb, 0x02, 0x35, 0x62, 0x20, 0x95, 0xd7,
	0x62, 0x55, 0x2a, 0x73, 0x3a, 0x5e, 0x25, 0x35, 0xd7, 0x62, 0x1c, 0x77, 0x18, 0x47, 0xda, 0xff,
	0x58, 0x9a, 0xcd, 0x49, 0x6e, 0x4d, 0xd4, 0x8d, 0xac, 0x35, 0x14, 0x4e, 0xb7, 0x86, 0xe2, 0xbc,
	0x35, 0x68, 0xd0, 0x4a, 0xea, 0xa3, 0x43, 0x2b, 0x10, 0xe6, 0xd4, 0x10, 0x18, 0x08, 0xca, 0x0c,
	0xb4, 0x7c, 0xca, 0x40, 0x97, 0xe6, 0x06, 0x7a, 0x0b, 0xdd, 0x17, 0x55, 0x12, 0xe7, 0x0a, 0x77,
	0x4e, 0xbc, 0x5a, 0x32, 0x4e, 0x24, 0x51, 0x3d, 0x45, 0x12, 0xb5, 0xac, 0x24, 0x90, 0xb1, 0xa8,
	0x24, 0xc6, 0x75, 0xce, 0x98, 0x57, 0x13, 0xe3, 0xef, 0x81, 0x3a, 0xe7, 0x31, 0xb8, 0xa1, 0xa3,
	0xd3, 0x50, 0xb2, 0x4e, 0xa3, 0xef, 0xaa, 0x77, 0x61, 0x75, 0x1e, 0x9b, 0x1b, 0x34, 0xa2, 0x5f,
	0xc8, 0xa2, 0x63, 0xf3, 0xf7, 0xe0, 0xd2, 0x02, 0x3e, 0x75, 0xa4, 0x49, 0x14, 0xab, 0x73, 0x14,
	0xd4, 0xa3, 0x85, 0x59, 0x77, 0xf5, 0xeb, 0x99, 0x75, 0xd7, 0xbe, 0xc6, 0x59, 0x77, 0xfd, 0x2f,
	0x63, 0xd6, 0xdd, 0x78, 0xb1, 0x59, 0xf7, 0xbf, 0x2a, 0xc2, 0xf9, 0x4f, 0x8c, 0xc8, 0x3a, 0xf0,
	0x02, 0xdb, 0x0a, 0xd5, 0x77, 0xa0, 0x1a, 0xbb, 0x8f, 0x5d, 0xef, 0xa9, 0x4b, 0x4b, 0x50, 0xe3,
	0xde, 0x95, 0x5c, 0xee, 0x48, 0xc6, 0x24, 0xa6, 0xfa, 0x26, 0x2c, 0x71, 0x25, 0x15, 0xcf, 0x22,
	0xe1, 0x78, 0xea, 0x1b, 0x50, 0xde, 0xc7, 0x65, 0xa4, 0x74, 0x16, 0x3e, 0xa1, 0xa9, 0xaf, 0x43,
	0xc9, 0xb5, 0x70, 0xd2, 0x9e, 0x81, 0x8d, 0x58, 0x88, 0x6c, 0xfb, 0x93, 0xf6, 0xd2, 0x99, 0xc8,
	0xb6, 0x3f, 0x51, 0xdf, 0x86, 0xca, 0xd4, 0x9a, 0x7a, 0xc1, 0x71, 0xbb, 0x72, 0x16, 0xbe, 0x40,
	0x44, 0x09, 0xf9, 0x81, 0x37, 0xb1, 0xc2, 0xb0, 0x5d, 0x3d, 0x53, 0x42, 0x02, 0x13, 0x25, 0x14,
	0x3a, 0x96, 0xe5, 0xb7, 0x6b, 0x67, 0x4a, 0x88, 0xf0, 0xb0, 0x63, 0xe1, 0x71, 0x18, 0x59, 0x53,
	0xb1, 0x48, 0x9e, 0xd6, 0x31, 0x8e, 0x48, 0x24, 0xf6, 0x81, 0x6b, 0x38, 0x34, 0x19, 0xcf, 0x20,
	0x21, 0x44, 0xd4, 0x43, 0x1c, 0x5a, 0x01, 0x4d, 0xc7, 0xd3, 0xf5, 0x80, 0x68, 0x88, 0x8e, 0x25,
	0xb1, 0x84, 0x9c, 0x86, 0x4e, 0xa1, 0xc8, 0x7b, 0x50, 0xb5, 0x3d, 0x9d, 0x14, 0xcd, 0xd7, 0x87,
	0x5b, 0x27, 0x52, 0x70, 0x7f, 0xcb, 0x2a, 0xb6, 0xf7, 0x31, 0x2a, 0xfc, 0xfb, 0x50, 0xb1, 0x3d,
	0x1d, 0x75, 0xbe, 0x7c, 0x3e, 0xc2, 0x25, 0xdb, 0x1b, 0x58, 0x91, 0xfa, 0x01, 0xd4, 0x6c, 0x4f,
	0x38, 0x8c, 0x95, 0xf3, 0x51, 0x56, 0x6d, 0x6f, 0x28, 0x6d, 0xf2, 0xa9, 0x61, 0x47, 0x6d, 0xe5,
	0xcc, 0xc1, 0x21, 0x9a, 0xfa, 0x3e, 0x80, 0x50, 0xae, 0xed, 0x1e, 0xb4, 0x2f, 0x9c, 0x45, 0x94,
	0x42, 0xd6, 0x7e, 0x56, 0x84, 0xdb, 0x51, 0x60, 0xb8, 0xa1, 0x41, 0xd1, 0x8a, 0xbe, 0x17, 0x58,
	0xc6, 0x63, 0xd3, 0x7b, 0xea, 0xa6, 0x27, 0xe2, 0x33, 0xcf, 0xa9, 0x6f, 0x5e, 0xda, 0x2f, 0x20,
	0x82, 0x7f, 0x5b, 0x80, 0xcb, 0xb2, 0x32, 0x3c, 0x0e, 0x27, 0x86, 0xe3, 0xe8, 0x56, 0x10, 0x78,
	0x41, 0x78, 0x42, 0x00, 0xfb, 0x2a, 0xac, 0x44, 0x9e, 0xcf, 0x71, 0xf4, 0x89, 0x67, 0x5a, 0x18,
	0xc8, 0x96, 0xee, 0xb4, 0x58, 0x2b, 0xf2, 0xfc, 0x1e, 0x42, 0xbb, 0x08, 0x54, 0x6f, 0x00, 0x5f,
	0x04, 0xb9, 0x20, 0xca, 0xb4, 0x68, 0xf0, 0x65, 0x94, 0x86, 0xfa, 0x2a, 0xac, 0xcc, 0xaa, 0x75,
	0xcf, 0xb7, 0x5c, 0x72, 0x14, 0x2d, 0xd6, 0x4a, 0x70, 0x86, 0xbe, 0x95, 0x5a, 0x7b, 0x51, 0x2a,
	0x15, 0xc2, 0xe0, 0x6b, 0xef, 0xc0, 0x8a, 0xb4, 0x3f, 0xad, 0xc3, 0x6a, 0x60, 0x85, 0x5e, 0x1c,
	0x4c, 0x32, 0xbe, 0xf3, 0x3b, 0xb0, 0x3c, 0x31, 0x7c, 0x63, 0x62, 0x47, 0xc7, 0x7a, 0x38, 0xf1,
	0x02, 0x19, 0xc5, 0xb7, 0x24, 0x74, 0x84, 0x40, 0xf5, 0x43, 0x0c, 0x5c, 0x5d, 0x97, 0x87, 0xaa,
	0xfa, 0x57, 0xb1, 0x15, 0x5b, 0x7a, 0x1c, 0xe2, 0x4a, 0xe7, 0x4f, 0x22, 0x11, 0xdd, 0xaf, 0xcd,
	0x30, 0x3e, 0x45, 0x84, 0x5d, 0xac, 0xdf, 0x99, 0x44, 0xea, 0x6d, 0x68, 0xee, 0x9b, 0x29, 0x74,
	0x1e, 0xac, 0xc3, 0xbe, 0x99, 0x60, 0xac, 0x41, 0x75, 0xe2, 0xc7, 0x54, 0xc9, 0x87, 0x5f, 0x99,
	0xf8, 0x31, 0x56, 0xfc, 0x00, 0xda, 0x81, 0x15, 0xda, 0xa6, 0xe5, 0x46, 0x3a, 0xf7, 0x65, 0x82,
	0xcf, 0xe3, 0x3d, 0x21, 0x84, 0x4b, 0xb2, 0x7e, 0x9b, 0xaa, 0x89, 0xe5, 0xa3, 0x3d, 0x5c, 0x93,
	0xc3, 0xc8, 0x73, 0x2c, 0xb4, 0xcf, 0xcc, 0xf0, 0xb8, 0x60, 0x56, 0x79, 0x65, 0x37, 0x33, 0xc8,
	0x77, 0x61, 0xed, 0x89, 0x1d, 0x44, 0xb1, 0xe1, 0x2c, 0xb4, 0xd5, 0x22, 0xaa, 0x8b, 0xa2, 0x3a,
	0xdb, 0xd4, 0x9b, 0x70, 0x31, 0x7c, 0x6a, 0xf8, 0x0b, 0x34, 0xcb, 0x3c, 0x5e, 0xc0, 0xba, 0x2c,
	0xc1, 0x77, 0x41, 0x99, 0x1a, 0x5f, 0x7a, 0x81, 0xee, 0x1b, 0x07, 0xd6, 0xbe, 0x11, 0x3b, 0x51,
	0x48, 0x33, 0xbf, 0xcc, 0x56, 0x08, 0xbe, 0x93, 0x80, 0x09, 0xd5, 0x76, 0xb3, 0xa8, 0x8a, 0x40,
	0x45, 0x78, 0x0a, 0xf5, 0x0a, 0xd4, 0xf6, 0x4d, 0x9d, 0x9b, 0xe1, 0x25, 0x6a, 0xba, 0xba, 0x6f,
	0x76, 0xc9, 0x10, 0xd1, 0xc0, 0xfc, 0x58, 0x0f, 0x0f, 0x8d, 0xc0, 0x0a, 0xdb, 0x6d, 0x61, 0x60,
	0x7e, 0x3c, 0x22, 0x00, 0x0e, 0x60, 0x56, 0x9d, 0xd2, 0xd3, 0x15, 0x3e, 0x80, 0x04, 0x31, 0x51,
	0xd7, 0xab, 0xb0, 0x22, 0x06, 0xeb, 0xd8, 0x53, 0x3b, 0xc2, 0xc1, 0x5e, 0xe5, 0x56, 0xc3, 0xc1,
	0x5b, 0x08, 0x7d, 0xb4, 0x87, 0xc1, 0x24, 0x49, 0x26, 0xc1, 0xba, 0x46, 0x58, 0x0d, 0x04, 0x4a,
	0x9c, 0xd7, 0x41, 0xc5, 0xc6, 0xbf, 0x8a, 0xbd, 0xc8, 0xd0, 0xe3, 0xd0, 0x32, 0xa9, 0xe9, 0xeb,
	0x84, 0xb8, 0x32, 0xf1, 0xe3, 0x4f, 0xb1, 0x62, 0x37, 0xb4, 0x4c, 0x6c, 0x78, 0x4e, 0xd4, 0x91,
	0x17, 0x19, 0x0e, 0xf2, 0xbd, 0x31, 0x2f, 0xea, 0x31, 0xd6, 0x3c, 0xda, 0x43, 0xfb, 0x49, 0x13,
	0x18, 0x4f, 0x0c, 0xdb, 0x31, 0xf6, 0x1c, 0xd2, 0xcf, 0x4d, 0x6e, 0x3f, 0x33, 0xa2, 0x8e, 0xac,
	0x7d, 0xb4, 0x87, 0x7b, 0x4c, 0x3e, 0x99, 0x84, 0x03, 0xb0, 0xc2, 0xf6, 0x2d, 0x92, 0xfb, 0x32,
	0x81, 0x77, 0x24, 0x54, 0xbd, 0x03, 0x0a, 0xa2, 0xe8, 0x61, 0x64, 0x04, 0x91, 0x10, 0xff, 0x6d,
	0x8e, 0x89, 0xf0, 0x11, 0x82, 0xb9, 0x16, 0xae, 0x40, 0xed, 0xcb, 0xe9, 0x91, 0x1e, 0x5a, 0x6e,
	0xd4, 0x7e, 0x89, 0x30, 0xaa, 0x5f, 0x4e, 0x8f, 0x46, 0x96, 0x1b, 0xe1, 0xd4, 0xc5, 0x2a, 0x1a,
	0x4f, 0x5b, 0xa3, 0x3a, 0xc4, 0xa5, 0x51, 0x60, 0x74, 0x1b, 0x46, 0x46, 0x14, 0x9a, 0x9c, 0xf4,
	0x65, 0xaa, 0x06, 0x0e, 0x22, 0xea, 0x97, 0xa0, 0x29, 0x10, 0x38, 0x83, 0x57, 0x08, 0x43, 0x10,
	0x71, 0x1e, 0xaf, 0xc2, 0x8a, 0xe1, 0xfb, 0xfa, 0xe4, 0xd0, 0x9a, 0x3c, 0x0e, 0x39, 0x9f, 0xef,
	0x10, 0x56, 0xcb, 0xf0, 0xfd, 0x2e, 0x41, 0x89, 0xd5, 0x1d, 0x50, 0x52, 0x78, 0x9c, 0xdd, 0xab,
	0x7c, 0x34, 0x09, 0x22, 0xe7, 0xf8, 0x32, 0xb4, 0xa2, 0xc3, 0xc0, 0x32, 0xcc, 0x50, 0x0c, 0xfa,
	0x35, 0x42, 0x6b, 0x0a, 0x20, 0x1f, 0xf2, 0x6b, 0xb0, 0xe2, 0x07, 0xde, 0xd4, 0x8a, 0x0e, 0xad,
	0x58, 0x34, 0x7b, 0x27, 0x91, 0x8d, 0x00, 0x53, 0xbb, 0xdf, 0x25, 0x29, 0x4a, 0x44, 0xde, 0xee,
	0x77, 0xb9, 0x9d, 0xcf, 0xe0, 0xd4, 0xb0, 0xf6, 0x17, 0x45, 0xb8, 0x94, 0xf2, 0x45, 0x29, 0x5f,
	0x76, 0x0f, 0x2a, 0xa1, 0x15, 0x3c, 0xb1, 0x02, 0x11, 0x06, 0x5e, 0xcd, 0xf5, 0xeb, 0x62, 0x1d,
	0xe1, 0x98, 0x48, 0x33, 0x71, 0x6c, 0xec, 0x58, 0xf1, 0x6c, 0x1a, 0x8e, 0xa9, 0xfe, 0x04, 0x2e,
	0xa6, 0x97, 0x42, 0x81, 0x14, 0x8a, 0xc8, 0xf0, 0xb5, 0x53, 0x56, 0xa2, 0xf4, 0x76, 0x9f, 0xad,
	0xa6, 0x98, 0x74, 0x05, 0x0f, 0xf5, 0x3d, 0x68, 0xbb, 0xba, 0x71, 0x70, 0x10, 0x58, 0x07, 0x46,
	0x64, 0xe1, 0x7c, 0x96, 0x23, 0x0d, 0x85, 0x6b, 0xbc, 0xec, 0x76, 0x92, 0xea, 0xee, 0xac, 0x56,
	0x35, 0xa0, 0x3d, 0x35, 0x8e, 0xf4, 0xdc, 0x9e, 0xad, 0x3e, 0x5b, 0xcf, 0x2e, 0x4f, 0x8d, 0xa3,
	0xf1, 0x62, 0xe7, 0x34, 0x97, 0xd4, 0x89, 0x86, 0xaf, 0x9b, 0x56, 0x64, 0xd8, 0x4e, 0xa8, 0xaa,
	0x50, 0x9e, 0x78, 0xd3, 0x29, 0x2d, 0x7c, 0x75, 0x46, 0xff, 0x55, 0x05, 0x4a, 0xd6, 0x91, 0x45,
	0x7b, 0xcb, 0x3a, 0xc3, 0xbf, 0x88, 0x65, 0x04, 0x07, 0x28, 0xa1, 0x12, 0x62, 0xe1, 0x7f, 0xb4,
	0xda, 0x89, 0xe7, 0x46, 0x86, 0xed, 0x5a, 0x81, 0x6e, 0x9b, 0x34, 0xba, 0x3a, 0x6b, 0x24, 0xb0,
	0xbe, 0xa9, 0xfd, 0x49, 0x11, 0x67, 0xe1, 0x74, 0x6a, 0xb8, 0x66, 0xd2, 0xe0, 0x75, 0xa0, 0xdd,
	0x6a, 0x18, 0x19, 0x53, 0x5f, 0xec, 0x6e, 0x67, 0x80, 0xd9, 0x42, 0x2c, 0x0e, 0x9c, 0xf8, 0x42,
	0xdc, 0x86, 0xea, 0x64, 0x6a, 0x3a, 0xb6, 0x6b, 0xd1, 0x76, 0xb6, 0xce, 0x64, 0x31, 0xe9, 0x7e,
	0x39, 0xdb, 0x7d, 0xdf, 0x36, 0x69, 0xf7, 0x5a, 0x66, 0xf8, 0x17, 0xb1, 0x7c, 0x04, 0x55, 0x08,
	0x44, 0xff, 0x11, 0x2b, 0xb6, 0x4d, 0xda, 0xa6, 0x96, 0x19, 0xfe, 0x45, 0xc8, 0xe4, 0xa9, 0x49,
	0xd1, 0x72, 0x9d, 0xe1, 0x5f, 0xf5, 0x15, 0x58, 0x76, 0xbc, 0x03, 0xdb, 0xd5, 0xc3, 0x43, 0xcb,
	0x71, 0x70, 0x90, 0x75, 0x3e, 0x49, 0x08, 0x3a, 0x42, 0x60, 0xdf, 0x54, 0xdf, 0x82, 0x8b, 0x69,
	0x2c, 0xd3, 0x0e, 0x23, 0xc3, 0x9d, 0x58, 0x62, 0x7b, 0xaa, 0xce, 0x70, 0x37, 0x44, 0x0d, 0xb6,
	0x14, 0x45, 0xc7, 0x62, 0x43, 0x8a, 0x7f, 0xb5, 0xff, 0x58, 0x84, 0xd5, 0x64, 0x17, 0x85, 0xea,
	0xd5, 0x2d, 0x37, 0x0a, 0x8e, 0xd5, 0xcb, 0x50, 0x71, 0x31, 0x50, 0x09, 0x45, 0x64, 0x22, 0x4a,
	0xe8, 0x8b, 0x48, 0xef, 0x91, 0x27, 0xcf, 0x00, 0xe8, 0xac, 0x6d, 0xec, 0x45, 0x49, 0xd5, 0xd4,
	0x38, 0x12, 0x9b, 0x7f, 0xaa, 0xda, 0x36, 0x8e, 0x32, 0xfb, 0x73, 0x7e, 0x8e, 0x94, 0xbf, 0x3f,
	0xe7, 0xa2, 0x9b, 0xed, 0xcf, 0xdb, 0x50, 0x75, 0x79, 0xa4, 0x24, 0x36, 0xfd, 0xb2, 0x38, 0x77,
	0x42, 0xd7, 0xfa, 0x5a, 0x4e, 0xe8, 0x96, 0x5f, 0xe0, 0x84, 0xee, 0xb7, 0xa1, 0x11, 0x07, 0x4e,
	0x62, 0x6c, 0xa8, 0xe4, 0xc0, 0x11, 0xc6, 0x8d, 0x7f, 0xd5, 0x1f, 0x8a, 0xb3, 0x0f, 0x9c, 0x55,
	0x28, 0xb8, 0xc6, 0xbd, 0xdb, 0xf9, 0x0d, 0xcd, 0x94, 0xc0, 0x12, 0x0a, 0x6d, 0x00, 0xab, 0xe8,
	0x95, 0xe3, 0x90, 0xc2, 0xc1, 0xa4, 0x19, 0xe1, 0xe1, 0x05, 0x58, 0xa8, 0x0a, 0x38, 0x08, 0x43,
	0xc4, 0x94, 0x1a, 0x8b, 0x69, 0x35, 0x6a, 0xff, 0xb8, 0x08, 0xf5, 0xc3, 0x28, 0xf2, 0x75, 0xdb,
	0xdd, 0xf7, 0xd4, 0xf7, 0xa1, 0xc1, 0xbd, 0x9a, 0x1e, 0x07, 0xa4, 0x71, 0x94, 0x66, 0x3b, 0xd3,
	0xbd, 0xd4, 0xe0, 0x18, 0x70, 0xe4, 0xdd, 0xc0, 0x09, 0x91, 0x94, 0x3b, 0x37, 0x4e, 0x5a, 0x3c,
	0x8b, 0x94, 0x23, 0x13, 0xe9, 0x0e, 0xac, 0x0a, 0xd2, 0xd4, 0x18, 0xf8, 0x54, 0x9f, 0x17, 0x4e,
	0xce, 0xd8, 0xd9, 0x05, 0x4e, 0x3c, 0x4a, 0x06, 0x4b, 0x1c, 0xc5, 0x38, 0x32, 0x1c, 0xcb, 0xe7,
	0xe5, 0xc8, 0x89, 0x53, 0x1c, 0x35, 0x0b, 0x2e, 0x84, 0x5f, 0x39, 0x5c, 0x1d, 0x69, 0xd7, 0xe5,
	0x1a, 0x53, 0x4b, 0xba, 0x2e, 0xfc, 0xff, 0x82, 0xea, 0xfd, 0x45, 0x01, 0x2e, 0x63, 0x3b, 0x5f,
	0xc5, 0x16, 0x46, 0x27, 0xc7, 0xfe, 0x4c, 0xc5, 0xef, 0x40, 0x19, 0xcb, 0xd4, 0xd8, 0xf2, 0x9c,
	0x89, 0x23, 0x09, 0x0e, 0xc4, 0x9a, 0xa2, 0x14, 0x11, 0x8d, 0x11, 0xf2, 0x0b, 0xf6, 0xe6, 0x97,
	0x25, 0xa8, 0x21, 0x6b, 0xb2, 0x8d, 0x1e, 0x2c, 0x0b, 0x99, 0x62, 0xe7, 0x6c, 0x4b, 0x9a, 0xc7,
	0xcd, 0x85, 0x9e, 0x64, 0x84, 0xc4, 0x5a, 0x9c, 0xea, 0x53, 0x4e, 0x84, 0x6c, 0x84, 0xb2, 0x25,
	0x9b, 0xe2, 0xf9, 0xd8, 0x70, 0x2a, 0xc9, 0xe6, 0x53, 0x50, 0x53, 0xbd, 0xe1, 0xa2, 0x92, 0x26,
	0xf3, 0xf2, 0x02, 0xab, 0x45, 0x71, 0x32, 0x65, 0xd6, 0xad, 0xe3, 0x31, 0x12, 0x23, 0xcb, 0x54,
	0xcf, 0x24, 0xcb, 0xf2, 0x33, 0xb0, 0x9c, 0x75, 0x51, 0xb0, 0xec, 0x82, 0x18, 0xbd, 0x1e, 0x61,
	0x54, 0xc8, 0x73, 0x26, 0x67, 0x8f, 0xb5, 0xc9, 0x89, 0xc6, 0x44, 0x83, 0x4c, 0x44, 0xbf, 0x04,
	0x93, 0xca, 0xf9, 0x98, 0x70, 0x22, 0xce, 0x44, 0x73, 0xe1, 0xea, 0xd4, 0x73, 0x0f, 0x3c, 0x73,
	0x4f, 0x9f, 0x78, 0x8e, 0x23, 0x42, 0x9f, 0xbf, 0x3c, 0x43, 0xfe, 0x83, 0x02, 0xac, 0xc9, 0x06,
	0x3d, 0x3f, 0x6b, 0xc9, 0xdf, 0x83, 0xa2, 0xe7, 0x0b, 0x3b, 0xbe, 0x9e, 0xe1, 0x39, 0x47, 0xc1,
	0x8a, 0x9e, 0xff, 0x82, 0xfd, 0xf8, 0x55, 0x11, 0x9a, 0x92, 0xab, 0x30, 0x63, 0xe1, 0xe2, 0x42,
	0xdd, 0xf3, 0xa5, 0x0d, 0xbf, 0x72, 0x5a, 0x2f, 0xe6, 0xdd, 0x5d, 0x38, 0xf4, 0x51, 0x29, 0xc2,
	0x83, 0x11, 0x97, 0xe2, 0x33, 0x70, 0xa9, 0x73, 0x3a, 0x64, 0xf2, 0x59, 0x62, 0xc4, 0x33, 0x9d,
	0x48, 0x23, 0x7e, 0x2d, 0x97, 0xd9, 0xa2, 0xee, 0xa4, 0xb3, 0xea, 0xce, 0x38, 0x20, 0x5f, 0xd1,
	0xb9, 0x34, 0xdf, 0xf2, 0x33, 0xf2, 0xe5, 0x2c, 0x52, 0x7c, 0xb5, 0xbf, 0x5b, 0x84, 0x16, 0xee,
	0x32, 0x8c, 0x28, 0x0a, 0xec, 0xbd, 0x38, 0xb2, 0x52, 0x86, 0x53, 0x48, 0x0c, 0x27, 0x93, 0xb2,
	0x2b, 0x88, 0x94, 0x9d, 0xfa, 0x11, 0xb4, 0xc2, 0x78, 0x2f, 0xa1, 0x94, 0xc3, 0xcc, 0x46, 0xcb,
	0x19, 0xe6, 0x2c, 0x4b, 0x80, 0x7c, 0x0d, 0xc7, 0x36, 0x42, 0xda, 0xb6, 0xd7, 0x19, 0x2f, 0xa8,
	0x6f, 0x09, 0xb7, 0x58, 0xbd, 0x5d, 0x58, 0x30, 0x27, 0x64, 0x37, 0xb5, 0xa2, 0xc0, 0x9e, 0xa4,
	0x7d, 0xe2, 0x77, 0xa0, 0x1c, 0xbb, 0x76, 0x44, 0x61, 0xd6, 0xf2, 0xbd, 0x0b, 0xd9, 0x25, 0xca,
	0xb5, 0x23, 0x46, 0xd5, 0xea, 0x1d, 0x58, 0x0a, 0x27, 0x86, 0x63, 0x51, 0xc4, 0xb5, 0x7c, 0x4f,
	0xcd, 0x4e, 0x37, 0xac, 0x61, 0x1c, 0x41, 0xfb, 0x09, 0xdf, 0x96, 0xed, 0x59, 0x86, 0x9b, 0x2b,
	0x90, 0x0f, 0x00, 0x52, 0xe3, 0x2e, 0x9e, 0x39, 0xee, 0x14, 0xb6, 0xf6, 0x5b, 0x50, 0xff, 0xd2,
	0x78, 0x62, 0x70, 0xdb, 0x7d, 0x09, 0x9a, 0x32, 0x7a, 0x4e, 0x35, 0xd2, 0x10, 0xb0, 0x01, 0xb6,
	0xf5, 0x3a, 0x2c, 0xed, 0x51, 0x76, 0x96, 0x37, 0x73, 0x69, 0xa1, 0x19, 0xac, 0x65, 0x1c, 0x47,
	0xbb, 0x0f, 0x20, 0xb7, 0x7d, 0xc6, 0x01, 0x86, 0x2a, 0x8f, 0xad, 0x63, 0x19, 0xaa, 0x3c, 0xb6,
	0x8e, 0xb3, 0x9a, 0xac, 0xcb, 0xe4, 0xeb, 0xff, 0x29, 0x42, 0x4b, 0x90, 0x71, 0xe1, 0xe6, 0x0e,
	0xfa, 0x75, 0x28, 0x47, 0xc6, 0x81, 0xec, 0xc7, 0xda, 0xc2, 0x9a, 0xcb, 0x1b, 0x65, 0x84, 0x94,
	0xac, 0x6d, 0x25, 0x12, 0xf5, 0xad, 0x3c, 0xe4, 0x45, 0x3d, 0x26, 0xbd, 0x2b, 0xa7, 0xed, 0x4c,
	0x81, 0x52, 0x18, 0x4f, 0xc9, 0x46, 0x0a, 0x0c, 0xff, 0xca, 0xbc, 0x78, 0x85, 0x43, 0x52, 0x79,
	0xf1, 0xaa, 0x80, 0x18, 0x47, 0xb3, 0xa8, 0xbf, 0xc6, 0x79, 0xf1, 0xa8, 0x3f, 0x1b, 0x5b, 0x36,
	0xbf, 0x96, 0xd8, 0xb2, 0xf5, 0x02, 0xb1, 0xe5, 0x4e, 0xb2, 0x8f, 0x27, 0x73, 0xe8, 0xc0, 0x72,
	0x46, 0x38, 0xd2, 0x9b, 0x5d, 0x3d, 0x59, 0x7e, 0x4c, 0x68, 0x6e, 0x9b, 0x13, 0x68, 0x6f, 0x43,
	0x15, 0x77, 0xeb, 0xcf, 0xa2, 0xfe, 0xbf, 0x53, 0x00, 0x40, 0x9a, 0x53, 0x74, 0x2f, 0xe7, 0x64,
	0x31, 0x67, 0x4e, 0xce, 0x48, 0x73, 0x75, 0x59, 0x4a, 0xeb, 0xf2, 0x8e, 0xb0, 0x21, 0xee, 0xb9,
	0x2e, 0x2e, 0xf0, 0x49, 0x0c, 0x48, 0xfb, 0x5d, 0xa8, 0x27, 0xa7, 0x0e, 0xb9, 0x5d, 0xba, 0x97,
	0x1e, 0x4b, 0x5e, 0x9f, 0x88, 0x54, 0x27, 0x9c, 0xf9, 0xe6, 0x4b, 0x67, 0x36, 0xff, 0x87, 0x05,
	0xa8, 0x21, 0xe4, 0xbc, 0xb3, 0xf4, 0x6d, 0xa8, 0x4a, 0x95, 0xe5, 0xcd, 0x8f, 0x99, 0x8c, 0x98,
	0xc4, 0x53, 0xef, 0x42, 0x85, 0x9f, 0xa9, 0x88, 0xee, 0x5c, 0xce, 0x1f, 0x01, 0x13, 0x58, 0xda,
	0x2f, 0x4a, 0x74, 0x4e, 0x1d, 0x79, 0xbc, 0x53, 0xeb, 0x50, 0xc6, 0x30, 0x5f, 0x9c, 0x6b, 0x64,
	0x89, 0x93, 0xf8, 0x9f, 0x11, 0x0e, 0xfa, 0x90, 0xe9, 0x71, 0xf8, 0x95, 0x23, 0x0e, 0x34, 0x2e,
	0x2d, 0x04, 0x1a, 0x84, 0xcb, 0x71, 0xd4, 0xb7, 0xa1, 0xe6, 0x7b, 0x61, 0x74, 0x10, 0x58, 0xf2,
	0xf8, 0xe2, 0x04, 0xfc, 0x04, 0x4d, 0x7d, 0x07, 0xaa, 0x62, 0xdd, 0xc9, 0x4d, 0x6e, 0xa5, 0x97,
	0x6b, 0x26, 0x31, 0x71, 0x00, 0xe8, 0x08, 0x45, 0x86, 0x2b, 0x3b, 0x80, 0xc4, 0x43, 0x32, 0xc2,
	0x51, 0xdf, 0x82, 0x0a, 0x37, 0x73, 0x91, 0xdf, 0x6a, 0xe7, 0x4d, 0x08, 0xc2, 0x17, 0x78, 0xea,
	0x6b, 0x50, 0x32, 0x7c, 0x5f, 0xa4, 0xb6, 0x2e, 0x2d, 0x88, 0x96, 0x70, 0x11, 0x43, 0x7d, 0x97,
	0xa4, 0x2a, 0x8e, 0x93, 0x44, 0x96, 0xea, 0x04, 0xfc, 0x14, 0xa2, 0x66, 0xc1, 0x8a, 0x6b, 0x45,
	0x4f, 0xbd, 0xe0, 0xb1, 0xbe, 0x77, 0xac, 0xfb, 0x5e, 0x10, 0xd1, 0x91, 0x80, 0x17, 0xc8, 0x03,
	0x7f, 0xfa, 0xaf, 0xfe, 0xe6, 0x42, 0xac, 0xa3, 0xcd, 0x39, 0x8a, 0x9c, 0x53, 0xab, 0x54, 0xb4,
	0xf3, 0x3f, 0xeb, 0x50, 0x3e, 0xf4, 0xc2, 0x48, 0xbd, 0x0a, 0x35, 0xfc, 0x4d, 0xd9, 0x5f, 0x52,
	0xc6, 0x3d, 0xb8, 0x1b, 0x4f, 0xf5, 0x89, 0x1f, 0x87, 0xe2, 0x90, 0xa3, 0xea, 0xc6, 0xd3, 0xae,
	0x1f, 0x87, 0x94, 0x00, 0xf0, 0x63, 0xdd, 0xf1, 0x0c, 0x93, 0xdb, 0x59, 0x8b, 0xd5, 0x26, 0x7e,
	0xbc, 0x85, 0x65, 0xf5, 0x43, 0xb8, 0xea, 0x1f, 0x1e, 0x87, 0xf6, 0x64, 0x76, 0xba, 0x1d, 0xda,
	0x3f, 0x15, 0xd9, 0x11, 0xb1, 0x9b, 0x5f, 0x93, 0x18, 0xfc, 0x3c, 0x74, 0x64, 0xff, 0xd4, 0x7a,
	0x40, 0x77, 0x0a, 0x3e, 0x80, 0x7a, 0x94, 0x0c, 0x8d, 0xeb, 0x30, 0x3b, 0x07, 0xe7, 0x52, 0xb2,
	0x6c, 0x86, 0x7e, 0xe2, 0x69, 0x59, 0xe5, 0x6b, 0x38, 0x2d, 0xfb, 0x08, 0xae, 0xa7, 0x79, 0xcf,
	0x92, 0x35, 0xba, 0x69, 0x39, 0xc6, 0x31, 0x59, 0x44, 0x99, 0x5d, 0x4d, 0xe1, 0xec, 0x24, 0x28,
	0x1b, 0x88, 0xa1, 0x6e, 0xc3, 0x85, 0x59, 0x5a, 0x44, 0x76, 0x8d, 0x27, 0x3c, 0xb3, 0x81, 0x6a,
	0x4e, 0xf2, 0x84, 0x29, 0x12, 0x98, 0x74, 0xe8, 0x13, 0x58, 0xce, 0xa6, 0x86, 0x84, 0x91, 0xbd,
	0x9c, 0x3b, 0xcc, 0x2c, 0x2a, 0x6b, 0x89, 0x72, 0x8f, 0x9f, 0x8d, 0x6c, 0xc2, 0x8a, 0x75, 0x14,
	0x59, 0x81, 0x6b, 0x38, 0xba, 0xc8, 0x75, 0xc1, 0xf9, 0x72, 0x5d, 0x2d, 0x49, 0xd7, 0xa7, 0x9c,
	0x97, 0xb0, 0x8b, 0x30, 0xb2, 0x0c, 0x87, 0xae, 0xe5, 0x70, 0xbb, 0x18, 0x61, 0x59, 0x1d, 0x42,
	0x23, 0xb0, 0xbe, 0x4a, 0x86, 0xce, 0xd3, 0xa4, 0x6f, 0x64, 0x95, 0x7b, 0x46, 0xde, 0x8f, 0xa5,
	0x39, 0xa8, 0x77, 0x40, 0x71, 0xad, 0xa3, 0x48, 0x8f, 0x6c, 0x8c, 0xd2, 0xb9, 0x1e, 0x5a, 0xfc,
	0xd0, 0x17, 0xe1, 0x63, 0x04, 0x73, 0xd9, 0x9f, 0x76, 0x62, 0xb9, 0xf6, 0xb5, 0x9c, 0x58, 0xaa,
	0x0c, 0x2e, 0xa7, 0x66, 0x2e, 0x8f, 0xb5, 0x71, 0xae, 0x86, 0xed, 0x36, 0xf9, 0xe1, 0xac, 0x15,
	0xcf, 0x4d, 0x72, 0x76, 0x51, 0x00, 0x1e, 0x1c, 0x8f, 0x66, 0x94, 0x74, 0xfd, 0xc5, 0x8f, 0x75,
	0xdb, 0x74, 0xac, 0xf6, 0x15, 0x92, 0x66, 0x75, 0xe2, 0xc7, 0x7d, 0xd3, 0xa1, 0x73, 0x9a, 0xd8,
	0xa7, 0x74, 0x33, 0x3f, 0xe0, 0x17, 0x25, 0xf5, 0x06, 0x00, 0x4f, 0x78, 0xe3, 0xbc, 0x6d, 0x6b,
	0x44, 0x54, 0xe7, 0x90, 0xae, 0x1f, 0x23, 0xc7, 0x38, 0xc4, 0x7d, 0x84, 0x1f, 0xb7, 0x5f, 0xe6,
	0x1c, 0xb1, 0x8c, 0x55, 0xef, 0xc3, 0x15, 0x31, 0x5b, 0xf9, 0xf1, 0x5a, 0x26, 0x83, 0xc1, 0x0f,
	0xfa, 0x2f, 0x73, 0x04, 0x9a, 0xa9, 0xe9, 0x14, 0xc6, 0x0d, 0x00, 0xdb, 0x7b, 0x6a, 0xd8, 0x11,
	0xf1, 0xfd, 0x0e, 0x6f, 0x94, 0x43, 0x44, 0xa3, 0xae, 0x8d, 0xf6, 0xec, 0xc7, 0xed, 0x57, 0x79,
	0xa3, 0x58, 0xc6, 0x2a, 0x0d, 0x5a, 0xa2, 0xbb, 0xe8, 0x4b, 0xf4, 0xb7, 0xe9, 0x28, 0xbe, 0xc5,
	0x1a, 0x1c, 0x88, 0xfe, 0xe4, 0xed, 0x79, 0x9c, 0x77, 0xdb, 0xeb, 0xf3, 0x38, 0xef, 0xaa, 0xaf,
	0xd0, 0x6c, 0x98, 0xf1, 0x79, 0xb7, 0xfd, 0x3a, 0x21, 0x35, 0x53, 0x8c, 0xde, 0xd5, 0xfe, 0xac,
	0x9a, 0xdc, 0x4e, 0x50, 0xbf, 0x0f, 0x55, 0xb1, 0x83, 0x11, 0xcb, 0x57, 0x56, 0x41, 0x73, 0xa7,
	0xcf, 0x4c, 0x22, 0xa3, 0x77, 0xb3, 0x43, 0xdd, 0xf6, 0x9f, 0xdc, 0xcf, 0x98, 0x93, 0x48, 0x07,
	0xe0, 0xca, 0x56, 0x63, 0x6b, 0x76, 0xd8, 0xf7, 0x9f, 0xdc, 0x4f, 0x99, 0x09, 0xd7, 0xaa, 0x20,
	0x8e, 0x5d, 0xfb, 0x28, 0x8f, 0xb8, 0x2c, 0x89, 0x77, 0x5d, 0xfb, 0x68, 0x91, 0xf8, 0xff, 0xbb,
	0xc6, 0x6f, 0xc1, 0x35, 0x9e, 0xa0, 0x6e, 0x91, 0xc9, 0x81, 0x13, 0xd4, 0xdd, 0xe5, 0xe9, 0x9b,
	0x13, 0xd4, 0x2d, 0x88, 0x1b, 0x27, 0xa8, 0x5b, 0x10, 0xe7, 0x79, 0xb7, 0x66, 0xae, 0x77, 0xa3,
	0x43, 0xef, 0x28, 0xf0, 0xc4, 0xdd, 0x06, 0x3a, 0xf4, 0xa6, 0xe2, 0x37, 0x90, 0xa9, 0x51, 0xdf,
	0x84, 0x0a, 0xd1, 0x86, 0xed, 0x8b, 0xc4, 0x70, 0x6d, 0x7e, 0x1a, 0x89, 0xc8, 0x92, 0x09, 0x34,
	0x71, 0x04, 0x9d, 0x64, 0x30, 0x2f, 0x25, 0x49, 0x46, 0x99, 0xbd, 0xcc, 0x49, 0x88, 0xae, 0xe5,
	0x25, 0x44, 0xb5, 0x21, 0xcd, 0xe6, 0x83, 0xc0, 0x98, 0xaa, 0x6f, 0x41, 0x0d, 0xb1, 0xb1, 0x21,
	0x0a, 0x94, 0xe6, 0xc3, 0x70, 0xc1, 0x8a, 0x25, 0x58, 0x14, 0x56, 0xd9, 0x26, 0x8f, 0xab, 0xcb,
	0x8c, 0xfe, 0x6b, 0x31, 0xd4, 0x51, 0xd3, 0x51, 0xec, 0x3b, 0x7c, 0x83, 0x68, 0xfb, 0x22, 0xec,
	0xc2, 0xbf, 0x08, 0x31, 0x6d, 0x5f, 0x1c, 0x8c, 0xe3, 0x5f, 0xdc, 0x8e, 0x84, 0x14, 0x9c, 0xf1,
	0xdb, 0x94, 0xbc, 0x80, 0x50, 0x93, 0xa0, 0xfc, 0xca, 0x22, 0x2f, 0xa0, 0x96, 0x9c, 0xfb, 0xd4,
	0x1b, 0x71, 0x5d, 0x51, 0x16, 0xb5, 0x3f, 0x29, 0xc0, 0x0a, 0x59, 0xd8, 0x2c, 0x6c, 0x53, 0xbf,
	0x07, 0x4b, 0xd4, 0x0d, 0x31, 0x9a, 0x6c, 0x1c, 0x9b, 0x74, 0x92, 0x71, 0x24, 0x1c, 0x4c, 0xe8,
	0xdb, 0x26, 0x79, 0xb2, 0x32, 0xa3, 0xff, 0x08, 0x33, 0x79, 0x76, 0x89, 0x60, 0xf8, 0x3f, 0x13,
	0x37, 0xd6, 0x9e, 0x23, 0x6e, 0xf4, 0xe1, 0x32, 0x75, 0x54, 0x2e, 0x5f, 0x36, 0x82, 0xf7, 0x8d,
	0x89, 0x95, 0x7b, 0x32, 0xa8, 0x42, 0xd9, 0x30, 0xcd, 0x40, 0x08, 0x8c, 0xfe, 0x0b, 0x5b, 0x9d,
	0x1a, 0xe1, 0x63, 0x79, 0x03, 0x55, 0x14, 0x51, 0x6a, 0x7b, 0x13, 0x23, 0x94, 0xf7, 0x32, 0x78,
	0x41, 0xfb, 0x59, 0x11, 0x60, 0x4a, 0xcd, 0x9b, 0xfa, 0x7e, 0x88, 0xcb, 0x9e, 0x69, 0x3d, 0xb1,
	0x27, 0xb2, 0x21, 0x51, 0xc2, 0xc0, 0x83, 0xb0, 0x74, 0xd3, 0x0e, 0x44, 0x3a, 0xb0, 0x46, 0x80,
	0x0d, 0x3b, 0xc0, 0x7e, 0x88, 0x53, 0x03, 0xea, 0x1b, 0x6d, 0x24, 0x71, 0x9d, 0x9c, 0x0f, 0x4a,
	0xeb, 0x61, 0x12, 0x86, 0xde, 0x00, 0xa0, 0x1b, 0x02, 0xbc, 0x9a, 0x67, 0x99, 0xea, 0x08, 0xe1,
	0xd5, 0xaf, 0xc1, 0xca, 0x6c, 0x79, 0xe4, 0x38, 0x3c, 0x63, 0xb7, 0x9c, 0x80, 0x39, 0xe2, 0x4b,
	0xd0, 0xe4, 0x57, 0x07, 0x6c, 0x97, 0x32, 0x0b, 0xc0, 0x13, 0xe6, 0x04, 0xeb, 0x13, 0x08, 0xe7,
	0x03, 0x35, 0x25, 0x30, 0x1a, 0x7c, 0x3e, 0x20, 0x88, 0x23, 0x68, 0x7f, 0x50, 0x80, 0x3a, 0x5d,
	0xc8, 0xc1, 0x3d, 0x48, 0xae, 0xa0, 0x51, 0x74, 0xc7, 0xfc, 0xcc, 0x88, 0x0c, 0x8e, 0x5f, 0xcf,
	0x4d, 0xdd, 0x6a, 0x2f, 0x65, 0x6e, 0xb5, 0xdf, 0x00, 0xf0, 0x7c, 0x4b, 0xb8, 0x02, 0x61, 0xa4,
	0x75, 0x84, 0xf0, 0xf9, 0x77, 0x19, 0x2a, 0xc2, 0x6d, 0x72, 0x3b, 0x15, 0x25, 0xed, 0x8f, 0xe9,
	0x56, 0x92, 0xcc, 0xa3, 0xa2, 0x4d, 0xeb, 0x53, 0xc3, 0xf7, 0x6d, 0xf7, 0x00, 0x9b, 0xc2, 0x6d,
	0x83, 0x6e, 0xfb, 0xe2, 0x52, 0x4f, 0x05, 0x8b, 0x7d, 0x1f, 0xf5, 0x42, 0x15, 0x34, 0x1d, 0xf8,
	0x26, 0x82, 0x36, 0x18, 0x3b, 0x38, 0x23, 0xb2, 0x79, 0x59, 0x5f, 0xdc, 0xd6, 0x49, 0xe5, 0x65,
	0x7d, 0xba, 0x34, 0x94, 0x69, 0x52, 0x58, 0x47, 0x2b, 0x81, 0x22, 0x27, 0xed, 0x7d, 0x74, 0x19,
	0x12, 0xcd, 0x31, 0xf6, 0x2c, 0xe7, 0xdc, 0xc7, 0x14, 0x7f, 0x51, 0x83, 0x7a, 0x42, 0xab, 0x2e,
	0x43, 0xd1, 0x36, 0x05, 0x51, 0xd1, 0x36, 0xd5, 0x37, 0x33, 0x27, 0x14, 0xd7, 0xe6, 0x27, 0x8b,
	0x68, 0x31, 0x75, 0x40, 0x21, 0xd5, 0x53, 0xca, 0x1e, 0x74, 0xda, 0x53, 0xe3, 0xc0, 0x12, 0x89,
	0x67, 0x5e, 0x78, 0xa1, 0xe5, 0x7c, 0x2e, 0x94, 0xae, 0xbc, 0x70, 0x28, 0x7d, 0x52, 0x7c, 0x50,
	0xfd, 0x1a, 0xe2, 0x83, 0xd3, 0x16, 0xa1, 0xfa, 0xd7, 0xb3, 0x08, 0x9d, 0x15, 0x82, 0xc0, 0x99,
	0x21, 0xc8, 0xf9, 0x57, 0xdb, 0xdc, 0x60, 0xa5, 0xf5, 0x35, 0x06, 0x2b, 0xcb, 0xcf, 0x1d, 0xac,
	0x3c, 0x84, 0x56, 0x7a, 0x5a, 0x86, 0x6d, 0x35, 0x27, 0x29, 0x95, 0x3f, 0x85, 0x59, 0x13, 0x4b,
	0xdb, 0x82, 0x30, 0xb5, 0xaa, 0xaf, 0x9e, 0x6f, 0x55, 0xbf, 0x0f, 0x15, 0x9a, 0x77, 0x18, 0x06,
	0x2c, 0x6e, 0x77, 0xe6, 0x26, 0x27, 0x13, 0xb8, 0xd8, 0x0c, 0x79, 0xe9, 0xb0, 0x7d, 0x29, 0xe7,
	0x78, 0x6b, 0xe6, 0xf7, 0x99, 0x40, 0x3b, 0x65, 0x97, 0x75, 0xf9, 0xb9, 0x77, 0x59, 0x1a, 0xb4,
	0xa6, 0x56, 0xe8, 0x85, 0x7a, 0x64, 0x84, 0x8f, 0x75, 0xdb, 0xa4, 0x68, 0xa3, 0xce, 0x1a, 0x04,
	0x1c, 0x1b, 0xe1, 0xe3, 0xbe, 0x89, 0x5b, 0x18, 0x9a, 0xb5, 0x58, 0xdd, 0xa6, 0xea, 0x2a, 0x95,
	0xfb, 0xa6, 0xfa, 0x1e, 0xae, 0xa9, 0x74, 0x73, 0x24, 0xa4, 0x4d, 0xda, 0xe2, 0xd8, 0x33, 0xd7,
	0x4a, 0x58, 0x82, 0xad, 0xdd, 0x23, 0xff, 0x77, 0x10, 0x78, 0xb1, 0xaf, 0xc7, 0x7c, 0xc5, 0x7e,
	0x6c, 0xbb, 0xa6, 0x3c, 0x8f, 0xc4, 0xff, 0xc2, 0x21, 0x71, 0x8f, 0x55, 0xb4, 0x4d, 0xed, 0x9f,
	0x14, 0xe0, 0x42, 0x42, 0xe4, 0x5a, 0xd1, 0xc9, 0x67, 0x44, 0xb7, 0xa0, 0x11, 0x19, 0xc1, 0x81,
	0x95, 0x38, 0x5f, 0x4a, 0xf5, 0x73, 0x10, 0xb9, 0xdf, 0xab, 0x14, 0x33, 0x45, 0xde, 0xc4, 0x73,
	0x84, 0xbb, 0x4a, 0xca, 0xe8, 0xb7, 0x71, 0xf1, 0x49, 0xbb, 0xdc, 0x1a, 0x02, 0x88, 0xf0, 0x3b,
	0xb0, 0xec, 0xc7, 0x7b, 0x8e, 0x1d, 0x1e, 0x5a, 0x26, 0xc7, 0x10, 0xb7, 0x44, 0x13, 0x28, 0x39,
	0xe5, 0x7f, 0x5f, 0x4e, 0x7b, 0x65, 0xea, 0xb1, 0xfa, 0x3a, 0xbf, 0xcb, 0x92, 0x7f, 0x79, 0x7e,
	0x26, 0x0a, 0x7e, 0xcd, 0xe5, 0x83, 0xcc, 0xb9, 0xea, 0xab, 0x27, 0x58, 0x14, 0x11, 0xdd, 0x1d,
	0x1b, 0x07, 0x61, 0x8f, 0x72, 0x7a, 0x3c, 0x53, 0xf0, 0x12, 0x34, 0x6d, 0x5f, 0xc7, 0x90, 0x83,
	0x47, 0x90, 0x4b, 0x74, 0x1f, 0xa8, 0x61, 0xfb, 0x1d, 0x09, 0x52, 0xef, 0xc3, 0x12, 0x37, 0x9d,
	0xbc, 0x3c, 0xe9, 0x82, 0x8c, 0x19, 0x47, 0x4e, 0x1f, 0xc9, 0x56, 0xcf, 0x79, 0x24, 0xfb, 0x2e,
	0xd4, 0x26, 0x87, 0xb6, 0x63, 0x06, 0x96, 0x2b, 0x9e, 0x86, 0x9d, 0x32, 0xf2, 0x04, 0x95, 0xae,
	0xd2, 0x1b, 0x81, 0x85, 0xb3, 0xa3, 0x7e, 0x16, 0x95, 0xc4, 0x54, 0x47, 0xd0, 0xa2, 0xa0, 0xcc,
	0x35, 0x1c, 0x9d, 0x84, 0xc7, 0xdf, 0x58, 0xdd, 0x3d, 0x55, 0x78, 0x7d, 0x41, 0x31, 0x13, 0x62,
	0xd3, 0x4e, 0x81, 0xae, 0xfe, 0x00, 0xea, 0x49, 0xd5, 0x6c, 0x61, 0x2d, 0x9c, 0xba, 0xb0, 0x7e,
	0x50, 0x7c, 0xaf, 0x70, 0xf5, 0x47, 0x70, 0x61, 0x81, 0xf7, 0xb3, 0x30, 0xd0, 0xfe, 0x46, 0x81,
	0xae, 0xe0, 0x89, 0x81, 0xfa, 0xa6, 0x11, 0x59, 0xba, 0xf5, 0x04, 0xb7, 0x47, 0xf7, 0x33, 0xd7,
	0x1c, 0x6e, 0xe7, 0x8b, 0x86, 0x50, 0xd3, 0xcb, 0xf3, 0x7d, 0xa8, 0x78, 0x7b, 0x5f, 0x5a, 0x13,
	0x1e, 0xb1, 0x9f, 0xec, 0xa6, 0x88, 0x9c, 0x09, 0x5c, 0xed, 0x53, 0x58, 0xf5, 0x82, 0xc9, 0xa1,
	0x15, 0x46, 0x81, 0x11, 0x79, 0x01, 0x67, 0x1b, 0xaa, 0x1f, 0x40, 0x85, 0xff, 0x13, 0xf9, 0x14,
	0xed, 0x04, 0xfd, 0xa4, 0xba, 0xcd, 0x04, 0x85, 0x76, 0x0f, 0x6a, 0x8f, 0xdf, 0x0b, 0x75, 0xdf,
	0xb0, 0x83, 0xd3, 0x43, 0x95, 0xe2, 0x2c, 0x54, 0xf9, 0xd7, 0x05, 0x00, 0x24, 0x42, 0x07, 0xe2,
	0xb9, 0xb9, 0x91, 0xa0, 0xb8, 0x2b, 0x26, 0x2e, 0xc4, 0xe1, 0x24, 0xba, 0x0e, 0x75, 0xac, 0x09,
	0x7d, 0x63, 0x22, 0xa3, 0x92, 0x19, 0x40, 0x7d, 0x23, 0x71, 0xdb, 0xe5, 0x9c, 0x3c, 0xa0, 0xec,
	0x61, 0xe2, 0xaf, 0xdf, 0x81, 0x7a, 0x68, 0x39, 0xd6, 0x24, 0xe2, 0xd1, 0xe1, 0x29, 0x14, 0x33,
	0x3c, 0xed, 0x23, 0x68, 0x21, 0x78, 0xd6, 0xe8, 0x9b, 0x50, 0xe1, 0x43, 0x10, 0x9b, 0x9b, 0xb5,
	0x05, 0x16, 0xbc, 0x9a, 0x09, 0x34, 0xed, 0x33, 0x2e, 0x2c, 0x74, 0x40, 0xcf, 0x4c, 0x8c, 0xae,
	0x5b, 0xc4, 0xa6, 0x7c, 0xb3, 0x57, 0x67, 0x55, 0x1e, 0x9c, 0x86, 0xda, 0x9f, 0x17, 0xa0, 0x4a,
	0x3d, 0xf6, 0xcc, 0x67, 0xe7, 0xfb, 0x32, 0xb4, 0xd2, 0xb7, 0x0a, 0x25, 0xf3, 0x66, 0xea, 0x5a,
	0x61, 0x98, 0xf8, 0xd1, 0x54, 0x4c, 0x48, 0x7e, 0x94, 0xb2, 0x3b, 0xa9, 0xa8, 0x99, 0x47, 0x86,
	0x32, 0x6a, 0xbe, 0x05, 0x8d, 0x64, 0x12, 0xdb, 0xbe, 0xc8, 0x63, 0x83, 0x04, 0xf5, 0x7d, 0x6c,
	0x3b, 0xb0, 0xd2, 0xbb, 0x68, 0x7e, 0xd7, 0xbc, 0x29, 0x80, 0x14, 0x5c, 0x68, 0xff, 0xa8, 0x00,
	0x57, 0xb1, 0xdf, 0x81, 0xe5, 0x3b, 0xf6, 0xc4, 0x10, 0x81, 0x97, 0x1b, 0x05, 0x9e, 0xe3, 0x58,
	0xc1, 0xb3, 0x0f, 0xf8, 0xbb, 0xa0, 0x08, 0x56, 0x18, 0x20, 0x85, 0x76, 0x60, 0x99, 0x22, 0xa4,
	0x5f, 0x91, 0xf0, 0x0d, 0x0e, 0xce, 0xa0, 0x06, 0xb1, 0xeb, 0xda, 0xee, 0x81, 0x88, 0xee, 0x13,
	0x54, 0xc6, 0xc1, 0xb8, 0xab, 0x58, 0x49, 0xf5, 0x52, 0x0f, 0xad, 0xe8, 0xaf, 0x4a, 0xd7, 0xfe,
	0xb0, 0x08, 0x0d, 0x6c, 0x0c, 0xc3, 0x0c, 0xfb, 0x39, 0xec, 0x96, 0x6e, 0xc3, 0x3b, 0x71, 0x18,
	0xf1, 0xed, 0x0d, 0x77, 0x6e, 0x75, 0x01, 0xe9, 0xfb, 0xea, 0x0f, 0xe4, 0x02, 0xc4, 0x17, 0xb8,
	0x97, 0x16, 0xd8, 0x89, 0x86, 0xef, 0xce, 0xad, 0x41, 0x57, 0x8f, 0xa0, 0xf6, 0xed, 0x2c, 0xfd,
	0xda, 0xdf, 0x2f, 0xc0, 0x32, 0xf6, 0xcc, 0xb4, 0x7c, 0xc7, 0x3b, 0x9e, 0xa2, 0x23, 0xfe, 0x2b,
	0xa2, 0xac, 0x7f, 0x50, 0xe0, 0x6e, 0xc6, 0x34, 0xac, 0xa9, 0xe7, 0x3e, 0x97, 0x15, 0xbd, 0x0e,
	0x17, 0x26, 0x71, 0x10, 0xd0, 0x05, 0xc3, 0xc9, 0xa1, 0x65, 0xc6, 0x4e, 0xd2, 0x33, 0x45, 0x54,
	0x8c, 0x24, 0x1c, 0x91, 0x45, 0xe7, 0x53, 0xc8, 0xbc, 0x6f, 0x8a, 0xa8, 0x48, 0x90, 0xb5, 0x3f,
	0x2f, 0x41, 0x9d, 0x14, 0x1a, 0x19, 0x11, 0xdd, 0xf3, 0x48, 0x9c, 0x61, 0x7e, 0x2e, 0x3e, 0xe3,
	0x2f, 0x59, 0x0a, 0x5b, 0x7d, 0x1d, 0x96, 0xdc, 0xe4, 0x7d, 0x4f, 0x9e, 0xf7, 0xc5, 0x5a, 0xc6,
	0x71, 0xd4, 0x3b, 0x68, 0x1b, 0x66, 0x7e, 0x62, 0x5a, 0xf8, 0x3d, 0x46, 0x18, 0x6a, 0x1f, 0x1a,
	0x33, 0xd7, 0x90, 0x7f, 0x05, 0xe8, 0x64, 0x57, 0xc2, 0xd2, 0xb4, 0xea, 0x7d, 0xa8, 0x09, 0xbb,
	0x95, 0x4b, 0x44, 0xfb, 0x24, 0xc3, 0x66, 0x09, 0xa6, 0xfa, 0x23, 0x68, 0xa6, 0x3c, 0x80, 0x8c,
	0xc9, 0xae, 0x9f, 0xd4, 0x03, 0x44, 0xc2, 0x1d, 0x2c, 0x15, 0x46, 0x56, 0x14, 0xaa, 0x7f, 0x0d,
	0x1a, 0x33, 0xa3, 0x94, 0xb1, 0xd9, 0xb5, 0x05, 0xfa, 0x19, 0x0e, 0x4b, 0xe3, 0xa3, 0x4e, 0x12,
	0xcb, 0x09, 0x45, 0x94, 0xb6, 0xa8, 0x93, 0x04, 0x85, 0xa5, 0xb0, 0xb5, 0xfb, 0x00, 0x7c, 0x03,
	0xf1, 0x4c, 0xab, 0xb9, 0x05, 0x4d, 0x4e, 0x25, 0xac, 0x4f, 0x91, 0xa1, 0x71, 0xb2, 0x74, 0xcb,
	0x05, 0xbe, 0x98, 0x3a, 0x4b, 0x78, 0x33, 0x59, 0xb0, 0x4b, 0x79, 0x3b, 0xa6, 0xa4, 0x1b, 0x72,
	0xc9, 0xd6, 0x7e, 0x22, 0x3b, 0x87, 0xbb, 0x1b, 0xf5, 0xed, 0xb9, 0x39, 0x71, 0x25, 0x87, 0x7c,
	0x71, 0xfd, 0x0c, 0x1d, 0xe3, 0x09, 0x6d, 0x7d, 0xf8, 0x00, 0xaa, 0x54, 0xee, 0x9b, 0xda, 0xfb,
	0xd0, 0x9c, 0x1a, 0x81, 0x11, 0x1d, 0x7a, 0xae, 0x6e, 0xf8, 0xfe, 0xc2, 0xe9, 0xc9, 0x15, 0xa8,
	0x89, 0x3d, 0x55, 0xb2, 0xf4, 0x46, 0xb4, 0x9f, 0x0a, 0xb5, 0x9f, 0x17, 0x60, 0x39, 0xa1, 0xe5,
	0x7b, 0x83, 0x79, 0xea, 0x37, 0xa0, 0x6c, 0xf8, 0xc9, 0xa5, 0xb9, 0xb9, 0x9e, 0xa6, 0x9a, 0x65,
	0x84, 0xa6, 0xbe, 0x03, 0x15, 0xe2, 0x23, 0x25, 0x73, 0x2d, 0x9f, 0x40, 0x44, 0x76, 0x1c, 0x55,
	0x0b, 0x61, 0x85, 0x0f, 0x7a, 0x3f, 0x30, 0xa6, 0x16, 0xee, 0x0d, 0x9f, 0x47, 0x44, 0x6f, 0xc0,
	0x12, 0x8e, 0x2b, 0xff, 0x92, 0xc6, 0x4c, 0xfa, 0x8c, 0x63, 0x69, 0x1f, 0x01, 0xdf, 0x5b, 0xea,
	0x24, 0xc7, 0xe7, 0x68, 0x50, 0xfb, 0x97, 0x85, 0x84, 0x05, 0x79, 0x94, 0x1f, 0x02, 0x24, 0x03,
	0x90, 0x1e, 0xe5, 0x7a, 0x0e, 0x9b, 0x04, 0x89, 0xa5, 0xf0, 0x53, 0x92, 0x2b, 0x9e, 0x5b, 0x72,
	0x74, 0x77, 0x02, 0xbb, 0x2f, 0xc5, 0xdd, 0xce, 0x69, 0x8e, 0x10, 0x98, 0xc0, 0xa3, 0x5b, 0x64,
	0x4f, 0x8d, 0x60, 0xfa, 0x6c, 0xd3, 0x64, 0x92, 0x50, 0x65, 0x57, 0xbb, 0x42, 0xb2, 0xda, 0x2d,
	0x6e, 0x47, 0x8b, 0x39, 0xdb, 0xd1, 0xd3, 0xd6, 0x3c, 0x6d, 0x02, 0x4d, 0xde, 0x88, 0x50, 0xa8,
	0x34, 0x45, 0xb1, 0xeb, 0x7e, 0x8e, 0x99, 0x38, 0x1b, 0x69, 0x32, 0x13, 0x7f, 0xbf, 0x48, 0x8f,
	0xd4, 0x82, 0x69, 0x12, 0x50, 0xa4, 0x35, 0xbf, 0xb8, 0x21, 0x4e, 0xf7, 0x28, 0x31, 0xb5, 0x5b,
	0xd0, 0x90, 0x2f, 0x07, 0x67, 0x01, 0x2d, 0x08, 0x50, 0xdf, 0x0f, 0xd1, 0x16, 0xd3, 0x41, 0x45,
	0x6e, 0xaf, 0x52, 0xdb, 0xd9, 0x77, 0xa0, 0x3c, 0xf5, 0x4c, 0x7e, 0x34, 0xb9, 0x70, 0xa3, 0x2e,
	0xdd, 0x59, 0x1d, 0xd1, 0x18, 0x21, 0x63, 0xf8, 0x19, 0xfa, 0xd6, 0x44, 0x3a, 0xe3, 0x50, 0xe4,
	0x18, 0x9a, 0x08, 0x64, 0x02, 0x86, 0xea, 0xe4, 0x93, 0xa2, 0x42, 0x95, 0xc2, 0xf6, 0xff, 0x45,
	0x41, 0xea, 0x73, 0xc1, 0x1f, 0x9d, 0x53, 0x02, 0x37, 0x00, 0x64, 0x97, 0x92, 0x93, 0x91, 0xba,
	0x80, 0xf4, 0x4d, 0x0c, 0xaa, 0x29, 0x7c, 0xb1, 0x4d, 0xa1, 0xe5, 0x0a, 0x16, 0xfb, 0xe6, 0x39,
	0x5e, 0x01, 0x51, 0x3a, 0x07, 0xe7, 0x93, 0xbc, 0x39, 0x4a, 0x05, 0xed, 0x91, 0x54, 0xdb, 0xd4,
	0x70, 0x8d, 0x03, 0x2b, 0x50, 0x2f, 0x43, 0xc5, 0xb1, 0x0c, 0x53, 0xbc, 0xfe, 0xaa, 0x31, 0x51,
	0x52, 0x35, 0x5c, 0xc3, 0x8c, 0xc9, 0xa1, 0xb1, 0x67, 0x3b, 0x76, 0x74, 0x2c, 0xfa, 0x96, 0x81,
	0x69, 0xff, 0x37, 0x19, 0x3f, 0xed, 0x66, 0x9e, 0x63, 0xfc, 0x2a, 0x94, 0x29, 0xd5, 0x27, 0x6c,
	0x91, 0xf2, 0x7c, 0x37, 0x00, 0x66, 0xa7, 0x1d, 0x72, 0x97, 0x97, 0x9c, 0x75, 0xa8, 0x6d, 0xa8,
	0x3e, 0xb1, 0x02, 0xfa, 0x92, 0x0f, 0x1f, 0xb5, 0x2c, 0x62, 0x97, 0x45, 0xc6, 0x82, 0x77, 0x99,
	0x0f, 0x3c, 0x03, 0x9b, 0x49, 0xa5, 0x92, 0x92, 0x8a, 0x7a, 0x1f, 0xaa, 0x42, 0x1e, 0xe2, 0x90,
	0xf8, 0x6a, 0x4e, 0xd7, 0x05, 0x06, 0x93, 0xa8, 0xda, 0x7f, 0x29, 0x40, 0x43, 0x98, 0x15, 0x71,
	0xf9, 0x7e, 0x2a, 0x58, 0xc8, 0xbb, 0xf0, 0x9a, 0x31, 0xc1, 0x54, 0xb8, 0xf0, 0x86, 0x0c, 0x83,
	0x4e, 0xb6, 0xf2, 0x74, 0x20, 0x94, 0x38, 0xe8, 0xf2, 0x89, 0xe8, 0x29, 0x07, 0x8d, 0x0a, 0xfe,
	0x2a, 0xf6, 0x02, 0x71, 0x3d, 0xb4, 0xc6, 0x44, 0x29, 0x6d, 0x5b, 0xd5, 0xb4, 0x6d, 0x69, 0x7f,
	0xbb, 0x00, 0x17, 0x33, 0x27, 0x04, 0x34, 0x3a, 0x3d, 0x52, 0xef, 0x27, 0xae, 0xb5, 0x70, 0xea,
	0xb1, 0x68, 0xd6, 0xb7, 0xa6, 0xf7, 0x0d, 0xe6, 0xfc, 0xbe, 0x81, 0x5b, 0xb2, 0xa8, 0x4e, 0xed,
	0x2b, 0x1b, 0x02, 0x86, 0x5b, 0x4b, 0xed, 0x1f, 0x36, 0x92, 0x63, 0x2a, 0xca, 0x41, 0xc9, 0x67,
	0x6b, 0xba, 0x1b, 0x8a, 0xa7, 0x6c, 0x8d, 0x04, 0xc6, 0x33, 0x42, 0x53, 0x63, 0x72, 0x68, 0xbb,
	0xa9, 0x55, 0xbe, 0x2e, 0x20, 0x7d, 0x93, 0x3e, 0xa7, 0x12, 0x87, 0x91, 0x37, 0xe5, 0x1d, 0xe2,
	0xed, 0x81, 0x04, 0xf5, 0x71, 0xa9, 0xa6, 0x3d, 0x36, 0xa5, 0x5f, 0xf9, 0x55, 0xbd, 0xec, 0x75,
	0x69, 0xac, 0x64, 0x09, 0x8a, 0xba, 0x09, 0xca, 0x5c, 0xbe, 0x53, 0x06, 0x6c, 0xd7, 0x17, 0xf2,
	0x9c, 0x29, 0x24, 0x46, 0x59, 0xd2, 0xf4, 0x4b, 0xc4, 0xdf, 0x82, 0xb5, 0xfc, 0x7c, 0xa4, 0x0c,
	0xe1, 0x5e, 0x5e, 0xe4, 0xb7, 0x80, 0xcb, 0x2e, 0x21, 0x7c, 0xc0, 0xc1, 0xfd, 0x84, 0x83, 0xc8,
	0x29, 0x1f, 0x04, 0xc6, 0x54, 0x1e, 0xc0, 0x2d, 0xe4, 0x94, 0xb1, 0x92, 0x25, 0x58, 0xb8, 0x12,
	0xd1, 0xf7, 0xb0, 0x6c, 0xf7, 0x40, 0x0f, 0x30, 0x4a, 0x16, 0x2f, 0xeb, 0x5a, 0x12, 0xca, 0x10,
	0xa8, 0xde, 0x01, 0x85, 0xf6, 0xfd, 0x5c, 0x80, 0x5c, 0x87, 0x0d, 0x92, 0xe9, 0x32, 0xc2, 0xbb,
	0x04, 0xa6, 0x13, 0x02, 0x99, 0x3e, 0xa3, 0x93, 0xbc, 0xe6, 0xec, 0x7e, 0xde, 0xd8, 0x38, 0x08,
	0xd5, 0x57, 0x60, 0xd9, 0x0e, 0x75, 0xaa, 0x3f, 0xb4, 0x4d, 0xd3, 0x72, 0x29, 0x73, 0x50, 0x63,
	0x4d, 0x3b, 0x7c, 0xe8, 0x85, 0xd1, 0x43, 0x82, 0xe1, 0x16, 0x8a, 0xd7, 0xa6, 0xd2, 0xe9, 0x2b,
	0xc4, 0x69, 0x85, 0xc3, 0x67, 0x0f, 0x8c, 0x53, 0x6e, 0x42, 0xc9, 0xba, 0x89, 0xd9, 0x39, 0xbd,
	0x7a, 0xbe, 0x73, 0xfa, 0x77, 0xa0, 0x1e, 0x79, 0x3e, 0x7d, 0x47, 0x20, 0x6c, 0xaf, 0xe6, 0x5c,
	0x44, 0x4d, 0x12, 0x9a, 0xac, 0x16, 0x79, 0xfe, 0xc7, 0x88, 0xf7, 0x5c, 0x57, 0x09, 0x6c, 0x97,
	0xbf, 0x54, 0x44, 0xbb, 0xbc, 0x24, 0xcf, 0x49, 0x38, 0xa8, 0x6f, 0xaa, 0xdf, 0x07, 0x48, 0xe6,
	0x98, 0x4c, 0x11, 0x5c, 0xce, 0x9f, 0x82, 0x2c, 0x85, 0x89, 0x74, 0x8f, 0xe3, 0x3d, 0x2b, 0x70,
	0xad, 0x48, 0x3c, 0x63, 0x9f, 0xa7, 0x4b, 0x76, 0x73, 0x2c, 0x85, 0xa9, 0xde, 0x85, 0x25, 0x8a,
	0x7c, 0xe8, 0x41, 0xfb, 0x09, 0x31, 0x11, 0x11, 0x71, 0x34, 0x0c, 0xa2, 0xc4, 0x09, 0xe2, 0xd5,
	0x9c, 0x20, 0xca, 0x38, 0xc0, 0xad, 0x68, 0xe6, 0xdc, 0x50, 0x7d, 0x17, 0xaa, 0xfb, 0x86, 0x33,
	0xf1, 0xf6, 0x1c, 0x7a, 0xe2, 0x3e, 0x1f, 0xac, 0x51, 0x9d, 0xbe, 0x67, 0x84, 0x96, 0x63, 0xbb,
	0x16, 0x93, 0xb8, 0x99, 0x24, 0xc5, 0xf5, 0x67, 0x49, 0x52, 0xe0, 0x90, 0xc8, 0x41, 0x8a, 0xcf,
	0xe9, 0xb4, 0xf3, 0xdc, 0x33, 0x1f, 0x12, 0x15, 0xd4, 0x37, 0x40, 0x9d, 0x78, 0xee, 0xbe, 0x7d,
	0x90, 0xba, 0xa5, 0x1e, 0xb6, 0x6f, 0xd2, 0xb5, 0xaf, 0x0b, 0xbc, 0x66, 0x67, 0x56, 0xa1, 0x76,
	0x41, 0x49, 0x8e, 0xba, 0xe4, 0xb9, 0xfa, 0xad, 0x33, 0x2e, 0xe3, 0xae, 0x48, 0x0a, 0x71, 0x3b,
	0x5d, 0xfd, 0x6d, 0xb8, 0x72, 0xe0, 0x78, 0x7b, 0x86, 0xa3, 0x2f, 0x3a, 0x61, 0x7a, 0x22, 0x3f,
	0x7f, 0xb8, 0x92, 0xe7, 0xab, 0xd9, 0x1a, 0xe7, 0x31, 0x4c, 0xd5, 0x8d, 0x68, 0x91, 0xda, 0x01,
	0x35, 0x87, 0xaf, 0x76, 0x5e, 0xbe, 0x17, 0xbc, 0x79, 0x8e, 0xda, 0x3f, 0x2b, 0x82, 0x6a, 0xc6,
	0x53, 0x5f, 0x0f, 0xac, 0xaf, 0x62, 0x2b, 0x8c, 0xf8, 0x9b, 0xfe, 0x6f, 0xc2, 0x53, 0xdf, 0x82,
	0x86, 0x19, 0x07, 0x7c, 0x07, 0x2f, 0x1e, 0x7a, 0x97, 0x19, 0x48, 0xd0, 0x80, 0x9c, 0xc0, 0xbe,
	0xed, 0x24, 0x49, 0xe9, 0x3a, 0x93, 0x45, 0x0a, 0xe8, 0xbc, 0xc7, 0x96, 0x4b, 0x57, 0x1d, 0xea,
	0x8c, 0x17, 0x70, 0x8f, 0x37, 0x35, 0x8e, 0xe8, 0x86, 0xaf, 0xb8, 0xe9, 0x55, 0x9d, 0x1a, 0x47,
	0x23, 0xfb, 0xa7, 0x16, 0x7d, 0xb0, 0xc0, 0x08, 0x23, 0x3d, 0xdd, 0x60, 0x4d, 0x3c, 0xca, 0x37,
	0xc2, 0x68, 0x63, 0xd6, 0xe8, 0x35, 0xa8, 0x13, 0x26, 0x71, 0xe1, 0x2f, 0x97, 0x6b, 0x08, 0x40,
	0x36, 0xda, 0xdf, 0x2a, 0xc0, 0x85, 0x39, 0x61, 0x79, 0xfe, 0x37, 0x21, 0xab, 0x64, 0xc0, 0xe5,
	0xd4, 0x80, 0xb5, 0x7f, 0x57, 0x84, 0x96, 0xe8, 0x4e, 0xe8, 0x7b, 0x6e, 0x68, 0x7d, 0x13, 0x5d,
	0x69, 0x43, 0x15, 0xdd, 0x93, 0xe5, 0xf2, 0x23, 0xb9, 0x26, 0x93, 0x45, 0xec, 0x24, 0x25, 0x83,
	0x65, 0xcc, 0x4a, 0x85, 0x93, 0x75, 0x35, 0x39, 0x8c, 0xdd, 0xc7, 0xba, 0xeb, 0x91, 0xae, 0x5a,
	0xac, 0x4a, 0xe5, 0x81, 0x87, 0x3d, 0xd8, 0xb7, 0x71, 0x12, 0x12, 0x80, 0xd4, 0x54, 0x63, 0x40,
	0xa0, 0x2e, 0x42, 0x70, 0x04, 0x8f, 0x2d, 0xcb, 0xd7, 0x0d, 0xc7, 0x7e, 0xc2, 0x75, 0x54, 0x63,
	0x75, 0x84, 0x74, 0x10, 0x80, 0xba, 0xe6, 0xf4, 0xa9, 0x5b, 0x35, 0x3c, 0xeb, 0xbe, 0x4c, 0xf0,
	0xe4, 0x86, 0xb7, 0xf6, 0x7b, 0x45, 0x50, 0xc2, 0xf0, 0x50, 0xe7, 0x57, 0x50, 0x0e, 0x0d, 0xd7,
	0xb5, 0x9c, 0x6f, 0x4d, 0x9b, 0x18, 0x4d, 0xd3, 0x37, 0x9e, 0x96, 0x78, 0x12, 0x85, 0x3e, 0xe4,
	0x84, 0x3b, 0x45, 0x23, 0x0c, 0x9f, 0x7a, 0x81, 0x29, 0x62, 0xde, 0xa4, 0x2c, 0xb7, 0xad, 0xd5,
	0x59, 0xf2, 0xea, 0x26, 0x00, 0xd6, 0xfa, 0x87, 0x81, 0x11, 0x5a, 0xe2, 0x4d, 0x7e, 0x0a, 0x92,
	0x6c, 0x59, 0xeb, 0xb3, 0x2d, 0xab, 0xf6, 0x9f, 0x0a, 0x50, 0x43, 0x19, 0xd0, 0xf7, 0x38, 0xbf,
	0xcd, 0xb1, 0xd3, 0x53, 0xa3, 0x25, 0xb2, 0x28, 0xfa, 0x3f, 0x33, 0xa7, 0x4a, 0xda, 0x9c, 0x6e,
	0x41, 0xc3, 0x3a, 0xb2, 0xe5, 0xbb, 0x6b, 0x1a, 0xfd, 0x12, 0x03, 0x04, 0xf1, 0xb7, 0xcf, 0x34,
	0x47, 0x71, 0x40, 0x13, 0xc7, 0x0b, 0xad, 0x6f, 0x5d, 0xab, 0xda, 0x11, 0xac, 0x1a, 0x71, 0xe4,
	0xc9, 0xd4, 0x9b, 0x70, 0x1c, 0xdf, 0x40, 0x7f, 0x50, 0x10, 0x97, 0x4c, 0x3b, 0x88, 0x8e, 0xf5,
	0xf0, 0x30, 0x8e, 0xe8, 0xce, 0x4d, 0x60, 0xf9, 0xde, 0x37, 0xe3, 0xdc, 0x15, 0x28, 0x39, 0xde,
	0x81, 0x10, 0x05, 0xfe, 0xd5, 0xde, 0x81, 0xfa, 0x63, 0xeb, 0x58, 0x4f, 0x9e, 0xbc, 0x9d, 0xeb,
	0xc8, 0xe5, 0x97, 0x05, 0x68, 0xa4, 0x62, 0x0f, 0xfa, 0x00, 0x4b, 0xd2, 0xf3, 0xd0, 0x9a, 0xd0,
	0x5e, 0xb5, 0xcc, 0x66, 0xc3, 0x19, 0x59, 0x13, 0xda, 0x25, 0x4e, 0x3c, 0x3f, 0xc9, 0xe1, 0x52,
	0x81, 0xd4, 0x63, 0x47, 0x8e, 0xdc, 0xa3, 0xf0, 0x82, 0x7a, 0x1b, 0x1a, 0xa6, 0x15, 0x4e, 0x02,
	0xdb, 0x8f, 0x66, 0x7b, 0xd2, 0x34, 0x08, 0xa7, 0x60, 0x68, 0x3d, 0xb1, 0x02, 0xb9, 0x27, 0x6d,
	0xb1, 0xa4, 0xac, 0xae, 0x8b, 0x6b, 0x01, 0x95, 0x9c, 0x70, 0x2e, 0x19, 0xac, 0x78, 0x70, 0xf5,
	0x21, 0x9d, 0x6b, 0x63, 0x34, 0x42, 0x9f, 0xca, 0xcb, 0x7b, 0xf1, 0x95, 0x72, 0xad, 0xbc, 0xeb,
	0xb2, 0xa8, 0x7d, 0x92, 0x10, 0xd3, 0xd4, 0xf8, 0x90, 0x0e, 0x10, 0x24, 0xaf, 0xfc, 0xaf, 0x1e,
	0xa4, 0x10, 0x98, 0x20, 0xa6, 0xd8, 0x56, 0xa3, 0x5b, 0xaf, 0x9e, 0xaf, 0xf3, 0xdb, 0x47, 0xf4,
	0xb2, 0x30, 0x3c, 0x90, 0x39, 0xf0, 0x69, 0x78, 0xa0, 0xdd, 0x86, 0xa6, 0x6f, 0xc4, 0xa1, 0x75,
	0x32, 0xc6, 0x3f, 0x2f, 0xd0, 0x17, 0xb4, 0xa2, 0x38, 0x48, 0x90, 0x5e, 0x85, 0x95, 0x3d, 0x6b,
	0xdf, 0x0b, 0x44, 0x76, 0x79, 0x66, 0x56, 0x2d, 0x0e, 0xee, 0x21, 0x74, 0x40, 0x5b, 0x05, 0x63,
	0x1f, 0xf7, 0x8b, 0x09, 0x1a, 0xff, 0x14, 0x47, 0x93, 0xa0, 0x12, 0xeb, 0x32, 0x54, 0xf8, 0x5a,
	0x2f, 0x4f, 0x4e, 0x78, 0x49, 0x7d, 0x17, 0xd6, 0xec, 0x90, 0x7f, 0x5a, 0xc9, 0x32, 0xf5, 0xc8,
	0xd3, 0x93, 0x48, 0x59, 0x5c, 0x59, 0xbf, 0x68, 0x87, 0x5b, 0xbc, 0x76, 0xec, 0x75, 0x65, 0x9d,
	0xf6, 0x67, 0x05, 0xa8, 0x18, 0xf2, 0x36, 0x6b, 0x3a, 0x59, 0x3f, 0x17, 0xe5, 0xf2, 0x3b, 0x5b,
	0xa9, 0x24, 0xfd, 0xf7, 0xa0, 0x8c, 0xb2, 0x12, 0xf7, 0xf2, 0xe7, 0xe3, 0xc0, 0x44, 0x88, 0x8c,
	0xb0, 0xd4, 0x37, 0x61, 0x89, 0x04, 0x97, 0xfb, 0xb9, 0xc4, 0xb4, 0x48, 0x19, 0xc7, 0xc3, 0x10,
	0x5a, 0x88, 0x51, 0xec, 0x55, 0xe7, 0xae, 0xf5, 0x65, 0x44, 0xcc, 0x24, 0xae, 0x76, 0x01, 0x56,
	0x64, 0x5c, 0x2d, 0xc2, 0x64, 0x6d, 0x05, 0x5a, 0x53, 0xc3, 0x8d, 0x0d, 0xf9, 0xb9, 0x0a, 0xed,
	0x43, 0xb8, 0xc0, 0x23, 0xf0, 0x20, 0x76, 0x2c, 0x5d, 0x88, 0x4f, 0x15, 0xf6, 0x5a, 0xe0, 0x9f,
	0xa4, 0xa1, 0xeb, 0x29, 0x39, 0x07, 0x8a, 0xda, 0x10, 0x9a, 0x9c, 0x98, 0x33, 0x53, 0x7f, 0x04,
	0x8d, 0x14, 0x1b, 0x71, 0x38, 0x7c, 0x33, 0x27, 0xdc, 0x4f, 0x61, 0x31, 0xc0, 0xc2, 0xc7, 0xf4,
	0x5f, 0x3b, 0x84, 0x15, 0x9a, 0x85, 0xba, 0x1f, 0x58, 0xa6, 0x3d, 0xc1, 0x50, 0x76, 0xd1, 0x05,
	0x5c, 0x86, 0x0a, 0x4d, 0x18, 0x79, 0x96, 0x28, 0x4a, 0xea, 0xeb, 0xf4, 0xf8, 0xbe, 0x44, 0x0a,
	0xbb, 0x36, 0xf7, 0xa6, 0x19, 0x79, 0x7a, 0xbe, 0x45, 0x01, 0x2d, 0x2b, 0x7a, 0xbe, 0xf6, 0xb3,
	0x32, 0x54, 0x7c, 0xcf, 0xb1, 0x27, 0xc7, 0xa9, 0x53, 0xfc, 0xf2, 0xdc, 0xd1, 0xe9, 0xec, 0x96,
	0xc2, 0xf7, 0x52, 0x17, 0x72, 0xe7, 0xcd, 0x81, 0xb3, 0x49, 0x9b, 0xc3, 0x26, 0x28, 0x73, 0x82,
	0x0f, 0x85, 0xe2, 0xb2, 0x7b, 0x98, 0x39, 0x24, 0x96, 0xa8, 0x6b, 0x43, 0x3c, 0xdd, 0xf8, 0x4d,
	0x68, 0xa5, 0x05, 0x1c, 0xe6, 0x7e, 0x05, 0x33, 0x8d, 0xc1, 0xb8, 0x42, 0x24, 0x7d, 0x07, 0x96,
	0x33, 0xea, 0x96, 0x17, 0x2f, 0xaf, 0xce, 0x9d, 0x97, 0xa7, 0x50, 0x98, 0x30, 0x10, 0xc9, 0xe2,
	0x0d, 0xa8, 0x1a, 0x99, 0x03, 0x8f, 0xd5, 0x9c, 0xb9, 0xc0, 0x24, 0x0e, 0xfa, 0x26, 0xcb, 0x35,
	0xf6, 0x1c, 0xcb, 0xa4, 0xeb, 0xda, 0x35, 0x26, 0x8b, 0xb8, 0x54, 0xd0, 0xce, 0x9f, 0xfb, 0xdc,
	0x3a, 0x55, 0xd2, 0x59, 0xc1, 0x88, 0xfc, 0xee, 0x6b, 0xe9, 0xab, 0x57, 0x1c, 0x07, 0x08, 0x67,
	0x76, 0x9d, 0x96, 0x23, 0x6e, 0x82, 0x32, 0x67, 0x23, 0xa1, 0xf8, 0x9e, 0xf2, 0xf5, 0x1c, 0xa5,
	0x27, 0x48, 0x8c, 0x5b, 0xd6, 0x4e, 0x42, 0xa4, 0xdd, 0x83, 0x8b, 0x33, 0x6b, 0x0c, 0x75, 0xe1,
	0x43, 0x43, 0xf4, 0xe4, 0xf2, 0xbf, 0x98, 0x01, 0x49, 0x59, 0xfb, 0x79, 0x01, 0x6a, 0xa4, 0x6f,
	0x9b, 0xae, 0x63, 0x35, 0x84, 0xee, 0x1d, 0x3b, 0x8c, 0x84, 0x77, 0x5d, 0xcd, 0xb1, 0x0d, 0x06,
	0xfc, 0x77, 0xcb, 0x0e, 0x23, 0xf5, 0x01, 0x34, 0x52, 0xcd, 0x0a, 0x97, 0xf1, 0xd2, 0x09, 0x93,
	0x64, 0xd6, 0x2d, 0x06, 0x04, 0x65, 0x08, 0xd4, 0xd6, 0xe0, 0x52, 0x62, 0x3b, 0xdc, 0x41, 0x8a,
	0xe9, 0x7c, 0x09, 0x56, 0x85, 0x36, 0x33, 0xe0, 0x8f, 0x40, 0xe5, 0x3c, 0xd3, 0x50, 0x3a, 0x97,
	0x8d, 0x9d, 0xe4, 0x3a, 0x0e, 0xfe, 0xc7, 0xc9, 0xe5, 0xc5, 0x91, 0x2f, 0x3e, 0x7f, 0x5c, 0x67,
	0xa2, 0xa4, 0xfd, 0xa2, 0x00, 0x2d, 0xe1, 0xf7, 0x02, 0x2b, 0x8c, 0x9d, 0xe8, 0x19, 0x3d, 0xe4,
	0x4d, 0x80, 0x30, 0x9e, 0x4c, 0xac, 0x30, 0xdc, 0x8f, 0x1d, 0xe2, 0x5d, 0x63, 0x29, 0x88, 0xb8,
	0xc2, 0x8d, 0xeb, 0x87, 0xf0, 0xe4, 0xbc, 0x94, 0x8e, 0x96, 0x0a, 0xb3, 0x68, 0xe9, 0x3f, 0x94,
	0xa0, 0x29, 0x44, 0xcf, 0x17, 0xfc, 0x73, 0x84, 0x2a, 0xb8, 0x63, 0xe3, 0x24, 0x22, 0x52, 0xc1,
	0x1d, 0x1b, 0x01, 0x72, 0x8e, 0xda, 0x4b, 0x8b, 0x47, 0xed, 0xdb, 0x27, 0x4e, 0x6a, 0x2d, 0x7f,
	0x52, 0xa7, 0x65, 0xbd, 0x38, 0xb5, 0x37, 0xf2, 0xa7, 0xf6, 0xad, 0x1c, 0x43, 0xc8, 0x30, 0xca,
	0x4e, 0xf0, 0xcd, 0x13, 0x26, 0xf8, 0xed, 0xbc, 0x09, 0x9e, 0xe1, 0x33, 0x37, 0xcd, 0x3b, 0xb0,
	0x9c, 0x51, 0xaf, 0x9c, 0xed, 0x57, 0xf3, 0xf4, 0xca, 0x51, 0x98, 0x30, 0x08, 0xc6, 0x09, 0xd4,
	0xb7, 0xe0, 0x62, 0x68, 0xbb, 0xa1, 0xb8, 0xc3, 0x16, 0xea, 0x66, 0xe0, 0xf9, 0xbe, 0x65, 0x8a,
	0x9d, 0x99, 0x4a, 0x75, 0xb4, 0x70, 0x87, 0x1b, 0xbc, 0x46, 0xfb, 0xfd, 0x02, 0xb4, 0xd2, 0x6a,
	0x9c, 0x8f, 0x27, 0x0b, 0x67, 0xc4, 0x93, 0xc5, 0x85, 0x78, 0xf2, 0xed, 0xe4, 0x78, 0xaa, 0x94,
	0x93, 0x83, 0x4d, 0xb7, 0x95, 0xdc, 0x6b, 0xfb, 0xa3, 0x02, 0x5c, 0x8e, 0x0e, 0x03, 0x2f, 0x8a,
	0x1c, 0xca, 0xc6, 0x7d, 0xb3, 0x56, 0x95, 0x7c, 0x9e, 0x81, 0x3f, 0xe8, 0xe0, 0x05, 0xed, 0xef,
	0x15, 0x60, 0x2d, 0xbf, 0x4f, 0x2f, 0x2e, 0xa2, 0x0f, 0xe7, 0x44, 0x94, 0x3d, 0x70, 0xce, 0x6f,
	0x35, 0x11, 0xd6, 0xef, 0x40, 0x8b, 0x7f, 0xb2, 0x75, 0x6a, 0x85, 0xa1, 0x71, 0xc0, 0x3f, 0x86,
	0xc1, 0xbd, 0x40, 0xe1, 0xce, 0xf2, 0xdc, 0xf9, 0x27, 0xc7, 0x4c, 0x39, 0x81, 0xb9, 0x28, 0xba,
	0xb8, 0x10, 0x45, 0x6b, 0x7d, 0x19, 0x8e, 0x84, 0xf1, 0x9e, 0xb8, 0x84, 0x7e, 0x9c, 0x7b, 0x6d,
	0xb0, 0x09, 0x05, 0x53, 0xac, 0xff, 0x05, 0x5a, 0xb2, 0xf7, 0x63, 0xc7, 0x11, 0x8f, 0x19, 0xe9,
	0xbf, 0xf6, 0x39, 0x5c, 0x5b, 0x60, 0x35, 0x8b, 0x03, 0xd5, 0xf7, 0xa0, 0xca, 0x2b, 0xf2, 0xbf,
	0xf6, 0xb4, 0x40, 0xca, 0x24, 0xba, 0xf6, 0xab, 0x02, 0x2c, 0xf3, 0xea, 0x53, 0x7b, 0xf8, 0x29,
	0xac, 0xd0, 0x19, 0x59, 0xec, 0xeb, 0xb2, 0x21, 0x9e, 0x2f, 0xba, 0x73, 0x7a, 0x43, 0xb3, 0x3e,
	0xb2, 0x65, 0xc1, 0x60, 0xc4, 0xe9, 0x91, 0x65, 0x60, 0x1d, 0xc4, 0x8e, 0x11, 0x24, 0x2c, 0x4b,
	0xcf, 0xca, 0x52, 0x30, 0x10, 0x2c, 0xb5, 0x7f, 0x55, 0x00, 0xbe, 0xb0, 0xe8, 0x7e, 0xe0, 0x1d,
	0xbc, 0xc0, 0x27, 0x0b, 0xd7, 0x80, 0xde, 0xe5, 0xf2, 0x3c, 0x25, 0xbd, 0xdd, 0xc1, 0x62, 0xce,
	0x24, 0x58, 0x5a, 0x9c, 0x04, 0x6f, 0x42, 0x99, 0x06, 0x53, 0xc9, 0x49, 0xe6, 0x67, 0x25, 0xcd,
	0x08, 0x51, 0xf3, 0x60, 0x45, 0xc0, 0x4f, 0x7c, 0x07, 0x93, 0x17, 0xc5, 0xdd, 0x00, 0xe0, 0x77,
	0xe2, 0x53, 0x49, 0xa8, 0x3a, 0x41, 0x06, 0xe2, 0xf3, 0x01, 0xc9, 0x95, 0xf9, 0x72, 0xe6, 0xca,
	0xbc, 0xf6, 0xbb, 0x52, 0xe5, 0xd2, 0x8d, 0x53, 0xd6, 0x3a, 0xf0, 0x0e, 0xa4, 0xf5, 0xac, 0xe5,
	0x74, 0x1a, 0xeb, 0x19, 0xc7, 0x52, 0x7f, 0x98, 0x39, 0xd7, 0x2f, 0xe6, 0xc4, 0x2b, 0x73, 0x03,
	0x4a, 0x9f, 0xee, 0xaf, 0xff, 0xf7, 0x02, 0xa8, 0x8b, 0x5f, 0x42, 0x53, 0x9b, 0x50, 0x1b, 0x0d,
	0x77, 0xf4, 0xc1, 0x70, 0xd0, 0x53, 0x7e, 0x43, 0x5d, 0x06, 0xc0, 0xd2, 0xa8, 0xb7, 0xd5, 0xeb,
	0x8e, 0x95, 0x82, 0x2c, 0xf7, 0x07, 0xa3, 0x1e, 0x1b, 0x2b, 0x45, 0xb5, 0x01, 0x55, 0x5e, 0x3f,
	0x56, 0x4a, 0xb2, 0xb2, 0xcb, 0x7a, 0x9d, 0x71, 0x4f, 0x29, 0xcb, 0xf2, 0x46, 0x6f, 0xab, 0x37,
	0xee, 0x29, 0x4b, 0x92, 0xf5, 0x06, 0x1b, 0xee, 0x28, 0x15, 0x75, 0x05, 0x1a, 0x58, 0x62, 0xbd,
	0x9d, 0xad, 0x4e, 0xb7, 0xa7, 0x54, 0x25, 0xfa, 0xee, 0xce, 0x06, 0x92, 0xd7, 0x24, 0xef, 0xdd,
	0x51, 0x4f, 0xa9, 0x4b, 0xda, 0xd1, 0xc3, 0xe1, 0xe7, 0x0a, 0xc8, 0xd2, 0xd6, 0xb0, 0xfb, 0x48,
	0x69, 0x24, 0x84, 0x03, 0x2a, 0x37, 0xd5, 0x16, 0xd4, 0xb1, 0xdc, 0xd9, 0x1a, 0xf7, 0x98, 0xd2,
	0x5a, 0xff, 0x9b, 0x25, 0x58, 0x99, 0xfb, 0xbc, 0x94, 0xba, 0x0a, 0x2b, 0xdb, 0xc3, 0xc1, 0xe6,
	0x70, 0xe3, 0x81, 0x3e, 0x1b, 0xec, 0x25, 0xb8, 0x90, 0x02, 0x8a, 0x31, 0x16, 0xe6, 0xc0, 0xa2,
	0x7b, 0xc5, 0x39, 0xb0, 0x18, 0x64, 0x49, 0x5d, 0x83, 0xd5, 0x14, 0x78, 0xb3, 0x37, 0xd6, 0xb7,
	0x87, 0x0c, 0xa5, 0x71, 0x0d, 0xd6, 0x52, 0x15, 0x8f, 0xfa, 0x5b, 0x5b, 0x7a, 0x77, 0x97, 0x8d,
	0x86, 0x6c, 0xa4, 0x2c, 0xcd, 0xf5, 0xe7, 0xe3, 0xfe, 0x60, 0x43, 0xa9, 0xa8, 0x6d, 0xb8, 0x98,
	0x02, 0x76, 0x36, 0x37, 0x59, 0x6f, 0x13, 0xdb, 0xae, 0xaa, 0x97, 0x41, 0x4d, 0xd5, 0x74, 0x87,
	0xdb, 0xdb, 0x9d, 0xc1, 0x86, 0x52, 0x53, 0x2f, 0x82, 0x92, 0x81, 0xef, 0x0e, 0xc6, 0x4a, 0x7d,
	0xae, 0x4b, 0x1b, 0xfd, 0xd1, 0xb8, 0x3f, 0xe8, 0x8e, 0x15, 0x50, 0xaf, 0xc0, 0xa5, 0x54, 0xc5,
	0x76, 0x07, 0xb5, 0xb1, 0xb1, 0xdb, 0xed, 0x29, 0x8d, 0x85, 0x61, 0x0c, 0xf5, 0x41, 0xaf, 0xc3,
	0x94, 0xe6, 0x1c, 0x0d, 0x56, 0x8c, 0x7a, 0x1d, 0xd6, 0x7d, 0xa8, 0xb4, 0xd4, 0x9b, 0x70, 0x75,
	0x6e, 0x10, 0x7a, 0x67, 0xb0, 0xa1, 0x6f, 0x0f, 0x37, 0xfa, 0x1f, 0x7f, 0xa1, 0x2c, 0xaf, 0x6f,
	0xf2, 0x4f, 0x49, 0xa1, 0x7e, 0x76, 0x07, 0xfd, 0xb1, 0x14, 0xfb, 0x0a, 0x34, 0xa8, 0x38, 0xea,
	0x75, 0x87, 0x83, 0x0d, 0xa5, 0x90, 0xd4, 0x3f, 0xf8, 0x82, 0x04, 0xad, 0x40, 0x93, 0x8a, 0x3b,
	0x3d, 0xd6, 0xed, 0x0d, 0xc6, 0x4a, 0x69, 0xfd, 0x8f, 0x8a, 0xe2, 0x6b, 0x53, 0xa4, 0xfa, 0x6e,
	0x67, 0xab, 0x97, 0xe2, 0xc5, 0xcb, 0xdb, 0xfd, 0xad, 0xad, 0xbe, 0x52, 0x48, 0x03, 0xba, 0x6c,
	0xa8, 0x14, 0x53, 0x14, 0x9d, 0xc1, 0x50, 0x29, 0x21, 0x77, 0x89, 0x30, 0xd8, 0x4d, 0xcc, 0x96,
	0x20, 0x0f, 0x87, 0xbb, 0x4c, 0x59, 0x22, 0x73, 0xa2, 0xf2, 0x46, 0xe7, 0x0b, 0xa5, 0x32, 0xab,
	0x7e, 0xd4, 0xdf, 0x1a, 0x0a, 0xb3, 0xe5, 0x0c, 0x7a, 0x9b, 0x1d, 0xa5, 0x36, 0x2b, 0x6f, 0xf6,
	0x37, 0x3b, 0x4a, 0x7d, 0x56, 0x1e, 0xf7, 0x58, 0x47, 0x81, 0x34, 0xfd, 0x83, 0xbe, 0xb0, 0x5e,
	0x41, 0xff, 0xa0, 0xaf, 0x34, 0xd3, 0xf4, 0x0f, 0xfa, 0x4a, 0x2b, 0x4d, 0xff, 0xa0, 0xaf, 0x2c,
	0xa3, 0xdd, 0xf1, 0xb2, 0x90, 0x87, 0xfe, 0x96, 0xfe, 0xb6, 0xb2, 0xb2, 0xde, 0x87, 0x95, 0xb9,
	0x0f, 0x78, 0xa1, 0xc5, 0x7d, 0xb2, 0xfd, 0x63, 0x7d, 0xbb, 0x37, 0x66, 0xfd, 0xae, 0x3e, 0xfe,
	0x62, 0xa7, 0xc7, 0x4d, 0xa2, 0xc7, 0x94, 0x02, 0xea, 0x71, 0xbe, 0x72, 0xb3, 0xb3, 0xbb, 0xd9,
	0x53, 0x8a, 0xeb, 0xbf, 0x03, 0xea, 0xe2, 0x67, 0xa4, 0x48, 0x50, 0xe3, 0xce, 0x78, 0xb4, 0x21,
	0xec, 0xaa, 0x80, 0xd6, 0x26, 0x20, 0x0f, 0xfb, 0xa3, 0xf1, 0x70, 0x93, 0x75, 0xb6, 0xb9, 0xba,
	0x04, 0x94, 0xf3, 0xe3, 0x7e, 0x81, 0x43, 0xd0, 0x4f, 0x94, 0xd7, 0x3f, 0xe6, 0x1f, 0x47, 0x4e,
	0x33, 0xbf, 0x02, 0x97, 0x3a, 0x3b, 0x3b, 0x39, 0xbd, 0x29, 0xe0, 0x2c, 0x98, 0xaf, 0x62, 0x34,
	0x03, 0xd7, 0x7f, 0xaf, 0x90, 0xfa, 0xca, 0xb2, 0x38, 0xdd, 0xbb, 0x0c, 0x2a, 0x62, 0x77, 0x1f,
	0xf6, 0xba, 0x8f, 0xf4, 0xcf, 0x3a, 0x5b, 0xbb, 0x3d, 0x7d, 0xf8, 0x48, 0xf9, 0x0d, 0x94, 0xc5,
	0x3c, 0xfc, 0xf3, 0x0e, 0x1b, 0xf4, 0x07, 0x9b, 0x4a, 0x41, 0xbd, 0x0e, 0xed, 0xf9, 0xca, 0x2e,
	0xeb, 0x8f, 0xfb, 0xdd, 0xce, 0x96, 0x52, 0xcc, 0x23, 0xdd, 0x1d, 0x3c, 0x1a, 0x0c, 0x3f, 0x1f,
	0x28, 0xa5, 0xf5, 0x7f, 0x5a, 0x80, 0x86, 0xc8, 0xa5, 0xd3, 0x1d, 0x94, 0x1a, 0x94, 0x85, 0x29,
	0xb6, 0xe1, 0x62, 0x7f, 0x84, 0x2e, 0xaa, 0xb3, 0xa5, 0xf7, 0x77, 0x3e, 0xbb, 0xaf, 0x8f, 0x7a,
	0xec, 0x33, 0x29, 0xfa, 0xfe, 0x48, 0x67, 0xbd, 0xed, 0xe1, 0xb8, 0x97, 0xa9, 0x2a, 0xaa, 0x2a,
	0x2c, 0xf7, 0x47, 0xfa, 0xee, 0xa0, 0xff, 0x63, 0x09, 0x2b, 0x2f, 0x32, 0xea, 0x6e, 0xf5, 0x71,
	0x1e, 0xd4, 0x72, 0x18, 0x89, 0x2a, 0x25, 0xcd, 0x48, 0xc0, 0x6e, 0xaf, 0xff, 0x69, 0x91, 0x2e,
	0x5b, 0xd2, 0xf7, 0xc6, 0x49, 0xea, 0x0d, 0xa8, 0x72, 0xb1, 0x8e, 0x94, 0x02, 0x4a, 0x6e, 0x63,
	0x77, 0x1b, 0x5d, 0xc0, 0xa7, 0xbb, 0xbd, 0xd1, 0x58, 0x1f, 0x8d, 0x3b, 0xe4, 0xe2, 0x2f, 0xc1,
	0x85, 0x39, 0xf8, 0x70, 0x47, 0x29, 0xab, 0x17, 0xa0, 0x25, 0xc0, 0xa3, 0x9d, 0xe1, 0x60, 0x84,
	0x7a, 0x46, 0x7b, 0x18, 0x3d, 0xd4, 0x87, 0x3b, 0xbd, 0x81, 0xde, 0x7d, 0xd8, 0x19, 0x0c, 0x7a,
	0x5b, 0x4a, 0x85, 0xec, 0x75, 0xf4, 0x50, 0xef, 0x6e, 0x0d, 0x47, 0xbd, 0x04, 0x5c, 0x25, 0x17,
	0x3e, 0x7a, 0xa8, 0x6f, 0x74, 0xc6, 0x38, 0x69, 0xd6, 0x60, 0xb5, 0xb3, 0x3b, 0x1e, 0x0a, 0xef,
	0x2a, 0xdb, 0x52, 0xea, 0x38, 0xc4, 0x8d, 0x3e, 0x1b, 0x7f, 0xa1, 0x8f, 0x1e, 0xee, 0x8e, 0x37,
	0x86, 0x9f, 0x0f, 0x70, 0xc1, 0x18, 0x32, 0xf4, 0x5e, 0x2b, 0xd0, 0xe8, 0x0e, 0x07, 0x1f, 0xf7,
	0x37, 0x39, 0x93, 0x06, 0x76, 0xa9, 0xc7, 0xd8, 0x90, 0xe9, 0xdb, 0xbd, 0xd1, 0xa8, 0xb3, 0xd9,
	0x53, 0x9a, 0xd8, 0xca, 0xce, 0x70, 0xab, 0xdf, 0xed, 0xf7, 0x46, 0x4a, 0x0b, 0x11, 0xa8, 0xf4,
	0x85, 0xde, 0xfb, 0xac, 0x37, 0x18, 0x8f, 0x94, 0x65, 0x54, 0xee, 0xf8, 0x21, 0x1b, 0x8e, 0xc7,
	0x5b, 0xbd, 0x0d, 0x3d, 0x5b, 0xb9, 0x82, 0xbd, 0x1a, 0xb2, 0xee, 0xc3, 0xde, 0x68, 0xcc, 0x3a,
	0xe3, 0x21, 0x93, 0x15, 0xca, 0xfa, 0x27, 0xe9, 0x07, 0xb9, 0x24, 0x4a, 0x80, 0xca, 0xc6, 0xb0,
	0xfb, 0x88, 0xf4, 0x5b, 0x85, 0xd2, 0xd6, 0x8f, 0xbb, 0x4a, 0x11, 0x7b, 0xb8, 0xd5, 0x7f, 0xf0,
	0x59, 0x9f, 0x8d, 0x75, 0x04, 0x94, 0xd4, 0x3a, 0x2c, 0x6d, 0xf7, 0x46, 0xc3, 0x91, 0x52, 0x46,
	0x24, 0xf6, 0x68, 0xac, 0x2c, 0xad, 0x7f, 0x00, 0xab, 0x39, 0x2f, 0x75, 0x10, 0xb5, 0xb3, 0xb1,
	0xd1, 0x43, 0x7f, 0xd8, 0x80, 0x2a, 0xea, 0xf8, 0xb3, 0xde, 0x06, 0x5f, 0x71, 0xb9, 0x90, 0x36,
	0x94, 0xd2, 0xfa, 0x5b, 0xa0, 0x2e, 0x5e, 0x4f, 0xc3, 0xf9, 0x86, 0xab, 0x6a, 0xbf, 0x4b, 0x58,
	0x05, 0xec, 0xdb, 0xe6, 0xd6, 0xf0, 0x01, 0x1a, 0xf3, 0xfa, 0x06, 0x34, 0x52, 0x1b, 0x69, 0xec,
	0x61, 0xa7, 0x3b, 0xee, 0x0f, 0x07, 0x5c, 0xad, 0x05, 0x9c, 0xbd, 0x02, 0xb0, 0xd3, 0xc1, 0x95,
	0x97, 0x4c, 0x52, 0x40, 0xba, 0x9d, 0x9d, 0xf1, 0x2e, 0xeb, 0x29, 0xa5, 0xf5, 0xcd, 0xe4, 0x94,
	0x42, 0xae, 0xa6, 0x42, 0x74, 0x0f, 0x3a, 0xa3, 0xde, 0x56, 0x7f, 0xd0, 0xe3, 0x9c, 0x04, 0xf0,
	0xe3, 0xce, 0x56, 0x17, 0x5d, 0xef, 0x4c, 0xfc, 0xdb, 0x9d, 0xc1, 0x6e, 0x67, 0x4b, 0x29, 0xad,
	0x7f, 0x05, 0xcb, 0xd9, 0x83, 0x34, 0xb5, 0x02, 0xc5, 0xde, 0xa7, 0xbc, 0xd3, 0x83, 0xe1, 0x58,
	0xef, 0x7d, 0xaa, 0x14, 0xf1, 0x7f, 0x7f, 0x30, 0x0b, 0x32, 0x10, 0x2e, 0xca, 0x65, 0xd4, 0x70,
	0x77, 0x38, 0x18, 0x77, 0xfa, 0x03, 0x5c, 0x47, 0x15, 0x68, 0x62, 0x6d, 0x02, 0xe1, 0x61, 0x06,
	0x5a, 0xf2, 0x48, 0xff, 0xbc, 0x3f, 0x7e, 0xa8, 0x54, 0xd7, 0x7f, 0x5e, 0x00, 0x98, 0xed, 0x22,
	0x70, 0x78, 0x3d, 0xc6, 0x90, 0x62, 0xa0, 0x6f, 0xf5, 0xb7, 0xfb, 0x63, 0xee, 0x0f, 0x10, 0xd6,
	0x1f, 0x7c, 0xd6, 0xd9, 0xea, 0x6f, 0xe8, 0xdd, 0xdd, 0xd1, 0x78, 0xb8, 0xdd, 0x63, 0xfa, 0xa3,
	0xde, 0x17, 0x4a, 0x11, 0xad, 0x02, 0x6b, 0x37, 0x76, 0x85, 0x88, 0xf5, 0xce, 0x26, 0x2d, 0x4b,
	0x28, 0x06, 0xac, 0xe0, 0x13, 0x57, 0x7f, 0xb0, 0x3b, 0xfa, 0x42, 0x29, 0xe3, 0xb4, 0x42, 0xe0,
	0x0e, 0x1b, 0x8e, 0x87, 0xfa, 0x76, 0x7f, 0xb4, 0xdd, 0x19, 0x77, 0x1f, 0x2a, 0x4b, 0x0f, 0xee,
	0xff, 0xf2, 0xd7, 0x37, 0x0b, 0xff, 0xf9, 0xd7, 0x37, 0x0b, 0xff, 0xf5, 0xd7, 0x37, 0x0b, 0x7f,
	0xfc, 0xdf, 0x6e, 0xfe, 0x06, 0x5c, 0x99, 0x78, 0x53, 0x11, 0xbd, 0xdd, 0x45, 0x3d, 0x3a, 0xfc,
	0xb2, 0xc7, 0x5e, 0xbc, 0xff, 0x60, 0xa9, 0x73, 0x60, 0xb9, 0xd1, 0xc3, 0xc2, 0xff, 0x0b, 0x00,
	0x00, 0xff, 0xff, 0xa6, 0xf8, 0x3e, 0xc4, 0xed, 0x6e, 0x00, 0x00,
}
