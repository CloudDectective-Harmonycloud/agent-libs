// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: draios.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "draios.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace draiosproto {

void protobuf_ShutdownFile_draios_2eproto() {
  delete counter::default_instance_;
  delete time_categories::default_instance_;
  delete transaction_categories::default_instance_;
  delete connection_categories::default_instance_;
  delete process::default_instance_;
  delete thread::default_instance_;
  delete ipv4tuple::default_instance_;
  delete ipv4_connection::default_instance_;
  delete ipv4_network_interface::default_instance_;
  delete metrics::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_draios_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_draios_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  counter::default_instance_ = new counter();
  time_categories::default_instance_ = new time_categories();
  transaction_categories::default_instance_ = new transaction_categories();
  connection_categories::default_instance_ = new connection_categories();
  process::default_instance_ = new process();
  thread::default_instance_ = new thread();
  ipv4tuple::default_instance_ = new ipv4tuple();
  ipv4_connection::default_instance_ = new ipv4_connection();
  ipv4_network_interface::default_instance_ = new ipv4_network_interface();
  metrics::default_instance_ = new metrics();
  counter::default_instance_->InitAsDefaultInstance();
  time_categories::default_instance_->InitAsDefaultInstance();
  transaction_categories::default_instance_->InitAsDefaultInstance();
  connection_categories::default_instance_->InitAsDefaultInstance();
  process::default_instance_->InitAsDefaultInstance();
  thread::default_instance_->InitAsDefaultInstance();
  ipv4tuple::default_instance_->InitAsDefaultInstance();
  ipv4_connection::default_instance_->InitAsDefaultInstance();
  ipv4_network_interface::default_instance_->InitAsDefaultInstance();
  metrics::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_draios_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_draios_2eproto_once_);
void protobuf_AddDesc_draios_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_draios_2eproto_once_,
                 &protobuf_AddDesc_draios_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_draios_2eproto {
  StaticDescriptorInitializer_draios_2eproto() {
    protobuf_AddDesc_draios_2eproto();
  }
} static_descriptor_initializer_draios_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int counter::kTimeNsFieldNumber;
const int counter::kCountFieldNumber;
const int counter::kBytesFieldNumber;
#endif  // !_MSC_VER

counter::counter()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void counter::InitAsDefaultInstance() {
}

counter::counter(const counter& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void counter::SharedCtor() {
  _cached_size_ = 0;
  time_ns_ = GOOGLE_ULONGLONG(0);
  count_ = 0u;
  bytes_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

counter::~counter() {
  SharedDtor();
}

void counter::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void counter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const counter& counter::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_draios_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_draios_2eproto();
#endif
  return *default_instance_;
}

counter* counter::default_instance_ = NULL;

counter* counter::New() const {
  return new counter;
}

void counter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    time_ns_ = GOOGLE_ULONGLONG(0);
    count_ = 0u;
    bytes_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool counter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 time_ns = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &time_ns_)));
          set_has_time_ns();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_count;
        break;
      }

      // optional uint32 count = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_bytes;
        break;
      }

      // optional uint32 bytes = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bytes_)));
          set_has_bytes();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void counter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 time_ns = 1;
  if (has_time_ns()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->time_ns(), output);
  }

  // optional uint32 count = 2;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->count(), output);
  }

  // optional uint32 bytes = 3;
  if (has_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->bytes(), output);
  }

}

int counter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 time_ns = 1;
    if (has_time_ns()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->time_ns());
    }

    // optional uint32 count = 2;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

    // optional uint32 bytes = 3;
    if (has_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bytes());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void counter::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const counter*>(&from));
}

void counter::MergeFrom(const counter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time_ns()) {
      set_time_ns(from.time_ns());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
    if (from.has_bytes()) {
      set_bytes(from.bytes());
    }
  }
}

void counter::CopyFrom(const counter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool counter::IsInitialized() const {

  return true;
}

void counter::Swap(counter* other) {
  if (other != this) {
    std::swap(time_ns_, other->time_ns_);
    std::swap(count_, other->count_);
    std::swap(bytes_, other->bytes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string counter::GetTypeName() const {
  return "draiosproto.counter";
}


// ===================================================================

#ifndef _MSC_VER
const int time_categories::kUnknownFieldNumber;
const int time_categories::kOtherFieldNumber;
const int time_categories::kFileFieldNumber;
const int time_categories::kNetFieldNumber;
const int time_categories::kIpcFieldNumber;
const int time_categories::kMemoryFieldNumber;
const int time_categories::kProcessFieldNumber;
const int time_categories::kSleepFieldNumber;
const int time_categories::kSystemFieldNumber;
const int time_categories::kSignalFieldNumber;
const int time_categories::kUserFieldNumber;
const int time_categories::kTimeFieldNumber;
const int time_categories::kIoFileFieldNumber;
const int time_categories::kIoNetFieldNumber;
const int time_categories::kIoOtherFieldNumber;
const int time_categories::kWaitFieldNumber;
const int time_categories::kProcessingFieldNumber;
#endif  // !_MSC_VER

time_categories::time_categories()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void time_categories::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  unknown_ = const_cast< ::draiosproto::counter*>(
      ::draiosproto::counter::internal_default_instance());
#else
  unknown_ = const_cast< ::draiosproto::counter*>(&::draiosproto::counter::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  other_ = const_cast< ::draiosproto::counter*>(
      ::draiosproto::counter::internal_default_instance());
#else
  other_ = const_cast< ::draiosproto::counter*>(&::draiosproto::counter::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  file_ = const_cast< ::draiosproto::counter*>(
      ::draiosproto::counter::internal_default_instance());
#else
  file_ = const_cast< ::draiosproto::counter*>(&::draiosproto::counter::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  net_ = const_cast< ::draiosproto::counter*>(
      ::draiosproto::counter::internal_default_instance());
#else
  net_ = const_cast< ::draiosproto::counter*>(&::draiosproto::counter::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  ipc_ = const_cast< ::draiosproto::counter*>(
      ::draiosproto::counter::internal_default_instance());
#else
  ipc_ = const_cast< ::draiosproto::counter*>(&::draiosproto::counter::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  memory_ = const_cast< ::draiosproto::counter*>(
      ::draiosproto::counter::internal_default_instance());
#else
  memory_ = const_cast< ::draiosproto::counter*>(&::draiosproto::counter::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  process_ = const_cast< ::draiosproto::counter*>(
      ::draiosproto::counter::internal_default_instance());
#else
  process_ = const_cast< ::draiosproto::counter*>(&::draiosproto::counter::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  sleep_ = const_cast< ::draiosproto::counter*>(
      ::draiosproto::counter::internal_default_instance());
#else
  sleep_ = const_cast< ::draiosproto::counter*>(&::draiosproto::counter::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  system_ = const_cast< ::draiosproto::counter*>(
      ::draiosproto::counter::internal_default_instance());
#else
  system_ = const_cast< ::draiosproto::counter*>(&::draiosproto::counter::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  signal_ = const_cast< ::draiosproto::counter*>(
      ::draiosproto::counter::internal_default_instance());
#else
  signal_ = const_cast< ::draiosproto::counter*>(&::draiosproto::counter::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_ = const_cast< ::draiosproto::counter*>(
      ::draiosproto::counter::internal_default_instance());
#else
  user_ = const_cast< ::draiosproto::counter*>(&::draiosproto::counter::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  time_ = const_cast< ::draiosproto::counter*>(
      ::draiosproto::counter::internal_default_instance());
#else
  time_ = const_cast< ::draiosproto::counter*>(&::draiosproto::counter::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  io_file_ = const_cast< ::draiosproto::counter*>(
      ::draiosproto::counter::internal_default_instance());
#else
  io_file_ = const_cast< ::draiosproto::counter*>(&::draiosproto::counter::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  io_net_ = const_cast< ::draiosproto::counter*>(
      ::draiosproto::counter::internal_default_instance());
#else
  io_net_ = const_cast< ::draiosproto::counter*>(&::draiosproto::counter::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  io_other_ = const_cast< ::draiosproto::counter*>(
      ::draiosproto::counter::internal_default_instance());
#else
  io_other_ = const_cast< ::draiosproto::counter*>(&::draiosproto::counter::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  wait_ = const_cast< ::draiosproto::counter*>(
      ::draiosproto::counter::internal_default_instance());
#else
  wait_ = const_cast< ::draiosproto::counter*>(&::draiosproto::counter::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  processing_ = const_cast< ::draiosproto::counter*>(
      ::draiosproto::counter::internal_default_instance());
#else
  processing_ = const_cast< ::draiosproto::counter*>(&::draiosproto::counter::default_instance());
#endif
}

time_categories::time_categories(const time_categories& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void time_categories::SharedCtor() {
  _cached_size_ = 0;
  unknown_ = NULL;
  other_ = NULL;
  file_ = NULL;
  net_ = NULL;
  ipc_ = NULL;
  memory_ = NULL;
  process_ = NULL;
  sleep_ = NULL;
  system_ = NULL;
  signal_ = NULL;
  user_ = NULL;
  time_ = NULL;
  io_file_ = NULL;
  io_net_ = NULL;
  io_other_ = NULL;
  wait_ = NULL;
  processing_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

time_categories::~time_categories() {
  SharedDtor();
}

void time_categories::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete unknown_;
    delete other_;
    delete file_;
    delete net_;
    delete ipc_;
    delete memory_;
    delete process_;
    delete sleep_;
    delete system_;
    delete signal_;
    delete user_;
    delete time_;
    delete io_file_;
    delete io_net_;
    delete io_other_;
    delete wait_;
    delete processing_;
  }
}

void time_categories::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const time_categories& time_categories::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_draios_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_draios_2eproto();
#endif
  return *default_instance_;
}

time_categories* time_categories::default_instance_ = NULL;

time_categories* time_categories::New() const {
  return new time_categories;
}

void time_categories::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_unknown()) {
      if (unknown_ != NULL) unknown_->::draiosproto::counter::Clear();
    }
    if (has_other()) {
      if (other_ != NULL) other_->::draiosproto::counter::Clear();
    }
    if (has_file()) {
      if (file_ != NULL) file_->::draiosproto::counter::Clear();
    }
    if (has_net()) {
      if (net_ != NULL) net_->::draiosproto::counter::Clear();
    }
    if (has_ipc()) {
      if (ipc_ != NULL) ipc_->::draiosproto::counter::Clear();
    }
    if (has_memory()) {
      if (memory_ != NULL) memory_->::draiosproto::counter::Clear();
    }
    if (has_process()) {
      if (process_ != NULL) process_->::draiosproto::counter::Clear();
    }
    if (has_sleep()) {
      if (sleep_ != NULL) sleep_->::draiosproto::counter::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_system()) {
      if (system_ != NULL) system_->::draiosproto::counter::Clear();
    }
    if (has_signal()) {
      if (signal_ != NULL) signal_->::draiosproto::counter::Clear();
    }
    if (has_user()) {
      if (user_ != NULL) user_->::draiosproto::counter::Clear();
    }
    if (has_time()) {
      if (time_ != NULL) time_->::draiosproto::counter::Clear();
    }
    if (has_io_file()) {
      if (io_file_ != NULL) io_file_->::draiosproto::counter::Clear();
    }
    if (has_io_net()) {
      if (io_net_ != NULL) io_net_->::draiosproto::counter::Clear();
    }
    if (has_io_other()) {
      if (io_other_ != NULL) io_other_->::draiosproto::counter::Clear();
    }
    if (has_wait()) {
      if (wait_ != NULL) wait_->::draiosproto::counter::Clear();
    }
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (has_processing()) {
      if (processing_ != NULL) processing_->::draiosproto::counter::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool time_categories::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .draiosproto.counter unknown = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_unknown()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_other;
        break;
      }

      // optional .draiosproto.counter other = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_other:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_other()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_file;
        break;
      }

      // optional .draiosproto.counter file = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_file:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_file()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_net;
        break;
      }

      // optional .draiosproto.counter net = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_net:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_net()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_ipc;
        break;
      }

      // optional .draiosproto.counter ipc = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ipc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ipc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_memory;
        break;
      }

      // optional .draiosproto.counter memory = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_memory:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_memory()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_process;
        break;
      }

      // optional .draiosproto.counter process = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_process:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_process()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_sleep;
        break;
      }

      // optional .draiosproto.counter sleep = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sleep:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sleep()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_system;
        break;
      }

      // optional .draiosproto.counter system = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_system:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_system()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_signal;
        break;
      }

      // optional .draiosproto.counter signal = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_signal:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_signal()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_user;
        break;
      }

      // optional .draiosproto.counter user = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_time;
        break;
      }

      // optional .draiosproto.counter time = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_time()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_io_file;
        break;
      }

      // optional .draiosproto.counter io_file = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_io_file:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_io_file()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_io_net;
        break;
      }

      // optional .draiosproto.counter io_net = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_io_net:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_io_net()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_io_other;
        break;
      }

      // optional .draiosproto.counter io_other = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_io_other:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_io_other()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(130)) goto parse_wait;
        break;
      }

      // optional .draiosproto.counter wait = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_wait:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_wait()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(138)) goto parse_processing;
        break;
      }

      // optional .draiosproto.counter processing = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_processing:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_processing()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void time_categories::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .draiosproto.counter unknown = 1;
  if (has_unknown()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->unknown(), output);
  }

  // optional .draiosproto.counter other = 2;
  if (has_other()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->other(), output);
  }

  // optional .draiosproto.counter file = 3;
  if (has_file()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->file(), output);
  }

  // optional .draiosproto.counter net = 4;
  if (has_net()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->net(), output);
  }

  // optional .draiosproto.counter ipc = 5;
  if (has_ipc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->ipc(), output);
  }

  // optional .draiosproto.counter memory = 6;
  if (has_memory()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->memory(), output);
  }

  // optional .draiosproto.counter process = 7;
  if (has_process()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->process(), output);
  }

  // optional .draiosproto.counter sleep = 8;
  if (has_sleep()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->sleep(), output);
  }

  // optional .draiosproto.counter system = 9;
  if (has_system()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->system(), output);
  }

  // optional .draiosproto.counter signal = 10;
  if (has_signal()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, this->signal(), output);
  }

  // optional .draiosproto.counter user = 11;
  if (has_user()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      11, this->user(), output);
  }

  // optional .draiosproto.counter time = 12;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      12, this->time(), output);
  }

  // optional .draiosproto.counter io_file = 13;
  if (has_io_file()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      13, this->io_file(), output);
  }

  // optional .draiosproto.counter io_net = 14;
  if (has_io_net()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      14, this->io_net(), output);
  }

  // optional .draiosproto.counter io_other = 15;
  if (has_io_other()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      15, this->io_other(), output);
  }

  // optional .draiosproto.counter wait = 16;
  if (has_wait()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      16, this->wait(), output);
  }

  // optional .draiosproto.counter processing = 17;
  if (has_processing()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      17, this->processing(), output);
  }

}

int time_categories::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .draiosproto.counter unknown = 1;
    if (has_unknown()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->unknown());
    }

    // optional .draiosproto.counter other = 2;
    if (has_other()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->other());
    }

    // optional .draiosproto.counter file = 3;
    if (has_file()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->file());
    }

    // optional .draiosproto.counter net = 4;
    if (has_net()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->net());
    }

    // optional .draiosproto.counter ipc = 5;
    if (has_ipc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ipc());
    }

    // optional .draiosproto.counter memory = 6;
    if (has_memory()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->memory());
    }

    // optional .draiosproto.counter process = 7;
    if (has_process()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->process());
    }

    // optional .draiosproto.counter sleep = 8;
    if (has_sleep()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sleep());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .draiosproto.counter system = 9;
    if (has_system()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->system());
    }

    // optional .draiosproto.counter signal = 10;
    if (has_signal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->signal());
    }

    // optional .draiosproto.counter user = 11;
    if (has_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user());
    }

    // optional .draiosproto.counter time = 12;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->time());
    }

    // optional .draiosproto.counter io_file = 13;
    if (has_io_file()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->io_file());
    }

    // optional .draiosproto.counter io_net = 14;
    if (has_io_net()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->io_net());
    }

    // optional .draiosproto.counter io_other = 15;
    if (has_io_other()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->io_other());
    }

    // optional .draiosproto.counter wait = 16;
    if (has_wait()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->wait());
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional .draiosproto.counter processing = 17;
    if (has_processing()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->processing());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void time_categories::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const time_categories*>(&from));
}

void time_categories::MergeFrom(const time_categories& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown()) {
      mutable_unknown()->::draiosproto::counter::MergeFrom(from.unknown());
    }
    if (from.has_other()) {
      mutable_other()->::draiosproto::counter::MergeFrom(from.other());
    }
    if (from.has_file()) {
      mutable_file()->::draiosproto::counter::MergeFrom(from.file());
    }
    if (from.has_net()) {
      mutable_net()->::draiosproto::counter::MergeFrom(from.net());
    }
    if (from.has_ipc()) {
      mutable_ipc()->::draiosproto::counter::MergeFrom(from.ipc());
    }
    if (from.has_memory()) {
      mutable_memory()->::draiosproto::counter::MergeFrom(from.memory());
    }
    if (from.has_process()) {
      mutable_process()->::draiosproto::counter::MergeFrom(from.process());
    }
    if (from.has_sleep()) {
      mutable_sleep()->::draiosproto::counter::MergeFrom(from.sleep());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_system()) {
      mutable_system()->::draiosproto::counter::MergeFrom(from.system());
    }
    if (from.has_signal()) {
      mutable_signal()->::draiosproto::counter::MergeFrom(from.signal());
    }
    if (from.has_user()) {
      mutable_user()->::draiosproto::counter::MergeFrom(from.user());
    }
    if (from.has_time()) {
      mutable_time()->::draiosproto::counter::MergeFrom(from.time());
    }
    if (from.has_io_file()) {
      mutable_io_file()->::draiosproto::counter::MergeFrom(from.io_file());
    }
    if (from.has_io_net()) {
      mutable_io_net()->::draiosproto::counter::MergeFrom(from.io_net());
    }
    if (from.has_io_other()) {
      mutable_io_other()->::draiosproto::counter::MergeFrom(from.io_other());
    }
    if (from.has_wait()) {
      mutable_wait()->::draiosproto::counter::MergeFrom(from.wait());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_processing()) {
      mutable_processing()->::draiosproto::counter::MergeFrom(from.processing());
    }
  }
}

void time_categories::CopyFrom(const time_categories& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool time_categories::IsInitialized() const {

  return true;
}

void time_categories::Swap(time_categories* other) {
  if (other != this) {
    std::swap(unknown_, other->unknown_);
    std::swap(other_, other->other_);
    std::swap(file_, other->file_);
    std::swap(net_, other->net_);
    std::swap(ipc_, other->ipc_);
    std::swap(memory_, other->memory_);
    std::swap(process_, other->process_);
    std::swap(sleep_, other->sleep_);
    std::swap(system_, other->system_);
    std::swap(signal_, other->signal_);
    std::swap(user_, other->user_);
    std::swap(time_, other->time_);
    std::swap(io_file_, other->io_file_);
    std::swap(io_net_, other->io_net_);
    std::swap(io_other_, other->io_other_);
    std::swap(wait_, other->wait_);
    std::swap(processing_, other->processing_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string time_categories::GetTypeName() const {
  return "draiosproto.time_categories";
}


// ===================================================================

#ifndef _MSC_VER
const int transaction_categories::kIncomingFieldNumber;
const int transaction_categories::kOutgoingFieldNumber;
#endif  // !_MSC_VER

transaction_categories::transaction_categories()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void transaction_categories::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  incoming_ = const_cast< ::draiosproto::counter*>(
      ::draiosproto::counter::internal_default_instance());
#else
  incoming_ = const_cast< ::draiosproto::counter*>(&::draiosproto::counter::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  outgoing_ = const_cast< ::draiosproto::counter*>(
      ::draiosproto::counter::internal_default_instance());
#else
  outgoing_ = const_cast< ::draiosproto::counter*>(&::draiosproto::counter::default_instance());
#endif
}

transaction_categories::transaction_categories(const transaction_categories& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void transaction_categories::SharedCtor() {
  _cached_size_ = 0;
  incoming_ = NULL;
  outgoing_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

transaction_categories::~transaction_categories() {
  SharedDtor();
}

void transaction_categories::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete incoming_;
    delete outgoing_;
  }
}

void transaction_categories::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const transaction_categories& transaction_categories::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_draios_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_draios_2eproto();
#endif
  return *default_instance_;
}

transaction_categories* transaction_categories::default_instance_ = NULL;

transaction_categories* transaction_categories::New() const {
  return new transaction_categories;
}

void transaction_categories::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_incoming()) {
      if (incoming_ != NULL) incoming_->::draiosproto::counter::Clear();
    }
    if (has_outgoing()) {
      if (outgoing_ != NULL) outgoing_->::draiosproto::counter::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool transaction_categories::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .draiosproto.counter incoming = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_incoming()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_outgoing;
        break;
      }

      // optional .draiosproto.counter outgoing = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_outgoing:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_outgoing()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void transaction_categories::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .draiosproto.counter incoming = 1;
  if (has_incoming()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->incoming(), output);
  }

  // optional .draiosproto.counter outgoing = 2;
  if (has_outgoing()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->outgoing(), output);
  }

}

int transaction_categories::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .draiosproto.counter incoming = 1;
    if (has_incoming()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->incoming());
    }

    // optional .draiosproto.counter outgoing = 2;
    if (has_outgoing()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->outgoing());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void transaction_categories::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const transaction_categories*>(&from));
}

void transaction_categories::MergeFrom(const transaction_categories& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_incoming()) {
      mutable_incoming()->::draiosproto::counter::MergeFrom(from.incoming());
    }
    if (from.has_outgoing()) {
      mutable_outgoing()->::draiosproto::counter::MergeFrom(from.outgoing());
    }
  }
}

void transaction_categories::CopyFrom(const transaction_categories& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool transaction_categories::IsInitialized() const {

  return true;
}

void transaction_categories::Swap(transaction_categories* other) {
  if (other != this) {
    std::swap(incoming_, other->incoming_);
    std::swap(outgoing_, other->outgoing_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string transaction_categories::GetTypeName() const {
  return "draiosproto.transaction_categories";
}


// ===================================================================

#ifndef _MSC_VER
const int connection_categories::kServerIncomingFieldNumber;
const int connection_categories::kServerOutgoingFieldNumber;
const int connection_categories::kClientIncomingFieldNumber;
const int connection_categories::kClientOutgoingFieldNumber;
#endif  // !_MSC_VER

connection_categories::connection_categories()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void connection_categories::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  server_incoming_ = const_cast< ::draiosproto::counter*>(
      ::draiosproto::counter::internal_default_instance());
#else
  server_incoming_ = const_cast< ::draiosproto::counter*>(&::draiosproto::counter::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  server_outgoing_ = const_cast< ::draiosproto::counter*>(
      ::draiosproto::counter::internal_default_instance());
#else
  server_outgoing_ = const_cast< ::draiosproto::counter*>(&::draiosproto::counter::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  client_incoming_ = const_cast< ::draiosproto::counter*>(
      ::draiosproto::counter::internal_default_instance());
#else
  client_incoming_ = const_cast< ::draiosproto::counter*>(&::draiosproto::counter::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  client_outgoing_ = const_cast< ::draiosproto::counter*>(
      ::draiosproto::counter::internal_default_instance());
#else
  client_outgoing_ = const_cast< ::draiosproto::counter*>(&::draiosproto::counter::default_instance());
#endif
}

connection_categories::connection_categories(const connection_categories& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void connection_categories::SharedCtor() {
  _cached_size_ = 0;
  server_incoming_ = NULL;
  server_outgoing_ = NULL;
  client_incoming_ = NULL;
  client_outgoing_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

connection_categories::~connection_categories() {
  SharedDtor();
}

void connection_categories::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete server_incoming_;
    delete server_outgoing_;
    delete client_incoming_;
    delete client_outgoing_;
  }
}

void connection_categories::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const connection_categories& connection_categories::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_draios_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_draios_2eproto();
#endif
  return *default_instance_;
}

connection_categories* connection_categories::default_instance_ = NULL;

connection_categories* connection_categories::New() const {
  return new connection_categories;
}

void connection_categories::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_server_incoming()) {
      if (server_incoming_ != NULL) server_incoming_->::draiosproto::counter::Clear();
    }
    if (has_server_outgoing()) {
      if (server_outgoing_ != NULL) server_outgoing_->::draiosproto::counter::Clear();
    }
    if (has_client_incoming()) {
      if (client_incoming_ != NULL) client_incoming_->::draiosproto::counter::Clear();
    }
    if (has_client_outgoing()) {
      if (client_outgoing_ != NULL) client_outgoing_->::draiosproto::counter::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool connection_categories::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .draiosproto.counter server_incoming = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_server_incoming()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_server_outgoing;
        break;
      }

      // optional .draiosproto.counter server_outgoing = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_server_outgoing:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_server_outgoing()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_client_incoming;
        break;
      }

      // optional .draiosproto.counter client_incoming = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_client_incoming:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_client_incoming()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_client_outgoing;
        break;
      }

      // optional .draiosproto.counter client_outgoing = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_client_outgoing:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_client_outgoing()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void connection_categories::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .draiosproto.counter server_incoming = 1;
  if (has_server_incoming()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->server_incoming(), output);
  }

  // optional .draiosproto.counter server_outgoing = 2;
  if (has_server_outgoing()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->server_outgoing(), output);
  }

  // optional .draiosproto.counter client_incoming = 3;
  if (has_client_incoming()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->client_incoming(), output);
  }

  // optional .draiosproto.counter client_outgoing = 4;
  if (has_client_outgoing()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->client_outgoing(), output);
  }

}

int connection_categories::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .draiosproto.counter server_incoming = 1;
    if (has_server_incoming()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->server_incoming());
    }

    // optional .draiosproto.counter server_outgoing = 2;
    if (has_server_outgoing()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->server_outgoing());
    }

    // optional .draiosproto.counter client_incoming = 3;
    if (has_client_incoming()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->client_incoming());
    }

    // optional .draiosproto.counter client_outgoing = 4;
    if (has_client_outgoing()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->client_outgoing());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void connection_categories::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const connection_categories*>(&from));
}

void connection_categories::MergeFrom(const connection_categories& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_server_incoming()) {
      mutable_server_incoming()->::draiosproto::counter::MergeFrom(from.server_incoming());
    }
    if (from.has_server_outgoing()) {
      mutable_server_outgoing()->::draiosproto::counter::MergeFrom(from.server_outgoing());
    }
    if (from.has_client_incoming()) {
      mutable_client_incoming()->::draiosproto::counter::MergeFrom(from.client_incoming());
    }
    if (from.has_client_outgoing()) {
      mutable_client_outgoing()->::draiosproto::counter::MergeFrom(from.client_outgoing());
    }
  }
}

void connection_categories::CopyFrom(const connection_categories& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool connection_categories::IsInitialized() const {

  return true;
}

void connection_categories::Swap(connection_categories* other) {
  if (other != this) {
    std::swap(server_incoming_, other->server_incoming_);
    std::swap(server_outgoing_, other->server_outgoing_);
    std::swap(client_incoming_, other->client_incoming_);
    std::swap(client_outgoing_, other->client_outgoing_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string connection_categories::GetTypeName() const {
  return "draiosproto.connection_categories";
}


// ===================================================================

#ifndef _MSC_VER
const int process::kPidFieldNumber;
const int process::kCommFieldNumber;
const int process::kExeFieldNumber;
const int process::kArgsFieldNumber;
const int process::kTcountersFieldNumber;
const int process::kTransactionCountersFieldNumber;
const int process::kLocalTransactionDelayFieldNumber;
#endif  // !_MSC_VER

process::process()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void process::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  tcounters_ = const_cast< ::draiosproto::time_categories*>(
      ::draiosproto::time_categories::internal_default_instance());
#else
  tcounters_ = const_cast< ::draiosproto::time_categories*>(&::draiosproto::time_categories::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  transaction_counters_ = const_cast< ::draiosproto::transaction_categories*>(
      ::draiosproto::transaction_categories::internal_default_instance());
#else
  transaction_counters_ = const_cast< ::draiosproto::transaction_categories*>(&::draiosproto::transaction_categories::default_instance());
#endif
}

process::process(const process& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void process::SharedCtor() {
  _cached_size_ = 0;
  pid_ = GOOGLE_ULONGLONG(0);
  comm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  exe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  tcounters_ = NULL;
  transaction_counters_ = NULL;
  local_transaction_delay_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

process::~process() {
  SharedDtor();
}

void process::SharedDtor() {
  if (comm_ != &::google::protobuf::internal::kEmptyString) {
    delete comm_;
  }
  if (exe_ != &::google::protobuf::internal::kEmptyString) {
    delete exe_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete tcounters_;
    delete transaction_counters_;
  }
}

void process::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const process& process::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_draios_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_draios_2eproto();
#endif
  return *default_instance_;
}

process* process::default_instance_ = NULL;

process* process::New() const {
  return new process;
}

void process::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    pid_ = GOOGLE_ULONGLONG(0);
    if (has_comm()) {
      if (comm_ != &::google::protobuf::internal::kEmptyString) {
        comm_->clear();
      }
    }
    if (has_exe()) {
      if (exe_ != &::google::protobuf::internal::kEmptyString) {
        exe_->clear();
      }
    }
    if (has_tcounters()) {
      if (tcounters_ != NULL) tcounters_->::draiosproto::time_categories::Clear();
    }
    if (has_transaction_counters()) {
      if (transaction_counters_ != NULL) transaction_counters_->::draiosproto::transaction_categories::Clear();
    }
    local_transaction_delay_ = GOOGLE_ULONGLONG(0);
  }
  args_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool process::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 pid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pid_)));
          set_has_pid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_comm;
        break;
      }

      // required string comm = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_comm:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_comm()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_exe;
        break;
      }

      // required string exe = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_exe:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_exe()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_args;
        break;
      }

      // repeated string args = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_args:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_args()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_args;
        if (input->ExpectTag(42)) goto parse_tcounters;
        break;
      }

      // optional .draiosproto.time_categories tcounters = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tcounters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tcounters()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_transaction_counters;
        break;
      }

      // optional .draiosproto.transaction_categories transaction_counters = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_transaction_counters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transaction_counters()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_local_transaction_delay;
        break;
      }

      // optional uint64 local_transaction_delay = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_local_transaction_delay:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &local_transaction_delay_)));
          set_has_local_transaction_delay();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void process::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 pid = 1;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->pid(), output);
  }

  // required string comm = 2;
  if (has_comm()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->comm(), output);
  }

  // required string exe = 3;
  if (has_exe()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->exe(), output);
  }

  // repeated string args = 4;
  for (int i = 0; i < this->args_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->args(i), output);
  }

  // optional .draiosproto.time_categories tcounters = 5;
  if (has_tcounters()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->tcounters(), output);
  }

  // optional .draiosproto.transaction_categories transaction_counters = 6;
  if (has_transaction_counters()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->transaction_counters(), output);
  }

  // optional uint64 local_transaction_delay = 7;
  if (has_local_transaction_delay()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->local_transaction_delay(), output);
  }

}

int process::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 pid = 1;
    if (has_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->pid());
    }

    // required string comm = 2;
    if (has_comm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->comm());
    }

    // required string exe = 3;
    if (has_exe()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->exe());
    }

    // optional .draiosproto.time_categories tcounters = 5;
    if (has_tcounters()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tcounters());
    }

    // optional .draiosproto.transaction_categories transaction_counters = 6;
    if (has_transaction_counters()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->transaction_counters());
    }

    // optional uint64 local_transaction_delay = 7;
    if (has_local_transaction_delay()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->local_transaction_delay());
    }

  }
  // repeated string args = 4;
  total_size += 1 * this->args_size();
  for (int i = 0; i < this->args_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->args(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void process::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const process*>(&from));
}

void process::MergeFrom(const process& from) {
  GOOGLE_CHECK_NE(&from, this);
  args_.MergeFrom(from.args_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pid()) {
      set_pid(from.pid());
    }
    if (from.has_comm()) {
      set_comm(from.comm());
    }
    if (from.has_exe()) {
      set_exe(from.exe());
    }
    if (from.has_tcounters()) {
      mutable_tcounters()->::draiosproto::time_categories::MergeFrom(from.tcounters());
    }
    if (from.has_transaction_counters()) {
      mutable_transaction_counters()->::draiosproto::transaction_categories::MergeFrom(from.transaction_counters());
    }
    if (from.has_local_transaction_delay()) {
      set_local_transaction_delay(from.local_transaction_delay());
    }
  }
}

void process::CopyFrom(const process& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool process::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void process::Swap(process* other) {
  if (other != this) {
    std::swap(pid_, other->pid_);
    std::swap(comm_, other->comm_);
    std::swap(exe_, other->exe_);
    args_.Swap(&other->args_);
    std::swap(tcounters_, other->tcounters_);
    std::swap(transaction_counters_, other->transaction_counters_);
    std::swap(local_transaction_delay_, other->local_transaction_delay_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string process::GetTypeName() const {
  return "draiosproto.process";
}


// ===================================================================

#ifndef _MSC_VER
const int thread::kPidFieldNumber;
const int thread::kTidFieldNumber;
const int thread::kTcountersFieldNumber;
const int thread::kTransactionCountersFieldNumber;
#endif  // !_MSC_VER

thread::thread()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void thread::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  tcounters_ = const_cast< ::draiosproto::time_categories*>(
      ::draiosproto::time_categories::internal_default_instance());
#else
  tcounters_ = const_cast< ::draiosproto::time_categories*>(&::draiosproto::time_categories::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  transaction_counters_ = const_cast< ::draiosproto::transaction_categories*>(
      ::draiosproto::transaction_categories::internal_default_instance());
#else
  transaction_counters_ = const_cast< ::draiosproto::transaction_categories*>(&::draiosproto::transaction_categories::default_instance());
#endif
}

thread::thread(const thread& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void thread::SharedCtor() {
  _cached_size_ = 0;
  pid_ = GOOGLE_ULONGLONG(0);
  tid_ = GOOGLE_ULONGLONG(0);
  tcounters_ = NULL;
  transaction_counters_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

thread::~thread() {
  SharedDtor();
}

void thread::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete tcounters_;
    delete transaction_counters_;
  }
}

void thread::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const thread& thread::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_draios_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_draios_2eproto();
#endif
  return *default_instance_;
}

thread* thread::default_instance_ = NULL;

thread* thread::New() const {
  return new thread;
}

void thread::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    pid_ = GOOGLE_ULONGLONG(0);
    tid_ = GOOGLE_ULONGLONG(0);
    if (has_tcounters()) {
      if (tcounters_ != NULL) tcounters_->::draiosproto::time_categories::Clear();
    }
    if (has_transaction_counters()) {
      if (transaction_counters_ != NULL) transaction_counters_->::draiosproto::transaction_categories::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool thread::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 pid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pid_)));
          set_has_pid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_tid;
        break;
      }

      // required uint64 tid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_tid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &tid_)));
          set_has_tid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_tcounters;
        break;
      }

      // optional .draiosproto.time_categories tcounters = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tcounters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tcounters()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_transaction_counters;
        break;
      }

      // optional .draiosproto.transaction_categories transaction_counters = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_transaction_counters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transaction_counters()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void thread::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 pid = 1;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->pid(), output);
  }

  // required uint64 tid = 2;
  if (has_tid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->tid(), output);
  }

  // optional .draiosproto.time_categories tcounters = 3;
  if (has_tcounters()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->tcounters(), output);
  }

  // optional .draiosproto.transaction_categories transaction_counters = 5;
  if (has_transaction_counters()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->transaction_counters(), output);
  }

}

int thread::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 pid = 1;
    if (has_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->pid());
    }

    // required uint64 tid = 2;
    if (has_tid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->tid());
    }

    // optional .draiosproto.time_categories tcounters = 3;
    if (has_tcounters()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tcounters());
    }

    // optional .draiosproto.transaction_categories transaction_counters = 5;
    if (has_transaction_counters()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->transaction_counters());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void thread::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const thread*>(&from));
}

void thread::MergeFrom(const thread& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pid()) {
      set_pid(from.pid());
    }
    if (from.has_tid()) {
      set_tid(from.tid());
    }
    if (from.has_tcounters()) {
      mutable_tcounters()->::draiosproto::time_categories::MergeFrom(from.tcounters());
    }
    if (from.has_transaction_counters()) {
      mutable_transaction_counters()->::draiosproto::transaction_categories::MergeFrom(from.transaction_counters());
    }
  }
}

void thread::CopyFrom(const thread& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool thread::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void thread::Swap(thread* other) {
  if (other != this) {
    std::swap(pid_, other->pid_);
    std::swap(tid_, other->tid_);
    std::swap(tcounters_, other->tcounters_);
    std::swap(transaction_counters_, other->transaction_counters_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string thread::GetTypeName() const {
  return "draiosproto.thread";
}


// ===================================================================

#ifndef _MSC_VER
const int ipv4tuple::kSipFieldNumber;
const int ipv4tuple::kDipFieldNumber;
const int ipv4tuple::kSportFieldNumber;
const int ipv4tuple::kDportFieldNumber;
const int ipv4tuple::kL4ProtoFieldNumber;
#endif  // !_MSC_VER

ipv4tuple::ipv4tuple()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ipv4tuple::InitAsDefaultInstance() {
}

ipv4tuple::ipv4tuple(const ipv4tuple& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ipv4tuple::SharedCtor() {
  _cached_size_ = 0;
  sip_ = 0u;
  dip_ = 0u;
  sport_ = 0u;
  dport_ = 0u;
  l4proto_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ipv4tuple::~ipv4tuple() {
  SharedDtor();
}

void ipv4tuple::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ipv4tuple::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ipv4tuple& ipv4tuple::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_draios_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_draios_2eproto();
#endif
  return *default_instance_;
}

ipv4tuple* ipv4tuple::default_instance_ = NULL;

ipv4tuple* ipv4tuple::New() const {
  return new ipv4tuple;
}

void ipv4tuple::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    sip_ = 0u;
    dip_ = 0u;
    sport_ = 0u;
    dport_ = 0u;
    l4proto_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ipv4tuple::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 sip = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sip_)));
          set_has_sip();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_dip;
        break;
      }

      // required uint32 dip = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_dip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dip_)));
          set_has_dip();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_sport;
        break;
      }

      // required uint32 sport = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sport:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sport_)));
          set_has_sport();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_dport;
        break;
      }

      // required uint32 dport = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_dport:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dport_)));
          set_has_dport();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_l4proto;
        break;
      }

      // required uint32 l4proto = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_l4proto:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &l4proto_)));
          set_has_l4proto();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ipv4tuple::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 sip = 1;
  if (has_sip()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sip(), output);
  }

  // required uint32 dip = 2;
  if (has_dip()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->dip(), output);
  }

  // required uint32 sport = 3;
  if (has_sport()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->sport(), output);
  }

  // required uint32 dport = 4;
  if (has_dport()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->dport(), output);
  }

  // required uint32 l4proto = 5;
  if (has_l4proto()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->l4proto(), output);
  }

}

int ipv4tuple::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 sip = 1;
    if (has_sip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sip());
    }

    // required uint32 dip = 2;
    if (has_dip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dip());
    }

    // required uint32 sport = 3;
    if (has_sport()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sport());
    }

    // required uint32 dport = 4;
    if (has_dport()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dport());
    }

    // required uint32 l4proto = 5;
    if (has_l4proto()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->l4proto());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ipv4tuple::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ipv4tuple*>(&from));
}

void ipv4tuple::MergeFrom(const ipv4tuple& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sip()) {
      set_sip(from.sip());
    }
    if (from.has_dip()) {
      set_dip(from.dip());
    }
    if (from.has_sport()) {
      set_sport(from.sport());
    }
    if (from.has_dport()) {
      set_dport(from.dport());
    }
    if (from.has_l4proto()) {
      set_l4proto(from.l4proto());
    }
  }
}

void ipv4tuple::CopyFrom(const ipv4tuple& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ipv4tuple::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void ipv4tuple::Swap(ipv4tuple* other) {
  if (other != this) {
    std::swap(sip_, other->sip_);
    std::swap(dip_, other->dip_);
    std::swap(sport_, other->sport_);
    std::swap(dport_, other->dport_);
    std::swap(l4proto_, other->l4proto_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ipv4tuple::GetTypeName() const {
  return "draiosproto.ipv4tuple";
}


// ===================================================================

#ifndef _MSC_VER
const int ipv4_connection::kTupleFieldNumber;
const int ipv4_connection::kSpidFieldNumber;
const int ipv4_connection::kStidFieldNumber;
const int ipv4_connection::kDpidFieldNumber;
const int ipv4_connection::kDtidFieldNumber;
const int ipv4_connection::kCountersFieldNumber;
const int ipv4_connection::kTransactionCountersFieldNumber;
#endif  // !_MSC_VER

ipv4_connection::ipv4_connection()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ipv4_connection::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  tuple_ = const_cast< ::draiosproto::ipv4tuple*>(
      ::draiosproto::ipv4tuple::internal_default_instance());
#else
  tuple_ = const_cast< ::draiosproto::ipv4tuple*>(&::draiosproto::ipv4tuple::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  counters_ = const_cast< ::draiosproto::connection_categories*>(
      ::draiosproto::connection_categories::internal_default_instance());
#else
  counters_ = const_cast< ::draiosproto::connection_categories*>(&::draiosproto::connection_categories::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  transaction_counters_ = const_cast< ::draiosproto::transaction_categories*>(
      ::draiosproto::transaction_categories::internal_default_instance());
#else
  transaction_counters_ = const_cast< ::draiosproto::transaction_categories*>(&::draiosproto::transaction_categories::default_instance());
#endif
}

ipv4_connection::ipv4_connection(const ipv4_connection& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ipv4_connection::SharedCtor() {
  _cached_size_ = 0;
  tuple_ = NULL;
  spid_ = GOOGLE_ULONGLONG(0);
  stid_ = GOOGLE_ULONGLONG(0);
  dpid_ = GOOGLE_ULONGLONG(0);
  dtid_ = GOOGLE_ULONGLONG(0);
  counters_ = NULL;
  transaction_counters_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ipv4_connection::~ipv4_connection() {
  SharedDtor();
}

void ipv4_connection::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete tuple_;
    delete counters_;
    delete transaction_counters_;
  }
}

void ipv4_connection::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ipv4_connection& ipv4_connection::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_draios_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_draios_2eproto();
#endif
  return *default_instance_;
}

ipv4_connection* ipv4_connection::default_instance_ = NULL;

ipv4_connection* ipv4_connection::New() const {
  return new ipv4_connection;
}

void ipv4_connection::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_tuple()) {
      if (tuple_ != NULL) tuple_->::draiosproto::ipv4tuple::Clear();
    }
    spid_ = GOOGLE_ULONGLONG(0);
    stid_ = GOOGLE_ULONGLONG(0);
    dpid_ = GOOGLE_ULONGLONG(0);
    dtid_ = GOOGLE_ULONGLONG(0);
    if (has_counters()) {
      if (counters_ != NULL) counters_->::draiosproto::connection_categories::Clear();
    }
    if (has_transaction_counters()) {
      if (transaction_counters_ != NULL) transaction_counters_->::draiosproto::transaction_categories::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ipv4_connection::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .draiosproto.ipv4tuple tuple = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tuple()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_spid;
        break;
      }

      // optional uint64 spid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_spid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &spid_)));
          set_has_spid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_stid;
        break;
      }

      // optional uint64 stid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_stid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &stid_)));
          set_has_stid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_dpid;
        break;
      }

      // optional uint64 dpid = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_dpid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dpid_)));
          set_has_dpid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_dtid;
        break;
      }

      // optional uint64 dtid = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_dtid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dtid_)));
          set_has_dtid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_counters;
        break;
      }

      // optional .draiosproto.connection_categories counters = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_counters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_counters()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_transaction_counters;
        break;
      }

      // optional .draiosproto.transaction_categories transaction_counters = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_transaction_counters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transaction_counters()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ipv4_connection::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .draiosproto.ipv4tuple tuple = 1;
  if (has_tuple()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->tuple(), output);
  }

  // optional uint64 spid = 2;
  if (has_spid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->spid(), output);
  }

  // optional uint64 stid = 3;
  if (has_stid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->stid(), output);
  }

  // optional uint64 dpid = 5;
  if (has_dpid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->dpid(), output);
  }

  // optional uint64 dtid = 6;
  if (has_dtid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->dtid(), output);
  }

  // optional .draiosproto.connection_categories counters = 8;
  if (has_counters()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->counters(), output);
  }

  // optional .draiosproto.transaction_categories transaction_counters = 9;
  if (has_transaction_counters()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->transaction_counters(), output);
  }

}

int ipv4_connection::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .draiosproto.ipv4tuple tuple = 1;
    if (has_tuple()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tuple());
    }

    // optional uint64 spid = 2;
    if (has_spid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->spid());
    }

    // optional uint64 stid = 3;
    if (has_stid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->stid());
    }

    // optional uint64 dpid = 5;
    if (has_dpid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->dpid());
    }

    // optional uint64 dtid = 6;
    if (has_dtid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->dtid());
    }

    // optional .draiosproto.connection_categories counters = 8;
    if (has_counters()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->counters());
    }

    // optional .draiosproto.transaction_categories transaction_counters = 9;
    if (has_transaction_counters()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->transaction_counters());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ipv4_connection::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ipv4_connection*>(&from));
}

void ipv4_connection::MergeFrom(const ipv4_connection& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tuple()) {
      mutable_tuple()->::draiosproto::ipv4tuple::MergeFrom(from.tuple());
    }
    if (from.has_spid()) {
      set_spid(from.spid());
    }
    if (from.has_stid()) {
      set_stid(from.stid());
    }
    if (from.has_dpid()) {
      set_dpid(from.dpid());
    }
    if (from.has_dtid()) {
      set_dtid(from.dtid());
    }
    if (from.has_counters()) {
      mutable_counters()->::draiosproto::connection_categories::MergeFrom(from.counters());
    }
    if (from.has_transaction_counters()) {
      mutable_transaction_counters()->::draiosproto::transaction_categories::MergeFrom(from.transaction_counters());
    }
  }
}

void ipv4_connection::CopyFrom(const ipv4_connection& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ipv4_connection::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_tuple()) {
    if (!this->tuple().IsInitialized()) return false;
  }
  return true;
}

void ipv4_connection::Swap(ipv4_connection* other) {
  if (other != this) {
    std::swap(tuple_, other->tuple_);
    std::swap(spid_, other->spid_);
    std::swap(stid_, other->stid_);
    std::swap(dpid_, other->dpid_);
    std::swap(dtid_, other->dtid_);
    std::swap(counters_, other->counters_);
    std::swap(transaction_counters_, other->transaction_counters_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ipv4_connection::GetTypeName() const {
  return "draiosproto.ipv4_connection";
}


// ===================================================================

#ifndef _MSC_VER
const int ipv4_network_interface::kNameFieldNumber;
const int ipv4_network_interface::kAddrFieldNumber;
const int ipv4_network_interface::kNetmaskFieldNumber;
const int ipv4_network_interface::kBcastFieldNumber;
#endif  // !_MSC_VER

ipv4_network_interface::ipv4_network_interface()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ipv4_network_interface::InitAsDefaultInstance() {
}

ipv4_network_interface::ipv4_network_interface(const ipv4_network_interface& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ipv4_network_interface::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  addr_ = 0u;
  netmask_ = 0u;
  bcast_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ipv4_network_interface::~ipv4_network_interface() {
  SharedDtor();
}

void ipv4_network_interface::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ipv4_network_interface::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ipv4_network_interface& ipv4_network_interface::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_draios_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_draios_2eproto();
#endif
  return *default_instance_;
}

ipv4_network_interface* ipv4_network_interface::default_instance_ = NULL;

ipv4_network_interface* ipv4_network_interface::New() const {
  return new ipv4_network_interface;
}

void ipv4_network_interface::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    addr_ = 0u;
    netmask_ = 0u;
    bcast_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ipv4_network_interface::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_addr;
        break;
      }

      // required uint32 addr = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_addr:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &addr_)));
          set_has_addr();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_netmask;
        break;
      }

      // required uint32 netmask = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_netmask:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &netmask_)));
          set_has_netmask();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_bcast;
        break;
      }

      // optional uint32 bcast = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bcast:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bcast_)));
          set_has_bcast();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ipv4_network_interface::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // required uint32 addr = 2;
  if (has_addr()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->addr(), output);
  }

  // required uint32 netmask = 3;
  if (has_netmask()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->netmask(), output);
  }

  // optional uint32 bcast = 4;
  if (has_bcast()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->bcast(), output);
  }

}

int ipv4_network_interface::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required uint32 addr = 2;
    if (has_addr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->addr());
    }

    // required uint32 netmask = 3;
    if (has_netmask()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->netmask());
    }

    // optional uint32 bcast = 4;
    if (has_bcast()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bcast());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ipv4_network_interface::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ipv4_network_interface*>(&from));
}

void ipv4_network_interface::MergeFrom(const ipv4_network_interface& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_addr()) {
      set_addr(from.addr());
    }
    if (from.has_netmask()) {
      set_netmask(from.netmask());
    }
    if (from.has_bcast()) {
      set_bcast(from.bcast());
    }
  }
}

void ipv4_network_interface::CopyFrom(const ipv4_network_interface& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ipv4_network_interface::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void ipv4_network_interface::Swap(ipv4_network_interface* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(addr_, other->addr_);
    std::swap(netmask_, other->netmask_);
    std::swap(bcast_, other->bcast_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ipv4_network_interface::GetTypeName() const {
  return "draiosproto.ipv4_network_interface";
}


// ===================================================================

#ifndef _MSC_VER
const int metrics::kTimestampNsFieldNumber;
const int metrics::kHostnameFieldNumber;
const int metrics::kMachineIdFieldNumber;
const int metrics::kCustomerIdFieldNumber;
const int metrics::kProcessesFieldNumber;
const int metrics::kThreadsFieldNumber;
const int metrics::kIpv4ConnectionsFieldNumber;
const int metrics::kIpv4NetworkInterfacesFieldNumber;
#endif  // !_MSC_VER

metrics::metrics()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void metrics::InitAsDefaultInstance() {
}

metrics::metrics(const metrics& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void metrics::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

metrics::~metrics() {
  SharedDtor();
}

void metrics::SharedDtor() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_id_;
  }
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete customer_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void metrics::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const metrics& metrics::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_draios_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_draios_2eproto();
#endif
  return *default_instance_;
}

metrics* metrics::default_instance_ = NULL;

metrics* metrics::New() const {
  return new metrics;
}

void metrics::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    timestamp_ns_ = GOOGLE_ULONGLONG(0);
    if (has_hostname()) {
      if (hostname_ != &::google::protobuf::internal::kEmptyString) {
        hostname_->clear();
      }
    }
    if (has_machine_id()) {
      if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
        machine_id_->clear();
      }
    }
    if (has_customer_id()) {
      if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
        customer_id_->clear();
      }
    }
  }
  processes_.Clear();
  threads_.Clear();
  ipv4_connections_.Clear();
  ipv4_network_interfaces_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool metrics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 timestamp_ns = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &timestamp_ns_)));
          set_has_timestamp_ns();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_hostname;
        break;
      }

      // optional string hostname = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hostname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hostname()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_machine_id;
        break;
      }

      // required string machine_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_machine_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_machine_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_customer_id;
        break;
      }

      // required string customer_id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_customer_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_customer_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_processes;
        break;
      }

      // repeated .draiosproto.process processes = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_processes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_processes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_processes;
        if (input->ExpectTag(50)) goto parse_threads;
        break;
      }

      // repeated .draiosproto.thread threads = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_threads:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_threads()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_threads;
        if (input->ExpectTag(58)) goto parse_ipv4_connections;
        break;
      }

      // repeated .draiosproto.ipv4_connection ipv4_connections = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ipv4_connections:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_ipv4_connections()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_ipv4_connections;
        if (input->ExpectTag(66)) goto parse_ipv4_network_interfaces;
        break;
      }

      // repeated .draiosproto.ipv4_network_interface ipv4_network_interfaces = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ipv4_network_interfaces:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_ipv4_network_interfaces()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_ipv4_network_interfaces;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void metrics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 timestamp_ns = 1;
  if (has_timestamp_ns()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->timestamp_ns(), output);
  }

  // optional string hostname = 2;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->hostname(), output);
  }

  // required string machine_id = 3;
  if (has_machine_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->machine_id(), output);
  }

  // required string customer_id = 4;
  if (has_customer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->customer_id(), output);
  }

  // repeated .draiosproto.process processes = 5;
  for (int i = 0; i < this->processes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->processes(i), output);
  }

  // repeated .draiosproto.thread threads = 6;
  for (int i = 0; i < this->threads_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->threads(i), output);
  }

  // repeated .draiosproto.ipv4_connection ipv4_connections = 7;
  for (int i = 0; i < this->ipv4_connections_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->ipv4_connections(i), output);
  }

  // repeated .draiosproto.ipv4_network_interface ipv4_network_interfaces = 8;
  for (int i = 0; i < this->ipv4_network_interfaces_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->ipv4_network_interfaces(i), output);
  }

}

int metrics::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 timestamp_ns = 1;
    if (has_timestamp_ns()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->timestamp_ns());
    }

    // optional string hostname = 2;
    if (has_hostname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hostname());
    }

    // required string machine_id = 3;
    if (has_machine_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->machine_id());
    }

    // required string customer_id = 4;
    if (has_customer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->customer_id());
    }

  }
  // repeated .draiosproto.process processes = 5;
  total_size += 1 * this->processes_size();
  for (int i = 0; i < this->processes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->processes(i));
  }

  // repeated .draiosproto.thread threads = 6;
  total_size += 1 * this->threads_size();
  for (int i = 0; i < this->threads_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->threads(i));
  }

  // repeated .draiosproto.ipv4_connection ipv4_connections = 7;
  total_size += 1 * this->ipv4_connections_size();
  for (int i = 0; i < this->ipv4_connections_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->ipv4_connections(i));
  }

  // repeated .draiosproto.ipv4_network_interface ipv4_network_interfaces = 8;
  total_size += 1 * this->ipv4_network_interfaces_size();
  for (int i = 0; i < this->ipv4_network_interfaces_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->ipv4_network_interfaces(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void metrics::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const metrics*>(&from));
}

void metrics::MergeFrom(const metrics& from) {
  GOOGLE_CHECK_NE(&from, this);
  processes_.MergeFrom(from.processes_);
  threads_.MergeFrom(from.threads_);
  ipv4_connections_.MergeFrom(from.ipv4_connections_);
  ipv4_network_interfaces_.MergeFrom(from.ipv4_network_interfaces_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp_ns()) {
      set_timestamp_ns(from.timestamp_ns());
    }
    if (from.has_hostname()) {
      set_hostname(from.hostname());
    }
    if (from.has_machine_id()) {
      set_machine_id(from.machine_id());
    }
    if (from.has_customer_id()) {
      set_customer_id(from.customer_id());
    }
  }
}

void metrics::CopyFrom(const metrics& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool metrics::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000d) != 0x0000000d) return false;

  for (int i = 0; i < processes_size(); i++) {
    if (!this->processes(i).IsInitialized()) return false;
  }
  for (int i = 0; i < threads_size(); i++) {
    if (!this->threads(i).IsInitialized()) return false;
  }
  for (int i = 0; i < ipv4_connections_size(); i++) {
    if (!this->ipv4_connections(i).IsInitialized()) return false;
  }
  for (int i = 0; i < ipv4_network_interfaces_size(); i++) {
    if (!this->ipv4_network_interfaces(i).IsInitialized()) return false;
  }
  return true;
}

void metrics::Swap(metrics* other) {
  if (other != this) {
    std::swap(timestamp_ns_, other->timestamp_ns_);
    std::swap(hostname_, other->hostname_);
    std::swap(machine_id_, other->machine_id_);
    std::swap(customer_id_, other->customer_id_);
    processes_.Swap(&other->processes_);
    threads_.Swap(&other->threads_);
    ipv4_connections_.Swap(&other->ipv4_connections_);
    ipv4_network_interfaces_.Swap(&other->ipv4_network_interfaces_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string metrics::GetTypeName() const {
  return "draiosproto.metrics";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace draiosproto

// @@protoc_insertion_point(global_scope)
