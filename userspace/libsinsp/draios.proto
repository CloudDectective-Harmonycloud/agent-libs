package draiosproto;

option optimize_for = LITE_RUNTIME;
option java_package = "com.draios.model.protobuf";
option java_outer_classname = "Agent";

message counter_time {
  required uint32 count = 1;
  required uint64 time_ns = 2;
}

message counter_time_bidirectional {
  required uint32 count_in = 1;
  required uint32 count_out = 2;
  required uint64 time_ns_in = 3;
  required uint64 time_ns_out = 4;
}

message counter_bytes {
  required uint32 count_in = 1;
  required uint32 count_out = 2;
  required uint32 bytes_in = 3;
  required uint32 bytes_out = 4;
}

message counter_time_bytes {
  required uint64 time_ns_in = 1;
  required uint64 time_ns_out = 2;
  required uint64 time_ns_other = 3;
  required uint32 count_in = 4;
  required uint32 count_out = 5;
  required uint32 count_other = 6;
  required uint32 bytes_in = 7;
  required uint32 bytes_out = 8;
  required uint32 bytes_other = 9;
}

message time_categories {
	optional counter_time unknown = 1;
	optional counter_time other = 2;
	optional counter_time file = 3;
	optional counter_time net = 4;
	optional counter_time ipc = 5;
	optional counter_time memory = 6;
	optional counter_time process = 7;
	optional counter_time sleep = 8;
	optional counter_time system = 9;
	optional counter_time signal = 10;
	optional counter_time user = 11;
	optional counter_time time = 12;
	optional counter_time_bytes io_file = 13;
	optional counter_time_bytes io_net = 14;
	optional counter_time_bytes io_other = 15;
	optional counter_time wait = 16;
	optional counter_time processing = 17;
}

message counter_syscall_errors {
  required uint32 cnt = 1;	// Syscall errors count
  repeated uint32 top_error_codes = 2; // Error codes that were generated the most
}

message resource_categories {
  optional uint32 health_score = 1; // the health score for this process or host. 0 means very crappy, 100 means very healthy.
  optional uint32 connection_queue_usage_pct = 2; // if this process or host is serving connections, the occupation of the connection queue FOR THE WORST THREAD IN THIS PROCESS OR HOST (0=empty, 100=full)
  optional uint32 fd_usage_pct = 3; // the ratio (open FDs / total available FDs) FOR THE WORST THREAD IN THIS PROCESS OR HOST. 0 means no FD in use, 100 means FD limit reached.
  optional uint32 cpu_pct = 4; // CPU load of a process (including all the childs). Not present for the host.
  optional uint64 resident_memory_usage_kb = 5; // Resident (Physical) Memory usage in kb
  optional counter_syscall_errors syscall_errors = 6; // Syscall error counter
}

message connection_categories {
  optional counter_bytes server = 1; // client-side metrics
  optional counter_bytes client = 2; // server-side metrics
  optional counter_time_bidirectional transaction_counters = 3; // The transaction counters for this connection
  optional uint32 n_aggregated_connections = 4; // If this is an aggregated connection, the number of real connections it represents
}

//
// HOST
// global host info.
//
message host {
  optional string hostname = 1; // The name of the host sending the data
  optional uint32 num_cpus = 2;	// Number of CPUs in the system
  repeated uint32 cpu_loads = 3;	// Array of CPU loads (0 to 100), with an entry for each CPU, with the 
  required uint64 physical_memory_size_bytes = 4;	// Physical RAM size

  optional time_categories tcounters = 5; // The time counters for this thread
  optional counter_time_bidirectional transaction_counters = 6; // The transaction counters for this process
  optional uint64 transaction_processing_delay = 7;	// the delay introduced by this process when processing transactions. 
													// It's calculated by subtracting outgoing connection time from incoming connection time. 
  optional resource_categories resource_counters = 8; // The resource counters for this process
}

//
// PROCESS
// info for a process, i.e. a collection of threads.
// NOTE: this is process info only, the main thread of a process will have a 
// separate thread message with tid=process pid.
//
message process {
  required uint64 pid = 1; // The ID of process this thread belongs to

  required string comm = 2;	// Command name (e.g. "top")
  required string exe = 3; // Full command name (e.g. "/bin/top")
  repeated string args = 4; // Command line arguments (e.g. "-d1")

  optional time_categories tcounters = 5; // The time counters for this thread
  optional counter_time_bidirectional transaction_counters = 6; // The transaction counters for this process
  optional uint64 transaction_processing_delay = 7;	// the delay introduced by this process when processing transactions. 
													// It's calculated by subtracting outgoing connection time from incoming connection time. 
  optional resource_categories resource_counters = 8; // The resource counters for this process
}

//
// THREAD
// This contains all the operational info (counters, etc.) for one of the threads.
//
message thread {
  required uint64 pid = 1; // The ID of process this thread belongs to
  required uint64 tid = 2; // The thread ID. If tid=pid, this is the main thread for this process.
  optional time_categories tcounters = 3; // The time counters for this thread

  // XXX Do we need this?
  //optional string cwd = 4; // Current working directory. This is set only if this thread has its 
                             // own working directory, which happens for main threads and threads 
							 // started with the CLONE_FS flag

  optional counter_time_bidirectional transaction_counters = 5; // The transaction counters for this thread
}

//
// IPv4 CONNECTION
//
message ipv4tuple {
  required uint32 sip = 1;
  required uint32 dip = 2;
  required uint32 sport = 3;
  required uint32 dport = 4;
  required uint32 l4proto = 5;
}

message ipv4_connection {
  required ipv4tuple tuple = 1;

  optional uint64 spid = 2; // The pid of the client
  optional uint64 stid = 3; // The tid of the client
  // XXX is this required?
  //optional uint64 sfd = 4; // The fd number of the client

  optional uint64 dpid = 5; // The pid of the server
  optional uint64 dtid = 6; // The tid of the server
  // XXX is this required?
  //optional uint64 dfd = 7; // The fd number of the server

  required connection_categories counters = 8; // the metrics for this connection
}

//
// NETWORK INTERFACE
//
message ipv4_network_interface {
  required string name = 1; // ifconfig entry name, e.g. eth0
  required uint32 addr = 2; // IP address
  required uint32 netmask = 3; // netmask
  optional uint32 bcast = 4; // broadcast address
}

//
// ENTRY POINT MESSAGE
//
message metrics {
  required uint64 timestamp_ns = 1; // The message timestamp, in ns from epoch
  required string machine_id = 2; // The unique ID of the machine that is sending this data
  required string customer_id = 3; // The unique ID of the customer that this machine belongs to
  required host hostinfo = 4; // The list of processes
  repeated process processes = 5; // The list of processes
  repeated thread threads = 6; // The list of threads
  repeated ipv4_connection ipv4_connections = 7; // The list of threads
  repeated ipv4_network_interface ipv4_network_interfaces = 8; // The list of the machine network interfaces
}
