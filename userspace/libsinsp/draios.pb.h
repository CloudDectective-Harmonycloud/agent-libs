// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: draios.proto

#ifndef PROTOBUF_draios_2eproto__INCLUDED
#define PROTOBUF_draios_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace draiosproto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_draios_2eproto();
void protobuf_AssignDesc_draios_2eproto();
void protobuf_ShutdownFile_draios_2eproto();

class counter_time;
class counter_time_bidirectional;
class counter_bytes;
class counter_time_bytes;
class time_categories;
class counter_syscall_errors;
class resource_categories;
class connection_categories;
class host;
class process;
class thread;
class ipv4tuple;
class ipv4_connection;
class ipv4_network_interface;
class metrics;

// ===================================================================

class counter_time : public ::google::protobuf::MessageLite {
 public:
  counter_time();
  virtual ~counter_time();

  counter_time(const counter_time& from);

  inline counter_time& operator=(const counter_time& from) {
    CopyFrom(from);
    return *this;
  }

  static const counter_time& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const counter_time* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(counter_time* other);

  // implements Message ----------------------------------------------

  counter_time* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const counter_time& from);
  void MergeFrom(const counter_time& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // required uint64 time_ns = 2;
  inline bool has_time_ns() const;
  inline void clear_time_ns();
  static const int kTimeNsFieldNumber = 2;
  inline ::google::protobuf::uint64 time_ns() const;
  inline void set_time_ns(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:draiosproto.counter_time)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_time_ns();
  inline void clear_has_time_ns();

  ::google::protobuf::uint64 time_ns_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_draios_2eproto();
  #endif
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static counter_time* default_instance_;
};
// -------------------------------------------------------------------

class counter_time_bidirectional : public ::google::protobuf::MessageLite {
 public:
  counter_time_bidirectional();
  virtual ~counter_time_bidirectional();

  counter_time_bidirectional(const counter_time_bidirectional& from);

  inline counter_time_bidirectional& operator=(const counter_time_bidirectional& from) {
    CopyFrom(from);
    return *this;
  }

  static const counter_time_bidirectional& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const counter_time_bidirectional* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(counter_time_bidirectional* other);

  // implements Message ----------------------------------------------

  counter_time_bidirectional* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const counter_time_bidirectional& from);
  void MergeFrom(const counter_time_bidirectional& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 count_in = 1;
  inline bool has_count_in() const;
  inline void clear_count_in();
  static const int kCountInFieldNumber = 1;
  inline ::google::protobuf::uint32 count_in() const;
  inline void set_count_in(::google::protobuf::uint32 value);

  // required uint32 count_out = 2;
  inline bool has_count_out() const;
  inline void clear_count_out();
  static const int kCountOutFieldNumber = 2;
  inline ::google::protobuf::uint32 count_out() const;
  inline void set_count_out(::google::protobuf::uint32 value);

  // required uint64 time_ns_in = 3;
  inline bool has_time_ns_in() const;
  inline void clear_time_ns_in();
  static const int kTimeNsInFieldNumber = 3;
  inline ::google::protobuf::uint64 time_ns_in() const;
  inline void set_time_ns_in(::google::protobuf::uint64 value);

  // required uint64 time_ns_out = 4;
  inline bool has_time_ns_out() const;
  inline void clear_time_ns_out();
  static const int kTimeNsOutFieldNumber = 4;
  inline ::google::protobuf::uint64 time_ns_out() const;
  inline void set_time_ns_out(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:draiosproto.counter_time_bidirectional)
 private:
  inline void set_has_count_in();
  inline void clear_has_count_in();
  inline void set_has_count_out();
  inline void clear_has_count_out();
  inline void set_has_time_ns_in();
  inline void clear_has_time_ns_in();
  inline void set_has_time_ns_out();
  inline void clear_has_time_ns_out();

  ::google::protobuf::uint32 count_in_;
  ::google::protobuf::uint32 count_out_;
  ::google::protobuf::uint64 time_ns_in_;
  ::google::protobuf::uint64 time_ns_out_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_draios_2eproto();
  #endif
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static counter_time_bidirectional* default_instance_;
};
// -------------------------------------------------------------------

class counter_bytes : public ::google::protobuf::MessageLite {
 public:
  counter_bytes();
  virtual ~counter_bytes();

  counter_bytes(const counter_bytes& from);

  inline counter_bytes& operator=(const counter_bytes& from) {
    CopyFrom(from);
    return *this;
  }

  static const counter_bytes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const counter_bytes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(counter_bytes* other);

  // implements Message ----------------------------------------------

  counter_bytes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const counter_bytes& from);
  void MergeFrom(const counter_bytes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 count_in = 1;
  inline bool has_count_in() const;
  inline void clear_count_in();
  static const int kCountInFieldNumber = 1;
  inline ::google::protobuf::uint32 count_in() const;
  inline void set_count_in(::google::protobuf::uint32 value);

  // required uint32 count_out = 2;
  inline bool has_count_out() const;
  inline void clear_count_out();
  static const int kCountOutFieldNumber = 2;
  inline ::google::protobuf::uint32 count_out() const;
  inline void set_count_out(::google::protobuf::uint32 value);

  // required uint32 bytes_in = 3;
  inline bool has_bytes_in() const;
  inline void clear_bytes_in();
  static const int kBytesInFieldNumber = 3;
  inline ::google::protobuf::uint32 bytes_in() const;
  inline void set_bytes_in(::google::protobuf::uint32 value);

  // required uint32 bytes_out = 4;
  inline bool has_bytes_out() const;
  inline void clear_bytes_out();
  static const int kBytesOutFieldNumber = 4;
  inline ::google::protobuf::uint32 bytes_out() const;
  inline void set_bytes_out(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.counter_bytes)
 private:
  inline void set_has_count_in();
  inline void clear_has_count_in();
  inline void set_has_count_out();
  inline void clear_has_count_out();
  inline void set_has_bytes_in();
  inline void clear_has_bytes_in();
  inline void set_has_bytes_out();
  inline void clear_has_bytes_out();

  ::google::protobuf::uint32 count_in_;
  ::google::protobuf::uint32 count_out_;
  ::google::protobuf::uint32 bytes_in_;
  ::google::protobuf::uint32 bytes_out_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_draios_2eproto();
  #endif
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static counter_bytes* default_instance_;
};
// -------------------------------------------------------------------

class counter_time_bytes : public ::google::protobuf::MessageLite {
 public:
  counter_time_bytes();
  virtual ~counter_time_bytes();

  counter_time_bytes(const counter_time_bytes& from);

  inline counter_time_bytes& operator=(const counter_time_bytes& from) {
    CopyFrom(from);
    return *this;
  }

  static const counter_time_bytes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const counter_time_bytes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(counter_time_bytes* other);

  // implements Message ----------------------------------------------

  counter_time_bytes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const counter_time_bytes& from);
  void MergeFrom(const counter_time_bytes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 time_ns_in = 1;
  inline bool has_time_ns_in() const;
  inline void clear_time_ns_in();
  static const int kTimeNsInFieldNumber = 1;
  inline ::google::protobuf::uint64 time_ns_in() const;
  inline void set_time_ns_in(::google::protobuf::uint64 value);

  // required uint64 time_ns_out = 2;
  inline bool has_time_ns_out() const;
  inline void clear_time_ns_out();
  static const int kTimeNsOutFieldNumber = 2;
  inline ::google::protobuf::uint64 time_ns_out() const;
  inline void set_time_ns_out(::google::protobuf::uint64 value);

  // required uint64 time_ns_other = 3;
  inline bool has_time_ns_other() const;
  inline void clear_time_ns_other();
  static const int kTimeNsOtherFieldNumber = 3;
  inline ::google::protobuf::uint64 time_ns_other() const;
  inline void set_time_ns_other(::google::protobuf::uint64 value);

  // required uint32 count_in = 4;
  inline bool has_count_in() const;
  inline void clear_count_in();
  static const int kCountInFieldNumber = 4;
  inline ::google::protobuf::uint32 count_in() const;
  inline void set_count_in(::google::protobuf::uint32 value);

  // required uint32 count_out = 5;
  inline bool has_count_out() const;
  inline void clear_count_out();
  static const int kCountOutFieldNumber = 5;
  inline ::google::protobuf::uint32 count_out() const;
  inline void set_count_out(::google::protobuf::uint32 value);

  // required uint32 count_other = 6;
  inline bool has_count_other() const;
  inline void clear_count_other();
  static const int kCountOtherFieldNumber = 6;
  inline ::google::protobuf::uint32 count_other() const;
  inline void set_count_other(::google::protobuf::uint32 value);

  // required uint32 bytes_in = 7;
  inline bool has_bytes_in() const;
  inline void clear_bytes_in();
  static const int kBytesInFieldNumber = 7;
  inline ::google::protobuf::uint32 bytes_in() const;
  inline void set_bytes_in(::google::protobuf::uint32 value);

  // required uint32 bytes_out = 8;
  inline bool has_bytes_out() const;
  inline void clear_bytes_out();
  static const int kBytesOutFieldNumber = 8;
  inline ::google::protobuf::uint32 bytes_out() const;
  inline void set_bytes_out(::google::protobuf::uint32 value);

  // required uint32 bytes_other = 9;
  inline bool has_bytes_other() const;
  inline void clear_bytes_other();
  static const int kBytesOtherFieldNumber = 9;
  inline ::google::protobuf::uint32 bytes_other() const;
  inline void set_bytes_other(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.counter_time_bytes)
 private:
  inline void set_has_time_ns_in();
  inline void clear_has_time_ns_in();
  inline void set_has_time_ns_out();
  inline void clear_has_time_ns_out();
  inline void set_has_time_ns_other();
  inline void clear_has_time_ns_other();
  inline void set_has_count_in();
  inline void clear_has_count_in();
  inline void set_has_count_out();
  inline void clear_has_count_out();
  inline void set_has_count_other();
  inline void clear_has_count_other();
  inline void set_has_bytes_in();
  inline void clear_has_bytes_in();
  inline void set_has_bytes_out();
  inline void clear_has_bytes_out();
  inline void set_has_bytes_other();
  inline void clear_has_bytes_other();

  ::google::protobuf::uint64 time_ns_in_;
  ::google::protobuf::uint64 time_ns_out_;
  ::google::protobuf::uint64 time_ns_other_;
  ::google::protobuf::uint32 count_in_;
  ::google::protobuf::uint32 count_out_;
  ::google::protobuf::uint32 count_other_;
  ::google::protobuf::uint32 bytes_in_;
  ::google::protobuf::uint32 bytes_out_;
  ::google::protobuf::uint32 bytes_other_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_draios_2eproto();
  #endif
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static counter_time_bytes* default_instance_;
};
// -------------------------------------------------------------------

class time_categories : public ::google::protobuf::MessageLite {
 public:
  time_categories();
  virtual ~time_categories();

  time_categories(const time_categories& from);

  inline time_categories& operator=(const time_categories& from) {
    CopyFrom(from);
    return *this;
  }

  static const time_categories& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const time_categories* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(time_categories* other);

  // implements Message ----------------------------------------------

  time_categories* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const time_categories& from);
  void MergeFrom(const time_categories& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .draiosproto.counter_time unknown = 1;
  inline bool has_unknown() const;
  inline void clear_unknown();
  static const int kUnknownFieldNumber = 1;
  inline const ::draiosproto::counter_time& unknown() const;
  inline ::draiosproto::counter_time* mutable_unknown();
  inline ::draiosproto::counter_time* release_unknown();
  inline void set_allocated_unknown(::draiosproto::counter_time* unknown);

  // optional .draiosproto.counter_time other = 2;
  inline bool has_other() const;
  inline void clear_other();
  static const int kOtherFieldNumber = 2;
  inline const ::draiosproto::counter_time& other() const;
  inline ::draiosproto::counter_time* mutable_other();
  inline ::draiosproto::counter_time* release_other();
  inline void set_allocated_other(::draiosproto::counter_time* other);

  // optional .draiosproto.counter_time file = 3;
  inline bool has_file() const;
  inline void clear_file();
  static const int kFileFieldNumber = 3;
  inline const ::draiosproto::counter_time& file() const;
  inline ::draiosproto::counter_time* mutable_file();
  inline ::draiosproto::counter_time* release_file();
  inline void set_allocated_file(::draiosproto::counter_time* file);

  // optional .draiosproto.counter_time net = 4;
  inline bool has_net() const;
  inline void clear_net();
  static const int kNetFieldNumber = 4;
  inline const ::draiosproto::counter_time& net() const;
  inline ::draiosproto::counter_time* mutable_net();
  inline ::draiosproto::counter_time* release_net();
  inline void set_allocated_net(::draiosproto::counter_time* net);

  // optional .draiosproto.counter_time ipc = 5;
  inline bool has_ipc() const;
  inline void clear_ipc();
  static const int kIpcFieldNumber = 5;
  inline const ::draiosproto::counter_time& ipc() const;
  inline ::draiosproto::counter_time* mutable_ipc();
  inline ::draiosproto::counter_time* release_ipc();
  inline void set_allocated_ipc(::draiosproto::counter_time* ipc);

  // optional .draiosproto.counter_time memory = 6;
  inline bool has_memory() const;
  inline void clear_memory();
  static const int kMemoryFieldNumber = 6;
  inline const ::draiosproto::counter_time& memory() const;
  inline ::draiosproto::counter_time* mutable_memory();
  inline ::draiosproto::counter_time* release_memory();
  inline void set_allocated_memory(::draiosproto::counter_time* memory);

  // optional .draiosproto.counter_time process = 7;
  inline bool has_process() const;
  inline void clear_process();
  static const int kProcessFieldNumber = 7;
  inline const ::draiosproto::counter_time& process() const;
  inline ::draiosproto::counter_time* mutable_process();
  inline ::draiosproto::counter_time* release_process();
  inline void set_allocated_process(::draiosproto::counter_time* process);

  // optional .draiosproto.counter_time sleep = 8;
  inline bool has_sleep() const;
  inline void clear_sleep();
  static const int kSleepFieldNumber = 8;
  inline const ::draiosproto::counter_time& sleep() const;
  inline ::draiosproto::counter_time* mutable_sleep();
  inline ::draiosproto::counter_time* release_sleep();
  inline void set_allocated_sleep(::draiosproto::counter_time* sleep);

  // optional .draiosproto.counter_time system = 9;
  inline bool has_system() const;
  inline void clear_system();
  static const int kSystemFieldNumber = 9;
  inline const ::draiosproto::counter_time& system() const;
  inline ::draiosproto::counter_time* mutable_system();
  inline ::draiosproto::counter_time* release_system();
  inline void set_allocated_system(::draiosproto::counter_time* system);

  // optional .draiosproto.counter_time signal = 10;
  inline bool has_signal() const;
  inline void clear_signal();
  static const int kSignalFieldNumber = 10;
  inline const ::draiosproto::counter_time& signal() const;
  inline ::draiosproto::counter_time* mutable_signal();
  inline ::draiosproto::counter_time* release_signal();
  inline void set_allocated_signal(::draiosproto::counter_time* signal);

  // optional .draiosproto.counter_time user = 11;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 11;
  inline const ::draiosproto::counter_time& user() const;
  inline ::draiosproto::counter_time* mutable_user();
  inline ::draiosproto::counter_time* release_user();
  inline void set_allocated_user(::draiosproto::counter_time* user);

  // optional .draiosproto.counter_time time = 12;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 12;
  inline const ::draiosproto::counter_time& time() const;
  inline ::draiosproto::counter_time* mutable_time();
  inline ::draiosproto::counter_time* release_time();
  inline void set_allocated_time(::draiosproto::counter_time* time);

  // optional .draiosproto.counter_time_bytes io_file = 13;
  inline bool has_io_file() const;
  inline void clear_io_file();
  static const int kIoFileFieldNumber = 13;
  inline const ::draiosproto::counter_time_bytes& io_file() const;
  inline ::draiosproto::counter_time_bytes* mutable_io_file();
  inline ::draiosproto::counter_time_bytes* release_io_file();
  inline void set_allocated_io_file(::draiosproto::counter_time_bytes* io_file);

  // optional .draiosproto.counter_time_bytes io_net = 14;
  inline bool has_io_net() const;
  inline void clear_io_net();
  static const int kIoNetFieldNumber = 14;
  inline const ::draiosproto::counter_time_bytes& io_net() const;
  inline ::draiosproto::counter_time_bytes* mutable_io_net();
  inline ::draiosproto::counter_time_bytes* release_io_net();
  inline void set_allocated_io_net(::draiosproto::counter_time_bytes* io_net);

  // optional .draiosproto.counter_time_bytes io_other = 15;
  inline bool has_io_other() const;
  inline void clear_io_other();
  static const int kIoOtherFieldNumber = 15;
  inline const ::draiosproto::counter_time_bytes& io_other() const;
  inline ::draiosproto::counter_time_bytes* mutable_io_other();
  inline ::draiosproto::counter_time_bytes* release_io_other();
  inline void set_allocated_io_other(::draiosproto::counter_time_bytes* io_other);

  // optional .draiosproto.counter_time wait = 16;
  inline bool has_wait() const;
  inline void clear_wait();
  static const int kWaitFieldNumber = 16;
  inline const ::draiosproto::counter_time& wait() const;
  inline ::draiosproto::counter_time* mutable_wait();
  inline ::draiosproto::counter_time* release_wait();
  inline void set_allocated_wait(::draiosproto::counter_time* wait);

  // optional .draiosproto.counter_time processing = 17;
  inline bool has_processing() const;
  inline void clear_processing();
  static const int kProcessingFieldNumber = 17;
  inline const ::draiosproto::counter_time& processing() const;
  inline ::draiosproto::counter_time* mutable_processing();
  inline ::draiosproto::counter_time* release_processing();
  inline void set_allocated_processing(::draiosproto::counter_time* processing);

  // @@protoc_insertion_point(class_scope:draiosproto.time_categories)
 private:
  inline void set_has_unknown();
  inline void clear_has_unknown();
  inline void set_has_other();
  inline void clear_has_other();
  inline void set_has_file();
  inline void clear_has_file();
  inline void set_has_net();
  inline void clear_has_net();
  inline void set_has_ipc();
  inline void clear_has_ipc();
  inline void set_has_memory();
  inline void clear_has_memory();
  inline void set_has_process();
  inline void clear_has_process();
  inline void set_has_sleep();
  inline void clear_has_sleep();
  inline void set_has_system();
  inline void clear_has_system();
  inline void set_has_signal();
  inline void clear_has_signal();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_io_file();
  inline void clear_has_io_file();
  inline void set_has_io_net();
  inline void clear_has_io_net();
  inline void set_has_io_other();
  inline void clear_has_io_other();
  inline void set_has_wait();
  inline void clear_has_wait();
  inline void set_has_processing();
  inline void clear_has_processing();

  ::draiosproto::counter_time* unknown_;
  ::draiosproto::counter_time* other_;
  ::draiosproto::counter_time* file_;
  ::draiosproto::counter_time* net_;
  ::draiosproto::counter_time* ipc_;
  ::draiosproto::counter_time* memory_;
  ::draiosproto::counter_time* process_;
  ::draiosproto::counter_time* sleep_;
  ::draiosproto::counter_time* system_;
  ::draiosproto::counter_time* signal_;
  ::draiosproto::counter_time* user_;
  ::draiosproto::counter_time* time_;
  ::draiosproto::counter_time_bytes* io_file_;
  ::draiosproto::counter_time_bytes* io_net_;
  ::draiosproto::counter_time_bytes* io_other_;
  ::draiosproto::counter_time* wait_;
  ::draiosproto::counter_time* processing_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_draios_2eproto();
  #endif
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static time_categories* default_instance_;
};
// -------------------------------------------------------------------

class counter_syscall_errors : public ::google::protobuf::MessageLite {
 public:
  counter_syscall_errors();
  virtual ~counter_syscall_errors();

  counter_syscall_errors(const counter_syscall_errors& from);

  inline counter_syscall_errors& operator=(const counter_syscall_errors& from) {
    CopyFrom(from);
    return *this;
  }

  static const counter_syscall_errors& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const counter_syscall_errors* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(counter_syscall_errors* other);

  // implements Message ----------------------------------------------

  counter_syscall_errors* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const counter_syscall_errors& from);
  void MergeFrom(const counter_syscall_errors& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated uint32 top_error_codes = 2;
  inline int top_error_codes_size() const;
  inline void clear_top_error_codes();
  static const int kTopErrorCodesFieldNumber = 2;
  inline ::google::protobuf::uint32 top_error_codes(int index) const;
  inline void set_top_error_codes(int index, ::google::protobuf::uint32 value);
  inline void add_top_error_codes(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      top_error_codes() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_top_error_codes();

  // @@protoc_insertion_point(class_scope:draiosproto.counter_syscall_errors)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > top_error_codes_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_draios_2eproto();
  #endif
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static counter_syscall_errors* default_instance_;
};
// -------------------------------------------------------------------

class resource_categories : public ::google::protobuf::MessageLite {
 public:
  resource_categories();
  virtual ~resource_categories();

  resource_categories(const resource_categories& from);

  inline resource_categories& operator=(const resource_categories& from) {
    CopyFrom(from);
    return *this;
  }

  static const resource_categories& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const resource_categories* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(resource_categories* other);

  // implements Message ----------------------------------------------

  resource_categories* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const resource_categories& from);
  void MergeFrom(const resource_categories& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 capacity_score = 1;
  inline bool has_capacity_score() const;
  inline void clear_capacity_score();
  static const int kCapacityScoreFieldNumber = 1;
  inline ::google::protobuf::uint32 capacity_score() const;
  inline void set_capacity_score(::google::protobuf::uint32 value);

  // optional uint32 connection_queue_usage_pct = 2;
  inline bool has_connection_queue_usage_pct() const;
  inline void clear_connection_queue_usage_pct();
  static const int kConnectionQueueUsagePctFieldNumber = 2;
  inline ::google::protobuf::uint32 connection_queue_usage_pct() const;
  inline void set_connection_queue_usage_pct(::google::protobuf::uint32 value);

  // optional uint32 fd_usage_pct = 3;
  inline bool has_fd_usage_pct() const;
  inline void clear_fd_usage_pct();
  static const int kFdUsagePctFieldNumber = 3;
  inline ::google::protobuf::uint32 fd_usage_pct() const;
  inline void set_fd_usage_pct(::google::protobuf::uint32 value);

  // optional uint32 cpu_pct = 4;
  inline bool has_cpu_pct() const;
  inline void clear_cpu_pct();
  static const int kCpuPctFieldNumber = 4;
  inline ::google::protobuf::uint32 cpu_pct() const;
  inline void set_cpu_pct(::google::protobuf::uint32 value);

  // optional uint64 resident_memory_usage_kb = 5;
  inline bool has_resident_memory_usage_kb() const;
  inline void clear_resident_memory_usage_kb();
  static const int kResidentMemoryUsageKbFieldNumber = 5;
  inline ::google::protobuf::uint64 resident_memory_usage_kb() const;
  inline void set_resident_memory_usage_kb(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:draiosproto.resource_categories)
 private:
  inline void set_has_capacity_score();
  inline void clear_has_capacity_score();
  inline void set_has_connection_queue_usage_pct();
  inline void clear_has_connection_queue_usage_pct();
  inline void set_has_fd_usage_pct();
  inline void clear_has_fd_usage_pct();
  inline void set_has_cpu_pct();
  inline void clear_has_cpu_pct();
  inline void set_has_resident_memory_usage_kb();
  inline void clear_has_resident_memory_usage_kb();

  ::google::protobuf::uint32 capacity_score_;
  ::google::protobuf::uint32 connection_queue_usage_pct_;
  ::google::protobuf::uint32 fd_usage_pct_;
  ::google::protobuf::uint32 cpu_pct_;
  ::google::protobuf::uint64 resident_memory_usage_kb_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_draios_2eproto();
  #endif
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static resource_categories* default_instance_;
};
// -------------------------------------------------------------------

class connection_categories : public ::google::protobuf::MessageLite {
 public:
  connection_categories();
  virtual ~connection_categories();

  connection_categories(const connection_categories& from);

  inline connection_categories& operator=(const connection_categories& from) {
    CopyFrom(from);
    return *this;
  }

  static const connection_categories& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const connection_categories* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(connection_categories* other);

  // implements Message ----------------------------------------------

  connection_categories* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const connection_categories& from);
  void MergeFrom(const connection_categories& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .draiosproto.counter_bytes server = 1;
  inline bool has_server() const;
  inline void clear_server();
  static const int kServerFieldNumber = 1;
  inline const ::draiosproto::counter_bytes& server() const;
  inline ::draiosproto::counter_bytes* mutable_server();
  inline ::draiosproto::counter_bytes* release_server();
  inline void set_allocated_server(::draiosproto::counter_bytes* server);

  // optional .draiosproto.counter_bytes client = 2;
  inline bool has_client() const;
  inline void clear_client();
  static const int kClientFieldNumber = 2;
  inline const ::draiosproto::counter_bytes& client() const;
  inline ::draiosproto::counter_bytes* mutable_client();
  inline ::draiosproto::counter_bytes* release_client();
  inline void set_allocated_client(::draiosproto::counter_bytes* client);

  // optional .draiosproto.counter_time_bidirectional transaction_counters = 3;
  inline bool has_transaction_counters() const;
  inline void clear_transaction_counters();
  static const int kTransactionCountersFieldNumber = 3;
  inline const ::draiosproto::counter_time_bidirectional& transaction_counters() const;
  inline ::draiosproto::counter_time_bidirectional* mutable_transaction_counters();
  inline ::draiosproto::counter_time_bidirectional* release_transaction_counters();
  inline void set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters);

  // optional uint32 n_aggregated_connections = 4;
  inline bool has_n_aggregated_connections() const;
  inline void clear_n_aggregated_connections();
  static const int kNAggregatedConnectionsFieldNumber = 4;
  inline ::google::protobuf::uint32 n_aggregated_connections() const;
  inline void set_n_aggregated_connections(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.connection_categories)
 private:
  inline void set_has_server();
  inline void clear_has_server();
  inline void set_has_client();
  inline void clear_has_client();
  inline void set_has_transaction_counters();
  inline void clear_has_transaction_counters();
  inline void set_has_n_aggregated_connections();
  inline void clear_has_n_aggregated_connections();

  ::draiosproto::counter_bytes* server_;
  ::draiosproto::counter_bytes* client_;
  ::draiosproto::counter_time_bidirectional* transaction_counters_;
  ::google::protobuf::uint32 n_aggregated_connections_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_draios_2eproto();
  #endif
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static connection_categories* default_instance_;
};
// -------------------------------------------------------------------

class host : public ::google::protobuf::MessageLite {
 public:
  host();
  virtual ~host();

  host(const host& from);

  inline host& operator=(const host& from) {
    CopyFrom(from);
    return *this;
  }

  static const host& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const host* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(host* other);

  // implements Message ----------------------------------------------

  host* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const host& from);
  void MergeFrom(const host& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string hostname = 1;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional uint32 num_cpus = 2;
  inline bool has_num_cpus() const;
  inline void clear_num_cpus();
  static const int kNumCpusFieldNumber = 2;
  inline ::google::protobuf::uint32 num_cpus() const;
  inline void set_num_cpus(::google::protobuf::uint32 value);

  // repeated uint32 cpu_loads = 3;
  inline int cpu_loads_size() const;
  inline void clear_cpu_loads();
  static const int kCpuLoadsFieldNumber = 3;
  inline ::google::protobuf::uint32 cpu_loads(int index) const;
  inline void set_cpu_loads(int index, ::google::protobuf::uint32 value);
  inline void add_cpu_loads(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      cpu_loads() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_cpu_loads();

  // required uint64 physical_memory_size_bytes = 4;
  inline bool has_physical_memory_size_bytes() const;
  inline void clear_physical_memory_size_bytes();
  static const int kPhysicalMemorySizeBytesFieldNumber = 4;
  inline ::google::protobuf::uint64 physical_memory_size_bytes() const;
  inline void set_physical_memory_size_bytes(::google::protobuf::uint64 value);

  // optional .draiosproto.time_categories tcounters = 5;
  inline bool has_tcounters() const;
  inline void clear_tcounters();
  static const int kTcountersFieldNumber = 5;
  inline const ::draiosproto::time_categories& tcounters() const;
  inline ::draiosproto::time_categories* mutable_tcounters();
  inline ::draiosproto::time_categories* release_tcounters();
  inline void set_allocated_tcounters(::draiosproto::time_categories* tcounters);

  // optional .draiosproto.counter_time_bidirectional transaction_counters = 6;
  inline bool has_transaction_counters() const;
  inline void clear_transaction_counters();
  static const int kTransactionCountersFieldNumber = 6;
  inline const ::draiosproto::counter_time_bidirectional& transaction_counters() const;
  inline ::draiosproto::counter_time_bidirectional* mutable_transaction_counters();
  inline ::draiosproto::counter_time_bidirectional* release_transaction_counters();
  inline void set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters);

  // optional uint64 transaction_processing_delay = 7;
  inline bool has_transaction_processing_delay() const;
  inline void clear_transaction_processing_delay();
  static const int kTransactionProcessingDelayFieldNumber = 7;
  inline ::google::protobuf::uint64 transaction_processing_delay() const;
  inline void set_transaction_processing_delay(::google::protobuf::uint64 value);

  // optional .draiosproto.resource_categories resource_counters = 8;
  inline bool has_resource_counters() const;
  inline void clear_resource_counters();
  static const int kResourceCountersFieldNumber = 8;
  inline const ::draiosproto::resource_categories& resource_counters() const;
  inline ::draiosproto::resource_categories* mutable_resource_counters();
  inline ::draiosproto::resource_categories* release_resource_counters();
  inline void set_allocated_resource_counters(::draiosproto::resource_categories* resource_counters);

  // optional .draiosproto.counter_syscall_errors syscall_errors = 9;
  inline bool has_syscall_errors() const;
  inline void clear_syscall_errors();
  static const int kSyscallErrorsFieldNumber = 9;
  inline const ::draiosproto::counter_syscall_errors& syscall_errors() const;
  inline ::draiosproto::counter_syscall_errors* mutable_syscall_errors();
  inline ::draiosproto::counter_syscall_errors* release_syscall_errors();
  inline void set_allocated_syscall_errors(::draiosproto::counter_syscall_errors* syscall_errors);

  // @@protoc_insertion_point(class_scope:draiosproto.host)
 private:
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_num_cpus();
  inline void clear_has_num_cpus();
  inline void set_has_physical_memory_size_bytes();
  inline void clear_has_physical_memory_size_bytes();
  inline void set_has_tcounters();
  inline void clear_has_tcounters();
  inline void set_has_transaction_counters();
  inline void clear_has_transaction_counters();
  inline void set_has_transaction_processing_delay();
  inline void clear_has_transaction_processing_delay();
  inline void set_has_resource_counters();
  inline void clear_has_resource_counters();
  inline void set_has_syscall_errors();
  inline void clear_has_syscall_errors();

  ::std::string* hostname_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > cpu_loads_;
  ::google::protobuf::uint64 physical_memory_size_bytes_;
  ::draiosproto::time_categories* tcounters_;
  ::draiosproto::counter_time_bidirectional* transaction_counters_;
  ::google::protobuf::uint64 transaction_processing_delay_;
  ::draiosproto::resource_categories* resource_counters_;
  ::draiosproto::counter_syscall_errors* syscall_errors_;
  ::google::protobuf::uint32 num_cpus_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_draios_2eproto();
  #endif
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static host* default_instance_;
};
// -------------------------------------------------------------------

class process : public ::google::protobuf::MessageLite {
 public:
  process();
  virtual ~process();

  process(const process& from);

  inline process& operator=(const process& from) {
    CopyFrom(from);
    return *this;
  }

  static const process& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const process* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(process* other);

  // implements Message ----------------------------------------------

  process* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const process& from);
  void MergeFrom(const process& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 pid = 1;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 1;
  inline ::google::protobuf::uint64 pid() const;
  inline void set_pid(::google::protobuf::uint64 value);

  // required string comm = 2;
  inline bool has_comm() const;
  inline void clear_comm();
  static const int kCommFieldNumber = 2;
  inline const ::std::string& comm() const;
  inline void set_comm(const ::std::string& value);
  inline void set_comm(const char* value);
  inline void set_comm(const char* value, size_t size);
  inline ::std::string* mutable_comm();
  inline ::std::string* release_comm();
  inline void set_allocated_comm(::std::string* comm);

  // required string exe = 3;
  inline bool has_exe() const;
  inline void clear_exe();
  static const int kExeFieldNumber = 3;
  inline const ::std::string& exe() const;
  inline void set_exe(const ::std::string& value);
  inline void set_exe(const char* value);
  inline void set_exe(const char* value, size_t size);
  inline ::std::string* mutable_exe();
  inline ::std::string* release_exe();
  inline void set_allocated_exe(::std::string* exe);

  // repeated string args = 4;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 4;
  inline const ::std::string& args(int index) const;
  inline ::std::string* mutable_args(int index);
  inline void set_args(int index, const ::std::string& value);
  inline void set_args(int index, const char* value);
  inline void set_args(int index, const char* value, size_t size);
  inline ::std::string* add_args();
  inline void add_args(const ::std::string& value);
  inline void add_args(const char* value);
  inline void add_args(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& args() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_args();

  // optional bool is_transaction_server = 5;
  inline bool has_is_transaction_server() const;
  inline void clear_is_transaction_server();
  static const int kIsTransactionServerFieldNumber = 5;
  inline bool is_transaction_server() const;
  inline void set_is_transaction_server(bool value);

  // optional .draiosproto.time_categories tcounters = 6;
  inline bool has_tcounters() const;
  inline void clear_tcounters();
  static const int kTcountersFieldNumber = 6;
  inline const ::draiosproto::time_categories& tcounters() const;
  inline ::draiosproto::time_categories* mutable_tcounters();
  inline ::draiosproto::time_categories* release_tcounters();
  inline void set_allocated_tcounters(::draiosproto::time_categories* tcounters);

  // optional .draiosproto.counter_time_bidirectional transaction_counters = 7;
  inline bool has_transaction_counters() const;
  inline void clear_transaction_counters();
  static const int kTransactionCountersFieldNumber = 7;
  inline const ::draiosproto::counter_time_bidirectional& transaction_counters() const;
  inline ::draiosproto::counter_time_bidirectional* mutable_transaction_counters();
  inline ::draiosproto::counter_time_bidirectional* release_transaction_counters();
  inline void set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters);

  // optional uint64 transaction_processing_delay = 8;
  inline bool has_transaction_processing_delay() const;
  inline void clear_transaction_processing_delay();
  static const int kTransactionProcessingDelayFieldNumber = 8;
  inline ::google::protobuf::uint64 transaction_processing_delay() const;
  inline void set_transaction_processing_delay(::google::protobuf::uint64 value);

  // optional .draiosproto.resource_categories resource_counters = 9;
  inline bool has_resource_counters() const;
  inline void clear_resource_counters();
  static const int kResourceCountersFieldNumber = 9;
  inline const ::draiosproto::resource_categories& resource_counters() const;
  inline ::draiosproto::resource_categories* mutable_resource_counters();
  inline ::draiosproto::resource_categories* release_resource_counters();
  inline void set_allocated_resource_counters(::draiosproto::resource_categories* resource_counters);

  // optional .draiosproto.counter_syscall_errors syscall_errors = 10;
  inline bool has_syscall_errors() const;
  inline void clear_syscall_errors();
  static const int kSyscallErrorsFieldNumber = 10;
  inline const ::draiosproto::counter_syscall_errors& syscall_errors() const;
  inline ::draiosproto::counter_syscall_errors* mutable_syscall_errors();
  inline ::draiosproto::counter_syscall_errors* release_syscall_errors();
  inline void set_allocated_syscall_errors(::draiosproto::counter_syscall_errors* syscall_errors);

  // @@protoc_insertion_point(class_scope:draiosproto.process)
 private:
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_comm();
  inline void clear_has_comm();
  inline void set_has_exe();
  inline void clear_has_exe();
  inline void set_has_is_transaction_server();
  inline void clear_has_is_transaction_server();
  inline void set_has_tcounters();
  inline void clear_has_tcounters();
  inline void set_has_transaction_counters();
  inline void clear_has_transaction_counters();
  inline void set_has_transaction_processing_delay();
  inline void clear_has_transaction_processing_delay();
  inline void set_has_resource_counters();
  inline void clear_has_resource_counters();
  inline void set_has_syscall_errors();
  inline void clear_has_syscall_errors();

  ::google::protobuf::uint64 pid_;
  ::std::string* comm_;
  ::std::string* exe_;
  ::google::protobuf::RepeatedPtrField< ::std::string> args_;
  ::draiosproto::time_categories* tcounters_;
  ::draiosproto::counter_time_bidirectional* transaction_counters_;
  ::google::protobuf::uint64 transaction_processing_delay_;
  ::draiosproto::resource_categories* resource_counters_;
  ::draiosproto::counter_syscall_errors* syscall_errors_;
  bool is_transaction_server_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_draios_2eproto();
  #endif
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static process* default_instance_;
};
// -------------------------------------------------------------------

class thread : public ::google::protobuf::MessageLite {
 public:
  thread();
  virtual ~thread();

  thread(const thread& from);

  inline thread& operator=(const thread& from) {
    CopyFrom(from);
    return *this;
  }

  static const thread& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const thread* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(thread* other);

  // implements Message ----------------------------------------------

  thread* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const thread& from);
  void MergeFrom(const thread& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 pid = 1;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 1;
  inline ::google::protobuf::uint64 pid() const;
  inline void set_pid(::google::protobuf::uint64 value);

  // required uint64 tid = 2;
  inline bool has_tid() const;
  inline void clear_tid();
  static const int kTidFieldNumber = 2;
  inline ::google::protobuf::uint64 tid() const;
  inline void set_tid(::google::protobuf::uint64 value);

  // optional .draiosproto.time_categories tcounters = 3;
  inline bool has_tcounters() const;
  inline void clear_tcounters();
  static const int kTcountersFieldNumber = 3;
  inline const ::draiosproto::time_categories& tcounters() const;
  inline ::draiosproto::time_categories* mutable_tcounters();
  inline ::draiosproto::time_categories* release_tcounters();
  inline void set_allocated_tcounters(::draiosproto::time_categories* tcounters);

  // optional .draiosproto.counter_time_bidirectional transaction_counters = 5;
  inline bool has_transaction_counters() const;
  inline void clear_transaction_counters();
  static const int kTransactionCountersFieldNumber = 5;
  inline const ::draiosproto::counter_time_bidirectional& transaction_counters() const;
  inline ::draiosproto::counter_time_bidirectional* mutable_transaction_counters();
  inline ::draiosproto::counter_time_bidirectional* release_transaction_counters();
  inline void set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters);

  // @@protoc_insertion_point(class_scope:draiosproto.thread)
 private:
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_tid();
  inline void clear_has_tid();
  inline void set_has_tcounters();
  inline void clear_has_tcounters();
  inline void set_has_transaction_counters();
  inline void clear_has_transaction_counters();

  ::google::protobuf::uint64 pid_;
  ::google::protobuf::uint64 tid_;
  ::draiosproto::time_categories* tcounters_;
  ::draiosproto::counter_time_bidirectional* transaction_counters_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_draios_2eproto();
  #endif
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static thread* default_instance_;
};
// -------------------------------------------------------------------

class ipv4tuple : public ::google::protobuf::MessageLite {
 public:
  ipv4tuple();
  virtual ~ipv4tuple();

  ipv4tuple(const ipv4tuple& from);

  inline ipv4tuple& operator=(const ipv4tuple& from) {
    CopyFrom(from);
    return *this;
  }

  static const ipv4tuple& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ipv4tuple* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ipv4tuple* other);

  // implements Message ----------------------------------------------

  ipv4tuple* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ipv4tuple& from);
  void MergeFrom(const ipv4tuple& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 sip = 1;
  inline bool has_sip() const;
  inline void clear_sip();
  static const int kSipFieldNumber = 1;
  inline ::google::protobuf::uint32 sip() const;
  inline void set_sip(::google::protobuf::uint32 value);

  // required uint32 dip = 2;
  inline bool has_dip() const;
  inline void clear_dip();
  static const int kDipFieldNumber = 2;
  inline ::google::protobuf::uint32 dip() const;
  inline void set_dip(::google::protobuf::uint32 value);

  // required uint32 sport = 3;
  inline bool has_sport() const;
  inline void clear_sport();
  static const int kSportFieldNumber = 3;
  inline ::google::protobuf::uint32 sport() const;
  inline void set_sport(::google::protobuf::uint32 value);

  // required uint32 dport = 4;
  inline bool has_dport() const;
  inline void clear_dport();
  static const int kDportFieldNumber = 4;
  inline ::google::protobuf::uint32 dport() const;
  inline void set_dport(::google::protobuf::uint32 value);

  // required uint32 l4proto = 5;
  inline bool has_l4proto() const;
  inline void clear_l4proto();
  static const int kL4ProtoFieldNumber = 5;
  inline ::google::protobuf::uint32 l4proto() const;
  inline void set_l4proto(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.ipv4tuple)
 private:
  inline void set_has_sip();
  inline void clear_has_sip();
  inline void set_has_dip();
  inline void clear_has_dip();
  inline void set_has_sport();
  inline void clear_has_sport();
  inline void set_has_dport();
  inline void clear_has_dport();
  inline void set_has_l4proto();
  inline void clear_has_l4proto();

  ::google::protobuf::uint32 sip_;
  ::google::protobuf::uint32 dip_;
  ::google::protobuf::uint32 sport_;
  ::google::protobuf::uint32 dport_;
  ::google::protobuf::uint32 l4proto_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_draios_2eproto();
  #endif
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static ipv4tuple* default_instance_;
};
// -------------------------------------------------------------------

class ipv4_connection : public ::google::protobuf::MessageLite {
 public:
  ipv4_connection();
  virtual ~ipv4_connection();

  ipv4_connection(const ipv4_connection& from);

  inline ipv4_connection& operator=(const ipv4_connection& from) {
    CopyFrom(from);
    return *this;
  }

  static const ipv4_connection& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ipv4_connection* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ipv4_connection* other);

  // implements Message ----------------------------------------------

  ipv4_connection* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ipv4_connection& from);
  void MergeFrom(const ipv4_connection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .draiosproto.ipv4tuple tuple = 1;
  inline bool has_tuple() const;
  inline void clear_tuple();
  static const int kTupleFieldNumber = 1;
  inline const ::draiosproto::ipv4tuple& tuple() const;
  inline ::draiosproto::ipv4tuple* mutable_tuple();
  inline ::draiosproto::ipv4tuple* release_tuple();
  inline void set_allocated_tuple(::draiosproto::ipv4tuple* tuple);

  // optional uint64 spid = 2;
  inline bool has_spid() const;
  inline void clear_spid();
  static const int kSpidFieldNumber = 2;
  inline ::google::protobuf::uint64 spid() const;
  inline void set_spid(::google::protobuf::uint64 value);

  // optional uint64 stid = 3;
  inline bool has_stid() const;
  inline void clear_stid();
  static const int kStidFieldNumber = 3;
  inline ::google::protobuf::uint64 stid() const;
  inline void set_stid(::google::protobuf::uint64 value);

  // optional uint64 dpid = 5;
  inline bool has_dpid() const;
  inline void clear_dpid();
  static const int kDpidFieldNumber = 5;
  inline ::google::protobuf::uint64 dpid() const;
  inline void set_dpid(::google::protobuf::uint64 value);

  // optional uint64 dtid = 6;
  inline bool has_dtid() const;
  inline void clear_dtid();
  static const int kDtidFieldNumber = 6;
  inline ::google::protobuf::uint64 dtid() const;
  inline void set_dtid(::google::protobuf::uint64 value);

  // required .draiosproto.connection_categories counters = 8;
  inline bool has_counters() const;
  inline void clear_counters();
  static const int kCountersFieldNumber = 8;
  inline const ::draiosproto::connection_categories& counters() const;
  inline ::draiosproto::connection_categories* mutable_counters();
  inline ::draiosproto::connection_categories* release_counters();
  inline void set_allocated_counters(::draiosproto::connection_categories* counters);

  // @@protoc_insertion_point(class_scope:draiosproto.ipv4_connection)
 private:
  inline void set_has_tuple();
  inline void clear_has_tuple();
  inline void set_has_spid();
  inline void clear_has_spid();
  inline void set_has_stid();
  inline void clear_has_stid();
  inline void set_has_dpid();
  inline void clear_has_dpid();
  inline void set_has_dtid();
  inline void clear_has_dtid();
  inline void set_has_counters();
  inline void clear_has_counters();

  ::draiosproto::ipv4tuple* tuple_;
  ::google::protobuf::uint64 spid_;
  ::google::protobuf::uint64 stid_;
  ::google::protobuf::uint64 dpid_;
  ::google::protobuf::uint64 dtid_;
  ::draiosproto::connection_categories* counters_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_draios_2eproto();
  #endif
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static ipv4_connection* default_instance_;
};
// -------------------------------------------------------------------

class ipv4_network_interface : public ::google::protobuf::MessageLite {
 public:
  ipv4_network_interface();
  virtual ~ipv4_network_interface();

  ipv4_network_interface(const ipv4_network_interface& from);

  inline ipv4_network_interface& operator=(const ipv4_network_interface& from) {
    CopyFrom(from);
    return *this;
  }

  static const ipv4_network_interface& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ipv4_network_interface* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ipv4_network_interface* other);

  // implements Message ----------------------------------------------

  ipv4_network_interface* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ipv4_network_interface& from);
  void MergeFrom(const ipv4_network_interface& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 addr = 2;
  inline bool has_addr() const;
  inline void clear_addr();
  static const int kAddrFieldNumber = 2;
  inline ::google::protobuf::uint32 addr() const;
  inline void set_addr(::google::protobuf::uint32 value);

  // required uint32 netmask = 3;
  inline bool has_netmask() const;
  inline void clear_netmask();
  static const int kNetmaskFieldNumber = 3;
  inline ::google::protobuf::uint32 netmask() const;
  inline void set_netmask(::google::protobuf::uint32 value);

  // optional uint32 bcast = 4;
  inline bool has_bcast() const;
  inline void clear_bcast();
  static const int kBcastFieldNumber = 4;
  inline ::google::protobuf::uint32 bcast() const;
  inline void set_bcast(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:draiosproto.ipv4_network_interface)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_addr();
  inline void clear_has_addr();
  inline void set_has_netmask();
  inline void clear_has_netmask();
  inline void set_has_bcast();
  inline void clear_has_bcast();

  ::std::string* name_;
  ::google::protobuf::uint32 addr_;
  ::google::protobuf::uint32 netmask_;
  ::google::protobuf::uint32 bcast_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_draios_2eproto();
  #endif
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static ipv4_network_interface* default_instance_;
};
// -------------------------------------------------------------------

class metrics : public ::google::protobuf::MessageLite {
 public:
  metrics();
  virtual ~metrics();

  metrics(const metrics& from);

  inline metrics& operator=(const metrics& from) {
    CopyFrom(from);
    return *this;
  }

  static const metrics& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const metrics* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(metrics* other);

  // implements Message ----------------------------------------------

  metrics* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const metrics& from);
  void MergeFrom(const metrics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp_ns = 1;
  inline bool has_timestamp_ns() const;
  inline void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp_ns() const;
  inline void set_timestamp_ns(::google::protobuf::uint64 value);

  // required string machine_id = 2;
  inline bool has_machine_id() const;
  inline void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  inline const ::std::string& machine_id() const;
  inline void set_machine_id(const ::std::string& value);
  inline void set_machine_id(const char* value);
  inline void set_machine_id(const char* value, size_t size);
  inline ::std::string* mutable_machine_id();
  inline ::std::string* release_machine_id();
  inline void set_allocated_machine_id(::std::string* machine_id);

  // required string customer_id = 3;
  inline bool has_customer_id() const;
  inline void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  inline const ::std::string& customer_id() const;
  inline void set_customer_id(const ::std::string& value);
  inline void set_customer_id(const char* value);
  inline void set_customer_id(const char* value, size_t size);
  inline ::std::string* mutable_customer_id();
  inline ::std::string* release_customer_id();
  inline void set_allocated_customer_id(::std::string* customer_id);

  // required .draiosproto.host hostinfo = 4;
  inline bool has_hostinfo() const;
  inline void clear_hostinfo();
  static const int kHostinfoFieldNumber = 4;
  inline const ::draiosproto::host& hostinfo() const;
  inline ::draiosproto::host* mutable_hostinfo();
  inline ::draiosproto::host* release_hostinfo();
  inline void set_allocated_hostinfo(::draiosproto::host* hostinfo);

  // repeated .draiosproto.process processes = 5;
  inline int processes_size() const;
  inline void clear_processes();
  static const int kProcessesFieldNumber = 5;
  inline const ::draiosproto::process& processes(int index) const;
  inline ::draiosproto::process* mutable_processes(int index);
  inline ::draiosproto::process* add_processes();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::process >&
      processes() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::process >*
      mutable_processes();

  // repeated .draiosproto.thread threads = 6;
  inline int threads_size() const;
  inline void clear_threads();
  static const int kThreadsFieldNumber = 6;
  inline const ::draiosproto::thread& threads(int index) const;
  inline ::draiosproto::thread* mutable_threads(int index);
  inline ::draiosproto::thread* add_threads();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::thread >&
      threads() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::thread >*
      mutable_threads();

  // repeated .draiosproto.ipv4_connection ipv4_connections = 7;
  inline int ipv4_connections_size() const;
  inline void clear_ipv4_connections();
  static const int kIpv4ConnectionsFieldNumber = 7;
  inline const ::draiosproto::ipv4_connection& ipv4_connections(int index) const;
  inline ::draiosproto::ipv4_connection* mutable_ipv4_connections(int index);
  inline ::draiosproto::ipv4_connection* add_ipv4_connections();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_connection >&
      ipv4_connections() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_connection >*
      mutable_ipv4_connections();

  // repeated .draiosproto.ipv4_network_interface ipv4_network_interfaces = 8;
  inline int ipv4_network_interfaces_size() const;
  inline void clear_ipv4_network_interfaces();
  static const int kIpv4NetworkInterfacesFieldNumber = 8;
  inline const ::draiosproto::ipv4_network_interface& ipv4_network_interfaces(int index) const;
  inline ::draiosproto::ipv4_network_interface* mutable_ipv4_network_interfaces(int index);
  inline ::draiosproto::ipv4_network_interface* add_ipv4_network_interfaces();
  inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_network_interface >&
      ipv4_network_interfaces() const;
  inline ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_network_interface >*
      mutable_ipv4_network_interfaces();

  // @@protoc_insertion_point(class_scope:draiosproto.metrics)
 private:
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();
  inline void set_has_hostinfo();
  inline void clear_has_hostinfo();

  ::google::protobuf::uint64 timestamp_ns_;
  ::std::string* machine_id_;
  ::std::string* customer_id_;
  ::draiosproto::host* hostinfo_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::process > processes_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::thread > threads_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_connection > ipv4_connections_;
  ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_network_interface > ipv4_network_interfaces_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_draios_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_draios_2eproto();
  #endif
  friend void protobuf_AssignDesc_draios_2eproto();
  friend void protobuf_ShutdownFile_draios_2eproto();

  void InitAsDefaultInstance();
  static metrics* default_instance_;
};
// ===================================================================


// ===================================================================

// counter_time

// required uint32 count = 1;
inline bool counter_time::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void counter_time::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void counter_time::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void counter_time::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 counter_time::count() const {
  return count_;
}
inline void counter_time::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// required uint64 time_ns = 2;
inline bool counter_time::has_time_ns() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void counter_time::set_has_time_ns() {
  _has_bits_[0] |= 0x00000002u;
}
inline void counter_time::clear_has_time_ns() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void counter_time::clear_time_ns() {
  time_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_time_ns();
}
inline ::google::protobuf::uint64 counter_time::time_ns() const {
  return time_ns_;
}
inline void counter_time::set_time_ns(::google::protobuf::uint64 value) {
  set_has_time_ns();
  time_ns_ = value;
}

// -------------------------------------------------------------------

// counter_time_bidirectional

// required uint32 count_in = 1;
inline bool counter_time_bidirectional::has_count_in() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void counter_time_bidirectional::set_has_count_in() {
  _has_bits_[0] |= 0x00000001u;
}
inline void counter_time_bidirectional::clear_has_count_in() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void counter_time_bidirectional::clear_count_in() {
  count_in_ = 0u;
  clear_has_count_in();
}
inline ::google::protobuf::uint32 counter_time_bidirectional::count_in() const {
  return count_in_;
}
inline void counter_time_bidirectional::set_count_in(::google::protobuf::uint32 value) {
  set_has_count_in();
  count_in_ = value;
}

// required uint32 count_out = 2;
inline bool counter_time_bidirectional::has_count_out() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void counter_time_bidirectional::set_has_count_out() {
  _has_bits_[0] |= 0x00000002u;
}
inline void counter_time_bidirectional::clear_has_count_out() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void counter_time_bidirectional::clear_count_out() {
  count_out_ = 0u;
  clear_has_count_out();
}
inline ::google::protobuf::uint32 counter_time_bidirectional::count_out() const {
  return count_out_;
}
inline void counter_time_bidirectional::set_count_out(::google::protobuf::uint32 value) {
  set_has_count_out();
  count_out_ = value;
}

// required uint64 time_ns_in = 3;
inline bool counter_time_bidirectional::has_time_ns_in() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void counter_time_bidirectional::set_has_time_ns_in() {
  _has_bits_[0] |= 0x00000004u;
}
inline void counter_time_bidirectional::clear_has_time_ns_in() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void counter_time_bidirectional::clear_time_ns_in() {
  time_ns_in_ = GOOGLE_ULONGLONG(0);
  clear_has_time_ns_in();
}
inline ::google::protobuf::uint64 counter_time_bidirectional::time_ns_in() const {
  return time_ns_in_;
}
inline void counter_time_bidirectional::set_time_ns_in(::google::protobuf::uint64 value) {
  set_has_time_ns_in();
  time_ns_in_ = value;
}

// required uint64 time_ns_out = 4;
inline bool counter_time_bidirectional::has_time_ns_out() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void counter_time_bidirectional::set_has_time_ns_out() {
  _has_bits_[0] |= 0x00000008u;
}
inline void counter_time_bidirectional::clear_has_time_ns_out() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void counter_time_bidirectional::clear_time_ns_out() {
  time_ns_out_ = GOOGLE_ULONGLONG(0);
  clear_has_time_ns_out();
}
inline ::google::protobuf::uint64 counter_time_bidirectional::time_ns_out() const {
  return time_ns_out_;
}
inline void counter_time_bidirectional::set_time_ns_out(::google::protobuf::uint64 value) {
  set_has_time_ns_out();
  time_ns_out_ = value;
}

// -------------------------------------------------------------------

// counter_bytes

// required uint32 count_in = 1;
inline bool counter_bytes::has_count_in() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void counter_bytes::set_has_count_in() {
  _has_bits_[0] |= 0x00000001u;
}
inline void counter_bytes::clear_has_count_in() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void counter_bytes::clear_count_in() {
  count_in_ = 0u;
  clear_has_count_in();
}
inline ::google::protobuf::uint32 counter_bytes::count_in() const {
  return count_in_;
}
inline void counter_bytes::set_count_in(::google::protobuf::uint32 value) {
  set_has_count_in();
  count_in_ = value;
}

// required uint32 count_out = 2;
inline bool counter_bytes::has_count_out() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void counter_bytes::set_has_count_out() {
  _has_bits_[0] |= 0x00000002u;
}
inline void counter_bytes::clear_has_count_out() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void counter_bytes::clear_count_out() {
  count_out_ = 0u;
  clear_has_count_out();
}
inline ::google::protobuf::uint32 counter_bytes::count_out() const {
  return count_out_;
}
inline void counter_bytes::set_count_out(::google::protobuf::uint32 value) {
  set_has_count_out();
  count_out_ = value;
}

// required uint32 bytes_in = 3;
inline bool counter_bytes::has_bytes_in() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void counter_bytes::set_has_bytes_in() {
  _has_bits_[0] |= 0x00000004u;
}
inline void counter_bytes::clear_has_bytes_in() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void counter_bytes::clear_bytes_in() {
  bytes_in_ = 0u;
  clear_has_bytes_in();
}
inline ::google::protobuf::uint32 counter_bytes::bytes_in() const {
  return bytes_in_;
}
inline void counter_bytes::set_bytes_in(::google::protobuf::uint32 value) {
  set_has_bytes_in();
  bytes_in_ = value;
}

// required uint32 bytes_out = 4;
inline bool counter_bytes::has_bytes_out() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void counter_bytes::set_has_bytes_out() {
  _has_bits_[0] |= 0x00000008u;
}
inline void counter_bytes::clear_has_bytes_out() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void counter_bytes::clear_bytes_out() {
  bytes_out_ = 0u;
  clear_has_bytes_out();
}
inline ::google::protobuf::uint32 counter_bytes::bytes_out() const {
  return bytes_out_;
}
inline void counter_bytes::set_bytes_out(::google::protobuf::uint32 value) {
  set_has_bytes_out();
  bytes_out_ = value;
}

// -------------------------------------------------------------------

// counter_time_bytes

// required uint64 time_ns_in = 1;
inline bool counter_time_bytes::has_time_ns_in() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void counter_time_bytes::set_has_time_ns_in() {
  _has_bits_[0] |= 0x00000001u;
}
inline void counter_time_bytes::clear_has_time_ns_in() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void counter_time_bytes::clear_time_ns_in() {
  time_ns_in_ = GOOGLE_ULONGLONG(0);
  clear_has_time_ns_in();
}
inline ::google::protobuf::uint64 counter_time_bytes::time_ns_in() const {
  return time_ns_in_;
}
inline void counter_time_bytes::set_time_ns_in(::google::protobuf::uint64 value) {
  set_has_time_ns_in();
  time_ns_in_ = value;
}

// required uint64 time_ns_out = 2;
inline bool counter_time_bytes::has_time_ns_out() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void counter_time_bytes::set_has_time_ns_out() {
  _has_bits_[0] |= 0x00000002u;
}
inline void counter_time_bytes::clear_has_time_ns_out() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void counter_time_bytes::clear_time_ns_out() {
  time_ns_out_ = GOOGLE_ULONGLONG(0);
  clear_has_time_ns_out();
}
inline ::google::protobuf::uint64 counter_time_bytes::time_ns_out() const {
  return time_ns_out_;
}
inline void counter_time_bytes::set_time_ns_out(::google::protobuf::uint64 value) {
  set_has_time_ns_out();
  time_ns_out_ = value;
}

// required uint64 time_ns_other = 3;
inline bool counter_time_bytes::has_time_ns_other() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void counter_time_bytes::set_has_time_ns_other() {
  _has_bits_[0] |= 0x00000004u;
}
inline void counter_time_bytes::clear_has_time_ns_other() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void counter_time_bytes::clear_time_ns_other() {
  time_ns_other_ = GOOGLE_ULONGLONG(0);
  clear_has_time_ns_other();
}
inline ::google::protobuf::uint64 counter_time_bytes::time_ns_other() const {
  return time_ns_other_;
}
inline void counter_time_bytes::set_time_ns_other(::google::protobuf::uint64 value) {
  set_has_time_ns_other();
  time_ns_other_ = value;
}

// required uint32 count_in = 4;
inline bool counter_time_bytes::has_count_in() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void counter_time_bytes::set_has_count_in() {
  _has_bits_[0] |= 0x00000008u;
}
inline void counter_time_bytes::clear_has_count_in() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void counter_time_bytes::clear_count_in() {
  count_in_ = 0u;
  clear_has_count_in();
}
inline ::google::protobuf::uint32 counter_time_bytes::count_in() const {
  return count_in_;
}
inline void counter_time_bytes::set_count_in(::google::protobuf::uint32 value) {
  set_has_count_in();
  count_in_ = value;
}

// required uint32 count_out = 5;
inline bool counter_time_bytes::has_count_out() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void counter_time_bytes::set_has_count_out() {
  _has_bits_[0] |= 0x00000010u;
}
inline void counter_time_bytes::clear_has_count_out() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void counter_time_bytes::clear_count_out() {
  count_out_ = 0u;
  clear_has_count_out();
}
inline ::google::protobuf::uint32 counter_time_bytes::count_out() const {
  return count_out_;
}
inline void counter_time_bytes::set_count_out(::google::protobuf::uint32 value) {
  set_has_count_out();
  count_out_ = value;
}

// required uint32 count_other = 6;
inline bool counter_time_bytes::has_count_other() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void counter_time_bytes::set_has_count_other() {
  _has_bits_[0] |= 0x00000020u;
}
inline void counter_time_bytes::clear_has_count_other() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void counter_time_bytes::clear_count_other() {
  count_other_ = 0u;
  clear_has_count_other();
}
inline ::google::protobuf::uint32 counter_time_bytes::count_other() const {
  return count_other_;
}
inline void counter_time_bytes::set_count_other(::google::protobuf::uint32 value) {
  set_has_count_other();
  count_other_ = value;
}

// required uint32 bytes_in = 7;
inline bool counter_time_bytes::has_bytes_in() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void counter_time_bytes::set_has_bytes_in() {
  _has_bits_[0] |= 0x00000040u;
}
inline void counter_time_bytes::clear_has_bytes_in() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void counter_time_bytes::clear_bytes_in() {
  bytes_in_ = 0u;
  clear_has_bytes_in();
}
inline ::google::protobuf::uint32 counter_time_bytes::bytes_in() const {
  return bytes_in_;
}
inline void counter_time_bytes::set_bytes_in(::google::protobuf::uint32 value) {
  set_has_bytes_in();
  bytes_in_ = value;
}

// required uint32 bytes_out = 8;
inline bool counter_time_bytes::has_bytes_out() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void counter_time_bytes::set_has_bytes_out() {
  _has_bits_[0] |= 0x00000080u;
}
inline void counter_time_bytes::clear_has_bytes_out() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void counter_time_bytes::clear_bytes_out() {
  bytes_out_ = 0u;
  clear_has_bytes_out();
}
inline ::google::protobuf::uint32 counter_time_bytes::bytes_out() const {
  return bytes_out_;
}
inline void counter_time_bytes::set_bytes_out(::google::protobuf::uint32 value) {
  set_has_bytes_out();
  bytes_out_ = value;
}

// required uint32 bytes_other = 9;
inline bool counter_time_bytes::has_bytes_other() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void counter_time_bytes::set_has_bytes_other() {
  _has_bits_[0] |= 0x00000100u;
}
inline void counter_time_bytes::clear_has_bytes_other() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void counter_time_bytes::clear_bytes_other() {
  bytes_other_ = 0u;
  clear_has_bytes_other();
}
inline ::google::protobuf::uint32 counter_time_bytes::bytes_other() const {
  return bytes_other_;
}
inline void counter_time_bytes::set_bytes_other(::google::protobuf::uint32 value) {
  set_has_bytes_other();
  bytes_other_ = value;
}

// -------------------------------------------------------------------

// time_categories

// optional .draiosproto.counter_time unknown = 1;
inline bool time_categories::has_unknown() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void time_categories::set_has_unknown() {
  _has_bits_[0] |= 0x00000001u;
}
inline void time_categories::clear_has_unknown() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void time_categories::clear_unknown() {
  if (unknown_ != NULL) unknown_->::draiosproto::counter_time::Clear();
  clear_has_unknown();
}
inline const ::draiosproto::counter_time& time_categories::unknown() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return unknown_ != NULL ? *unknown_ : *default_instance().unknown_;
#else
  return unknown_ != NULL ? *unknown_ : *default_instance_->unknown_;
#endif
}
inline ::draiosproto::counter_time* time_categories::mutable_unknown() {
  set_has_unknown();
  if (unknown_ == NULL) unknown_ = new ::draiosproto::counter_time;
  return unknown_;
}
inline ::draiosproto::counter_time* time_categories::release_unknown() {
  clear_has_unknown();
  ::draiosproto::counter_time* temp = unknown_;
  unknown_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_unknown(::draiosproto::counter_time* unknown) {
  delete unknown_;
  unknown_ = unknown;
  if (unknown) {
    set_has_unknown();
  } else {
    clear_has_unknown();
  }
}

// optional .draiosproto.counter_time other = 2;
inline bool time_categories::has_other() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void time_categories::set_has_other() {
  _has_bits_[0] |= 0x00000002u;
}
inline void time_categories::clear_has_other() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void time_categories::clear_other() {
  if (other_ != NULL) other_->::draiosproto::counter_time::Clear();
  clear_has_other();
}
inline const ::draiosproto::counter_time& time_categories::other() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return other_ != NULL ? *other_ : *default_instance().other_;
#else
  return other_ != NULL ? *other_ : *default_instance_->other_;
#endif
}
inline ::draiosproto::counter_time* time_categories::mutable_other() {
  set_has_other();
  if (other_ == NULL) other_ = new ::draiosproto::counter_time;
  return other_;
}
inline ::draiosproto::counter_time* time_categories::release_other() {
  clear_has_other();
  ::draiosproto::counter_time* temp = other_;
  other_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_other(::draiosproto::counter_time* other) {
  delete other_;
  other_ = other;
  if (other) {
    set_has_other();
  } else {
    clear_has_other();
  }
}

// optional .draiosproto.counter_time file = 3;
inline bool time_categories::has_file() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void time_categories::set_has_file() {
  _has_bits_[0] |= 0x00000004u;
}
inline void time_categories::clear_has_file() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void time_categories::clear_file() {
  if (file_ != NULL) file_->::draiosproto::counter_time::Clear();
  clear_has_file();
}
inline const ::draiosproto::counter_time& time_categories::file() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return file_ != NULL ? *file_ : *default_instance().file_;
#else
  return file_ != NULL ? *file_ : *default_instance_->file_;
#endif
}
inline ::draiosproto::counter_time* time_categories::mutable_file() {
  set_has_file();
  if (file_ == NULL) file_ = new ::draiosproto::counter_time;
  return file_;
}
inline ::draiosproto::counter_time* time_categories::release_file() {
  clear_has_file();
  ::draiosproto::counter_time* temp = file_;
  file_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_file(::draiosproto::counter_time* file) {
  delete file_;
  file_ = file;
  if (file) {
    set_has_file();
  } else {
    clear_has_file();
  }
}

// optional .draiosproto.counter_time net = 4;
inline bool time_categories::has_net() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void time_categories::set_has_net() {
  _has_bits_[0] |= 0x00000008u;
}
inline void time_categories::clear_has_net() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void time_categories::clear_net() {
  if (net_ != NULL) net_->::draiosproto::counter_time::Clear();
  clear_has_net();
}
inline const ::draiosproto::counter_time& time_categories::net() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return net_ != NULL ? *net_ : *default_instance().net_;
#else
  return net_ != NULL ? *net_ : *default_instance_->net_;
#endif
}
inline ::draiosproto::counter_time* time_categories::mutable_net() {
  set_has_net();
  if (net_ == NULL) net_ = new ::draiosproto::counter_time;
  return net_;
}
inline ::draiosproto::counter_time* time_categories::release_net() {
  clear_has_net();
  ::draiosproto::counter_time* temp = net_;
  net_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_net(::draiosproto::counter_time* net) {
  delete net_;
  net_ = net;
  if (net) {
    set_has_net();
  } else {
    clear_has_net();
  }
}

// optional .draiosproto.counter_time ipc = 5;
inline bool time_categories::has_ipc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void time_categories::set_has_ipc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void time_categories::clear_has_ipc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void time_categories::clear_ipc() {
  if (ipc_ != NULL) ipc_->::draiosproto::counter_time::Clear();
  clear_has_ipc();
}
inline const ::draiosproto::counter_time& time_categories::ipc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ipc_ != NULL ? *ipc_ : *default_instance().ipc_;
#else
  return ipc_ != NULL ? *ipc_ : *default_instance_->ipc_;
#endif
}
inline ::draiosproto::counter_time* time_categories::mutable_ipc() {
  set_has_ipc();
  if (ipc_ == NULL) ipc_ = new ::draiosproto::counter_time;
  return ipc_;
}
inline ::draiosproto::counter_time* time_categories::release_ipc() {
  clear_has_ipc();
  ::draiosproto::counter_time* temp = ipc_;
  ipc_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_ipc(::draiosproto::counter_time* ipc) {
  delete ipc_;
  ipc_ = ipc;
  if (ipc) {
    set_has_ipc();
  } else {
    clear_has_ipc();
  }
}

// optional .draiosproto.counter_time memory = 6;
inline bool time_categories::has_memory() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void time_categories::set_has_memory() {
  _has_bits_[0] |= 0x00000020u;
}
inline void time_categories::clear_has_memory() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void time_categories::clear_memory() {
  if (memory_ != NULL) memory_->::draiosproto::counter_time::Clear();
  clear_has_memory();
}
inline const ::draiosproto::counter_time& time_categories::memory() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return memory_ != NULL ? *memory_ : *default_instance().memory_;
#else
  return memory_ != NULL ? *memory_ : *default_instance_->memory_;
#endif
}
inline ::draiosproto::counter_time* time_categories::mutable_memory() {
  set_has_memory();
  if (memory_ == NULL) memory_ = new ::draiosproto::counter_time;
  return memory_;
}
inline ::draiosproto::counter_time* time_categories::release_memory() {
  clear_has_memory();
  ::draiosproto::counter_time* temp = memory_;
  memory_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_memory(::draiosproto::counter_time* memory) {
  delete memory_;
  memory_ = memory;
  if (memory) {
    set_has_memory();
  } else {
    clear_has_memory();
  }
}

// optional .draiosproto.counter_time process = 7;
inline bool time_categories::has_process() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void time_categories::set_has_process() {
  _has_bits_[0] |= 0x00000040u;
}
inline void time_categories::clear_has_process() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void time_categories::clear_process() {
  if (process_ != NULL) process_->::draiosproto::counter_time::Clear();
  clear_has_process();
}
inline const ::draiosproto::counter_time& time_categories::process() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return process_ != NULL ? *process_ : *default_instance().process_;
#else
  return process_ != NULL ? *process_ : *default_instance_->process_;
#endif
}
inline ::draiosproto::counter_time* time_categories::mutable_process() {
  set_has_process();
  if (process_ == NULL) process_ = new ::draiosproto::counter_time;
  return process_;
}
inline ::draiosproto::counter_time* time_categories::release_process() {
  clear_has_process();
  ::draiosproto::counter_time* temp = process_;
  process_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_process(::draiosproto::counter_time* process) {
  delete process_;
  process_ = process;
  if (process) {
    set_has_process();
  } else {
    clear_has_process();
  }
}

// optional .draiosproto.counter_time sleep = 8;
inline bool time_categories::has_sleep() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void time_categories::set_has_sleep() {
  _has_bits_[0] |= 0x00000080u;
}
inline void time_categories::clear_has_sleep() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void time_categories::clear_sleep() {
  if (sleep_ != NULL) sleep_->::draiosproto::counter_time::Clear();
  clear_has_sleep();
}
inline const ::draiosproto::counter_time& time_categories::sleep() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sleep_ != NULL ? *sleep_ : *default_instance().sleep_;
#else
  return sleep_ != NULL ? *sleep_ : *default_instance_->sleep_;
#endif
}
inline ::draiosproto::counter_time* time_categories::mutable_sleep() {
  set_has_sleep();
  if (sleep_ == NULL) sleep_ = new ::draiosproto::counter_time;
  return sleep_;
}
inline ::draiosproto::counter_time* time_categories::release_sleep() {
  clear_has_sleep();
  ::draiosproto::counter_time* temp = sleep_;
  sleep_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_sleep(::draiosproto::counter_time* sleep) {
  delete sleep_;
  sleep_ = sleep;
  if (sleep) {
    set_has_sleep();
  } else {
    clear_has_sleep();
  }
}

// optional .draiosproto.counter_time system = 9;
inline bool time_categories::has_system() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void time_categories::set_has_system() {
  _has_bits_[0] |= 0x00000100u;
}
inline void time_categories::clear_has_system() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void time_categories::clear_system() {
  if (system_ != NULL) system_->::draiosproto::counter_time::Clear();
  clear_has_system();
}
inline const ::draiosproto::counter_time& time_categories::system() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return system_ != NULL ? *system_ : *default_instance().system_;
#else
  return system_ != NULL ? *system_ : *default_instance_->system_;
#endif
}
inline ::draiosproto::counter_time* time_categories::mutable_system() {
  set_has_system();
  if (system_ == NULL) system_ = new ::draiosproto::counter_time;
  return system_;
}
inline ::draiosproto::counter_time* time_categories::release_system() {
  clear_has_system();
  ::draiosproto::counter_time* temp = system_;
  system_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_system(::draiosproto::counter_time* system) {
  delete system_;
  system_ = system;
  if (system) {
    set_has_system();
  } else {
    clear_has_system();
  }
}

// optional .draiosproto.counter_time signal = 10;
inline bool time_categories::has_signal() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void time_categories::set_has_signal() {
  _has_bits_[0] |= 0x00000200u;
}
inline void time_categories::clear_has_signal() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void time_categories::clear_signal() {
  if (signal_ != NULL) signal_->::draiosproto::counter_time::Clear();
  clear_has_signal();
}
inline const ::draiosproto::counter_time& time_categories::signal() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return signal_ != NULL ? *signal_ : *default_instance().signal_;
#else
  return signal_ != NULL ? *signal_ : *default_instance_->signal_;
#endif
}
inline ::draiosproto::counter_time* time_categories::mutable_signal() {
  set_has_signal();
  if (signal_ == NULL) signal_ = new ::draiosproto::counter_time;
  return signal_;
}
inline ::draiosproto::counter_time* time_categories::release_signal() {
  clear_has_signal();
  ::draiosproto::counter_time* temp = signal_;
  signal_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_signal(::draiosproto::counter_time* signal) {
  delete signal_;
  signal_ = signal;
  if (signal) {
    set_has_signal();
  } else {
    clear_has_signal();
  }
}

// optional .draiosproto.counter_time user = 11;
inline bool time_categories::has_user() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void time_categories::set_has_user() {
  _has_bits_[0] |= 0x00000400u;
}
inline void time_categories::clear_has_user() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void time_categories::clear_user() {
  if (user_ != NULL) user_->::draiosproto::counter_time::Clear();
  clear_has_user();
}
inline const ::draiosproto::counter_time& time_categories::user() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_ != NULL ? *user_ : *default_instance().user_;
#else
  return user_ != NULL ? *user_ : *default_instance_->user_;
#endif
}
inline ::draiosproto::counter_time* time_categories::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::draiosproto::counter_time;
  return user_;
}
inline ::draiosproto::counter_time* time_categories::release_user() {
  clear_has_user();
  ::draiosproto::counter_time* temp = user_;
  user_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_user(::draiosproto::counter_time* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
}

// optional .draiosproto.counter_time time = 12;
inline bool time_categories::has_time() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void time_categories::set_has_time() {
  _has_bits_[0] |= 0x00000800u;
}
inline void time_categories::clear_has_time() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void time_categories::clear_time() {
  if (time_ != NULL) time_->::draiosproto::counter_time::Clear();
  clear_has_time();
}
inline const ::draiosproto::counter_time& time_categories::time() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return time_ != NULL ? *time_ : *default_instance().time_;
#else
  return time_ != NULL ? *time_ : *default_instance_->time_;
#endif
}
inline ::draiosproto::counter_time* time_categories::mutable_time() {
  set_has_time();
  if (time_ == NULL) time_ = new ::draiosproto::counter_time;
  return time_;
}
inline ::draiosproto::counter_time* time_categories::release_time() {
  clear_has_time();
  ::draiosproto::counter_time* temp = time_;
  time_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_time(::draiosproto::counter_time* time) {
  delete time_;
  time_ = time;
  if (time) {
    set_has_time();
  } else {
    clear_has_time();
  }
}

// optional .draiosproto.counter_time_bytes io_file = 13;
inline bool time_categories::has_io_file() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void time_categories::set_has_io_file() {
  _has_bits_[0] |= 0x00001000u;
}
inline void time_categories::clear_has_io_file() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void time_categories::clear_io_file() {
  if (io_file_ != NULL) io_file_->::draiosproto::counter_time_bytes::Clear();
  clear_has_io_file();
}
inline const ::draiosproto::counter_time_bytes& time_categories::io_file() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return io_file_ != NULL ? *io_file_ : *default_instance().io_file_;
#else
  return io_file_ != NULL ? *io_file_ : *default_instance_->io_file_;
#endif
}
inline ::draiosproto::counter_time_bytes* time_categories::mutable_io_file() {
  set_has_io_file();
  if (io_file_ == NULL) io_file_ = new ::draiosproto::counter_time_bytes;
  return io_file_;
}
inline ::draiosproto::counter_time_bytes* time_categories::release_io_file() {
  clear_has_io_file();
  ::draiosproto::counter_time_bytes* temp = io_file_;
  io_file_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_io_file(::draiosproto::counter_time_bytes* io_file) {
  delete io_file_;
  io_file_ = io_file;
  if (io_file) {
    set_has_io_file();
  } else {
    clear_has_io_file();
  }
}

// optional .draiosproto.counter_time_bytes io_net = 14;
inline bool time_categories::has_io_net() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void time_categories::set_has_io_net() {
  _has_bits_[0] |= 0x00002000u;
}
inline void time_categories::clear_has_io_net() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void time_categories::clear_io_net() {
  if (io_net_ != NULL) io_net_->::draiosproto::counter_time_bytes::Clear();
  clear_has_io_net();
}
inline const ::draiosproto::counter_time_bytes& time_categories::io_net() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return io_net_ != NULL ? *io_net_ : *default_instance().io_net_;
#else
  return io_net_ != NULL ? *io_net_ : *default_instance_->io_net_;
#endif
}
inline ::draiosproto::counter_time_bytes* time_categories::mutable_io_net() {
  set_has_io_net();
  if (io_net_ == NULL) io_net_ = new ::draiosproto::counter_time_bytes;
  return io_net_;
}
inline ::draiosproto::counter_time_bytes* time_categories::release_io_net() {
  clear_has_io_net();
  ::draiosproto::counter_time_bytes* temp = io_net_;
  io_net_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_io_net(::draiosproto::counter_time_bytes* io_net) {
  delete io_net_;
  io_net_ = io_net;
  if (io_net) {
    set_has_io_net();
  } else {
    clear_has_io_net();
  }
}

// optional .draiosproto.counter_time_bytes io_other = 15;
inline bool time_categories::has_io_other() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void time_categories::set_has_io_other() {
  _has_bits_[0] |= 0x00004000u;
}
inline void time_categories::clear_has_io_other() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void time_categories::clear_io_other() {
  if (io_other_ != NULL) io_other_->::draiosproto::counter_time_bytes::Clear();
  clear_has_io_other();
}
inline const ::draiosproto::counter_time_bytes& time_categories::io_other() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return io_other_ != NULL ? *io_other_ : *default_instance().io_other_;
#else
  return io_other_ != NULL ? *io_other_ : *default_instance_->io_other_;
#endif
}
inline ::draiosproto::counter_time_bytes* time_categories::mutable_io_other() {
  set_has_io_other();
  if (io_other_ == NULL) io_other_ = new ::draiosproto::counter_time_bytes;
  return io_other_;
}
inline ::draiosproto::counter_time_bytes* time_categories::release_io_other() {
  clear_has_io_other();
  ::draiosproto::counter_time_bytes* temp = io_other_;
  io_other_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_io_other(::draiosproto::counter_time_bytes* io_other) {
  delete io_other_;
  io_other_ = io_other;
  if (io_other) {
    set_has_io_other();
  } else {
    clear_has_io_other();
  }
}

// optional .draiosproto.counter_time wait = 16;
inline bool time_categories::has_wait() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void time_categories::set_has_wait() {
  _has_bits_[0] |= 0x00008000u;
}
inline void time_categories::clear_has_wait() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void time_categories::clear_wait() {
  if (wait_ != NULL) wait_->::draiosproto::counter_time::Clear();
  clear_has_wait();
}
inline const ::draiosproto::counter_time& time_categories::wait() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return wait_ != NULL ? *wait_ : *default_instance().wait_;
#else
  return wait_ != NULL ? *wait_ : *default_instance_->wait_;
#endif
}
inline ::draiosproto::counter_time* time_categories::mutable_wait() {
  set_has_wait();
  if (wait_ == NULL) wait_ = new ::draiosproto::counter_time;
  return wait_;
}
inline ::draiosproto::counter_time* time_categories::release_wait() {
  clear_has_wait();
  ::draiosproto::counter_time* temp = wait_;
  wait_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_wait(::draiosproto::counter_time* wait) {
  delete wait_;
  wait_ = wait;
  if (wait) {
    set_has_wait();
  } else {
    clear_has_wait();
  }
}

// optional .draiosproto.counter_time processing = 17;
inline bool time_categories::has_processing() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void time_categories::set_has_processing() {
  _has_bits_[0] |= 0x00010000u;
}
inline void time_categories::clear_has_processing() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void time_categories::clear_processing() {
  if (processing_ != NULL) processing_->::draiosproto::counter_time::Clear();
  clear_has_processing();
}
inline const ::draiosproto::counter_time& time_categories::processing() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return processing_ != NULL ? *processing_ : *default_instance().processing_;
#else
  return processing_ != NULL ? *processing_ : *default_instance_->processing_;
#endif
}
inline ::draiosproto::counter_time* time_categories::mutable_processing() {
  set_has_processing();
  if (processing_ == NULL) processing_ = new ::draiosproto::counter_time;
  return processing_;
}
inline ::draiosproto::counter_time* time_categories::release_processing() {
  clear_has_processing();
  ::draiosproto::counter_time* temp = processing_;
  processing_ = NULL;
  return temp;
}
inline void time_categories::set_allocated_processing(::draiosproto::counter_time* processing) {
  delete processing_;
  processing_ = processing;
  if (processing) {
    set_has_processing();
  } else {
    clear_has_processing();
  }
}

// -------------------------------------------------------------------

// counter_syscall_errors

// required uint32 count = 1;
inline bool counter_syscall_errors::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void counter_syscall_errors::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void counter_syscall_errors::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void counter_syscall_errors::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 counter_syscall_errors::count() const {
  return count_;
}
inline void counter_syscall_errors::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated uint32 top_error_codes = 2;
inline int counter_syscall_errors::top_error_codes_size() const {
  return top_error_codes_.size();
}
inline void counter_syscall_errors::clear_top_error_codes() {
  top_error_codes_.Clear();
}
inline ::google::protobuf::uint32 counter_syscall_errors::top_error_codes(int index) const {
  return top_error_codes_.Get(index);
}
inline void counter_syscall_errors::set_top_error_codes(int index, ::google::protobuf::uint32 value) {
  top_error_codes_.Set(index, value);
}
inline void counter_syscall_errors::add_top_error_codes(::google::protobuf::uint32 value) {
  top_error_codes_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
counter_syscall_errors::top_error_codes() const {
  return top_error_codes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
counter_syscall_errors::mutable_top_error_codes() {
  return &top_error_codes_;
}

// -------------------------------------------------------------------

// resource_categories

// optional uint32 capacity_score = 1;
inline bool resource_categories::has_capacity_score() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void resource_categories::set_has_capacity_score() {
  _has_bits_[0] |= 0x00000001u;
}
inline void resource_categories::clear_has_capacity_score() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void resource_categories::clear_capacity_score() {
  capacity_score_ = 0u;
  clear_has_capacity_score();
}
inline ::google::protobuf::uint32 resource_categories::capacity_score() const {
  return capacity_score_;
}
inline void resource_categories::set_capacity_score(::google::protobuf::uint32 value) {
  set_has_capacity_score();
  capacity_score_ = value;
}

// optional uint32 connection_queue_usage_pct = 2;
inline bool resource_categories::has_connection_queue_usage_pct() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void resource_categories::set_has_connection_queue_usage_pct() {
  _has_bits_[0] |= 0x00000002u;
}
inline void resource_categories::clear_has_connection_queue_usage_pct() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void resource_categories::clear_connection_queue_usage_pct() {
  connection_queue_usage_pct_ = 0u;
  clear_has_connection_queue_usage_pct();
}
inline ::google::protobuf::uint32 resource_categories::connection_queue_usage_pct() const {
  return connection_queue_usage_pct_;
}
inline void resource_categories::set_connection_queue_usage_pct(::google::protobuf::uint32 value) {
  set_has_connection_queue_usage_pct();
  connection_queue_usage_pct_ = value;
}

// optional uint32 fd_usage_pct = 3;
inline bool resource_categories::has_fd_usage_pct() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void resource_categories::set_has_fd_usage_pct() {
  _has_bits_[0] |= 0x00000004u;
}
inline void resource_categories::clear_has_fd_usage_pct() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void resource_categories::clear_fd_usage_pct() {
  fd_usage_pct_ = 0u;
  clear_has_fd_usage_pct();
}
inline ::google::protobuf::uint32 resource_categories::fd_usage_pct() const {
  return fd_usage_pct_;
}
inline void resource_categories::set_fd_usage_pct(::google::protobuf::uint32 value) {
  set_has_fd_usage_pct();
  fd_usage_pct_ = value;
}

// optional uint32 cpu_pct = 4;
inline bool resource_categories::has_cpu_pct() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void resource_categories::set_has_cpu_pct() {
  _has_bits_[0] |= 0x00000008u;
}
inline void resource_categories::clear_has_cpu_pct() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void resource_categories::clear_cpu_pct() {
  cpu_pct_ = 0u;
  clear_has_cpu_pct();
}
inline ::google::protobuf::uint32 resource_categories::cpu_pct() const {
  return cpu_pct_;
}
inline void resource_categories::set_cpu_pct(::google::protobuf::uint32 value) {
  set_has_cpu_pct();
  cpu_pct_ = value;
}

// optional uint64 resident_memory_usage_kb = 5;
inline bool resource_categories::has_resident_memory_usage_kb() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void resource_categories::set_has_resident_memory_usage_kb() {
  _has_bits_[0] |= 0x00000010u;
}
inline void resource_categories::clear_has_resident_memory_usage_kb() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void resource_categories::clear_resident_memory_usage_kb() {
  resident_memory_usage_kb_ = GOOGLE_ULONGLONG(0);
  clear_has_resident_memory_usage_kb();
}
inline ::google::protobuf::uint64 resource_categories::resident_memory_usage_kb() const {
  return resident_memory_usage_kb_;
}
inline void resource_categories::set_resident_memory_usage_kb(::google::protobuf::uint64 value) {
  set_has_resident_memory_usage_kb();
  resident_memory_usage_kb_ = value;
}

// -------------------------------------------------------------------

// connection_categories

// optional .draiosproto.counter_bytes server = 1;
inline bool connection_categories::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void connection_categories::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void connection_categories::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void connection_categories::clear_server() {
  if (server_ != NULL) server_->::draiosproto::counter_bytes::Clear();
  clear_has_server();
}
inline const ::draiosproto::counter_bytes& connection_categories::server() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return server_ != NULL ? *server_ : *default_instance().server_;
#else
  return server_ != NULL ? *server_ : *default_instance_->server_;
#endif
}
inline ::draiosproto::counter_bytes* connection_categories::mutable_server() {
  set_has_server();
  if (server_ == NULL) server_ = new ::draiosproto::counter_bytes;
  return server_;
}
inline ::draiosproto::counter_bytes* connection_categories::release_server() {
  clear_has_server();
  ::draiosproto::counter_bytes* temp = server_;
  server_ = NULL;
  return temp;
}
inline void connection_categories::set_allocated_server(::draiosproto::counter_bytes* server) {
  delete server_;
  server_ = server;
  if (server) {
    set_has_server();
  } else {
    clear_has_server();
  }
}

// optional .draiosproto.counter_bytes client = 2;
inline bool connection_categories::has_client() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void connection_categories::set_has_client() {
  _has_bits_[0] |= 0x00000002u;
}
inline void connection_categories::clear_has_client() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void connection_categories::clear_client() {
  if (client_ != NULL) client_->::draiosproto::counter_bytes::Clear();
  clear_has_client();
}
inline const ::draiosproto::counter_bytes& connection_categories::client() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return client_ != NULL ? *client_ : *default_instance().client_;
#else
  return client_ != NULL ? *client_ : *default_instance_->client_;
#endif
}
inline ::draiosproto::counter_bytes* connection_categories::mutable_client() {
  set_has_client();
  if (client_ == NULL) client_ = new ::draiosproto::counter_bytes;
  return client_;
}
inline ::draiosproto::counter_bytes* connection_categories::release_client() {
  clear_has_client();
  ::draiosproto::counter_bytes* temp = client_;
  client_ = NULL;
  return temp;
}
inline void connection_categories::set_allocated_client(::draiosproto::counter_bytes* client) {
  delete client_;
  client_ = client;
  if (client) {
    set_has_client();
  } else {
    clear_has_client();
  }
}

// optional .draiosproto.counter_time_bidirectional transaction_counters = 3;
inline bool connection_categories::has_transaction_counters() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void connection_categories::set_has_transaction_counters() {
  _has_bits_[0] |= 0x00000004u;
}
inline void connection_categories::clear_has_transaction_counters() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void connection_categories::clear_transaction_counters() {
  if (transaction_counters_ != NULL) transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& connection_categories::transaction_counters() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transaction_counters_ != NULL ? *transaction_counters_ : *default_instance().transaction_counters_;
#else
  return transaction_counters_ != NULL ? *transaction_counters_ : *default_instance_->transaction_counters_;
#endif
}
inline ::draiosproto::counter_time_bidirectional* connection_categories::mutable_transaction_counters() {
  set_has_transaction_counters();
  if (transaction_counters_ == NULL) transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  return transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* connection_categories::release_transaction_counters() {
  clear_has_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = transaction_counters_;
  transaction_counters_ = NULL;
  return temp;
}
inline void connection_categories::set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters) {
  delete transaction_counters_;
  transaction_counters_ = transaction_counters;
  if (transaction_counters) {
    set_has_transaction_counters();
  } else {
    clear_has_transaction_counters();
  }
}

// optional uint32 n_aggregated_connections = 4;
inline bool connection_categories::has_n_aggregated_connections() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void connection_categories::set_has_n_aggregated_connections() {
  _has_bits_[0] |= 0x00000008u;
}
inline void connection_categories::clear_has_n_aggregated_connections() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void connection_categories::clear_n_aggregated_connections() {
  n_aggregated_connections_ = 0u;
  clear_has_n_aggregated_connections();
}
inline ::google::protobuf::uint32 connection_categories::n_aggregated_connections() const {
  return n_aggregated_connections_;
}
inline void connection_categories::set_n_aggregated_connections(::google::protobuf::uint32 value) {
  set_has_n_aggregated_connections();
  n_aggregated_connections_ = value;
}

// -------------------------------------------------------------------

// host

// optional string hostname = 1;
inline bool host::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void host::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void host::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void host::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& host::hostname() const {
  return *hostname_;
}
inline void host::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void host::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void host::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* host::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* host::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void host::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 num_cpus = 2;
inline bool host::has_num_cpus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void host::set_has_num_cpus() {
  _has_bits_[0] |= 0x00000002u;
}
inline void host::clear_has_num_cpus() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void host::clear_num_cpus() {
  num_cpus_ = 0u;
  clear_has_num_cpus();
}
inline ::google::protobuf::uint32 host::num_cpus() const {
  return num_cpus_;
}
inline void host::set_num_cpus(::google::protobuf::uint32 value) {
  set_has_num_cpus();
  num_cpus_ = value;
}

// repeated uint32 cpu_loads = 3;
inline int host::cpu_loads_size() const {
  return cpu_loads_.size();
}
inline void host::clear_cpu_loads() {
  cpu_loads_.Clear();
}
inline ::google::protobuf::uint32 host::cpu_loads(int index) const {
  return cpu_loads_.Get(index);
}
inline void host::set_cpu_loads(int index, ::google::protobuf::uint32 value) {
  cpu_loads_.Set(index, value);
}
inline void host::add_cpu_loads(::google::protobuf::uint32 value) {
  cpu_loads_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
host::cpu_loads() const {
  return cpu_loads_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
host::mutable_cpu_loads() {
  return &cpu_loads_;
}

// required uint64 physical_memory_size_bytes = 4;
inline bool host::has_physical_memory_size_bytes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void host::set_has_physical_memory_size_bytes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void host::clear_has_physical_memory_size_bytes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void host::clear_physical_memory_size_bytes() {
  physical_memory_size_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_physical_memory_size_bytes();
}
inline ::google::protobuf::uint64 host::physical_memory_size_bytes() const {
  return physical_memory_size_bytes_;
}
inline void host::set_physical_memory_size_bytes(::google::protobuf::uint64 value) {
  set_has_physical_memory_size_bytes();
  physical_memory_size_bytes_ = value;
}

// optional .draiosproto.time_categories tcounters = 5;
inline bool host::has_tcounters() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void host::set_has_tcounters() {
  _has_bits_[0] |= 0x00000010u;
}
inline void host::clear_has_tcounters() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void host::clear_tcounters() {
  if (tcounters_ != NULL) tcounters_->::draiosproto::time_categories::Clear();
  clear_has_tcounters();
}
inline const ::draiosproto::time_categories& host::tcounters() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tcounters_ != NULL ? *tcounters_ : *default_instance().tcounters_;
#else
  return tcounters_ != NULL ? *tcounters_ : *default_instance_->tcounters_;
#endif
}
inline ::draiosproto::time_categories* host::mutable_tcounters() {
  set_has_tcounters();
  if (tcounters_ == NULL) tcounters_ = new ::draiosproto::time_categories;
  return tcounters_;
}
inline ::draiosproto::time_categories* host::release_tcounters() {
  clear_has_tcounters();
  ::draiosproto::time_categories* temp = tcounters_;
  tcounters_ = NULL;
  return temp;
}
inline void host::set_allocated_tcounters(::draiosproto::time_categories* tcounters) {
  delete tcounters_;
  tcounters_ = tcounters;
  if (tcounters) {
    set_has_tcounters();
  } else {
    clear_has_tcounters();
  }
}

// optional .draiosproto.counter_time_bidirectional transaction_counters = 6;
inline bool host::has_transaction_counters() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void host::set_has_transaction_counters() {
  _has_bits_[0] |= 0x00000020u;
}
inline void host::clear_has_transaction_counters() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void host::clear_transaction_counters() {
  if (transaction_counters_ != NULL) transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& host::transaction_counters() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transaction_counters_ != NULL ? *transaction_counters_ : *default_instance().transaction_counters_;
#else
  return transaction_counters_ != NULL ? *transaction_counters_ : *default_instance_->transaction_counters_;
#endif
}
inline ::draiosproto::counter_time_bidirectional* host::mutable_transaction_counters() {
  set_has_transaction_counters();
  if (transaction_counters_ == NULL) transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  return transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* host::release_transaction_counters() {
  clear_has_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = transaction_counters_;
  transaction_counters_ = NULL;
  return temp;
}
inline void host::set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters) {
  delete transaction_counters_;
  transaction_counters_ = transaction_counters;
  if (transaction_counters) {
    set_has_transaction_counters();
  } else {
    clear_has_transaction_counters();
  }
}

// optional uint64 transaction_processing_delay = 7;
inline bool host::has_transaction_processing_delay() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void host::set_has_transaction_processing_delay() {
  _has_bits_[0] |= 0x00000040u;
}
inline void host::clear_has_transaction_processing_delay() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void host::clear_transaction_processing_delay() {
  transaction_processing_delay_ = GOOGLE_ULONGLONG(0);
  clear_has_transaction_processing_delay();
}
inline ::google::protobuf::uint64 host::transaction_processing_delay() const {
  return transaction_processing_delay_;
}
inline void host::set_transaction_processing_delay(::google::protobuf::uint64 value) {
  set_has_transaction_processing_delay();
  transaction_processing_delay_ = value;
}

// optional .draiosproto.resource_categories resource_counters = 8;
inline bool host::has_resource_counters() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void host::set_has_resource_counters() {
  _has_bits_[0] |= 0x00000080u;
}
inline void host::clear_has_resource_counters() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void host::clear_resource_counters() {
  if (resource_counters_ != NULL) resource_counters_->::draiosproto::resource_categories::Clear();
  clear_has_resource_counters();
}
inline const ::draiosproto::resource_categories& host::resource_counters() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return resource_counters_ != NULL ? *resource_counters_ : *default_instance().resource_counters_;
#else
  return resource_counters_ != NULL ? *resource_counters_ : *default_instance_->resource_counters_;
#endif
}
inline ::draiosproto::resource_categories* host::mutable_resource_counters() {
  set_has_resource_counters();
  if (resource_counters_ == NULL) resource_counters_ = new ::draiosproto::resource_categories;
  return resource_counters_;
}
inline ::draiosproto::resource_categories* host::release_resource_counters() {
  clear_has_resource_counters();
  ::draiosproto::resource_categories* temp = resource_counters_;
  resource_counters_ = NULL;
  return temp;
}
inline void host::set_allocated_resource_counters(::draiosproto::resource_categories* resource_counters) {
  delete resource_counters_;
  resource_counters_ = resource_counters;
  if (resource_counters) {
    set_has_resource_counters();
  } else {
    clear_has_resource_counters();
  }
}

// optional .draiosproto.counter_syscall_errors syscall_errors = 9;
inline bool host::has_syscall_errors() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void host::set_has_syscall_errors() {
  _has_bits_[0] |= 0x00000100u;
}
inline void host::clear_has_syscall_errors() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void host::clear_syscall_errors() {
  if (syscall_errors_ != NULL) syscall_errors_->::draiosproto::counter_syscall_errors::Clear();
  clear_has_syscall_errors();
}
inline const ::draiosproto::counter_syscall_errors& host::syscall_errors() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return syscall_errors_ != NULL ? *syscall_errors_ : *default_instance().syscall_errors_;
#else
  return syscall_errors_ != NULL ? *syscall_errors_ : *default_instance_->syscall_errors_;
#endif
}
inline ::draiosproto::counter_syscall_errors* host::mutable_syscall_errors() {
  set_has_syscall_errors();
  if (syscall_errors_ == NULL) syscall_errors_ = new ::draiosproto::counter_syscall_errors;
  return syscall_errors_;
}
inline ::draiosproto::counter_syscall_errors* host::release_syscall_errors() {
  clear_has_syscall_errors();
  ::draiosproto::counter_syscall_errors* temp = syscall_errors_;
  syscall_errors_ = NULL;
  return temp;
}
inline void host::set_allocated_syscall_errors(::draiosproto::counter_syscall_errors* syscall_errors) {
  delete syscall_errors_;
  syscall_errors_ = syscall_errors;
  if (syscall_errors) {
    set_has_syscall_errors();
  } else {
    clear_has_syscall_errors();
  }
}

// -------------------------------------------------------------------

// process

// required uint64 pid = 1;
inline bool process::has_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void process::set_has_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void process::clear_has_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void process::clear_pid() {
  pid_ = GOOGLE_ULONGLONG(0);
  clear_has_pid();
}
inline ::google::protobuf::uint64 process::pid() const {
  return pid_;
}
inline void process::set_pid(::google::protobuf::uint64 value) {
  set_has_pid();
  pid_ = value;
}

// required string comm = 2;
inline bool process::has_comm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void process::set_has_comm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void process::clear_has_comm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void process::clear_comm() {
  if (comm_ != &::google::protobuf::internal::kEmptyString) {
    comm_->clear();
  }
  clear_has_comm();
}
inline const ::std::string& process::comm() const {
  return *comm_;
}
inline void process::set_comm(const ::std::string& value) {
  set_has_comm();
  if (comm_ == &::google::protobuf::internal::kEmptyString) {
    comm_ = new ::std::string;
  }
  comm_->assign(value);
}
inline void process::set_comm(const char* value) {
  set_has_comm();
  if (comm_ == &::google::protobuf::internal::kEmptyString) {
    comm_ = new ::std::string;
  }
  comm_->assign(value);
}
inline void process::set_comm(const char* value, size_t size) {
  set_has_comm();
  if (comm_ == &::google::protobuf::internal::kEmptyString) {
    comm_ = new ::std::string;
  }
  comm_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* process::mutable_comm() {
  set_has_comm();
  if (comm_ == &::google::protobuf::internal::kEmptyString) {
    comm_ = new ::std::string;
  }
  return comm_;
}
inline ::std::string* process::release_comm() {
  clear_has_comm();
  if (comm_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comm_;
    comm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void process::set_allocated_comm(::std::string* comm) {
  if (comm_ != &::google::protobuf::internal::kEmptyString) {
    delete comm_;
  }
  if (comm) {
    set_has_comm();
    comm_ = comm;
  } else {
    clear_has_comm();
    comm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string exe = 3;
inline bool process::has_exe() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void process::set_has_exe() {
  _has_bits_[0] |= 0x00000004u;
}
inline void process::clear_has_exe() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void process::clear_exe() {
  if (exe_ != &::google::protobuf::internal::kEmptyString) {
    exe_->clear();
  }
  clear_has_exe();
}
inline const ::std::string& process::exe() const {
  return *exe_;
}
inline void process::set_exe(const ::std::string& value) {
  set_has_exe();
  if (exe_ == &::google::protobuf::internal::kEmptyString) {
    exe_ = new ::std::string;
  }
  exe_->assign(value);
}
inline void process::set_exe(const char* value) {
  set_has_exe();
  if (exe_ == &::google::protobuf::internal::kEmptyString) {
    exe_ = new ::std::string;
  }
  exe_->assign(value);
}
inline void process::set_exe(const char* value, size_t size) {
  set_has_exe();
  if (exe_ == &::google::protobuf::internal::kEmptyString) {
    exe_ = new ::std::string;
  }
  exe_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* process::mutable_exe() {
  set_has_exe();
  if (exe_ == &::google::protobuf::internal::kEmptyString) {
    exe_ = new ::std::string;
  }
  return exe_;
}
inline ::std::string* process::release_exe() {
  clear_has_exe();
  if (exe_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exe_;
    exe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void process::set_allocated_exe(::std::string* exe) {
  if (exe_ != &::google::protobuf::internal::kEmptyString) {
    delete exe_;
  }
  if (exe) {
    set_has_exe();
    exe_ = exe;
  } else {
    clear_has_exe();
    exe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string args = 4;
inline int process::args_size() const {
  return args_.size();
}
inline void process::clear_args() {
  args_.Clear();
}
inline const ::std::string& process::args(int index) const {
  return args_.Get(index);
}
inline ::std::string* process::mutable_args(int index) {
  return args_.Mutable(index);
}
inline void process::set_args(int index, const ::std::string& value) {
  args_.Mutable(index)->assign(value);
}
inline void process::set_args(int index, const char* value) {
  args_.Mutable(index)->assign(value);
}
inline void process::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* process::add_args() {
  return args_.Add();
}
inline void process::add_args(const ::std::string& value) {
  args_.Add()->assign(value);
}
inline void process::add_args(const char* value) {
  args_.Add()->assign(value);
}
inline void process::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
process::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
process::mutable_args() {
  return &args_;
}

// optional bool is_transaction_server = 5;
inline bool process::has_is_transaction_server() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void process::set_has_is_transaction_server() {
  _has_bits_[0] |= 0x00000010u;
}
inline void process::clear_has_is_transaction_server() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void process::clear_is_transaction_server() {
  is_transaction_server_ = false;
  clear_has_is_transaction_server();
}
inline bool process::is_transaction_server() const {
  return is_transaction_server_;
}
inline void process::set_is_transaction_server(bool value) {
  set_has_is_transaction_server();
  is_transaction_server_ = value;
}

// optional .draiosproto.time_categories tcounters = 6;
inline bool process::has_tcounters() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void process::set_has_tcounters() {
  _has_bits_[0] |= 0x00000020u;
}
inline void process::clear_has_tcounters() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void process::clear_tcounters() {
  if (tcounters_ != NULL) tcounters_->::draiosproto::time_categories::Clear();
  clear_has_tcounters();
}
inline const ::draiosproto::time_categories& process::tcounters() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tcounters_ != NULL ? *tcounters_ : *default_instance().tcounters_;
#else
  return tcounters_ != NULL ? *tcounters_ : *default_instance_->tcounters_;
#endif
}
inline ::draiosproto::time_categories* process::mutable_tcounters() {
  set_has_tcounters();
  if (tcounters_ == NULL) tcounters_ = new ::draiosproto::time_categories;
  return tcounters_;
}
inline ::draiosproto::time_categories* process::release_tcounters() {
  clear_has_tcounters();
  ::draiosproto::time_categories* temp = tcounters_;
  tcounters_ = NULL;
  return temp;
}
inline void process::set_allocated_tcounters(::draiosproto::time_categories* tcounters) {
  delete tcounters_;
  tcounters_ = tcounters;
  if (tcounters) {
    set_has_tcounters();
  } else {
    clear_has_tcounters();
  }
}

// optional .draiosproto.counter_time_bidirectional transaction_counters = 7;
inline bool process::has_transaction_counters() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void process::set_has_transaction_counters() {
  _has_bits_[0] |= 0x00000040u;
}
inline void process::clear_has_transaction_counters() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void process::clear_transaction_counters() {
  if (transaction_counters_ != NULL) transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& process::transaction_counters() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transaction_counters_ != NULL ? *transaction_counters_ : *default_instance().transaction_counters_;
#else
  return transaction_counters_ != NULL ? *transaction_counters_ : *default_instance_->transaction_counters_;
#endif
}
inline ::draiosproto::counter_time_bidirectional* process::mutable_transaction_counters() {
  set_has_transaction_counters();
  if (transaction_counters_ == NULL) transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  return transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* process::release_transaction_counters() {
  clear_has_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = transaction_counters_;
  transaction_counters_ = NULL;
  return temp;
}
inline void process::set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters) {
  delete transaction_counters_;
  transaction_counters_ = transaction_counters;
  if (transaction_counters) {
    set_has_transaction_counters();
  } else {
    clear_has_transaction_counters();
  }
}

// optional uint64 transaction_processing_delay = 8;
inline bool process::has_transaction_processing_delay() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void process::set_has_transaction_processing_delay() {
  _has_bits_[0] |= 0x00000080u;
}
inline void process::clear_has_transaction_processing_delay() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void process::clear_transaction_processing_delay() {
  transaction_processing_delay_ = GOOGLE_ULONGLONG(0);
  clear_has_transaction_processing_delay();
}
inline ::google::protobuf::uint64 process::transaction_processing_delay() const {
  return transaction_processing_delay_;
}
inline void process::set_transaction_processing_delay(::google::protobuf::uint64 value) {
  set_has_transaction_processing_delay();
  transaction_processing_delay_ = value;
}

// optional .draiosproto.resource_categories resource_counters = 9;
inline bool process::has_resource_counters() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void process::set_has_resource_counters() {
  _has_bits_[0] |= 0x00000100u;
}
inline void process::clear_has_resource_counters() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void process::clear_resource_counters() {
  if (resource_counters_ != NULL) resource_counters_->::draiosproto::resource_categories::Clear();
  clear_has_resource_counters();
}
inline const ::draiosproto::resource_categories& process::resource_counters() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return resource_counters_ != NULL ? *resource_counters_ : *default_instance().resource_counters_;
#else
  return resource_counters_ != NULL ? *resource_counters_ : *default_instance_->resource_counters_;
#endif
}
inline ::draiosproto::resource_categories* process::mutable_resource_counters() {
  set_has_resource_counters();
  if (resource_counters_ == NULL) resource_counters_ = new ::draiosproto::resource_categories;
  return resource_counters_;
}
inline ::draiosproto::resource_categories* process::release_resource_counters() {
  clear_has_resource_counters();
  ::draiosproto::resource_categories* temp = resource_counters_;
  resource_counters_ = NULL;
  return temp;
}
inline void process::set_allocated_resource_counters(::draiosproto::resource_categories* resource_counters) {
  delete resource_counters_;
  resource_counters_ = resource_counters;
  if (resource_counters) {
    set_has_resource_counters();
  } else {
    clear_has_resource_counters();
  }
}

// optional .draiosproto.counter_syscall_errors syscall_errors = 10;
inline bool process::has_syscall_errors() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void process::set_has_syscall_errors() {
  _has_bits_[0] |= 0x00000200u;
}
inline void process::clear_has_syscall_errors() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void process::clear_syscall_errors() {
  if (syscall_errors_ != NULL) syscall_errors_->::draiosproto::counter_syscall_errors::Clear();
  clear_has_syscall_errors();
}
inline const ::draiosproto::counter_syscall_errors& process::syscall_errors() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return syscall_errors_ != NULL ? *syscall_errors_ : *default_instance().syscall_errors_;
#else
  return syscall_errors_ != NULL ? *syscall_errors_ : *default_instance_->syscall_errors_;
#endif
}
inline ::draiosproto::counter_syscall_errors* process::mutable_syscall_errors() {
  set_has_syscall_errors();
  if (syscall_errors_ == NULL) syscall_errors_ = new ::draiosproto::counter_syscall_errors;
  return syscall_errors_;
}
inline ::draiosproto::counter_syscall_errors* process::release_syscall_errors() {
  clear_has_syscall_errors();
  ::draiosproto::counter_syscall_errors* temp = syscall_errors_;
  syscall_errors_ = NULL;
  return temp;
}
inline void process::set_allocated_syscall_errors(::draiosproto::counter_syscall_errors* syscall_errors) {
  delete syscall_errors_;
  syscall_errors_ = syscall_errors;
  if (syscall_errors) {
    set_has_syscall_errors();
  } else {
    clear_has_syscall_errors();
  }
}

// -------------------------------------------------------------------

// thread

// required uint64 pid = 1;
inline bool thread::has_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void thread::set_has_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void thread::clear_has_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void thread::clear_pid() {
  pid_ = GOOGLE_ULONGLONG(0);
  clear_has_pid();
}
inline ::google::protobuf::uint64 thread::pid() const {
  return pid_;
}
inline void thread::set_pid(::google::protobuf::uint64 value) {
  set_has_pid();
  pid_ = value;
}

// required uint64 tid = 2;
inline bool thread::has_tid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void thread::set_has_tid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void thread::clear_has_tid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void thread::clear_tid() {
  tid_ = GOOGLE_ULONGLONG(0);
  clear_has_tid();
}
inline ::google::protobuf::uint64 thread::tid() const {
  return tid_;
}
inline void thread::set_tid(::google::protobuf::uint64 value) {
  set_has_tid();
  tid_ = value;
}

// optional .draiosproto.time_categories tcounters = 3;
inline bool thread::has_tcounters() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void thread::set_has_tcounters() {
  _has_bits_[0] |= 0x00000004u;
}
inline void thread::clear_has_tcounters() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void thread::clear_tcounters() {
  if (tcounters_ != NULL) tcounters_->::draiosproto::time_categories::Clear();
  clear_has_tcounters();
}
inline const ::draiosproto::time_categories& thread::tcounters() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tcounters_ != NULL ? *tcounters_ : *default_instance().tcounters_;
#else
  return tcounters_ != NULL ? *tcounters_ : *default_instance_->tcounters_;
#endif
}
inline ::draiosproto::time_categories* thread::mutable_tcounters() {
  set_has_tcounters();
  if (tcounters_ == NULL) tcounters_ = new ::draiosproto::time_categories;
  return tcounters_;
}
inline ::draiosproto::time_categories* thread::release_tcounters() {
  clear_has_tcounters();
  ::draiosproto::time_categories* temp = tcounters_;
  tcounters_ = NULL;
  return temp;
}
inline void thread::set_allocated_tcounters(::draiosproto::time_categories* tcounters) {
  delete tcounters_;
  tcounters_ = tcounters;
  if (tcounters) {
    set_has_tcounters();
  } else {
    clear_has_tcounters();
  }
}

// optional .draiosproto.counter_time_bidirectional transaction_counters = 5;
inline bool thread::has_transaction_counters() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void thread::set_has_transaction_counters() {
  _has_bits_[0] |= 0x00000008u;
}
inline void thread::clear_has_transaction_counters() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void thread::clear_transaction_counters() {
  if (transaction_counters_ != NULL) transaction_counters_->::draiosproto::counter_time_bidirectional::Clear();
  clear_has_transaction_counters();
}
inline const ::draiosproto::counter_time_bidirectional& thread::transaction_counters() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transaction_counters_ != NULL ? *transaction_counters_ : *default_instance().transaction_counters_;
#else
  return transaction_counters_ != NULL ? *transaction_counters_ : *default_instance_->transaction_counters_;
#endif
}
inline ::draiosproto::counter_time_bidirectional* thread::mutable_transaction_counters() {
  set_has_transaction_counters();
  if (transaction_counters_ == NULL) transaction_counters_ = new ::draiosproto::counter_time_bidirectional;
  return transaction_counters_;
}
inline ::draiosproto::counter_time_bidirectional* thread::release_transaction_counters() {
  clear_has_transaction_counters();
  ::draiosproto::counter_time_bidirectional* temp = transaction_counters_;
  transaction_counters_ = NULL;
  return temp;
}
inline void thread::set_allocated_transaction_counters(::draiosproto::counter_time_bidirectional* transaction_counters) {
  delete transaction_counters_;
  transaction_counters_ = transaction_counters;
  if (transaction_counters) {
    set_has_transaction_counters();
  } else {
    clear_has_transaction_counters();
  }
}

// -------------------------------------------------------------------

// ipv4tuple

// required uint32 sip = 1;
inline bool ipv4tuple::has_sip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ipv4tuple::set_has_sip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ipv4tuple::clear_has_sip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ipv4tuple::clear_sip() {
  sip_ = 0u;
  clear_has_sip();
}
inline ::google::protobuf::uint32 ipv4tuple::sip() const {
  return sip_;
}
inline void ipv4tuple::set_sip(::google::protobuf::uint32 value) {
  set_has_sip();
  sip_ = value;
}

// required uint32 dip = 2;
inline bool ipv4tuple::has_dip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ipv4tuple::set_has_dip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ipv4tuple::clear_has_dip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ipv4tuple::clear_dip() {
  dip_ = 0u;
  clear_has_dip();
}
inline ::google::protobuf::uint32 ipv4tuple::dip() const {
  return dip_;
}
inline void ipv4tuple::set_dip(::google::protobuf::uint32 value) {
  set_has_dip();
  dip_ = value;
}

// required uint32 sport = 3;
inline bool ipv4tuple::has_sport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ipv4tuple::set_has_sport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ipv4tuple::clear_has_sport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ipv4tuple::clear_sport() {
  sport_ = 0u;
  clear_has_sport();
}
inline ::google::protobuf::uint32 ipv4tuple::sport() const {
  return sport_;
}
inline void ipv4tuple::set_sport(::google::protobuf::uint32 value) {
  set_has_sport();
  sport_ = value;
}

// required uint32 dport = 4;
inline bool ipv4tuple::has_dport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ipv4tuple::set_has_dport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ipv4tuple::clear_has_dport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ipv4tuple::clear_dport() {
  dport_ = 0u;
  clear_has_dport();
}
inline ::google::protobuf::uint32 ipv4tuple::dport() const {
  return dport_;
}
inline void ipv4tuple::set_dport(::google::protobuf::uint32 value) {
  set_has_dport();
  dport_ = value;
}

// required uint32 l4proto = 5;
inline bool ipv4tuple::has_l4proto() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ipv4tuple::set_has_l4proto() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ipv4tuple::clear_has_l4proto() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ipv4tuple::clear_l4proto() {
  l4proto_ = 0u;
  clear_has_l4proto();
}
inline ::google::protobuf::uint32 ipv4tuple::l4proto() const {
  return l4proto_;
}
inline void ipv4tuple::set_l4proto(::google::protobuf::uint32 value) {
  set_has_l4proto();
  l4proto_ = value;
}

// -------------------------------------------------------------------

// ipv4_connection

// required .draiosproto.ipv4tuple tuple = 1;
inline bool ipv4_connection::has_tuple() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ipv4_connection::set_has_tuple() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ipv4_connection::clear_has_tuple() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ipv4_connection::clear_tuple() {
  if (tuple_ != NULL) tuple_->::draiosproto::ipv4tuple::Clear();
  clear_has_tuple();
}
inline const ::draiosproto::ipv4tuple& ipv4_connection::tuple() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tuple_ != NULL ? *tuple_ : *default_instance().tuple_;
#else
  return tuple_ != NULL ? *tuple_ : *default_instance_->tuple_;
#endif
}
inline ::draiosproto::ipv4tuple* ipv4_connection::mutable_tuple() {
  set_has_tuple();
  if (tuple_ == NULL) tuple_ = new ::draiosproto::ipv4tuple;
  return tuple_;
}
inline ::draiosproto::ipv4tuple* ipv4_connection::release_tuple() {
  clear_has_tuple();
  ::draiosproto::ipv4tuple* temp = tuple_;
  tuple_ = NULL;
  return temp;
}
inline void ipv4_connection::set_allocated_tuple(::draiosproto::ipv4tuple* tuple) {
  delete tuple_;
  tuple_ = tuple;
  if (tuple) {
    set_has_tuple();
  } else {
    clear_has_tuple();
  }
}

// optional uint64 spid = 2;
inline bool ipv4_connection::has_spid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ipv4_connection::set_has_spid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ipv4_connection::clear_has_spid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ipv4_connection::clear_spid() {
  spid_ = GOOGLE_ULONGLONG(0);
  clear_has_spid();
}
inline ::google::protobuf::uint64 ipv4_connection::spid() const {
  return spid_;
}
inline void ipv4_connection::set_spid(::google::protobuf::uint64 value) {
  set_has_spid();
  spid_ = value;
}

// optional uint64 stid = 3;
inline bool ipv4_connection::has_stid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ipv4_connection::set_has_stid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ipv4_connection::clear_has_stid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ipv4_connection::clear_stid() {
  stid_ = GOOGLE_ULONGLONG(0);
  clear_has_stid();
}
inline ::google::protobuf::uint64 ipv4_connection::stid() const {
  return stid_;
}
inline void ipv4_connection::set_stid(::google::protobuf::uint64 value) {
  set_has_stid();
  stid_ = value;
}

// optional uint64 dpid = 5;
inline bool ipv4_connection::has_dpid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ipv4_connection::set_has_dpid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ipv4_connection::clear_has_dpid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ipv4_connection::clear_dpid() {
  dpid_ = GOOGLE_ULONGLONG(0);
  clear_has_dpid();
}
inline ::google::protobuf::uint64 ipv4_connection::dpid() const {
  return dpid_;
}
inline void ipv4_connection::set_dpid(::google::protobuf::uint64 value) {
  set_has_dpid();
  dpid_ = value;
}

// optional uint64 dtid = 6;
inline bool ipv4_connection::has_dtid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ipv4_connection::set_has_dtid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ipv4_connection::clear_has_dtid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ipv4_connection::clear_dtid() {
  dtid_ = GOOGLE_ULONGLONG(0);
  clear_has_dtid();
}
inline ::google::protobuf::uint64 ipv4_connection::dtid() const {
  return dtid_;
}
inline void ipv4_connection::set_dtid(::google::protobuf::uint64 value) {
  set_has_dtid();
  dtid_ = value;
}

// required .draiosproto.connection_categories counters = 8;
inline bool ipv4_connection::has_counters() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ipv4_connection::set_has_counters() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ipv4_connection::clear_has_counters() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ipv4_connection::clear_counters() {
  if (counters_ != NULL) counters_->::draiosproto::connection_categories::Clear();
  clear_has_counters();
}
inline const ::draiosproto::connection_categories& ipv4_connection::counters() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return counters_ != NULL ? *counters_ : *default_instance().counters_;
#else
  return counters_ != NULL ? *counters_ : *default_instance_->counters_;
#endif
}
inline ::draiosproto::connection_categories* ipv4_connection::mutable_counters() {
  set_has_counters();
  if (counters_ == NULL) counters_ = new ::draiosproto::connection_categories;
  return counters_;
}
inline ::draiosproto::connection_categories* ipv4_connection::release_counters() {
  clear_has_counters();
  ::draiosproto::connection_categories* temp = counters_;
  counters_ = NULL;
  return temp;
}
inline void ipv4_connection::set_allocated_counters(::draiosproto::connection_categories* counters) {
  delete counters_;
  counters_ = counters;
  if (counters) {
    set_has_counters();
  } else {
    clear_has_counters();
  }
}

// -------------------------------------------------------------------

// ipv4_network_interface

// required string name = 1;
inline bool ipv4_network_interface::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ipv4_network_interface::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ipv4_network_interface::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ipv4_network_interface::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ipv4_network_interface::name() const {
  return *name_;
}
inline void ipv4_network_interface::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ipv4_network_interface::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ipv4_network_interface::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ipv4_network_interface::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ipv4_network_interface::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ipv4_network_interface::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 addr = 2;
inline bool ipv4_network_interface::has_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ipv4_network_interface::set_has_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ipv4_network_interface::clear_has_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ipv4_network_interface::clear_addr() {
  addr_ = 0u;
  clear_has_addr();
}
inline ::google::protobuf::uint32 ipv4_network_interface::addr() const {
  return addr_;
}
inline void ipv4_network_interface::set_addr(::google::protobuf::uint32 value) {
  set_has_addr();
  addr_ = value;
}

// required uint32 netmask = 3;
inline bool ipv4_network_interface::has_netmask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ipv4_network_interface::set_has_netmask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ipv4_network_interface::clear_has_netmask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ipv4_network_interface::clear_netmask() {
  netmask_ = 0u;
  clear_has_netmask();
}
inline ::google::protobuf::uint32 ipv4_network_interface::netmask() const {
  return netmask_;
}
inline void ipv4_network_interface::set_netmask(::google::protobuf::uint32 value) {
  set_has_netmask();
  netmask_ = value;
}

// optional uint32 bcast = 4;
inline bool ipv4_network_interface::has_bcast() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ipv4_network_interface::set_has_bcast() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ipv4_network_interface::clear_has_bcast() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ipv4_network_interface::clear_bcast() {
  bcast_ = 0u;
  clear_has_bcast();
}
inline ::google::protobuf::uint32 ipv4_network_interface::bcast() const {
  return bcast_;
}
inline void ipv4_network_interface::set_bcast(::google::protobuf::uint32 value) {
  set_has_bcast();
  bcast_ = value;
}

// -------------------------------------------------------------------

// metrics

// required uint64 timestamp_ns = 1;
inline bool metrics::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void metrics::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void metrics::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void metrics::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 metrics::timestamp_ns() const {
  return timestamp_ns_;
}
inline void metrics::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
}

// required string machine_id = 2;
inline bool metrics::has_machine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void metrics::set_has_machine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void metrics::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void metrics::clear_machine_id() {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    machine_id_->clear();
  }
  clear_has_machine_id();
}
inline const ::std::string& metrics::machine_id() const {
  return *machine_id_;
}
inline void metrics::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void metrics::set_machine_id(const char* value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void metrics::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* metrics::mutable_machine_id() {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  return machine_id_;
}
inline ::std::string* metrics::release_machine_id() {
  clear_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_id_;
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void metrics::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_id_;
  }
  if (machine_id) {
    set_has_machine_id();
    machine_id_ = machine_id;
  } else {
    clear_has_machine_id();
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string customer_id = 3;
inline bool metrics::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void metrics::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void metrics::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void metrics::clear_customer_id() {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    customer_id_->clear();
  }
  clear_has_customer_id();
}
inline const ::std::string& metrics::customer_id() const {
  return *customer_id_;
}
inline void metrics::set_customer_id(const ::std::string& value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void metrics::set_customer_id(const char* value) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(value);
}
inline void metrics::set_customer_id(const char* value, size_t size) {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  customer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* metrics::mutable_customer_id() {
  set_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    customer_id_ = new ::std::string;
  }
  return customer_id_;
}
inline ::std::string* metrics::release_customer_id() {
  clear_has_customer_id();
  if (customer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customer_id_;
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void metrics::set_allocated_customer_id(::std::string* customer_id) {
  if (customer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete customer_id_;
  }
  if (customer_id) {
    set_has_customer_id();
    customer_id_ = customer_id;
  } else {
    clear_has_customer_id();
    customer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .draiosproto.host hostinfo = 4;
inline bool metrics::has_hostinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void metrics::set_has_hostinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void metrics::clear_has_hostinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void metrics::clear_hostinfo() {
  if (hostinfo_ != NULL) hostinfo_->::draiosproto::host::Clear();
  clear_has_hostinfo();
}
inline const ::draiosproto::host& metrics::hostinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return hostinfo_ != NULL ? *hostinfo_ : *default_instance().hostinfo_;
#else
  return hostinfo_ != NULL ? *hostinfo_ : *default_instance_->hostinfo_;
#endif
}
inline ::draiosproto::host* metrics::mutable_hostinfo() {
  set_has_hostinfo();
  if (hostinfo_ == NULL) hostinfo_ = new ::draiosproto::host;
  return hostinfo_;
}
inline ::draiosproto::host* metrics::release_hostinfo() {
  clear_has_hostinfo();
  ::draiosproto::host* temp = hostinfo_;
  hostinfo_ = NULL;
  return temp;
}
inline void metrics::set_allocated_hostinfo(::draiosproto::host* hostinfo) {
  delete hostinfo_;
  hostinfo_ = hostinfo;
  if (hostinfo) {
    set_has_hostinfo();
  } else {
    clear_has_hostinfo();
  }
}

// repeated .draiosproto.process processes = 5;
inline int metrics::processes_size() const {
  return processes_.size();
}
inline void metrics::clear_processes() {
  processes_.Clear();
}
inline const ::draiosproto::process& metrics::processes(int index) const {
  return processes_.Get(index);
}
inline ::draiosproto::process* metrics::mutable_processes(int index) {
  return processes_.Mutable(index);
}
inline ::draiosproto::process* metrics::add_processes() {
  return processes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::process >&
metrics::processes() const {
  return processes_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::process >*
metrics::mutable_processes() {
  return &processes_;
}

// repeated .draiosproto.thread threads = 6;
inline int metrics::threads_size() const {
  return threads_.size();
}
inline void metrics::clear_threads() {
  threads_.Clear();
}
inline const ::draiosproto::thread& metrics::threads(int index) const {
  return threads_.Get(index);
}
inline ::draiosproto::thread* metrics::mutable_threads(int index) {
  return threads_.Mutable(index);
}
inline ::draiosproto::thread* metrics::add_threads() {
  return threads_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::thread >&
metrics::threads() const {
  return threads_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::thread >*
metrics::mutable_threads() {
  return &threads_;
}

// repeated .draiosproto.ipv4_connection ipv4_connections = 7;
inline int metrics::ipv4_connections_size() const {
  return ipv4_connections_.size();
}
inline void metrics::clear_ipv4_connections() {
  ipv4_connections_.Clear();
}
inline const ::draiosproto::ipv4_connection& metrics::ipv4_connections(int index) const {
  return ipv4_connections_.Get(index);
}
inline ::draiosproto::ipv4_connection* metrics::mutable_ipv4_connections(int index) {
  return ipv4_connections_.Mutable(index);
}
inline ::draiosproto::ipv4_connection* metrics::add_ipv4_connections() {
  return ipv4_connections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_connection >&
metrics::ipv4_connections() const {
  return ipv4_connections_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_connection >*
metrics::mutable_ipv4_connections() {
  return &ipv4_connections_;
}

// repeated .draiosproto.ipv4_network_interface ipv4_network_interfaces = 8;
inline int metrics::ipv4_network_interfaces_size() const {
  return ipv4_network_interfaces_.size();
}
inline void metrics::clear_ipv4_network_interfaces() {
  ipv4_network_interfaces_.Clear();
}
inline const ::draiosproto::ipv4_network_interface& metrics::ipv4_network_interfaces(int index) const {
  return ipv4_network_interfaces_.Get(index);
}
inline ::draiosproto::ipv4_network_interface* metrics::mutable_ipv4_network_interfaces(int index) {
  return ipv4_network_interfaces_.Mutable(index);
}
inline ::draiosproto::ipv4_network_interface* metrics::add_ipv4_network_interfaces() {
  return ipv4_network_interfaces_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_network_interface >&
metrics::ipv4_network_interfaces() const {
  return ipv4_network_interfaces_;
}
inline ::google::protobuf::RepeatedPtrField< ::draiosproto::ipv4_network_interface >*
metrics::mutable_ipv4_network_interfaces() {
  return &ipv4_network_interfaces_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace draiosproto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_draios_2eproto__INCLUDED
